/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/rendering_utils/resources/js/initAgCharts.js":
/*!******************************************************!*\
  !*** ./src/rendering_utils/resources/js/initAgCharts.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var ag_charts_community__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ag-charts-community */ \"./node_modules/ag-charts-community/dist/package/main.esm.mjs\");\n/* harmony import */ var ag_charts_enterprise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ag-charts-enterprise */ \"./node_modules/ag-charts-enterprise/dist/package/main.esm.mjs\");\n\n\nag_charts_community__WEBPACK_IMPORTED_MODULE_0__.AgCharts.setLicenseKey(\"Using_this_{AG_Charts_and_AG_Grid}_Enterprise_key_{AG-063143}_in_excess_of_the_licence_granted_is_not_permitted___Please_report_misuse_to_legal@ag-grid.com___For_help_with_changing_this_key_please_contact_info@ag-grid.com___{Dasein_VFX_Ltd}_is_granted_a_{Single_Application}_Developer_License_for_the_application_{Opportunity_app.py}_only_for_{1}_Front-End_JavaScript_developer___All_Front-End_JavaScript_developers_working_on_{Opportunity_app.py}_need_to_be_licensed___{Opportunity_app.py}_has_not_been_granted_a_Deployment_License_Add-on___This_key_works_with_{AG_Charts_and_AG_Grid}_Enterprise_versions_released_before_{6_August_2025}____[v3]_[0102]_MTc1NDQzNDgwMDAwMA==d6878e1886072524d654527411c06681\");\ndocument.addEventListener('DOMContentLoaded', function () {\n  var yAxisColor = '#999999';\n  var xAxisColor = '#889999';\n  var yGridLineColor = '#303030';\n  var backgroundFillColor = '#171718';\n  function createOriginalChart(api) {\n    var createRangeChartParams = {\n      cellRange: {\n        columns: ['Frames', 'RENDERTIME']\n      },\n      chartType: 'line',\n      chartContainer: document.querySelector('#originalChartContainer'),\n      aggFunc: 'sum',\n      chartThemeOverrides: {\n        common: {\n          background: {\n            fill: backgroundFillColor // light/mid grey\n          },\n          legend: {\n            enabled: false,\n            position: 'top'\n          },\n          axes: {\n            number: {\n              label: {\n                formatter: function formatter(params) {\n                  return typeof params.value === 'number' ? params.value.toFixed(0) : ''; // Ensure value is a number\n                },\n                color: yAxisColor // Change this to your desired y-axis text color\n              },\n              gridLine: {\n                style: [{\n                  stroke: yGridLineColor // Change this to your desired y-axis grid line color\n                }]\n              }\n            },\n            category: {\n              label: {\n                color: xAxisColor // Change this to your desired x-axis text color\n              },\n              line: {\n                stroke: xAxisColor // Change this to your desired x-axis text color\n              }\n            }\n          }\n        }\n      }\n    };\n    api.createRangeChart(createRangeChartParams);\n  }\n  function createLayerChart(api, rowData) {\n    var chartContainer = document.querySelector('#layerChartContainer');\n    chartContainer.innerHTML = ''; // Clear previous chart\n\n    // Preprocess the data to group by LAYER and aggregate by Frames\n    var groupedData = rowData.reduce(function (acc, row) {\n      var layer = row['DEADLINERENDERFULLNAME'];\n      var frame = row['Frames'];\n      if (!acc[layer]) {\n        acc[layer] = {};\n      }\n      if (!acc[layer][frame]) {\n        acc[layer][frame] = 0;\n      }\n      acc[layer][frame] += row['RENDERTIME'];\n      return acc;\n    }, {});\n\n    // Calculate the overall aggregated data\n    var aggregatedData = rowData.reduce(function (acc, row) {\n      var frame = row['Frames'];\n      if (!acc[frame]) {\n        acc[frame] = 0;\n      }\n      acc[frame] += row['RENDERTIME'];\n      return acc;\n    }, {});\n\n    // Convert the grouped data into a series format for the chart\n    var series = Object.keys(groupedData).map(function (layer) {\n      return {\n        xKey: 'Frames',\n        yKey: 'RENDERTIME',\n        title: layer,\n        data: Object.keys(groupedData[layer]).map(function (frame) {\n          return {\n            Frames: frame,\n            RENDERTIME: groupedData[layer][frame]\n          };\n        })\n      };\n    });\n\n    // Add the aggregated series to the chart\n    series.push({\n      xKey: 'Frames',\n      yKey: 'RENDERTIME',\n      title: 'Aggregated',\n      data: Object.keys(aggregatedData).map(function (frame) {\n        return {\n          Frames: frame,\n          RENDERTIME: aggregatedData[frame]\n        };\n      })\n    });\n    var chartOptions = {\n      container: chartContainer,\n      data: [],\n      series: series.map(function (s) {\n        return {\n          type: 'line',\n          xKey: s.xKey,\n          yKey: s.yKey,\n          title: s.title,\n          data: s.data\n        };\n      }),\n      legend: {\n        item: {\n          label: {\n            color: xAxisColor\n          }\n        },\n        enabled: true,\n        position: 'top'\n      },\n      axes: [{\n        type: 'category',\n        position: 'bottom',\n        label: {\n          color: xAxisColor // Change this to your desired x-axis text color\n        },\n        line: {\n          color: xAxisColor // Change this to your desired x-axis text color\n        }\n      }, {\n        type: 'number',\n        position: 'left',\n        label: {\n          formatter: function formatter(params) {\n            return typeof params.value === 'number' ? params.value.toFixed(0) : ''; // Ensure value is a number\n          },\n          color: yAxisColor // Change this to your desired y-axis text color\n        },\n        gridLine: {\n          style: [{\n            stroke: yGridLineColor // Change this to your desired y-axis grid line color\n            // lineDash: [4, 2]\n          }]\n        }\n      }],\n      background: {\n        fill: backgroundFillColor // Change this to your desired background color\n      },\n      zoom: {\n        enabled: true,\n        enableSelecting: true,\n        panKey: \"shift\"\n      }\n    };\n    ag_charts_community__WEBPACK_IMPORTED_MODULE_0__.AgCharts.create(chartOptions);\n  }\n\n  // Export the functions to be used in deadline-render-viewer-grid-default.js\n  window.createOriginalChart = createOriginalChart;\n  window.createLayerChart = createLayerChart;\n});\n\n//# sourceURL=webpack://utils/./src/rendering_utils/resources/js/initAgCharts.js?");

/***/ }),

/***/ "./node_modules/ag-charts-community/dist/package/main.esm.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/ag-charts-community/dist/package/main.esm.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AG_CHARTS_LOCALE_EN_US: () => (/* binding */ AG_CHARTS_LOCALE_EN_US),\n/* harmony export */   AgCharts: () => (/* binding */ AgCharts),\n/* harmony export */   AgErrorBarSupportedSeriesTypes: () => (/* binding */ AgErrorBarSupportedSeriesTypes),\n/* harmony export */   AgTooltipPositionType: () => (/* binding */ AgTooltipPositionType),\n/* harmony export */   Marker: () => (/* binding */ Marker),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   _ModuleSupport: () => (/* binding */ module_support_exports),\n/* harmony export */   _Scale: () => (/* binding */ sparklines_scale_exports),\n/* harmony export */   _Scene: () => (/* binding */ integrated_charts_scene_exports),\n/* harmony export */   _Theme: () => (/* binding */ integrated_charts_theme_exports),\n/* harmony export */   _Util: () => (/* binding */ sparklines_util_exports),\n/* harmony export */   time: () => (/* binding */ time_exports)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp(target, key, result);\n  return result;\n};\n\n// packages/ag-charts-locale/src/en-US.ts\nvar AG_CHARTS_LOCALE_EN_US = {\n  // Screen reader announcement when the focused item becomes visible\n  ariaAnnounceVisible: \"visible\",\n  // Screen reader announcement when the focused item becomes hidden\n  ariaAnnounceHidden: \"hidden\",\n  // Screen reader announcement when focusing an item in the chart\n  ariaAnnounceHoverDatum: \"${datum}\",\n  // Screen reader announcement when focusing a chart\n  ariaAnnounceChart: \"chart, ${seriesCount}[number] series, ${caption}\",\n  // Screen reader announcement when focusing an item in a treemap or sunburst chart\n  ariaAnnounceHierarchyDatum: \"level ${level}[number], ${count}[number] children, ${description}\",\n  // Screen reader announcement when focusing a link in a Sankey or chord chart\n  ariaAnnounceFlowProportionLink: \"link ${index} of ${count}, from ${from} to ${to}, ${sizeName} ${size}\",\n  // Screen reader announcement when focusing a node in a Sankey or chord chart\n  ariaAnnounceFlowProportionNode: \"node ${index} of ${count}, ${description}\",\n  // Screen reader text for annotations toolbar\n  ariaLabelAnnotationsToolbar: \"Annotations\",\n  // Screen reader text for annotation-options toolbar\n  ariaLabelAnnotationOptionsToolbar: \"Annotation Options\",\n  // Screen reader text for the legend toolbar\n  ariaLabelLegend: \"Legend\",\n  // Screen reader text for the legend pagination button\n  ariaLabelLegendPagination: \"Legend Pagination\",\n  // Screen reader text for the previous legend page button\n  ariaLabelLegendPagePrevious: \"Previous Legend Page\",\n  // Screen reader text for the next legend page button\n  ariaLabelLegendPageNext: \"Next Legend Page\",\n  // Screen reader text for the an item in the legend\n  ariaLabelLegendItem: \"${label}, Legend item ${index}[number] of ${count}[number], \",\n  // Screen reader text for the an unknown item in the legend\n  ariaLabelLegendItemUnknown: \"Unknown legend item\",\n  // Screen reader text for the navigator element\n  ariaLabelNavigator: \"Navigator\",\n  // Screen reader text for an accessibility control that changes the position of the navigator's range\n  ariaLabelNavigatorRange: \"Range\",\n  // Screen reader text for an accessibility control that changes the start of the navigator's range\n  ariaLabelNavigatorMinimum: \"Minimum\",\n  // Screen reader text for an accessibility control that changes the end of the navigator's range\n  ariaLabelNavigatorMaximum: \"Maximum\",\n  // Screen reader text for ranges toolbar\n  ariaLabelRangesToolbar: \"Ranges\",\n  // Screen reader text for zoom toolbar\n  ariaLabelZoomToolbar: \"Zoom\",\n  // Screen reader text for the value of the navigator's range\n  ariaValuePanRange: \"${min}[percent] to ${max}[percent]\",\n  // Default text for the 'loading data' overlay\n  overlayLoadingData: \"Loading data...\",\n  // Default text for the 'no data' overlay\n  overlayNoData: \"No data to display\",\n  // Default text for the 'no visible series' overlay\n  overlayNoVisibleSeries: \"No visible series\",\n  // Text for the annotation toolbar's trend line button\n  toolbarAnnotationsTrendLine: \"Trend line\",\n  // Text for the annotation toolbar's horizontal line button\n  toolbarAnnotationsHorizontalLine: \"Horizontal line\",\n  // Text for the annotation toolbar's vertical line button\n  toolbarAnnotationsVerticalLine: \"Vertical line\",\n  // Text for the annotation toolbar's parallel channel button\n  toolbarAnnotationsParallelChannel: \"Parallel channel\",\n  // Text for the annotation toolbar's disjoint channel button\n  toolbarAnnotationsDisjointChannel: \"Disjoint channel\",\n  // Text for the annotation toolbar's clear all button\n  toolbarAnnotationsClearAll: \"Clear all annotations\",\n  // Text for the annotation toolbar's color picker annotation button\n  toolbarAnnotationsColor: \"Pick annotation color\",\n  // Text for the annotation toolbar's lock annotation button\n  toolbarAnnotationsLock: \"Lock annotation\",\n  // Text for the annotation toolbar's unlock annotation button\n  toolbarAnnotationsUnlock: \"Unlock annotation\",\n  // Text for the annotation toolbar's delete annotation button\n  toolbarAnnotationsDelete: \"Delete annotation\",\n  // Text for the range toolbar's 1 month button\n  toolbarRange1Month: \"1m\",\n  // Aria label for the range toolbar's 1 month button\n  toolbarRange1MonthAria: \"1 month\",\n  // Text for the range toolbar's 3 month button\n  toolbarRange3Months: \"3m\",\n  // Aria label for the range toolbar's 3 month button\n  toolbarRange3MonthsAria: \"3 months\",\n  // Text for the range toolbar's 6 month button\n  toolbarRange6Months: \"6m\",\n  // Aria label for the range toolbar's 6 month button\n  toolbarRange6MonthsAria: \"6 months\",\n  // Text for the range toolbar's year to date button\n  toolbarRangeYearToDate: \"YTD\",\n  // Aria label for the range toolbar's year to date month button\n  toolbarRangeYearToDateAria: \"Year to date\",\n  // Text for the range toolbar's 1 year button\n  toolbarRange1Year: \"1y\",\n  // Aria label for the range toolbar's 1 year button\n  toolbarRange1YearAria: \"1 year\",\n  // Text for the range toolbar's full range button\n  toolbarRangeAll: \"All\",\n  // Aria label for the range toolbar's full range button\n  toolbarRangeAllAria: \"All\",\n  // Text for the zoom toolbar's zoom out button\n  toolbarZoomZoomOut: \"Zoom out\",\n  // Text for the zoom toolbar's zoom in button\n  toolbarZoomZoomIn: \"Zoom in\",\n  // Text for the zoom toolbar's pan left button\n  toolbarZoomPanLeft: \"Pan left\",\n  // Text for the zoom toolbar's pan right button\n  toolbarZoomPanRight: \"Pan right\",\n  // Text for the zoom toolbar's pan to the start button\n  toolbarZoomPanStart: \"Pan to the start\",\n  // Text for the zoom toolbar's pan to the end button\n  toolbarZoomPanEnd: \"Pan to the end\",\n  // Text for the zoom toolbar's pan reset button\n  toolbarZoomReset: \"Reset the zoom\",\n  // Text for the context menu's download button\n  contextMenuDownload: \"Download\",\n  // Text for the context menu's toggle series visibility button\n  contextMenuToggleSeriesVisibility: \"Toggle Visibility\",\n  // Text for the context menu's toggle other series visibility button\n  contextMenuToggleOtherSeries: \"Toggle Other Series\",\n  // Text for the context menu's zoom to point button\n  contextMenuZoomToCursor: \"Zoom to here\",\n  // Text for the context menu's pan to point button\n  contextMenuPanToCursor: \"Pan to here\"\n};\n\n// packages/ag-charts-types/src/chart/errorBarOptions.ts\nvar AgErrorBarSupportedSeriesTypes = [\"bar\", \"line\", \"scatter\"];\n\n// packages/ag-charts-types/src/chart/navigatorOptions.ts\nvar __MINI_CHART_SERIES_OPTIONS = {};\nvar __VERIFY_MINI_CHART_SERIES_OPTIONS = void 0;\n__VERIFY_MINI_CHART_SERIES_OPTIONS = __MINI_CHART_SERIES_OPTIONS;\n\n// packages/ag-charts-types/src/chart/tooltipOptions.ts\nvar AgTooltipPositionType = /* @__PURE__ */ ((AgTooltipPositionType2) => {\n  AgTooltipPositionType2[\"POINTER\"] = \"pointer\";\n  AgTooltipPositionType2[\"NODE\"] = \"node\";\n  AgTooltipPositionType2[\"TOP\"] = \"top\";\n  AgTooltipPositionType2[\"RIGHT\"] = \"right\";\n  AgTooltipPositionType2[\"BOTTOM\"] = \"bottom\";\n  AgTooltipPositionType2[\"LEFT\"] = \"left\";\n  AgTooltipPositionType2[\"TOP_LEFT\"] = \"top-left\";\n  AgTooltipPositionType2[\"TOP_RIGHT\"] = \"top-right\";\n  AgTooltipPositionType2[\"BOTTOM_RIGHT\"] = \"bottom-right\";\n  AgTooltipPositionType2[\"BOTTOM_LEFT\"] = \"bottom-left\";\n  return AgTooltipPositionType2;\n})(AgTooltipPositionType || {});\n\n// packages/ag-charts-types/src/chart/themeOptions.ts\nvar __THEME_OVERRIDES = {};\nvar __VERIFY_THEME_OVERRIDES = void 0;\n__VERIFY_THEME_OVERRIDES = __THEME_OVERRIDES;\n\n// packages/ag-charts-community/src/util/time/index.ts\nvar time_exports = {};\n__export(time_exports, {\n  TimeInterval: () => TimeInterval,\n  day: () => day,\n  friday: () => friday,\n  hour: () => hour,\n  millisecond: () => millisecond,\n  minute: () => minute,\n  monday: () => monday,\n  month: () => month,\n  saturday: () => saturday,\n  second: () => second,\n  sunday: () => sunday,\n  thursday: () => thursday,\n  tuesday: () => tuesday,\n  utcDay: () => utcDay,\n  utcHour: () => utcHour,\n  utcMinute: () => utcMinute,\n  utcMonth: () => utcMonth,\n  utcYear: () => utcYear,\n  wednesday: () => wednesday,\n  year: () => year\n});\n\n// packages/ag-charts-community/src/util/function.ts\nvar doOnceState = /* @__PURE__ */ new Map();\nfunction doOnce(func, key) {\n  if (doOnceState.has(key))\n    return;\n  doOnceState.set(key, true);\n  func();\n}\ndoOnce.clear = () => doOnceState.clear();\nfunction identity(x) {\n  return x;\n}\nfunction* iterate(...iterators) {\n  for (const iterator of iterators) {\n    yield* iterator;\n  }\n}\nfunction throttle(callback, waitMs = 0, options) {\n  const { leading = true, trailing = true } = options ?? {};\n  let timerId;\n  let lastArgs;\n  let shouldWait = false;\n  function timeoutHandler() {\n    if (trailing && lastArgs) {\n      timerId = setTimeout(timeoutHandler, waitMs);\n      callback(...lastArgs);\n    } else {\n      shouldWait = false;\n    }\n    lastArgs = null;\n  }\n  function throttleCallback(...args) {\n    if (shouldWait) {\n      lastArgs = args;\n    } else {\n      shouldWait = true;\n      timerId = setTimeout(timeoutHandler, waitMs);\n      if (leading) {\n        callback(...args);\n      } else {\n        lastArgs = args;\n      }\n    }\n  }\n  return Object.assign(throttleCallback, {\n    cancel() {\n      clearTimeout(timerId);\n      shouldWait = false;\n      lastArgs = null;\n    }\n  });\n}\nfunction joinFunctions(...fns) {\n  return () => {\n    for (const fn of fns) {\n      fn();\n    }\n  };\n}\n\n// packages/ag-charts-community/src/util/logger.ts\nvar Logger = {\n  log(...logContent) {\n    console.log(...logContent);\n  },\n  warn(message, ...logContent) {\n    console.warn(`AG Charts - ${message}`, ...logContent);\n  },\n  error(message, ...logContent) {\n    if (typeof message === \"object\") {\n      console.error(`AG Charts error`, message, ...logContent);\n    } else {\n      console.error(`AG Charts - ${message}`, ...logContent);\n    }\n  },\n  table(...logContent) {\n    console.table(...logContent);\n  },\n  warnOnce(message, ...logContent) {\n    doOnce(() => Logger.warn(message, ...logContent), `Logger.warn: ${message}`);\n  },\n  errorOnce(message, ...logContent) {\n    doOnce(() => Logger.error(message, ...logContent), `Logger.error: ${message}`);\n  }\n};\n\n// packages/ag-charts-community/src/util/time/interval.ts\nvar TimeInterval = class {\n  constructor(_encode, _decode, _rangeCallback) {\n    this._encode = _encode;\n    this._decode = _decode;\n    this._rangeCallback = _rangeCallback;\n  }\n  /**\n   * Returns a new date representing the latest interval boundary date before or equal to date.\n   * For example, `day.floor(date)` typically returns 12:00 AM local time on the given date.\n   * @param date\n   */\n  floor(date) {\n    const d = new Date(date);\n    const e = this._encode(d);\n    return this._decode(e);\n  }\n  /**\n   * Returns a new date representing the earliest interval boundary date after or equal to date.\n   * @param date\n   */\n  ceil(date) {\n    const d = new Date(Number(date) - 1);\n    const e = this._encode(d);\n    return this._decode(e + 1);\n  }\n  /**\n   * Returns an array of dates representing every interval boundary after or equal to start (inclusive) and before stop (exclusive).\n   * @param start Range start.\n   * @param stop Range end.\n   * @param extend If specified, the requested range will be extended to the closest \"nice\" values.\n   */\n  range(start, stop, extend) {\n    const rangeCallback = this._rangeCallback?.(start, stop);\n    const e0 = this._encode(extend ? this.floor(start) : this.ceil(start));\n    const e1 = this._encode(extend ? this.ceil(stop) : this.floor(stop));\n    if (e1 < e0) {\n      return [];\n    }\n    const range3 = [];\n    for (let e = e0; e <= e1; e++) {\n      const d = this._decode(e);\n      range3.push(d);\n    }\n    rangeCallback?.();\n    return range3;\n  }\n};\nvar CountableTimeInterval = class extends TimeInterval {\n  getOffset(snapTo, step) {\n    const s = typeof snapTo === \"number\" || snapTo instanceof Date ? this._encode(new Date(snapTo)) : 0;\n    return Math.floor(s) % step;\n  }\n  /**\n   * Returns a filtered view of this interval representing every step'th date.\n   * It can be a number of minutes, hours, days etc.\n   * Must be a positive integer.\n   * @param step\n   */\n  every(step, options) {\n    let offset4 = 0;\n    let rangeCallback;\n    const unsafeStep = step;\n    step = Math.max(1, Math.round(step));\n    if (unsafeStep !== step) {\n      Logger.warnOnce(`interval step of [${unsafeStep}] rounded to [${step}].`);\n    }\n    const { snapTo = \"start\" } = options ?? {};\n    if (typeof snapTo === \"string\") {\n      const initialOffset = offset4;\n      rangeCallback = (start, stop) => {\n        const s = snapTo === \"start\" ? start : stop;\n        offset4 = this.getOffset(s, step);\n        return () => offset4 = initialOffset;\n      };\n    } else if (typeof snapTo === \"number\") {\n      offset4 = this.getOffset(new Date(snapTo), step);\n    } else if (snapTo instanceof Date) {\n      offset4 = this.getOffset(snapTo, step);\n    }\n    const encode13 = (date) => {\n      const e = this._encode(date);\n      return Math.floor((e - offset4) / step);\n    };\n    const decode13 = (encoded) => {\n      return this._decode(encoded * step + offset4);\n    };\n    return new TimeInterval(encode13, decode13, rangeCallback);\n  }\n};\n\n// packages/ag-charts-community/src/util/time/millisecond.ts\nfunction encode(date) {\n  return date.getTime();\n}\nfunction decode(encoded) {\n  return new Date(encoded);\n}\nvar millisecond = new CountableTimeInterval(encode, decode);\nvar millisecond_default = millisecond;\n\n// packages/ag-charts-community/src/util/time/duration.ts\nvar epochYear = (/* @__PURE__ */ new Date(0)).getFullYear();\nvar durationSecond = 1e3;\nvar durationMinute = durationSecond * 60;\nvar durationHour = durationMinute * 60;\nvar durationDay = durationHour * 24;\nvar durationWeek = durationDay * 7;\nvar durationMonth = durationDay * 30;\nvar durationYear = durationDay * 365;\n\n// packages/ag-charts-community/src/util/time/second.ts\nvar offset = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;\nfunction encode2(date) {\n  return Math.floor((date.getTime() - offset) / durationSecond);\n}\nfunction decode2(encoded) {\n  return new Date(offset + encoded * durationSecond);\n}\nvar second = new CountableTimeInterval(encode2, decode2);\nvar second_default = second;\n\n// packages/ag-charts-community/src/util/time/minute.ts\nvar offset2 = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;\nfunction encode3(date) {\n  return Math.floor((date.getTime() - offset2) / durationMinute);\n}\nfunction decode3(encoded) {\n  return new Date(offset2 + encoded * durationMinute);\n}\nvar minute = new CountableTimeInterval(encode3, decode3);\nvar minute_default = minute;\n\n// packages/ag-charts-community/src/util/time/hour.ts\nvar offset3 = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;\nfunction encode4(date) {\n  return Math.floor((date.getTime() - offset3) / durationHour);\n}\nfunction decode4(encoded) {\n  return new Date(offset3 + encoded * durationHour);\n}\nvar hour = new CountableTimeInterval(encode4, decode4);\nvar hour_default = hour;\n\n// packages/ag-charts-community/src/util/time/day.ts\nfunction encode5(date) {\n  const tzOffsetMs = date.getTimezoneOffset() * durationMinute;\n  return Math.floor((date.getTime() - tzOffsetMs) / durationDay);\n}\nfunction decode5(encoded) {\n  const d = new Date(1970, 0, 1);\n  d.setDate(d.getDate() + encoded);\n  return d;\n}\nvar day = new CountableTimeInterval(encode5, decode5);\nvar day_default = day;\n\n// packages/ag-charts-community/src/util/time/week.ts\nfunction weekday(weekStart) {\n  const thursday2 = 4;\n  const dayShift = (7 + weekStart - thursday2) % 7;\n  function encode13(date) {\n    const tzOffsetMs = date.getTimezoneOffset() * durationMinute;\n    return Math.floor((date.getTime() - tzOffsetMs) / durationWeek - dayShift / 7);\n  }\n  function decode13(encoded) {\n    const d = new Date(1970, 0, 1);\n    d.setDate(d.getDate() + encoded * 7 + dayShift);\n    return d;\n  }\n  return new CountableTimeInterval(encode13, decode13);\n}\nvar sunday = weekday(0);\nvar monday = weekday(1);\nvar tuesday = weekday(2);\nvar wednesday = weekday(3);\nvar thursday = weekday(4);\nvar friday = weekday(5);\nvar saturday = weekday(6);\nvar week_default = sunday;\n\n// packages/ag-charts-community/src/util/time/month.ts\nfunction encode6(date) {\n  return date.getFullYear() * 12 + date.getMonth();\n}\nfunction decode6(encoded) {\n  const year2 = Math.floor(encoded / 12);\n  const month2 = encoded - year2 * 12;\n  return new Date(year2, month2, 1);\n}\nvar month = new CountableTimeInterval(encode6, decode6);\nvar month_default = month;\n\n// packages/ag-charts-community/src/util/time/year.ts\nfunction encode7(date) {\n  return date.getFullYear();\n}\nfunction decode7(encoded) {\n  const d = /* @__PURE__ */ new Date();\n  d.setFullYear(encoded);\n  d.setMonth(0, 1);\n  d.setHours(0, 0, 0, 0);\n  return d;\n}\nvar year = new CountableTimeInterval(encode7, decode7);\nvar year_default = year;\n\n// packages/ag-charts-community/src/util/time/utcMinute.ts\nfunction encode8(date) {\n  return Math.floor(date.getTime() / durationMinute);\n}\nfunction decode8(encoded) {\n  return new Date(encoded * durationMinute);\n}\nvar utcMinute = new CountableTimeInterval(encode8, decode8);\n\n// packages/ag-charts-community/src/util/time/utcHour.ts\nfunction encode9(date) {\n  return Math.floor(date.getTime() / durationHour);\n}\nfunction decode9(encoded) {\n  return new Date(encoded * durationHour);\n}\nvar utcHour = new CountableTimeInterval(encode9, decode9);\n\n// packages/ag-charts-community/src/util/time/utcDay.ts\nfunction encode10(date) {\n  return Math.floor(date.getTime() / durationDay);\n}\nfunction decode10(encoded) {\n  const d = /* @__PURE__ */ new Date(0);\n  d.setUTCDate(d.getUTCDate() + encoded);\n  d.setUTCHours(0, 0, 0, 0);\n  return d;\n}\nvar utcDay = new CountableTimeInterval(encode10, decode10);\n\n// packages/ag-charts-community/src/util/time/utcMonth.ts\nfunction encode11(date) {\n  return date.getUTCFullYear() * 12 + date.getUTCMonth();\n}\nfunction decode11(encoded) {\n  const year2 = Math.floor(encoded / 12);\n  const month2 = encoded - year2 * 12;\n  return new Date(Date.UTC(year2, month2, 1));\n}\nvar utcMonth = new CountableTimeInterval(encode11, decode11);\n\n// packages/ag-charts-community/src/util/time/utcYear.ts\nfunction encode12(date) {\n  return date.getUTCFullYear();\n}\nfunction decode12(encoded) {\n  const d = /* @__PURE__ */ new Date();\n  d.setUTCFullYear(encoded);\n  d.setUTCMonth(0, 1);\n  d.setUTCHours(0, 0, 0, 0);\n  return d;\n}\nvar utcYear = new CountableTimeInterval(encode12, decode12);\n\n// packages/ag-charts-community/src/motion/fromToMotion.ts\nvar fromToMotion_exports = {};\n__export(fromToMotion_exports, {\n  NODE_UPDATE_STATE_TO_PHASE_MAPPING: () => NODE_UPDATE_STATE_TO_PHASE_MAPPING,\n  fromToMotion: () => fromToMotion,\n  staticFromToMotion: () => staticFromToMotion\n});\n\n// packages/ag-charts-community/src/util/id.ts\nvar ID_MAP = /* @__PURE__ */ new Map();\nfunction resetIds() {\n  ID_MAP.clear();\n}\nfunction createId(instance) {\n  const constructor = instance.constructor;\n  const className = Object.hasOwn(constructor, \"className\") ? constructor.className : constructor.name;\n  if (!className) {\n    throw new Error(`The ${constructor} is missing the 'className' property.`);\n  }\n  const nextId = (ID_MAP.get(className) ?? 0) + 1;\n  ID_MAP.set(className, nextId);\n  return `${className}-${nextId}`;\n}\nfunction uuid() {\n  const url = URL.createObjectURL(new Blob());\n  return url.split(\"/\").at(-1);\n}\n\n// packages/ag-charts-community/src/util/interpolating.ts\nvar interpolate = \"$interpolate\";\nvar isInterpolating = (x) => x[interpolate] != null;\n\n// packages/ag-charts-community/src/util/nearest.ts\nfunction nearestSquared(x, y, objects, maxDistanceSquared = Infinity) {\n  const result = { nearest: void 0, distanceSquared: maxDistanceSquared };\n  for (const obj of objects) {\n    const thisDistance = obj.distanceSquared(x, y);\n    if (thisDistance === 0) {\n      return { nearest: obj, distanceSquared: 0 };\n    } else if (thisDistance < result.distanceSquared) {\n      result.nearest = obj;\n      result.distanceSquared = thisDistance;\n    }\n  }\n  return result;\n}\nfunction nearestSquaredInContainer(x, y, container, maxDistanceSquared = Infinity) {\n  const { x: tx, y: ty } = container.transformPoint(x, y);\n  const result = { nearest: void 0, distanceSquared: maxDistanceSquared };\n  for (const child of container.children) {\n    const { nearest, distanceSquared: distanceSquared3 } = child.nearestSquared(tx, ty, result.distanceSquared);\n    if (distanceSquared3 === 0) {\n      return { nearest, distanceSquared: distanceSquared3 };\n    } else if (distanceSquared3 < result.distanceSquared) {\n      result.nearest = nearest;\n      result.distanceSquared = distanceSquared3;\n    }\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/util/number.ts\nfunction clamp(min, value, max) {\n  return Math.min(max, Math.max(min, value));\n}\nfunction clampArray(value, array) {\n  const [min, max] = findMinMax(array);\n  return clamp(min, value, max);\n}\nfunction findMinMax(array) {\n  return array.length ? [Math.min(...array), Math.max(...array)] : [];\n}\nfunction findRangeExtent(array) {\n  const [min, max] = findMinMax(array);\n  return max - min;\n}\nfunction isEqual(a, b, epsilon2 = 1e-10) {\n  return Math.abs(a - b) < epsilon2;\n}\nfunction isNegative(value) {\n  return Math.sign(value) === -1 || Object.is(value, -0);\n}\nfunction round(value, decimals = 2) {\n  const base = 10 ** decimals;\n  return Math.round(value * base) / base;\n}\nfunction toFixed(value, fractionOrSignificantDigits = 2) {\n  const power = Math.floor(Math.log(Math.abs(value)) / Math.LN10);\n  if (power >= 0 || !isFinite(power)) {\n    return value.toFixed(fractionOrSignificantDigits);\n  }\n  return value.toFixed(Math.abs(power) - 1 + fractionOrSignificantDigits);\n}\nfunction mod(n, m) {\n  return Math.floor(n % m + (n < 0 ? m : 0));\n}\nfunction countFractionDigits(value, maximumFractionDigits = 10) {\n  const [, decimal = \"\"] = (Math.abs(value) % 1).toLocaleString(\"en-GB\", { minimumFractionDigits: 0, maximumFractionDigits }).split(\".\");\n  return decimal.length;\n}\nfunction formatNormalizedPercentage(ratio, locale) {\n  locale = locale ?? navigator.language;\n  return new Intl.NumberFormat(locale, { style: \"percent\" }).format(ratio);\n}\nfunction formatPercentage(percent, locale) {\n  return formatNormalizedPercentage(percent / 100, locale);\n}\n\n// packages/ag-charts-community/src/scene/bbox.ts\nvar _BBox = class _BBox {\n  constructor(x, y, width, height) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n  static fromDOMRect({ x, y, width, height }) {\n    return new _BBox(x, y, width, height);\n  }\n  clone() {\n    const { x, y, width, height } = this;\n    return new _BBox(x, y, width, height);\n  }\n  equals(other) {\n    return this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;\n  }\n  containsPoint(x, y) {\n    return x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height;\n  }\n  collidesBBox(other) {\n    return this.x < other.x + other.width && this.x + this.width > other.x && this.y < other.y + other.height && this.y + this.height > other.y;\n  }\n  computeCenter() {\n    return { x: this.x + this.width / 2, y: this.y + this.height / 2 };\n  }\n  isFinite() {\n    return Number.isFinite(this.x) && Number.isFinite(this.y) && Number.isFinite(this.width) && Number.isFinite(this.height);\n  }\n  distanceSquared(x, y) {\n    if (this.containsPoint(x, y)) {\n      return 0;\n    }\n    const dx = x - clamp(this.x, x, this.x + this.width);\n    const dy = y - clamp(this.y, y, this.y + this.height);\n    return dx * dx + dy * dy;\n  }\n  static nearestBox(x, y, boxes) {\n    return nearestSquared(x, y, boxes);\n  }\n  clip(clipRect) {\n    if (clipRect === void 0)\n      return this;\n    const x1 = Math.max(this.x, clipRect.x);\n    const y1 = Math.max(this.y, clipRect.y);\n    const x2 = Math.min(this.x + this.width, clipRect.x + clipRect.width);\n    const y2 = Math.min(this.y + this.height, clipRect.y + clipRect.height);\n    this.x = x1;\n    this.y = y1;\n    this.width = Math.max(0, x2 - x1);\n    this.height = Math.max(0, y2 - y1);\n    return this;\n  }\n  shrink(amount, position) {\n    const apply2 = (pos, amt) => {\n      switch (pos) {\n        case \"top\":\n          this.y += amt;\n        case \"bottom\":\n          this.height -= amt;\n          break;\n        case \"left\":\n          this.x += amt;\n        case \"right\":\n          this.width -= amt;\n          break;\n        case \"vertical\":\n          this.y += amt;\n          this.height -= amt * 2;\n          break;\n        case \"horizontal\":\n          this.x += amt;\n          this.width -= amt * 2;\n          break;\n        case void 0:\n          this.x += amt;\n          this.width -= amt * 2;\n          this.y += amt;\n          this.height -= amt * 2;\n          break;\n        default:\n      }\n    };\n    if (typeof amount === \"number\") {\n      apply2(position, amount);\n    } else if (typeof amount === \"object\") {\n      Object.entries(amount).forEach(([pos, amt]) => apply2(pos, amt));\n    }\n    return this;\n  }\n  grow(amount, position) {\n    if (typeof amount === \"number\") {\n      this.shrink(-amount, position);\n    } else {\n      const paddingCopy = { ...amount };\n      for (const key in paddingCopy) {\n        paddingCopy[key] *= -1;\n      }\n      this.shrink(paddingCopy);\n    }\n    return this;\n  }\n  translate(x, y) {\n    this.x += x;\n    this.y += y;\n    return this;\n  }\n  combine(other) {\n    const { x, y, width, height } = this;\n    this.x = Math.min(x, other.x);\n    this.y = Math.min(y, other.y);\n    this.width = Math.max(x + width, other.x + other.width) - this.x;\n    this.height = Math.max(y + height, other.y + other.height) - this.y;\n  }\n  static merge(boxes) {\n    let left = Infinity;\n    let top = Infinity;\n    let right = -Infinity;\n    let bottom = -Infinity;\n    for (const box of boxes) {\n      if (box.x < left) {\n        left = box.x;\n      }\n      if (box.y < top) {\n        top = box.y;\n      }\n      if (box.x + box.width > right) {\n        right = box.x + box.width;\n      }\n      if (box.y + box.height > bottom) {\n        bottom = box.y + box.height;\n      }\n    }\n    return new _BBox(left, top, right - left, bottom - top);\n  }\n  [interpolate](other, d) {\n    return new _BBox(\n      this.x * (1 - d) + other.x * d,\n      this.y * (1 - d) + other.y * d,\n      this.width * (1 - d) + other.width * d,\n      this.height * (1 - d) + other.height * d\n    );\n  }\n};\n_BBox.zero = new _BBox(0, 0, 0, 0);\n_BBox.NaN = new _BBox(NaN, NaN, NaN, NaN);\nvar BBox = _BBox;\n\n// packages/ag-charts-community/src/scene/changeDetectable.ts\nvar RedrawType = /* @__PURE__ */ ((RedrawType2) => {\n  RedrawType2[RedrawType2[\"NONE\"] = 0] = \"NONE\";\n  RedrawType2[RedrawType2[\"TRIVIAL\"] = 1] = \"TRIVIAL\";\n  RedrawType2[RedrawType2[\"MINOR\"] = 2] = \"MINOR\";\n  RedrawType2[RedrawType2[\"MAJOR\"] = 3] = \"MAJOR\";\n  return RedrawType2;\n})(RedrawType || {});\nfunction SceneChangeDetection(opts) {\n  return function(target, key) {\n    const privateKey = `__${key}`;\n    if (target[key]) {\n      return;\n    }\n    prepareGetSet(target, key, privateKey, opts);\n  };\n}\nfunction prepareGetSet(target, key, privateKey, opts) {\n  const {\n    redraw = 1 /* TRIVIAL */,\n    type = \"normal\",\n    changeCb,\n    convertor,\n    checkDirtyOnAssignment = false\n  } = opts ?? {};\n  const requiredOpts = { redraw, type, changeCb, checkDirtyOnAssignment, convertor };\n  let setter;\n  switch (type) {\n    case \"normal\":\n      setter = buildNormalSetter(privateKey, requiredOpts);\n      break;\n    case \"transform\":\n      setter = buildTransformSetter(privateKey, requiredOpts);\n      break;\n    case \"path\":\n      setter = buildPathSetter(privateKey, requiredOpts);\n      break;\n    case \"font\":\n      setter = buildFontSetter(privateKey, requiredOpts);\n      break;\n  }\n  setter = buildCheckDirtyChain(\n    buildChangeCallbackChain(buildConvertorChain(setter, requiredOpts), requiredOpts),\n    requiredOpts\n  );\n  const getter = function() {\n    return this[privateKey];\n  };\n  Object.defineProperty(target, key, {\n    set: setter,\n    get: getter,\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction buildConvertorChain(setterFn, opts) {\n  const { convertor } = opts;\n  if (convertor) {\n    return function(value) {\n      setterFn.call(this, convertor(value));\n    };\n  }\n  return setterFn;\n}\nvar NO_CHANGE = Symbol(\"no-change\");\nfunction buildChangeCallbackChain(setterFn, opts) {\n  const { changeCb } = opts;\n  if (changeCb) {\n    return function(value) {\n      const change = setterFn.call(this, value);\n      if (change !== NO_CHANGE) {\n        changeCb.call(this, this);\n      }\n      return change;\n    };\n  }\n  return setterFn;\n}\nfunction buildCheckDirtyChain(setterFn, opts) {\n  const { checkDirtyOnAssignment } = opts;\n  if (checkDirtyOnAssignment) {\n    return function(value) {\n      const change = setterFn.call(this, value);\n      if (change !== NO_CHANGE && value != null && value._dirty > 0 /* NONE */) {\n        this.markDirty(value, value._dirty);\n      }\n      return change;\n    };\n  }\n  return setterFn;\n}\nfunction buildNormalSetter(privateKey, opts) {\n  const { redraw = 1 /* TRIVIAL */, changeCb } = opts;\n  return function(value) {\n    const oldValue = this[privateKey];\n    if (value !== oldValue) {\n      this[privateKey] = value;\n      this.markDirty(this, redraw);\n      changeCb?.(this);\n      return value;\n    }\n    return NO_CHANGE;\n  };\n}\nfunction buildTransformSetter(privateKey, opts) {\n  const { redraw = 1 /* TRIVIAL */ } = opts;\n  return function(value) {\n    const oldValue = this[privateKey];\n    if (value !== oldValue) {\n      this[privateKey] = value;\n      this.markDirtyTransform(redraw);\n      return value;\n    }\n    return NO_CHANGE;\n  };\n}\nfunction buildPathSetter(privateKey, opts) {\n  const { redraw = 1 /* TRIVIAL */ } = opts;\n  return function(value) {\n    const oldValue = this[privateKey];\n    if (value !== oldValue) {\n      this[privateKey] = value;\n      if (!this._dirtyPath) {\n        this._dirtyPath = true;\n        this.markDirty(this, redraw);\n      }\n      return value;\n    }\n    return NO_CHANGE;\n  };\n}\nfunction buildFontSetter(privateKey, opts) {\n  const { redraw = 1 /* TRIVIAL */ } = opts;\n  return function(value) {\n    const oldValue = this[privateKey];\n    if (value !== oldValue) {\n      this[privateKey] = value;\n      if (!this._dirtyFont) {\n        this._dirtyFont = true;\n        this.markDirty(this, redraw);\n      }\n      return value;\n    }\n    return NO_CHANGE;\n  };\n}\nvar ChangeDetectable = class {\n  constructor() {\n    this._dirty = 3 /* MAJOR */;\n  }\n  markDirty(_source, type = 1 /* TRIVIAL */) {\n    if (this._dirty < type) {\n      this._dirty = type;\n    }\n  }\n  markClean(_opts) {\n    this._dirty = 0 /* NONE */;\n  }\n  isDirty() {\n    return this._dirty > 0 /* NONE */;\n  }\n};\n\n// packages/ag-charts-community/src/scene/matrix.ts\nvar _Matrix = class _Matrix {\n  get e() {\n    return [...this.elements];\n  }\n  constructor(elements3 = [1, 0, 0, 1, 0, 0]) {\n    this.elements = elements3;\n  }\n  setElements(elements3) {\n    const e = this.elements;\n    e[0] = elements3[0];\n    e[1] = elements3[1];\n    e[2] = elements3[2];\n    e[3] = elements3[3];\n    e[4] = elements3[4];\n    e[5] = elements3[5];\n    return this;\n  }\n  get identity() {\n    const e = this.elements;\n    return e[0] === 1 && e[1] === 0 && e[2] === 0 && e[3] === 1 && e[4] === 0 && e[5] === 0;\n  }\n  /**\n   * Performs the AxB matrix multiplication and saves the result\n   * to `C`, if given, or to `A` otherwise.\n   */\n  AxB(A, B, C) {\n    const a = A[0] * B[0] + A[2] * B[1], b = A[1] * B[0] + A[3] * B[1], c = A[0] * B[2] + A[2] * B[3], d = A[1] * B[2] + A[3] * B[3], e = A[0] * B[4] + A[2] * B[5] + A[4], f = A[1] * B[4] + A[3] * B[5] + A[5];\n    C = C ?? A;\n    C[0] = a;\n    C[1] = b;\n    C[2] = c;\n    C[3] = d;\n    C[4] = e;\n    C[5] = f;\n  }\n  /**\n   * The `other` matrix gets post-multiplied to the current matrix.\n   * Returns the current matrix.\n   * @param other\n   */\n  multiplySelf(other) {\n    this.AxB(this.elements, other.elements);\n    return this;\n  }\n  /**\n   * The `other` matrix gets post-multiplied to the current matrix.\n   * Returns a new matrix.\n   * @param other\n   */\n  multiply(other) {\n    const elements3 = new Array(6);\n    this.AxB(this.elements, other.elements, elements3);\n    return new _Matrix(elements3);\n  }\n  preMultiplySelf(other) {\n    this.AxB(other.elements, this.elements, this.elements);\n    return this;\n  }\n  /**\n   * Returns the inverse of this matrix as a new matrix.\n   */\n  inverse() {\n    const el = this.elements;\n    let a = el[0], b = el[1], c = el[2], d = el[3];\n    const e = el[4], f = el[5];\n    const rD = 1 / (a * d - b * c);\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    return new _Matrix([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n  }\n  /**\n   * Save the inverse of this matrix to the given matrix.\n   */\n  inverseTo(other) {\n    const el = this.elements;\n    let a = el[0], b = el[1], c = el[2], d = el[3];\n    const e = el[4], f = el[5];\n    const rD = 1 / (a * d - b * c);\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    other.setElements([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n    return this;\n  }\n  invertSelf() {\n    const el = this.elements;\n    let a = el[0], b = el[1], c = el[2], d = el[3];\n    const e = el[4], f = el[5];\n    const rD = 1 / (a * d - b * c);\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    el[0] = d;\n    el[1] = -b;\n    el[2] = -c;\n    el[3] = a;\n    el[4] = c * f - d * e;\n    el[5] = b * e - a * f;\n    return this;\n  }\n  transformPoint(x, y) {\n    const e = this.elements;\n    return {\n      x: x * e[0] + y * e[2] + e[4],\n      y: x * e[1] + y * e[3] + e[5]\n    };\n  }\n  transformBBox(bbox, target) {\n    const elements3 = this.elements;\n    const xx = elements3[0];\n    const xy = elements3[1];\n    const yx = elements3[2];\n    const yy = elements3[3];\n    const h_w = bbox.width * 0.5;\n    const h_h = bbox.height * 0.5;\n    const cx = bbox.x + h_w;\n    const cy = bbox.y + h_h;\n    const w = Math.abs(h_w * xx) + Math.abs(h_h * yx);\n    const h = Math.abs(h_w * xy) + Math.abs(h_h * yy);\n    if (!target) {\n      target = new BBox(0, 0, 0, 0);\n    }\n    target.x = cx * xx + cy * yx + elements3[4] - w;\n    target.y = cx * xy + cy * yy + elements3[5] - h;\n    target.width = w + w;\n    target.height = h + h;\n    return target;\n  }\n  toContext(ctx) {\n    if (this.identity) {\n      return;\n    }\n    const e = this.elements;\n    ctx.transform(e[0], e[1], e[2], e[3], e[4], e[5]);\n  }\n  static flyweight(sourceMatrix) {\n    return _Matrix.instance.setElements(sourceMatrix.elements);\n  }\n  static updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, opts) {\n    const [bbcx, bbcy] = [0, 0];\n    const sx = scalingX;\n    const sy = scalingY;\n    let scx;\n    let scy;\n    if (sx === 1 && sy === 1) {\n      scx = 0;\n      scy = 0;\n    } else {\n      scx = opts?.scalingCenterX == null ? bbcx : opts?.scalingCenterX;\n      scy = opts?.scalingCenterY == null ? bbcy : opts?.scalingCenterY;\n    }\n    const r = rotation;\n    const cos = Math.cos(r);\n    const sin = Math.sin(r);\n    let rcx;\n    let rcy;\n    if (r === 0) {\n      rcx = 0;\n      rcy = 0;\n    } else {\n      rcx = opts?.rotationCenterX == null ? bbcx : opts?.rotationCenterX;\n      rcy = opts?.rotationCenterY == null ? bbcy : opts?.rotationCenterY;\n    }\n    const tx = translationX;\n    const ty = translationY;\n    const tx4 = scx * (1 - sx) - rcx;\n    const ty4 = scy * (1 - sy) - rcy;\n    matrix.setElements([\n      cos * sx,\n      sin * sx,\n      -sin * sy,\n      cos * sy,\n      cos * tx4 - sin * ty4 + rcx + tx,\n      sin * tx4 + cos * ty4 + rcy + ty\n    ]);\n    return matrix;\n  }\n  static fromContext(ctx) {\n    const domMatrix = ctx.getTransform();\n    return new _Matrix([domMatrix.a, domMatrix.b, domMatrix.c, domMatrix.d, domMatrix.e, domMatrix.f]);\n  }\n};\n_Matrix.instance = new _Matrix();\nvar Matrix = _Matrix;\n\n// packages/ag-charts-community/src/scene/node.ts\nvar PointerEvents = /* @__PURE__ */ ((PointerEvents2) => {\n  PointerEvents2[PointerEvents2[\"All\"] = 0] = \"All\";\n  PointerEvents2[PointerEvents2[\"None\"] = 1] = \"None\";\n  return PointerEvents2;\n})(PointerEvents || {});\nvar _Node = class _Node extends ChangeDetectable {\n  constructor({ isVirtual, tag, zIndex } = {}) {\n    super();\n    /** Unique number to allow creation order to be easily determined. */\n    this.serialNumber = _Node._nextSerialNumber++;\n    /**\n     * Unique node ID in the form `ClassName-NaturalNumber`.\n     */\n    this.id = createId(this);\n    /**\n     * To simplify the type system (especially in Selections) we don't have the `Parent` node\n     * (one that has children). Instead, we mimic HTML DOM, where any node can have children.\n     * But we still need to distinguish regular leaf nodes from container leafs somehow.\n     */\n    this.isContainerNode = false;\n    this._virtualChildren = [];\n    this._children = [];\n    // Used to check for duplicate nodes.\n    this.childSet = {};\n    // These matrices may need to have package level visibility\n    // for performance optimization purposes.\n    this.matrix = new Matrix();\n    this.dirtyTransform = false;\n    this.scalingX = 1;\n    this.scalingY = 1;\n    this.scalingCenterX = null;\n    this.scalingCenterY = null;\n    this.rotationCenterX = null;\n    this.rotationCenterY = null;\n    this.rotation = 0;\n    this.translationX = 0;\n    this.translationY = 0;\n    this._childNodeCounts = {\n      groups: 0,\n      nonGroups: 0\n    };\n    this.visible = true;\n    this.dirtyZIndex = false;\n    this.zIndex = 0;\n    /** Discriminators for render order within a zIndex. */\n    this.zIndexSubOrder = void 0;\n    this.pointerEvents = 0 /* All */;\n    this.isVirtual = isVirtual ?? false;\n    this.tag = tag ?? NaN;\n    this.zIndex = zIndex ?? 0;\n  }\n  /**\n   * Some arbitrary data bound to the node.\n   */\n  get datum() {\n    return this._datum ?? this._parent?.datum;\n  }\n  get previousDatum() {\n    return this._previousDatum;\n  }\n  set datum(datum) {\n    if (this._datum !== datum) {\n      this._previousDatum = this._datum;\n    }\n    this._datum = datum;\n  }\n  _setLayerManager(value) {\n    this._layerManager = value;\n    this._debug = value?.debug;\n    for (const child of this._children) {\n      child._setLayerManager(value);\n    }\n    for (const child of this._virtualChildren) {\n      child._setLayerManager(value);\n    }\n  }\n  get layerManager() {\n    return this._layerManager;\n  }\n  *ancestors() {\n    let node = this;\n    while (node = node.parent) {\n      yield node;\n    }\n  }\n  *traverseUp() {\n    yield this;\n    yield* this.ancestors();\n  }\n  get parent() {\n    return this._parent;\n  }\n  get children() {\n    return this._virtualChildren.length ? this._children.concat(this._virtualChildren.flatMap((next) => next.children)) : this._children;\n  }\n  get virtualChildren() {\n    return this._virtualChildren;\n  }\n  hasVirtualChildren() {\n    return this._virtualChildren.length > 0;\n  }\n  // new Set<Node>()\n  setProperties(styles, pickKeys) {\n    const keys = pickKeys ?? Object.keys(styles);\n    for (const key of keys) {\n      this[key] = styles[key];\n    }\n    return this;\n  }\n  /**\n   * Appends one or more new node instances to this parent.\n   * If one needs to:\n   * - move a child to the end of the list of children\n   * - move a child from one parent to another (including parents in other scenes)\n   * one should use the {@link insertBefore} method instead.\n   * @param nodes A node or nodes to append.\n   */\n  append(nodes) {\n    if (!Array.isArray(nodes)) {\n      nodes = [nodes];\n    }\n    for (const node of nodes) {\n      if (node.parent) {\n        throw new Error(`${node} already belongs to another parent: ${node.parent}.`);\n      }\n      if (node.layerManager) {\n        throw new Error(`${node} already belongs to a scene: ${node.layerManager}.`);\n      }\n      if (this.childSet[node.id]) {\n        throw new Error(`Duplicate ${node.constructor.name} node: ${node}`);\n      }\n      if (node.isVirtual) {\n        this._virtualChildren.push(node);\n      } else {\n        this._children.push(node);\n      }\n      this.childSet[node.id] = true;\n      node._parent = this;\n      node._setLayerManager(this.layerManager);\n    }\n    this.dirtyZIndex = true;\n    this.markDirty(this, 3 /* MAJOR */);\n  }\n  appendChild(node) {\n    this.append(node);\n    return node;\n  }\n  removeChild(node) {\n    const error = () => {\n      throw new Error(`The node to be removed is not a child of this node.`);\n    };\n    if (node.parent !== this) {\n      error();\n    }\n    if (node.isVirtual) {\n      const i = this._virtualChildren.indexOf(node);\n      if (i < 0)\n        error();\n      this._virtualChildren.splice(i, 1);\n    } else {\n      const i = this._children.indexOf(node);\n      if (i < 0)\n        error();\n      this._children.splice(i, 1);\n    }\n    delete this.childSet[node.id];\n    node._parent = void 0;\n    node._setLayerManager();\n    this.dirtyZIndex = true;\n    this.markDirty(node, 3 /* MAJOR */);\n    return node;\n  }\n  calculateCumulativeMatrix() {\n    this.computeTransformMatrix();\n    const matrix = Matrix.flyweight(this.matrix);\n    for (const parent of this.ancestors()) {\n      parent.computeTransformMatrix();\n      matrix.preMultiplySelf(parent.matrix);\n    }\n    return matrix;\n  }\n  transformPoint(x, y) {\n    const matrix = this.calculateCumulativeMatrix();\n    return matrix.invertSelf().transformPoint(x, y);\n  }\n  inverseTransformPoint(x, y) {\n    const matrix = this.calculateCumulativeMatrix();\n    return matrix.transformPoint(x, y);\n  }\n  transformBBox(bbox) {\n    const matrix = this.calculateCumulativeMatrix();\n    return matrix.invertSelf().transformBBox(bbox);\n  }\n  inverseTransformBBox(bbox) {\n    const matrix = this.calculateCumulativeMatrix();\n    return matrix.transformBBox(bbox);\n  }\n  markDirtyTransform() {\n    this.dirtyTransform = true;\n    this.markDirty(this, 3 /* MAJOR */);\n  }\n  destroy() {\n    this.parent?.removeChild(this);\n  }\n  containsPoint(_x, _y) {\n    return false;\n  }\n  /**\n   * Hit testing method.\n   * Recursively checks if the given point is inside this node or any of its children.\n   * Returns the first matching node or `undefined`.\n   * Nodes that render later (show on top) are hit tested first.\n   */\n  pickNode(x, y) {\n    if (!this.visible || this.pointerEvents === 1 /* None */ || !this.containsPoint(x, y)) {\n      return;\n    }\n    const { children } = this;\n    if (children.length > 1e3) {\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        const containsPoint = child.computeTransformedBBox()?.containsPoint(x, y);\n        const hit = containsPoint ? child.pickNode(x, y) : void 0;\n        if (hit) {\n          return hit;\n        }\n      }\n    } else if (children.length) {\n      for (let i = children.length - 1; i >= 0; i--) {\n        const hit = children[i].pickNode(x, y);\n        if (hit) {\n          return hit;\n        }\n      }\n    } else if (!this.isContainerNode) {\n      return this;\n    }\n  }\n  getCachedBBox() {\n    return this.cachedBBox ?? BBox.zero;\n  }\n  computeBBox() {\n    return;\n  }\n  computeTransformedBBox() {\n    const bbox = this.computeBBox();\n    if (!bbox) {\n      return;\n    }\n    this.computeTransformMatrix();\n    const matrix = Matrix.flyweight(this.matrix);\n    for (const parent of this.ancestors()) {\n      parent.computeTransformMatrix();\n      matrix.preMultiplySelf(parent.matrix);\n    }\n    matrix.transformBBox(bbox, bbox);\n    return bbox;\n  }\n  computeTransformMatrix() {\n    if (!this.dirtyTransform) {\n      return;\n    }\n    const {\n      matrix,\n      scalingX,\n      scalingY,\n      rotation,\n      translationX,\n      translationY,\n      scalingCenterX,\n      scalingCenterY,\n      rotationCenterX,\n      rotationCenterY\n    } = this;\n    Matrix.updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, {\n      scalingCenterX,\n      scalingCenterY,\n      rotationCenterX,\n      rotationCenterY\n    });\n    this.dirtyTransform = false;\n  }\n  /** Perform any pre-rendering initialization. */\n  preRender() {\n    this._childNodeCounts.groups = 0;\n    this._childNodeCounts.nonGroups = 1;\n    for (const child of this.children) {\n      const childCounts = child.preRender();\n      this._childNodeCounts.groups += childCounts.groups;\n      this._childNodeCounts.nonGroups += childCounts.nonGroups;\n    }\n    return this._childNodeCounts;\n  }\n  render(renderCtx) {\n    const { stats } = renderCtx;\n    this._dirty = 0 /* NONE */;\n    this.cachedBBox = this.computeBBox();\n    if (stats) {\n      stats.nodesRendered++;\n    }\n  }\n  markDirty(_source, type = 1 /* TRIVIAL */, parentType = type) {\n    if (this._dirty > type || this._dirty === type && type === parentType) {\n      return;\n    }\n    this._dirty = type;\n    if (this.parent) {\n      this.parent.markDirty(this, parentType);\n    } else if (this.layerManager) {\n      this.layerManager.markDirty();\n    }\n  }\n  get dirty() {\n    return this._dirty;\n  }\n  markClean(opts) {\n    const { force = false, recursive = true } = opts ?? {};\n    if (this._dirty === 0 /* NONE */ && !force) {\n      return;\n    }\n    this._dirty = 0 /* NONE */;\n    if (recursive !== false) {\n      for (const child of this._virtualChildren) {\n        child.markClean({ force });\n      }\n    }\n    if (recursive === true) {\n      for (const child of this._children) {\n        child.markClean({ force });\n      }\n    }\n  }\n  onVisibleChange() {\n  }\n  get nodeCount() {\n    let count = 1;\n    let dirtyCount = this._dirty >= 0 /* NONE */ || this.dirtyTransform ? 1 : 0;\n    let visibleCount = this.visible ? 1 : 0;\n    const countChild = (child) => {\n      const { count: childCount, visibleCount: childVisibleCount, dirtyCount: childDirtyCount } = child.nodeCount;\n      count += childCount;\n      visibleCount += childVisibleCount;\n      dirtyCount += childDirtyCount;\n    };\n    for (const child of this._children) {\n      countChild(child);\n    }\n    for (const child of this._virtualChildren) {\n      countChild(child);\n    }\n    return { count, visibleCount, dirtyCount };\n  }\n  onZIndexChange() {\n    if (this.parent) {\n      this.parent.dirtyZIndex = true;\n    }\n  }\n};\n_Node._nextSerialNumber = 0;\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"scalingX\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"scalingY\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"scalingCenterX\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"scalingCenterY\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"rotationCenterX\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"rotationCenterY\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"rotation\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"translationX\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"translationY\", 2);\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 3 /* MAJOR */,\n    changeCb: (target) => target.onVisibleChange()\n  })\n], _Node.prototype, \"visible\", 2);\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 1 /* TRIVIAL */,\n    changeCb: (target) => target.onZIndexChange()\n  })\n], _Node.prototype, \"zIndex\", 2);\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 1 /* TRIVIAL */,\n    changeCb: (target) => target.onZIndexChange()\n  })\n], _Node.prototype, \"zIndexSubOrder\", 2);\nvar Node = _Node;\n\n// packages/ag-charts-community/src/util/color.ts\nvar lerp = (x, y, t) => x * (1 - t) + y * t;\nvar srgbToLinear = (value) => {\n  const sign = value < 0 ? -1 : 1;\n  const abs = Math.abs(value);\n  if (abs <= 0.04045)\n    return value / 12.92;\n  return sign * ((abs + 0.055) / 1.055) ** 2.4;\n};\nvar srgbFromLinear = (value) => {\n  const sign = value < 0 ? -1 : 1;\n  const abs = Math.abs(value);\n  if (abs > 31308e-7) {\n    return sign * (1.055 * abs ** (1 / 2.4) - 0.055);\n  }\n  return 12.92 * value;\n};\nvar _Color = class _Color {\n  /**\n   * Every color component should be in the [0, 1] range.\n   * Some easing functions (such as elastic easing) can overshoot the target value by some amount.\n   * So, when animating colors, if the source or target color components are already near\n   * or at the edge of the allowed [0, 1] range, it is possible for the intermediate color\n   * component value to end up outside of that range mid-animation. For this reason the constructor\n   * performs range checking/constraining.\n   * @param r Red component.\n   * @param g Green component.\n   * @param b Blue component.\n   * @param a Alpha (opacity) component.\n   */\n  constructor(r, g, b, a = 1) {\n    this.r = clamp(0, r || 0, 1);\n    this.g = clamp(0, g || 0, 1);\n    this.b = clamp(0, b || 0, 1);\n    this.a = clamp(0, a || 0, 1);\n  }\n  /**\n   * A color string can be in one of the following formats to be valid:\n   * - #rgb\n   * - #rrggbb\n   * - rgb(r, g, b)\n   * - rgba(r, g, b, a)\n   * - CSS color name such as 'white', 'orange', 'cyan', etc.\n   */\n  static validColorString(str) {\n    if (str.indexOf(\"#\") >= 0) {\n      return !!_Color.parseHex(str);\n    }\n    if (str.indexOf(\"rgb\") >= 0) {\n      return !!_Color.stringToRgba(str);\n    }\n    return !!_Color.nameToHex[str.toLowerCase()];\n  }\n  /**\n   * The given string can be in one of the following formats:\n   * - #rgb\n   * - #rrggbb\n   * - rgb(r, g, b)\n   * - rgba(r, g, b, a)\n   * - CSS color name such as 'white', 'orange', 'cyan', etc.\n   * @param str\n   */\n  static fromString(str) {\n    if (str.indexOf(\"#\") >= 0) {\n      return _Color.fromHexString(str);\n    }\n    const hex = _Color.nameToHex[str.toLowerCase()];\n    if (hex) {\n      return _Color.fromHexString(hex);\n    }\n    if (str.indexOf(\"rgb\") >= 0) {\n      return _Color.fromRgbaString(str);\n    }\n    throw new Error(`Invalid color string: '${str}'`);\n  }\n  // See https://drafts.csswg.org/css-color/#hex-notation\n  static parseHex(input) {\n    input = input.replace(/ /g, \"\").slice(1);\n    let parts;\n    switch (input.length) {\n      case 6:\n      case 8:\n        parts = [];\n        for (let i = 0; i < input.length; i += 2) {\n          parts.push(parseInt(`${input[i]}${input[i + 1]}`, 16));\n        }\n        break;\n      case 3:\n      case 4:\n        parts = input.split(\"\").map((p) => parseInt(p, 16)).map((p) => p + p * 16);\n        break;\n    }\n    if (parts?.length >= 3 && parts.every((p) => p >= 0)) {\n      if (parts.length === 3) {\n        parts.push(255);\n      }\n      return parts;\n    }\n  }\n  static fromHexString(str) {\n    const values = _Color.parseHex(str);\n    if (values) {\n      const [r, g, b, a] = values;\n      return new _Color(r / 255, g / 255, b / 255, a / 255);\n    }\n    throw new Error(`Malformed hexadecimal color string: '${str}'`);\n  }\n  static stringToRgba(str) {\n    let po = -1;\n    let pc = -1;\n    for (let i = 0; i < str.length; i++) {\n      const c = str[i];\n      if (po === -1 && c === \"(\") {\n        po = i;\n      } else if (c === \")\") {\n        pc = i;\n        break;\n      }\n    }\n    if (po === -1 || pc === -1)\n      return;\n    const contents = str.substring(po + 1, pc);\n    const parts = contents.split(\",\");\n    const rgba = [];\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i];\n      let value = parseFloat(part);\n      if (!Number.isFinite(value)) {\n        return;\n      }\n      if (part.indexOf(\"%\") >= 0) {\n        value = clamp(0, value, 100);\n        value /= 100;\n      } else if (i === 3) {\n        value = clamp(0, value, 1);\n      } else {\n        value = clamp(0, value, 255);\n        value /= 255;\n      }\n      rgba.push(value);\n    }\n    return rgba;\n  }\n  static fromRgbaString(str) {\n    const rgba = _Color.stringToRgba(str);\n    if (rgba) {\n      if (rgba.length === 3) {\n        return new _Color(rgba[0], rgba[1], rgba[2]);\n      } else if (rgba.length === 4) {\n        return new _Color(rgba[0], rgba[1], rgba[2], rgba[3]);\n      }\n    }\n    throw new Error(`Malformed rgb/rgba color string: '${str}'`);\n  }\n  static fromArray(arr) {\n    if (arr.length === 4) {\n      return new _Color(arr[0], arr[1], arr[2], arr[3]);\n    }\n    if (arr.length === 3) {\n      return new _Color(arr[0], arr[1], arr[2]);\n    }\n    throw new Error(\"The given array should contain 3 or 4 color components (numbers).\");\n  }\n  static fromHSB(h, s, b, alpha = 1) {\n    const rgb = _Color.HSBtoRGB(h, s, b);\n    return new _Color(rgb[0], rgb[1], rgb[2], alpha);\n  }\n  static fromHSL(h, s, l, alpha = 1) {\n    const rgb = _Color.HSLtoRGB(h, s, l);\n    return new _Color(rgb[0], rgb[1], rgb[2], alpha);\n  }\n  static fromOKLCH(l, c, h, alpha = 1) {\n    const rgb = _Color.OKLCHtoRGB(l, c, h);\n    return new _Color(rgb[0], rgb[1], rgb[2], alpha);\n  }\n  static padHex(str) {\n    return str.length === 1 ? \"0\" + str : str;\n  }\n  toHexString() {\n    let hex = \"#\" + _Color.padHex(Math.round(this.r * 255).toString(16)) + _Color.padHex(Math.round(this.g * 255).toString(16)) + _Color.padHex(Math.round(this.b * 255).toString(16));\n    if (this.a < 1) {\n      hex += _Color.padHex(Math.round(this.a * 255).toString(16));\n    }\n    return hex;\n  }\n  toRgbaString(fractionDigits = 3) {\n    const components = [Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255)];\n    const k = Math.pow(10, fractionDigits);\n    if (this.a !== 1) {\n      components.push(Math.round(this.a * k) / k);\n      return `rgba(${components.join(\", \")})`;\n    }\n    return `rgb(${components.join(\", \")})`;\n  }\n  toString() {\n    if (this.a === 1) {\n      return this.toHexString();\n    }\n    return this.toRgbaString();\n  }\n  toHSB() {\n    return _Color.RGBtoHSB(this.r, this.g, this.b);\n  }\n  static RGBtoOKLCH(r, g, b) {\n    const LSRGB0 = srgbToLinear(r);\n    const LSRGB1 = srgbToLinear(g);\n    const LSRGB2 = srgbToLinear(b);\n    const LMS0 = Math.cbrt(0.4122214708 * LSRGB0 + 0.5363325363 * LSRGB1 + 0.0514459929 * LSRGB2);\n    const LMS1 = Math.cbrt(0.2119034982 * LSRGB0 + 0.6806995451 * LSRGB1 + 0.1073969566 * LSRGB2);\n    const LMS2 = Math.cbrt(0.0883024619 * LSRGB0 + 0.2817188376 * LSRGB1 + 0.6299787005 * LSRGB2);\n    const OKLAB0 = 0.2104542553 * LMS0 + 0.793617785 * LMS1 - 0.0040720468 * LMS2;\n    const OKLAB1 = 1.9779984951 * LMS0 - 2.428592205 * LMS1 + 0.4505937099 * LMS2;\n    const OKLAB2 = 0.0259040371 * LMS0 + 0.7827717662 * LMS1 - 0.808675766 * LMS2;\n    const hue = Math.atan2(OKLAB2, OKLAB1) * 180 / Math.PI;\n    const OKLCH0 = OKLAB0;\n    const OKLCH1 = Math.hypot(OKLAB1, OKLAB2);\n    const OKLCH2 = hue >= 0 ? hue : hue + 360;\n    return [OKLCH0, OKLCH1, OKLCH2];\n  }\n  static OKLCHtoRGB(l, c, h) {\n    const OKLAB0 = l;\n    const OKLAB1 = c * Math.cos(h * Math.PI / 180);\n    const OKLAB2 = c * Math.sin(h * Math.PI / 180);\n    const LMS0 = (OKLAB0 + 0.3963377774 * OKLAB1 + 0.2158037573 * OKLAB2) ** 3;\n    const LMS1 = (OKLAB0 - 0.1055613458 * OKLAB1 - 0.0638541728 * OKLAB2) ** 3;\n    const LMS2 = (OKLAB0 - 0.0894841775 * OKLAB1 - 1.291485548 * OKLAB2) ** 3;\n    const LSRGB0 = 4.0767416621 * LMS0 - 3.3077115913 * LMS1 + 0.2309699292 * LMS2;\n    const LSRGB1 = -1.2684380046 * LMS0 + 2.6097574011 * LMS1 - 0.3413193965 * LMS2;\n    const LSRGB2 = -0.0041960863 * LMS0 - 0.7034186147 * LMS1 + 1.707614701 * LMS2;\n    const SRGB0 = srgbFromLinear(LSRGB0);\n    const SRGB1 = srgbFromLinear(LSRGB1);\n    const SRGB2 = srgbFromLinear(LSRGB2);\n    return [SRGB0, SRGB1, SRGB2];\n  }\n  static RGBtoHSL(r, g, b) {\n    const min = Math.min(r, g, b);\n    const max = Math.max(r, g, b);\n    const l = (max + min) / 2;\n    let h;\n    let s;\n    if (max === min) {\n      h = 0;\n      s = 0;\n    } else {\n      const delta3 = max - min;\n      s = l > 0.5 ? delta3 / (2 - max - min) : delta3 / (max + min);\n      if (max === r) {\n        h = (g - b) / delta3 + (g < b ? 6 : 0);\n      } else if (max === g) {\n        h = (b - r) / delta3 + 2;\n      } else {\n        h = (r - g) / delta3 + 4;\n      }\n      h *= 360 / 6;\n    }\n    return [h, s, l];\n  }\n  static HSLtoRGB(h, s, l) {\n    h = (h % 360 + 360) % 360;\n    if (s === 0) {\n      return [l, l, l];\n    }\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    function hueToRgb(t) {\n      if (t < 0)\n        t += 1;\n      if (t > 1)\n        t -= 1;\n      if (t < 1 / 6)\n        return p + (q - p) * 6 * t;\n      if (t < 1 / 2)\n        return q;\n      if (t < 2 / 3)\n        return p + (q - p) * (2 / 3 - t) * 6;\n      return p;\n    }\n    const r = hueToRgb(h / 360 + 1 / 3);\n    const g = hueToRgb(h / 360);\n    const b = hueToRgb(h / 360 - 1 / 3);\n    return [r, g, b];\n  }\n  /**\n   * Converts the given RGB triple to an array of HSB (HSV) components.\n   */\n  static RGBtoHSB(r, g, b) {\n    const min = Math.min(r, g, b);\n    const max = Math.max(r, g, b);\n    const S = max === 0 ? 0 : (max - min) / max;\n    let H = 0;\n    if (min !== max) {\n      const delta3 = max - min;\n      const rc = (max - r) / delta3;\n      const gc = (max - g) / delta3;\n      const bc = (max - b) / delta3;\n      if (r === max) {\n        H = bc - gc;\n      } else if (g === max) {\n        H = 2 + rc - bc;\n      } else {\n        H = 4 + gc - rc;\n      }\n      H /= 6;\n      if (H < 0) {\n        H = H + 1;\n      }\n    }\n    return [H * 360, S, max];\n  }\n  /**\n   * Converts the given HSB (HSV) triple to an array of RGB components.\n   */\n  static HSBtoRGB(H, S, B) {\n    H = (H % 360 + 360) % 360 / 360;\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    if (S === 0) {\n      r = g = b = B;\n    } else {\n      const h = (H - Math.floor(H)) * 6;\n      const f = h - Math.floor(h);\n      const p = B * (1 - S);\n      const q = B * (1 - S * f);\n      const t = B * (1 - S * (1 - f));\n      switch (h >> 0) {\n        case 0:\n          r = B;\n          g = t;\n          b = p;\n          break;\n        case 1:\n          r = q;\n          g = B;\n          b = p;\n          break;\n        case 2:\n          r = p;\n          g = B;\n          b = t;\n          break;\n        case 3:\n          r = p;\n          g = q;\n          b = B;\n          break;\n        case 4:\n          r = t;\n          g = p;\n          b = B;\n          break;\n        case 5:\n          r = B;\n          g = p;\n          b = q;\n          break;\n      }\n    }\n    return [r, g, b];\n  }\n  static mix(c0, c1, t) {\n    return new _Color(lerp(c0.r, c1.r, t), lerp(c0.g, c1.g, t), lerp(c0.b, c1.b, t), lerp(c0.a, c1.a, t));\n  }\n};\n/**\n * CSS Color Module Level 4:\n * https://drafts.csswg.org/css-color/#named-colors\n */\n_Color.nameToHex = {\n  // @ts-expect-error\n  __proto__: null,\n  aliceblue: \"#F0F8FF\",\n  antiquewhite: \"#FAEBD7\",\n  aqua: \"#00FFFF\",\n  aquamarine: \"#7FFFD4\",\n  azure: \"#F0FFFF\",\n  beige: \"#F5F5DC\",\n  bisque: \"#FFE4C4\",\n  black: \"#000000\",\n  blanchedalmond: \"#FFEBCD\",\n  blue: \"#0000FF\",\n  blueviolet: \"#8A2BE2\",\n  brown: \"#A52A2A\",\n  burlywood: \"#DEB887\",\n  cadetblue: \"#5F9EA0\",\n  chartreuse: \"#7FFF00\",\n  chocolate: \"#D2691E\",\n  coral: \"#FF7F50\",\n  cornflowerblue: \"#6495ED\",\n  cornsilk: \"#FFF8DC\",\n  crimson: \"#DC143C\",\n  cyan: \"#00FFFF\",\n  darkblue: \"#00008B\",\n  darkcyan: \"#008B8B\",\n  darkgoldenrod: \"#B8860B\",\n  darkgray: \"#A9A9A9\",\n  darkgreen: \"#006400\",\n  darkgrey: \"#A9A9A9\",\n  darkkhaki: \"#BDB76B\",\n  darkmagenta: \"#8B008B\",\n  darkolivegreen: \"#556B2F\",\n  darkorange: \"#FF8C00\",\n  darkorchid: \"#9932CC\",\n  darkred: \"#8B0000\",\n  darksalmon: \"#E9967A\",\n  darkseagreen: \"#8FBC8F\",\n  darkslateblue: \"#483D8B\",\n  darkslategray: \"#2F4F4F\",\n  darkslategrey: \"#2F4F4F\",\n  darkturquoise: \"#00CED1\",\n  darkviolet: \"#9400D3\",\n  deeppink: \"#FF1493\",\n  deepskyblue: \"#00BFFF\",\n  dimgray: \"#696969\",\n  dimgrey: \"#696969\",\n  dodgerblue: \"#1E90FF\",\n  firebrick: \"#B22222\",\n  floralwhite: \"#FFFAF0\",\n  forestgreen: \"#228B22\",\n  fuchsia: \"#FF00FF\",\n  gainsboro: \"#DCDCDC\",\n  ghostwhite: \"#F8F8FF\",\n  gold: \"#FFD700\",\n  goldenrod: \"#DAA520\",\n  gray: \"#808080\",\n  green: \"#008000\",\n  greenyellow: \"#ADFF2F\",\n  grey: \"#808080\",\n  honeydew: \"#F0FFF0\",\n  hotpink: \"#FF69B4\",\n  indianred: \"#CD5C5C\",\n  indigo: \"#4B0082\",\n  ivory: \"#FFFFF0\",\n  khaki: \"#F0E68C\",\n  lavender: \"#E6E6FA\",\n  lavenderblush: \"#FFF0F5\",\n  lawngreen: \"#7CFC00\",\n  lemonchiffon: \"#FFFACD\",\n  lightblue: \"#ADD8E6\",\n  lightcoral: \"#F08080\",\n  lightcyan: \"#E0FFFF\",\n  lightgoldenrodyellow: \"#FAFAD2\",\n  lightgray: \"#D3D3D3\",\n  lightgreen: \"#90EE90\",\n  lightgrey: \"#D3D3D3\",\n  lightpink: \"#FFB6C1\",\n  lightsalmon: \"#FFA07A\",\n  lightseagreen: \"#20B2AA\",\n  lightskyblue: \"#87CEFA\",\n  lightslategray: \"#778899\",\n  lightslategrey: \"#778899\",\n  lightsteelblue: \"#B0C4DE\",\n  lightyellow: \"#FFFFE0\",\n  lime: \"#00FF00\",\n  limegreen: \"#32CD32\",\n  linen: \"#FAF0E6\",\n  magenta: \"#FF00FF\",\n  maroon: \"#800000\",\n  mediumaquamarine: \"#66CDAA\",\n  mediumblue: \"#0000CD\",\n  mediumorchid: \"#BA55D3\",\n  mediumpurple: \"#9370DB\",\n  mediumseagreen: \"#3CB371\",\n  mediumslateblue: \"#7B68EE\",\n  mediumspringgreen: \"#00FA9A\",\n  mediumturquoise: \"#48D1CC\",\n  mediumvioletred: \"#C71585\",\n  midnightblue: \"#191970\",\n  mintcream: \"#F5FFFA\",\n  mistyrose: \"#FFE4E1\",\n  moccasin: \"#FFE4B5\",\n  navajowhite: \"#FFDEAD\",\n  navy: \"#000080\",\n  oldlace: \"#FDF5E6\",\n  olive: \"#808000\",\n  olivedrab: \"#6B8E23\",\n  orange: \"#FFA500\",\n  orangered: \"#FF4500\",\n  orchid: \"#DA70D6\",\n  palegoldenrod: \"#EEE8AA\",\n  palegreen: \"#98FB98\",\n  paleturquoise: \"#AFEEEE\",\n  palevioletred: \"#DB7093\",\n  papayawhip: \"#FFEFD5\",\n  peachpuff: \"#FFDAB9\",\n  peru: \"#CD853F\",\n  pink: \"#FFC0CB\",\n  plum: \"#DDA0DD\",\n  powderblue: \"#B0E0E6\",\n  purple: \"#800080\",\n  rebeccapurple: \"#663399\",\n  red: \"#FF0000\",\n  rosybrown: \"#BC8F8F\",\n  royalblue: \"#4169E1\",\n  saddlebrown: \"#8B4513\",\n  salmon: \"#FA8072\",\n  sandybrown: \"#F4A460\",\n  seagreen: \"#2E8B57\",\n  seashell: \"#FFF5EE\",\n  sienna: \"#A0522D\",\n  silver: \"#C0C0C0\",\n  skyblue: \"#87CEEB\",\n  slateblue: \"#6A5ACD\",\n  slategray: \"#708090\",\n  slategrey: \"#708090\",\n  snow: \"#FFFAFA\",\n  springgreen: \"#00FF7F\",\n  steelblue: \"#4682B4\",\n  tan: \"#D2B48C\",\n  teal: \"#008080\",\n  thistle: \"#D8BFD8\",\n  tomato: \"#FF6347\",\n  transparent: \"#00000000\",\n  turquoise: \"#40E0D0\",\n  violet: \"#EE82EE\",\n  wheat: \"#F5DEB3\",\n  white: \"#FFFFFF\",\n  whitesmoke: \"#F5F5F5\",\n  yellow: \"#FFFF00\",\n  yellowgreen: \"#9ACD32\"\n};\nvar Color = _Color;\n\n// packages/ag-charts-community/src/util/interpolate.ts\nfunction interpolateNumber(a, b) {\n  return (d) => Number(a) * (1 - d) + Number(b) * d;\n}\nfunction interpolateColor(a, b) {\n  if (typeof a === \"string\") {\n    try {\n      a = Color.fromString(a);\n    } catch (e) {\n      a = Color.fromArray([0, 0, 0]);\n    }\n  }\n  if (typeof b === \"string\") {\n    try {\n      b = Color.fromString(b);\n    } catch (e) {\n      b = Color.fromArray([0, 0, 0]);\n    }\n  }\n  return (d) => Color.mix(a, b, d).toRgbaString();\n}\n\n// packages/ag-charts-community/src/util/decorator.ts\nvar BREAK_TRANSFORM_CHAIN = Symbol(\"BREAK\");\nvar CONFIG_KEY = \"__decorator_config\";\nfunction initialiseConfig(target, propertyKeyOrSymbol) {\n  if (Object.getOwnPropertyDescriptor(target, CONFIG_KEY) == null) {\n    Object.defineProperty(target, CONFIG_KEY, { value: {} });\n  }\n  const config = target[CONFIG_KEY];\n  const propertyKey = propertyKeyOrSymbol.toString();\n  if (typeof config[propertyKey] !== \"undefined\") {\n    return config[propertyKey];\n  }\n  const valuesMap = /* @__PURE__ */ new WeakMap();\n  config[propertyKey] = { setters: [], getters: [], observers: [], valuesMap };\n  const descriptor = Object.getOwnPropertyDescriptor(target, propertyKeyOrSymbol);\n  const prevSet = descriptor?.set;\n  const prevGet = descriptor?.get;\n  const getter = function() {\n    let value = prevGet ? prevGet.call(this) : valuesMap.get(this);\n    for (const transformFn of config[propertyKey].getters) {\n      value = transformFn(this, propertyKeyOrSymbol, value);\n      if (value === BREAK_TRANSFORM_CHAIN) {\n        return;\n      }\n    }\n    return value;\n  };\n  const setter = function(value) {\n    const { setters, observers } = config[propertyKey];\n    let oldValue;\n    if (setters.some((f) => f.length > 2)) {\n      oldValue = prevGet ? prevGet.call(this) : valuesMap.get(this);\n    }\n    for (const transformFn of setters) {\n      value = transformFn(this, propertyKeyOrSymbol, value, oldValue);\n      if (value === BREAK_TRANSFORM_CHAIN) {\n        return;\n      }\n    }\n    if (prevSet) {\n      prevSet.call(this, value);\n    } else {\n      valuesMap.set(this, value);\n    }\n    for (const observerFn of observers) {\n      observerFn(this, value, oldValue);\n    }\n  };\n  Object.defineProperty(target, propertyKeyOrSymbol, {\n    set: setter,\n    get: getter,\n    enumerable: true,\n    configurable: false\n  });\n  return config[propertyKey];\n}\nfunction addTransformToInstanceProperty(setTransform, getTransform, configMetadata) {\n  return (target, propertyKeyOrSymbol) => {\n    const config = initialiseConfig(target, propertyKeyOrSymbol);\n    config.setters.push(setTransform);\n    if (getTransform) {\n      config.getters.unshift(getTransform);\n    }\n    if (configMetadata) {\n      Object.assign(config, configMetadata);\n    }\n  };\n}\nfunction addObserverToInstanceProperty(setObserver) {\n  return (target, propertyKeyOrSymbol) => {\n    initialiseConfig(target, propertyKeyOrSymbol).observers.push(setObserver);\n  };\n}\nfunction isDecoratedObject(target) {\n  return typeof target !== \"undefined\" && CONFIG_KEY in target;\n}\nfunction listDecoratedProperties(target) {\n  const targets = /* @__PURE__ */ new Set();\n  while (isDecoratedObject(target)) {\n    targets.add(target?.[CONFIG_KEY]);\n    target = Object.getPrototypeOf(target);\n  }\n  return Array.from(targets).flatMap((configMap) => Object.keys(configMap));\n}\nfunction extractDecoratedProperties(target) {\n  return listDecoratedProperties(target).reduce((result, key) => {\n    result[key] = target[key] ?? null;\n    return result;\n  }, {});\n}\nfunction extractDecoratedPropertyMetadata(target, propertyKeyOrSymbol) {\n  const propertyKey = propertyKeyOrSymbol.toString();\n  while (isDecoratedObject(target)) {\n    const config = target[CONFIG_KEY];\n    if (Object.hasOwn(config, propertyKey)) {\n      return config[propertyKey];\n    }\n    target = Object.getPrototypeOf(target);\n  }\n}\n\n// packages/ag-charts-community/src/util/type-guards.ts\nfunction isDefined(val) {\n  return val != null;\n}\nfunction isArray(value) {\n  return Array.isArray(value);\n}\nfunction isBoolean(value) {\n  return typeof value === \"boolean\";\n}\nfunction isDate(value) {\n  return value instanceof Date;\n}\nfunction isValidDate(value) {\n  return isDate(value) && !isNaN(Number(value));\n}\nfunction isRegExp(value) {\n  return value instanceof RegExp;\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null && !isArray(value);\n}\nfunction isObjectLike(value) {\n  return isArray(value) || isPlainObject(value);\n}\nfunction isPlainObject(value) {\n  return typeof value === \"object\" && value !== null && value.constructor === Object;\n}\nfunction isString(value) {\n  return typeof value === \"string\";\n}\nfunction isNumber(value) {\n  return typeof value === \"number\";\n}\nfunction isFiniteNumber(value) {\n  return isNumber(value) && Number.isFinite(value);\n}\nfunction isHtmlElement(value) {\n  return typeof window !== \"undefined\" && value instanceof HTMLElement;\n}\nfunction isEnumKey(enumObject, enumKey) {\n  return isString(enumKey) && Object.keys(enumObject).includes(enumKey);\n}\nfunction isEnumValue(enumObject, enumValue) {\n  return Object.values(enumObject).includes(enumValue);\n}\nfunction isSymbol(value) {\n  return typeof value === \"symbol\";\n}\n\n// packages/ag-charts-community/src/util/object.ts\nfunction deepMerge(...sources) {\n  return mergeDefaults(...sources.reverse());\n}\nfunction mergeDefaults(...sources) {\n  const target = {};\n  for (const source of sources) {\n    if (!isObject(source))\n      continue;\n    const keys = isDecoratedObject(source) ? listDecoratedProperties(source) : Object.keys(source);\n    for (const key of keys) {\n      if (isPlainObject(target[key]) && isPlainObject(source[key])) {\n        target[key] = mergeDefaults(target[key], source[key]);\n      } else {\n        target[key] ?? (target[key] = source[key]);\n      }\n    }\n  }\n  return target;\n}\nfunction mergeArrayDefaults(dataArray, ...itemDefaults) {\n  if (itemDefaults && isArray(dataArray)) {\n    return dataArray.map((item) => mergeDefaults(item, ...itemDefaults));\n  }\n  return dataArray;\n}\nfunction mapValues(object, mapper) {\n  return Object.entries(object).reduce(\n    (result, [key, value]) => {\n      result[key] = mapper(value, key, object);\n      return result;\n    },\n    {}\n  );\n}\nfunction without(object, keys) {\n  const clone = { ...object };\n  for (const key of keys) {\n    delete clone[key];\n  }\n  return clone;\n}\nfunction getPath(object, path) {\n  const pathArray = isArray(path) ? path : path.split(\".\");\n  return pathArray.reduce((value, pathKey) => value[pathKey], object);\n}\nvar SKIP_JS_BUILTINS = /* @__PURE__ */ new Set([\"__proto__\", \"constructor\", \"prototype\"]);\nfunction setPath(object, path, newValue) {\n  const pathArray = isArray(path) ? path.slice() : path.split(\".\");\n  const lastKey = pathArray.pop();\n  if (pathArray.some((p) => SKIP_JS_BUILTINS.has(p)))\n    return;\n  const lastObject = pathArray.reduce((value, pathKey) => value[pathKey], object);\n  lastObject[lastKey] = newValue;\n  return lastObject[lastKey];\n}\nfunction partialAssign(keysToCopy, target, source) {\n  if (source === void 0) {\n    return target;\n  }\n  for (const key of keysToCopy) {\n    const value = source[key];\n    if (value !== void 0) {\n      target[key] = value;\n    }\n  }\n  return target;\n}\n\n// packages/ag-charts-community/src/util/properties.ts\nvar BaseProperties = class {\n  set(properties) {\n    const { className = this.constructor.name } = this.constructor;\n    if (typeof properties !== \"object\") {\n      Logger.warn(`unable to set ${className} - expecting a properties object`);\n      return this;\n    }\n    const keys = new Set(Object.keys(properties));\n    for (const propertyKey of listDecoratedProperties(this)) {\n      if (keys.has(propertyKey)) {\n        const value = properties[propertyKey];\n        const self = this;\n        if (isProperties(self[propertyKey])) {\n          self[propertyKey] = self[propertyKey] instanceof PropertiesArray ? self[propertyKey].reset(value) : self[propertyKey].set(value);\n        } else {\n          self[propertyKey] = value;\n        }\n        keys.delete(propertyKey);\n      }\n    }\n    for (const unknownKey of keys) {\n      Logger.warn(`unable to set [${unknownKey}] in ${className} - property is unknown`);\n    }\n    return this;\n  }\n  isValid(warningPrefix) {\n    return listDecoratedProperties(this).every((propertyKey) => {\n      const { optional } = extractDecoratedPropertyMetadata(this, propertyKey);\n      const valid = optional === true || typeof this[propertyKey] !== \"undefined\";\n      if (!valid) {\n        Logger.warnOnce(`${warningPrefix ?? \"\"}[${propertyKey}] is required.`);\n      }\n      return valid;\n    });\n  }\n  toJson() {\n    return listDecoratedProperties(this).reduce((object, propertyKey) => {\n      const propertyValue = this[propertyKey];\n      object[propertyKey] = isProperties(propertyValue) ? propertyValue.toJson() : propertyValue;\n      return object;\n    }, {});\n  }\n};\nvar PropertiesArray = class _PropertiesArray extends Array {\n  constructor(itemFactory, ...properties) {\n    super(properties.length);\n    const isConstructor = (value2) => Boolean(value2?.prototype?.constructor?.name);\n    const value = isConstructor(itemFactory) ? (params) => new itemFactory().set(params) : itemFactory;\n    Object.defineProperty(this, \"itemFactory\", { value, enumerable: false, configurable: false });\n    this.set(properties);\n  }\n  set(properties) {\n    if (isArray(properties)) {\n      this.length = properties.length;\n      for (let i = 0; i < properties.length; i++) {\n        this[i] = this.itemFactory(properties[i]);\n      }\n    }\n    return this;\n  }\n  reset(properties) {\n    return new _PropertiesArray(this.itemFactory, ...properties);\n  }\n  toJson() {\n    return this.map((value) => value?.toJson?.() ?? value);\n  }\n};\nfunction isProperties(value) {\n  return value instanceof BaseProperties || value instanceof PropertiesArray;\n}\n\n// packages/ag-charts-community/src/util/json.ts\nvar CLASS_INSTANCE_TYPE = \"class-instance\";\nfunction jsonDiff(source, target, skip) {\n  if (isArray(target)) {\n    if (!isArray(source) || source.length !== target.length || target.some((v, i) => jsonDiff(source[i], v) != null)) {\n      return target;\n    }\n  } else if (isPlainObject(target)) {\n    if (!isPlainObject(source)) {\n      return target;\n    }\n    const result = {};\n    const allKeys = /* @__PURE__ */ new Set([\n      ...Object.keys(source),\n      ...Object.keys(target)\n    ]);\n    for (const key of allKeys) {\n      if (source[key] === target[key] || skip?.includes(key)) {\n        continue;\n      }\n      if (typeof source[key] === typeof target[key]) {\n        const diff2 = jsonDiff(source[key], target[key]);\n        if (diff2 !== null) {\n          result[key] = diff2;\n        }\n      } else {\n        result[key] = target[key];\n      }\n    }\n    return Object.keys(result).length ? result : null;\n  } else if (source !== target) {\n    return target;\n  }\n  return null;\n}\nfunction deepClone(source, options) {\n  if (isArray(source)) {\n    return source.map((item) => deepClone(item, options));\n  }\n  if (isPlainObject(source)) {\n    return mapValues(\n      source,\n      (value, key) => options?.shallow?.includes(key) ? shallowClone(value) : deepClone(value, options)\n    );\n  }\n  return shallowClone(source);\n}\nfunction shallowClone(source) {\n  if (isArray(source)) {\n    return [...source];\n  }\n  if (isPlainObject(source)) {\n    return { ...source };\n  }\n  if (isDate(source)) {\n    return new Date(source);\n  }\n  if (isRegExp(source)) {\n    return new RegExp(source.source, source.flags);\n  }\n  return source;\n}\nfunction jsonWalk(json, visit, opts, ...jsons) {\n  if (isArray(json)) {\n    visit(json, ...jsons);\n    json.forEach((node, index) => {\n      jsonWalk(node, visit, opts, ...keyMapper(jsons, index));\n    });\n  } else if (isPlainObject(json)) {\n    visit(json, ...jsons);\n    for (const key of Object.keys(json)) {\n      if (opts?.skip?.includes(key)) {\n        continue;\n      }\n      const value = json[key];\n      if (isArray(value) || isPlainObject(value)) {\n        jsonWalk(value, visit, opts, ...keyMapper(jsons, key));\n      }\n    }\n  }\n}\nfunction jsonApply(target, source, params = {}) {\n  const { path, constructedArrays, matcherPath = path?.replace(/(\\[[0-9+]+])/i, \"[]\"), skip = [] } = params;\n  if (target == null) {\n    throw new Error(`AG Charts - target is uninitialised: ${path ?? \"<root>\"}`);\n  }\n  if (source == null) {\n    return target;\n  }\n  if (isProperties(target)) {\n    return target.set(source);\n  }\n  const targetAny = target;\n  const targetType = classify(target);\n  for (const property in source) {\n    if (SKIP_JS_BUILTINS.has(property))\n      continue;\n    const propertyMatcherPath = `${matcherPath ? matcherPath + \".\" : \"\"}${property}`;\n    if (skip.includes(propertyMatcherPath))\n      continue;\n    const newValue = source[property];\n    const propertyPath = `${path ? path + \".\" : \"\"}${property}`;\n    const targetClass = targetAny.constructor;\n    const currentValue = targetAny[property];\n    let ctr;\n    try {\n      const currentValueType = classify(currentValue);\n      const newValueType = classify(newValue);\n      if (targetType === CLASS_INSTANCE_TYPE && !(property in target)) {\n        Logger.warn(`unable to set [${propertyPath}] in ${targetClass?.name} - property is unknown`);\n        continue;\n      }\n      if (currentValueType != null && newValueType != null && newValueType !== currentValueType && (currentValueType !== CLASS_INSTANCE_TYPE || newValueType !== \"object\")) {\n        Logger.warn(\n          `unable to set [${propertyPath}] in ${targetClass?.name} - can't apply type of [${newValueType}], allowed types are: [${currentValueType}]`\n        );\n        continue;\n      }\n      if (isProperties(currentValue)) {\n        targetAny[property].set(newValue);\n      } else if (newValueType === \"array\") {\n        ctr ?? (ctr = constructedArrays?.get(currentValue));\n        if (ctr == null) {\n          targetAny[property] = newValue;\n        } else {\n          const newValueArray = newValue;\n          targetAny[property] = newValueArray.map(\n            (v) => jsonApply(new ctr(), v, {\n              ...params,\n              path: propertyPath,\n              matcherPath: propertyMatcherPath + \"[]\"\n            })\n          );\n        }\n      } else if (newValueType === CLASS_INSTANCE_TYPE) {\n        targetAny[property] = newValue;\n      } else if (newValueType === \"object\") {\n        if (currentValue != null) {\n          jsonApply(currentValue, newValue, {\n            ...params,\n            path: propertyPath,\n            matcherPath: propertyMatcherPath\n          });\n        } else if (ctr == null) {\n          targetAny[property] = {};\n          jsonApply(targetAny[property], newValue, {\n            ...params,\n            path: propertyPath,\n            matcherPath: propertyMatcherPath\n          });\n        } else {\n          targetAny[property] = jsonApply(new ctr(), newValue, {\n            ...params,\n            path: propertyPath,\n            matcherPath: propertyMatcherPath\n          });\n        }\n      } else {\n        targetAny[property] = newValue;\n      }\n    } catch (error) {\n      Logger.warn(`unable to set [${propertyPath}] in [${targetClass?.name}]; nested error is: ${error.message}`);\n    }\n  }\n  return target;\n}\nfunction keyMapper(data, key) {\n  return data.map((dataObject) => dataObject?.[key]);\n}\nfunction classify(value) {\n  if (value == null) {\n    return null;\n  }\n  if (isHtmlElement(value) || isDate(value)) {\n    return \"primitive\";\n  }\n  if (isArray(value)) {\n    return \"array\";\n  }\n  if (isObject(value)) {\n    return isPlainObject(value) ? \"object\" : CLASS_INSTANCE_TYPE;\n  }\n  if (isFunction(value)) {\n    return \"function\";\n  }\n  return \"primitive\";\n}\n\n// packages/ag-charts-community/src/motion/easing.ts\nvar easing_exports = {};\n__export(easing_exports, {\n  easeIn: () => easeIn,\n  easeInOut: () => easeInOut,\n  easeInOutQuad: () => easeInOutQuad,\n  easeInQuad: () => easeInQuad,\n  easeOut: () => easeOut,\n  easeOutQuad: () => easeOutQuad,\n  inverseEaseOut: () => inverseEaseOut,\n  linear: () => linear\n});\nvar linear = (n) => n;\nvar easeIn = (n) => 1 - Math.cos(n * Math.PI / 2);\nvar easeOut = (n) => Math.sin(n * Math.PI / 2);\nvar easeInOut = (n) => -(Math.cos(n * Math.PI) - 1) / 2;\nvar easeInQuad = (n) => n * n;\nvar easeOutQuad = (n) => 1 - (1 - n) ** 2;\nvar easeInOutQuad = (n) => n < 0.5 ? 2 * n * n : 1 - (-2 * n + 2) ** 2 / 2;\nvar inverseEaseOut = (x) => 2 * Math.asin(x) / Math.PI;\n\n// packages/ag-charts-community/src/motion/animation.ts\nvar QUICK_TRANSITION = 0.2;\nvar PHASE_ORDER = [\"initial\", \"remove\", \"update\", \"add\", \"trailing\", \"end\", \"none\"];\nvar PHASE_METADATA = {\n  initial: {\n    animationDuration: 1,\n    animationDelay: 0\n  },\n  add: {\n    animationDuration: 0.25,\n    animationDelay: 0.75\n  },\n  remove: {\n    animationDuration: 0.25,\n    animationDelay: 0\n  },\n  update: {\n    animationDuration: 0.5,\n    animationDelay: 0.25\n  },\n  trailing: {\n    animationDuration: QUICK_TRANSITION,\n    animationDelay: 1,\n    skipIfNoEarlierAnimations: true\n  },\n  end: {\n    animationDelay: 1 + QUICK_TRANSITION,\n    animationDuration: 0,\n    skipIfNoEarlierAnimations: true\n  },\n  none: {\n    animationDuration: 0,\n    animationDelay: 0\n  }\n};\nvar RepeatType = /* @__PURE__ */ ((RepeatType2) => {\n  RepeatType2[\"Loop\"] = \"loop\";\n  RepeatType2[\"Reverse\"] = \"reverse\";\n  return RepeatType2;\n})(RepeatType || {});\nfunction isNodeArray(array) {\n  return array.every((n) => n instanceof Node);\n}\nfunction deconstructSelectionsOrNodes(selectionsOrNodes) {\n  return isNodeArray(selectionsOrNodes) ? { nodes: selectionsOrNodes, selections: [] } : { nodes: [], selections: selectionsOrNodes };\n}\nvar Animation = class {\n  constructor(opts) {\n    this.isComplete = false;\n    this.elapsed = 0;\n    this.iteration = 0;\n    this.isPlaying = false;\n    this.isReverse = false;\n    this.id = opts.id;\n    this.groupId = opts.groupId;\n    this.autoplay = opts.autoplay ?? true;\n    this.ease = opts.ease ?? linear;\n    this.phase = opts.phase;\n    const durationProportion = opts.duration ?? PHASE_METADATA[this.phase].animationDuration;\n    this.duration = durationProportion * opts.defaultDuration;\n    this.delay = (opts.delay ?? 0) * opts.defaultDuration;\n    this.onComplete = opts.onComplete;\n    this.onPlay = opts.onPlay;\n    this.onStop = opts.onStop;\n    this.onUpdate = opts.onUpdate;\n    this.interpolate = this.createInterpolator(opts.from, opts.to);\n    this.from = opts.from;\n    if (opts.skip === true) {\n      this.onUpdate?.(opts.to, false, this);\n      this.onStop?.(this);\n      this.onComplete?.(this);\n      this.isComplete = true;\n    }\n    if (opts.collapsable !== false) {\n      this.duration = this.checkCollapse(opts, this.duration);\n    }\n  }\n  checkCollapse(opts, calculatedDuration) {\n    if (opts.from === opts.to)\n      return 0;\n    const diff2 = typeof opts.from === \"object\" ? jsonDiff(opts.from, opts.to) : null;\n    if (diff2) {\n      return calculatedDuration;\n    }\n    return 0;\n  }\n  play(initialUpdate = false) {\n    if (this.isPlaying || this.isComplete)\n      return;\n    this.isPlaying = true;\n    this.onPlay?.(this);\n    if (!this.autoplay)\n      return;\n    this.autoplay = false;\n    if (!initialUpdate)\n      return;\n    this.onUpdate?.(this.from, true, this);\n  }\n  pause() {\n    this.isPlaying = false;\n  }\n  stop() {\n    this.isPlaying = false;\n    if (!this.isComplete) {\n      this.isComplete = true;\n      this.onStop?.(this);\n    }\n  }\n  update(time2) {\n    if (this.isComplete)\n      return time2;\n    if (!this.isPlaying && this.autoplay) {\n      this.play(true);\n    }\n    const previousElapsed = this.elapsed;\n    this.elapsed += time2;\n    if (this.delay > this.elapsed)\n      return 0;\n    const value = this.interpolate(this.isReverse ? 1 - this.delta : this.delta);\n    this.onUpdate?.(value, false, this);\n    const totalDuration = this.delay + this.duration;\n    if (this.elapsed >= totalDuration) {\n      this.stop();\n      this.isComplete = true;\n      this.onComplete?.(this);\n      return time2 - (totalDuration - previousElapsed);\n    }\n    return 0;\n  }\n  get delta() {\n    return this.ease(clamp(0, (this.elapsed - this.delay) / this.duration, 1));\n  }\n  createInterpolator(from2, to) {\n    if (typeof to !== \"object\" || isInterpolating(to)) {\n      return this.interpolateValue(from2, to);\n    }\n    const interpolatorEntries = [];\n    for (const key in to) {\n      const interpolator = this.interpolateValue(from2[key], to[key]);\n      if (interpolator != null) {\n        interpolatorEntries.push([key, interpolator]);\n      }\n    }\n    return (d) => {\n      const result = {};\n      for (const [key, interpolator] of interpolatorEntries) {\n        result[key] = interpolator(d);\n      }\n      return result;\n    };\n  }\n  interpolateValue(a, b) {\n    if (a === void 0 || b === void 0) {\n      return;\n    } else if (isInterpolating(a)) {\n      return (d) => a[interpolate](b, d);\n    }\n    try {\n      switch (typeof a) {\n        case \"number\":\n          return interpolateNumber(a, b);\n        case \"string\":\n          return interpolateColor(a, b);\n        case \"boolean\":\n          if (a === b)\n            return () => a;\n          break;\n      }\n    } catch (e) {\n    }\n    throw new Error(`Unable to interpolate values: ${a}, ${b}`);\n  }\n};\n\n// packages/ag-charts-community/src/motion/fromToMotion.ts\nvar NODE_UPDATE_STATE_TO_PHASE_MAPPING = {\n  added: \"add\",\n  updated: \"update\",\n  removed: \"remove\",\n  unknown: \"initial\",\n  \"no-op\": \"none\"\n};\nfunction fromToMotion(groupId, subId, animationManager, selectionsOrNodes, fns, getDatumId, diff2) {\n  const { fromFn, toFn, intermediateFn } = fns;\n  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);\n  const processNodes = (liveNodes, subNodes) => {\n    let prevFromProps;\n    let liveNodeIndex = 0;\n    let nodeIndex = 0;\n    for (const node of subNodes) {\n      const isLive = liveNodes[liveNodeIndex] === node;\n      const ctx = {\n        last: nodeIndex >= subNodes.length - 1,\n        lastLive: liveNodeIndex >= liveNodes.length - 1,\n        prev: subNodes[nodeIndex - 1],\n        prevFromProps,\n        prevLive: liveNodes[liveNodeIndex - 1],\n        next: subNodes[nodeIndex + 1],\n        nextLive: liveNodes[liveNodeIndex + (isLive ? 1 : 0)]\n      };\n      const animationId = `${groupId}_${subId}_${node.id}`;\n      animationManager.stopByAnimationId(animationId);\n      let status = \"unknown\";\n      if (!isLive) {\n        status = \"removed\";\n      } else if (getDatumId && diff2) {\n        status = calculateStatus(node, node.datum, getDatumId, diff2);\n      }\n      const { phase, start, finish, delay, duration, ...from2 } = fromFn(node, node.datum, status, ctx);\n      const {\n        phase: toPhase,\n        start: toStart,\n        finish: toFinish,\n        delay: toDelay,\n        duration: toDuration,\n        ...to\n      } = toFn(node, node.datum, status, ctx);\n      const collapsable = finish == null && toFinish == null;\n      animationManager.animate({\n        id: animationId,\n        groupId,\n        phase: phase ?? toPhase ?? \"update\",\n        duration: duration ?? toDuration,\n        delay: delay ?? toDelay,\n        from: from2,\n        to,\n        ease: easeOut,\n        collapsable,\n        onPlay: () => {\n          node.setProperties({ ...start, ...toStart });\n        },\n        onUpdate(props) {\n          node.setProperties(props);\n          if (intermediateFn) {\n            node.setProperties(intermediateFn(node, node.datum, status, ctx));\n          }\n        },\n        onStop: () => {\n          node.setProperties({\n            ...start,\n            ...toStart,\n            ...from2,\n            ...to,\n            ...finish,\n            ...toFinish\n          });\n        }\n      });\n      if (isLive) {\n        liveNodeIndex++;\n      }\n      nodeIndex++;\n      prevFromProps = from2;\n    }\n  };\n  let selectionIndex = 0;\n  for (const selection of selections) {\n    const selectionNodes = selection.nodes();\n    const liveNodes = selectionNodes.filter((n) => !selection.isGarbage(n));\n    processNodes(liveNodes, selectionNodes);\n    animationManager.animate({\n      id: `${groupId}_${subId}_selection_${selectionIndex}`,\n      groupId,\n      phase: \"end\",\n      from: 0,\n      to: 1,\n      ease: easeOut,\n      onStop() {\n        selection.cleanup();\n      }\n    });\n    selectionIndex++;\n  }\n  processNodes(nodes, nodes);\n}\nfunction staticFromToMotion(groupId, subId, animationManager, selectionsOrNodes, from2, to, extraOpts) {\n  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);\n  const { start, finish, phase } = extraOpts;\n  const collapsable = finish == null;\n  animationManager.animate({\n    id: `${groupId}_${subId}`,\n    groupId,\n    phase: phase ?? \"update\",\n    from: from2,\n    to,\n    ease: easeOut,\n    collapsable,\n    onPlay: () => {\n      if (!start)\n        return;\n      for (const node of nodes) {\n        node.setProperties(start);\n      }\n      for (const selection of selections) {\n        for (const node of selection.nodes()) {\n          node.setProperties(start);\n        }\n      }\n    },\n    onUpdate(props) {\n      for (const node of nodes) {\n        node.setProperties(props);\n      }\n      for (const selection of selections) {\n        for (const node of selection.nodes()) {\n          node.setProperties(props);\n        }\n      }\n    },\n    onStop: () => {\n      for (const node of nodes) {\n        node.setProperties({ ...to, ...finish });\n      }\n      for (const selection of selections) {\n        for (const node of selection.nodes()) {\n          node.setProperties({ ...to, ...finish });\n        }\n      }\n    }\n  });\n}\nfunction calculateStatus(node, datum, getDatumId, diff2) {\n  const id = getDatumId(node, datum);\n  if (diff2.added.has(id)) {\n    return \"added\";\n  }\n  if (diff2.removed.has(id)) {\n    return \"removed\";\n  }\n  return \"updated\";\n}\n\n// packages/ag-charts-community/src/util/timeFormat.ts\nvar CONSTANTS = {\n  periods: [\"AM\", \"PM\"],\n  days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n  shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n  months: [\n    \"January\",\n    \"February\",\n    \"March\",\n    \"April\",\n    \"May\",\n    \"June\",\n    \"July\",\n    \"August\",\n    \"September\",\n    \"October\",\n    \"November\",\n    \"December\"\n  ],\n  shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n};\nfunction dayOfYear(date, startOfYear = new Date(date.getFullYear(), 0, 1)) {\n  const startOffset = date.getTimezoneOffset() - startOfYear.getTimezoneOffset();\n  const timeDiff = date.getTime() - startOfYear.getTime() + startOffset * 6e4;\n  const timeOneDay = 36e5 * 24;\n  return Math.floor(timeDiff / timeOneDay);\n}\nfunction weekOfYear(date, startDay) {\n  const startOfYear = new Date(date.getFullYear(), 0, 1);\n  const startOfYearDay = startOfYear.getDay();\n  const firstWeekStartOffset = (startDay - startOfYearDay + 7) % 7;\n  const startOffset = new Date(date.getFullYear(), 0, firstWeekStartOffset + 1);\n  if (startOffset <= date) {\n    return Math.floor(dayOfYear(date, startOffset) / 7) + 1;\n  }\n  return 0;\n}\nvar SUNDAY = 0;\nvar MONDAY = 1;\nvar THURSDAY = 4;\nfunction isoWeekOfYear(date, year2 = date.getFullYear()) {\n  const firstOfYear = new Date(year2, 0, 1);\n  const firstOfYearDay = firstOfYear.getDay();\n  const firstThursdayOffset = (THURSDAY - firstOfYearDay + 7) % 7;\n  const startOffset = new Date(year2, 0, firstThursdayOffset - (THURSDAY - MONDAY) + 1);\n  if (startOffset <= date) {\n    return Math.floor(dayOfYear(date, startOffset) / 7) + 1;\n  }\n  return isoWeekOfYear(date, year2 - 1);\n}\nfunction timezone(date) {\n  const offset4 = date.getTimezoneOffset();\n  const unsignedOffset = Math.abs(offset4);\n  const sign = offset4 > 0 ? \"-\" : \"+\";\n  return `${sign}${pad(Math.floor(unsignedOffset / 60), 2, \"0\")}${pad(Math.floor(unsignedOffset % 60), 2, \"0\")}`;\n}\nvar FORMATTERS = {\n  a: (d) => CONSTANTS.shortDays[d.getDay()],\n  A: (d) => CONSTANTS.days[d.getDay()],\n  b: (d) => CONSTANTS.shortMonths[d.getMonth()],\n  B: (d) => CONSTANTS.months[d.getMonth()],\n  c: \"%x, %X\",\n  d: (d, p) => pad(d.getDate(), 2, p ?? \"0\"),\n  e: \"%_d\",\n  f: (d, p) => pad(d.getMilliseconds() * 1e3, 6, p ?? \"0\"),\n  H: (d, p) => pad(d.getHours(), 2, p ?? \"0\"),\n  I: (d, p) => {\n    const hours = d.getHours() % 12;\n    return hours === 0 ? \"12\" : pad(hours, 2, p ?? \"0\");\n  },\n  j: (d, p) => pad(dayOfYear(d) + 1, 3, p ?? \"0\"),\n  m: (d, p) => pad(d.getMonth() + 1, 2, p ?? \"0\"),\n  M: (d, p) => pad(d.getMinutes(), 2, p ?? \"0\"),\n  L: (d, p) => pad(d.getMilliseconds(), 3, p ?? \"0\"),\n  p: (d) => d.getHours() < 12 ? \"AM\" : \"PM\",\n  Q: (d) => String(d.getTime()),\n  s: (d) => String(Math.floor(d.getTime() / 1e3)),\n  S: (d, p) => pad(d.getSeconds(), 2, p ?? \"0\"),\n  u: (d) => {\n    let day2 = d.getDay();\n    if (day2 < 1)\n      day2 += 7;\n    return String(day2 % 7);\n  },\n  U: (d, p) => pad(weekOfYear(d, SUNDAY), 2, p ?? \"0\"),\n  V: (d, p) => pad(isoWeekOfYear(d), 2, p ?? \"0\"),\n  w: (d, p) => pad(d.getDay(), 2, p ?? \"0\"),\n  W: (d, p) => pad(weekOfYear(d, MONDAY), 2, p ?? \"0\"),\n  x: \"%-m/%-d/%Y\",\n  X: \"%-I:%M:%S %p\",\n  y: (d, p) => pad(d.getFullYear() % 100, 2, p ?? \"0\"),\n  Y: (d, p) => pad(d.getFullYear(), 4, p ?? \"0\"),\n  Z: (d) => timezone(d),\n  \"%\": () => \"%\"\n};\nvar PADS = {\n  _: \" \",\n  \"0\": \"0\",\n  \"-\": \"\"\n};\nfunction pad(value, size, padChar) {\n  const output = String(Math.floor(value));\n  if (output.length >= size) {\n    return output;\n  }\n  return `${padChar.repeat(size - output.length)}${output}`;\n}\nfunction buildFormatter(formatString) {\n  const formatParts = [];\n  while (formatString.length > 0) {\n    let nextEscapeIdx = formatString.indexOf(\"%\");\n    if (nextEscapeIdx !== 0) {\n      const literalPart = nextEscapeIdx > 0 ? formatString.substring(0, nextEscapeIdx) : formatString;\n      formatParts.push(literalPart);\n    }\n    if (nextEscapeIdx < 0)\n      break;\n    const maybePadSpecifier = formatString[nextEscapeIdx + 1];\n    const maybePad = PADS[maybePadSpecifier];\n    if (maybePad != null) {\n      nextEscapeIdx++;\n    }\n    const maybeFormatterSpecifier = formatString[nextEscapeIdx + 1];\n    const maybeFormatter = FORMATTERS[maybeFormatterSpecifier];\n    if (typeof maybeFormatter === \"function\") {\n      formatParts.push([maybeFormatter, maybePad]);\n    } else if (typeof maybeFormatter === \"string\") {\n      const formatter = buildFormatter(maybeFormatter);\n      formatParts.push([formatter, maybePad]);\n    } else {\n      formatParts.push(`${maybePad ?? \"\"}${maybeFormatterSpecifier}`);\n    }\n    formatString = formatString.substring(nextEscapeIdx + 2);\n  }\n  return (dateTime) => {\n    const dateTimeAsDate = typeof dateTime === \"number\" ? new Date(dateTime) : dateTime;\n    return formatParts.map((c) => typeof c === \"string\" ? c : c[0](dateTimeAsDate, c[1])).join(\"\");\n  };\n}\n\n// packages/ag-charts-community/src/util/timeFormatDefaults.ts\nfunction dateToNumber(x) {\n  return x instanceof Date ? x.getTime() : x;\n}\nfunction defaultTimeTickFormat(ticks, domain, formatOffset) {\n  const formatString = calculateDefaultTimeTickFormat(ticks, domain, formatOffset);\n  const formatter = buildFormatter(formatString);\n  return (date) => formatter(date);\n}\nfunction calculateDefaultTimeTickFormat(ticks = [], domain = ticks, formatOffset = 0) {\n  let minInterval = Infinity;\n  for (let i = 1; i < ticks.length; i++) {\n    minInterval = Math.min(minInterval, Math.abs(ticks[i] - ticks[i - 1]));\n  }\n  const startYear = new Date(domain[0]).getFullYear();\n  const stopYear = new Date(domain.at(-1)).getFullYear();\n  const yearChange = stopYear - startYear > 0;\n  const timeFormat = isFinite(minInterval) ? getIntervalLowestGranularityFormat(minInterval, ticks) : getLowestGranularityFormat(ticks[0]);\n  return formatStringBuilder(Math.max(timeFormat - formatOffset, 0), yearChange, ticks);\n}\nfunction getIntervalLowestGranularityFormat(value, ticks) {\n  if (value < durationSecond) {\n    return 0 /* MILLISECOND */;\n  } else if (value < durationMinute) {\n    return 1 /* SECOND */;\n  } else if (value < durationHour) {\n    return 2 /* MINUTE */;\n  } else if (value < durationDay) {\n    return 3 /* HOUR */;\n  } else if (value < durationWeek) {\n    return 4 /* WEEK_DAY */;\n  } else if (value < durationDay * 28 || value < durationDay * 31 && hasDuplicateMonth(ticks)) {\n    return 5 /* SHORT_MONTH */;\n  } else if (value < durationYear) {\n    return 6 /* MONTH */;\n  }\n  return 7 /* YEAR */;\n}\nfunction getLowestGranularityFormat(value) {\n  if (second_default.floor(value) < value) {\n    return 0 /* MILLISECOND */;\n  } else if (minute_default.floor(value) < value) {\n    return 1 /* SECOND */;\n  } else if (hour_default.floor(value) < value) {\n    return 2 /* MINUTE */;\n  } else if (day_default.floor(value) < value) {\n    return 3 /* HOUR */;\n  } else if (month_default.floor(value) < value) {\n    if (week_default.floor(value) < value) {\n      return 4 /* WEEK_DAY */;\n    }\n    return 5 /* SHORT_MONTH */;\n  } else if (year_default.floor(value) < value) {\n    return 6 /* MONTH */;\n  }\n  return 7 /* YEAR */;\n}\nfunction hasDuplicateMonth(ticks) {\n  let prevMonth = new Date(ticks[0]).getMonth();\n  for (let i = 1; i < ticks.length; i++) {\n    const tickMonth = new Date(ticks[i]).getMonth();\n    if (prevMonth === tickMonth) {\n      return true;\n    }\n    prevMonth = tickMonth;\n  }\n  return false;\n}\nfunction formatStringBuilder(defaultTimeFormat, yearChange, ticks) {\n  const firstTick = dateToNumber(ticks[0]);\n  const lastTick = dateToNumber(ticks.at(-1));\n  const extent2 = Math.abs(lastTick - firstTick);\n  const activeYear = yearChange || defaultTimeFormat === 7 /* YEAR */;\n  const activeDate = extent2 === 0;\n  const parts = [\n    [\"hour\", 6 * durationHour, 14 * durationDay, 3 /* HOUR */, \"%I %p\"],\n    [\"hour\", durationMinute, 6 * durationHour, 3 /* HOUR */, \"%I:%M\"],\n    [\"second\", 1e3, 6 * durationHour, 1 /* SECOND */, \":%S\"],\n    [\"ms\", 0, 6 * durationHour, 0 /* MILLISECOND */, \".%L\"],\n    [\"am/pm\", durationMinute, 6 * durationHour, 3 /* HOUR */, \"%p\"],\n    \" \",\n    [\"day\", durationDay, durationWeek, 4 /* WEEK_DAY */, \"%a\"],\n    [\"month\", activeDate ? 0 : durationWeek, 52 * durationWeek, 5 /* SHORT_MONTH */, \"%b %d\"],\n    [\"month\", 5 * durationWeek, 10 * durationYear, 6 /* MONTH */, \"%B\"],\n    \" \",\n    [\"year\", activeYear ? 0 : durationYear, Infinity, 7 /* YEAR */, \"%Y\"]\n  ];\n  const formatParts = parts.filter((v) => {\n    if (typeof v === \"string\")\n      return true;\n    const [_, min, max, format] = v;\n    return format >= defaultTimeFormat && min <= extent2 && extent2 < max;\n  }).reduce(\n    (r, next) => {\n      if (typeof next === \"string\") {\n        r.result.push(next);\n      } else if (!r.used.has(next[0])) {\n        r.result.push(next);\n        r.used.add(next[0]);\n      }\n      return r;\n    },\n    { result: [], used: /* @__PURE__ */ new Set() }\n  ).result;\n  const firstFormat = formatParts.findIndex((v) => typeof v !== \"string\");\n  const lastFormat = formatParts.length - [...formatParts].reverse().findIndex((v) => typeof v !== \"string\");\n  return formatParts.slice(firstFormat, lastFormat).map((v) => typeof v === \"string\" ? v : v[4]).join(\"\").replaceAll(/\\s+/g, \" \").trim();\n}\n\n// packages/ag-charts-community/src/scale/invalidating.ts\nvar Invalidating = (target, propertyKey) => {\n  const mappedProperty = Symbol(String(propertyKey));\n  target[mappedProperty] = void 0;\n  Object.defineProperty(target, propertyKey, {\n    get() {\n      return this[mappedProperty];\n    },\n    set(newValue) {\n      const oldValue = this[mappedProperty];\n      if (oldValue !== newValue) {\n        this[mappedProperty] = newValue;\n        this.invalid = true;\n      }\n    },\n    enumerable: true,\n    configurable: false\n  });\n};\n\n// packages/ag-charts-community/src/scale/bandScale.ts\nvar _BandScale = class _BandScale {\n  constructor() {\n    this.type = \"band\";\n    this.invalid = true;\n    this.range = [0, 1];\n    this.round = false;\n    this.interval = void 0;\n    /**\n     * Maps datum to its index in the {@link domain} array.\n     * Used to check for duplicate data (not allowed).\n     */\n    this.index = /* @__PURE__ */ new Map();\n    /**\n     * The output range values for datum at each index.\n     */\n    this.ordinalRange = [];\n    /**\n     * Contains unique data only.\n     */\n    this._domain = [];\n    this._bandwidth = 1;\n    this._step = 1;\n    this._inset = 1;\n    this._rawBandwidth = 1;\n    /**\n     * The ratio of the range that is reserved for space between bands.\n     */\n    this._paddingInner = 0;\n    /**\n     * The ratio of the range that is reserved for space before the first\n     * and after the last band.\n     */\n    this._paddingOuter = 0;\n  }\n  static is(value) {\n    return value instanceof _BandScale;\n  }\n  refresh() {\n    if (!this.invalid)\n      return;\n    this.invalid = false;\n    this.update();\n    if (this.invalid) {\n      Logger.warnOnce(\"Expected update to not invalidate scale\");\n    }\n  }\n  set domain(values) {\n    this.index = /* @__PURE__ */ new Map();\n    this.invalid = true;\n    this._domain = [];\n    for (const value of values) {\n      const key = dateToNumber(value);\n      if (this.getIndex(key) === void 0) {\n        this.index.set(key, this._domain.push(value) - 1);\n      }\n    }\n  }\n  get domain() {\n    return this._domain;\n  }\n  getDomain() {\n    return this._domain;\n  }\n  ticks() {\n    this.refresh();\n    return this._domain;\n  }\n  convert(d) {\n    this.refresh();\n    const i = this.getIndex(d);\n    if (i == null) {\n      return NaN;\n    }\n    return this.ordinalRange[i] ?? NaN;\n  }\n  invert(position) {\n    this.refresh();\n    const index = this.ordinalRange.findIndex((p) => p === position);\n    return this.domain[index];\n  }\n  invertNearest(position) {\n    this.refresh();\n    let nearest = -1;\n    let minDistance = Infinity;\n    const index = this.ordinalRange.findIndex((p, i) => {\n      if (p === position)\n        return true;\n      const distance3 = Math.abs(position - p);\n      if (distance3 < minDistance) {\n        minDistance = distance3;\n        nearest = i;\n      }\n      return false;\n    });\n    return this.domain[index] ?? this.domain[nearest];\n  }\n  get bandwidth() {\n    this.refresh();\n    return this._bandwidth;\n  }\n  get step() {\n    this.refresh();\n    return this._step;\n  }\n  get inset() {\n    this.refresh();\n    return this._inset;\n  }\n  get rawBandwidth() {\n    this.refresh();\n    return this._rawBandwidth;\n  }\n  set padding(value) {\n    value = clamp(0, value, 1);\n    this._paddingInner = value;\n    this._paddingOuter = value;\n  }\n  get padding() {\n    return this._paddingInner;\n  }\n  set paddingInner(value) {\n    this._paddingInner = clamp(0, value, 1);\n  }\n  get paddingInner() {\n    return this._paddingInner;\n  }\n  set paddingOuter(value) {\n    this._paddingOuter = clamp(0, value, 1);\n  }\n  get paddingOuter() {\n    return this._paddingOuter;\n  }\n  update() {\n    const count = this._domain.length;\n    if (count === 0)\n      return;\n    const [r0, r1] = this.range;\n    let { _paddingInner: paddingInner } = this;\n    const { _paddingOuter: paddingOuter, round: round3 } = this;\n    const rangeDistance = r1 - r0;\n    let rawStep, step, inset;\n    if (count === 1) {\n      paddingInner = 0;\n      rawStep = rangeDistance * (1 - paddingOuter * 2);\n      step = round3 ? Math.round(rawStep) : rawStep;\n      inset = rangeDistance * paddingOuter;\n    } else {\n      rawStep = rangeDistance / Math.max(1, count - paddingInner + paddingOuter * 2);\n      step = round3 ? Math.floor(rawStep) : rawStep;\n      inset = r0 + (rangeDistance - step * (count - paddingInner)) / 2;\n    }\n    let bandwidth = step * (1 - paddingInner);\n    if (round3) {\n      inset = Math.round(inset);\n      bandwidth = Math.round(bandwidth);\n    }\n    this._step = step;\n    this._inset = inset;\n    this._bandwidth = bandwidth;\n    this._rawBandwidth = rawStep * (1 - paddingInner);\n    this.ordinalRange = this._domain.map((_, i) => inset + step * i);\n  }\n  getIndex(value) {\n    return this.index.get(value instanceof Date ? value.getTime() : value);\n  }\n};\n__decorateClass([\n  Invalidating\n], _BandScale.prototype, \"range\", 2);\n__decorateClass([\n  Invalidating\n], _BandScale.prototype, \"round\", 2);\n__decorateClass([\n  Invalidating\n], _BandScale.prototype, \"interval\", 2);\nvar BandScale = _BandScale;\n\n// packages/ag-charts-community/src/util/validation.ts\nfunction Validate(predicate, options = {}) {\n  const { optional = false, property: overrideProperty } = options;\n  return addTransformToInstanceProperty(\n    (target, property, value) => {\n      const context = { ...options, target, property };\n      if (optional && typeof value === \"undefined\" || predicate(value, context)) {\n        if (isProperties(target[property]) && !isProperties(value)) {\n          target[property].set(value);\n          return target[property];\n        }\n        return value;\n      }\n      const cleanKey = overrideProperty ?? String(property).replace(/^_*/, \"\");\n      const targetName = target.constructor.className ?? target.constructor.name.replace(/Properties$/, \"\");\n      let valueString = stringify(value);\n      const maxLength = 50;\n      if (valueString != null && valueString.length > maxLength) {\n        const excessCharacters = valueString.length - maxLength;\n        valueString = valueString.slice(0, maxLength) + `... (+${excessCharacters} characters)`;\n      }\n      Logger.warn(\n        `Property [${cleanKey}] of [${targetName}] cannot be set to [${valueString}]${predicate.message ? `; expecting ${getPredicateMessage(predicate, context)}` : \"\"}, ignoring.`\n      );\n      return BREAK_TRANSFORM_CHAIN;\n    },\n    void 0,\n    { optional }\n  );\n}\nvar AND = (...predicates) => {\n  const messages = [];\n  return predicateWithMessage(\n    (value, ctx) => {\n      messages.length = 0;\n      return predicates.every((predicate) => {\n        const isValid = predicate(value, ctx);\n        if (!isValid) {\n          messages.push(getPredicateMessage(predicate, ctx));\n        }\n        return isValid;\n      });\n    },\n    () => messages.filter(Boolean).join(\" AND \")\n  );\n};\nvar OR = (...predicates) => predicateWithMessage(\n  (value, ctx) => predicates.some((predicate) => predicate(value, ctx)),\n  (ctx) => predicates.map(getPredicateMessageMapper(ctx)).filter(Boolean).join(\" OR \")\n);\nvar OBJECT = attachObjectRestrictions(\n  predicateWithMessage(\n    (value, ctx) => isProperties(value) || isObject(value) && isProperties(ctx.target[ctx.property]),\n    \"a properties object\"\n  )\n);\nvar PLAIN_OBJECT = attachObjectRestrictions(predicateWithMessage((value) => isObject(value), \"an object\"));\nvar BOOLEAN = predicateWithMessage(isBoolean, \"a boolean\");\nvar FUNCTION = predicateWithMessage(isFunction, \"a function\");\nvar STRING = predicateWithMessage(isString, \"a string\");\nvar NUMBER = attachNumberRestrictions(predicateWithMessage(isFiniteNumber, \"a number\"));\nvar NAN = predicateWithMessage((value) => isNumber(value) && isNaN(value), \"NaN\");\nvar POSITIVE_NUMBER = NUMBER.restrict({ min: 0 });\nvar RATIO = NUMBER.restrict({ min: 0, max: 1 });\nvar DEGREE = NUMBER.restrict({ min: -360, max: 360 });\nvar NUMBER_OR_NAN = OR(NUMBER, NAN);\nvar ARRAY = attachArrayRestrictions(predicateWithMessage(isArray, \"an array\"));\nvar ARRAY_OF = (predicate, message) => predicateWithMessage(\n  (value, ctx) => isArray(value) && value.every((item) => predicate(item, ctx)),\n  (ctx) => {\n    const arrayMessage = getPredicateMessage(ARRAY, ctx) ?? \"\";\n    return message ? `${arrayMessage} of ${message}` : arrayMessage;\n  }\n);\nvar isComparable = (value) => isFiniteNumber(value) || isValidDate(value);\nvar LESS_THAN = (otherField) => predicateWithMessage(\n  (v, ctx) => !isComparable(v) || !isComparable(ctx.target[otherField]) || v < ctx.target[otherField],\n  `to be less than ${otherField}`\n);\nvar GREATER_THAN = (otherField) => predicateWithMessage(\n  (v, ctx) => !isComparable(v) || !isComparable(ctx.target[otherField]) || v > ctx.target[otherField],\n  `to be greater than ${otherField}`\n);\nvar DATE = predicateWithMessage(isValidDate, \"Date object\");\nvar DATE_OR_DATETIME_MS = OR(DATE, POSITIVE_NUMBER);\nvar colorMessage = `A color string can be in one of the following formats to be valid: #rgb, #rrggbb, rgb(r, g, b), rgba(r, g, b, a) or a CSS color name such as 'white', 'orange', 'cyan', etc`;\nvar COLOR_STRING = predicateWithMessage(\n  (v) => isString(v) && Color.validColorString(v),\n  `color String. ${colorMessage}`\n);\nvar COLOR_STRING_ARRAY = predicateWithMessage(ARRAY_OF(COLOR_STRING), `color strings. ${colorMessage}`);\nvar BOOLEAN_ARRAY = ARRAY_OF(BOOLEAN, \"boolean values\");\nvar NUMBER_ARRAY = ARRAY_OF(NUMBER, \"numbers\");\nvar STRING_ARRAY = ARRAY_OF(STRING, \"strings\");\nvar DATE_ARRAY = predicateWithMessage(ARRAY_OF(DATE), \"Date objects\");\nvar OBJECT_ARRAY = predicateWithMessage(ARRAY_OF(OBJECT), \"objects\");\nvar LINE_CAP = UNION([\"butt\", \"round\", \"square\"], \"a line cap\");\nvar LINE_JOIN = UNION([\"round\", \"bevel\", \"miter\"], \"a line join\");\nvar LINE_DASH = predicateWithMessage(\n  ARRAY_OF(POSITIVE_NUMBER),\n  \"numbers specifying the length in pixels of alternating dashes and gaps, for example, [6, 3] means dashes with a length of 6 pixels with gaps between of 3 pixels.\"\n);\nvar POSITION = UNION([\"top\", \"right\", \"bottom\", \"left\"], \"a position\");\nvar FONT_STYLE = UNION([\"normal\", \"italic\", \"oblique\"], \"a font style\");\nvar FONT_WEIGHT = OR(\n  UNION([\"normal\", \"bold\", \"bolder\", \"lighter\"], \"a font weight\"),\n  NUMBER.restrict({ min: 1, max: 1e3 })\n);\nvar TEXT_WRAP = UNION([\"never\", \"always\", \"hyphenate\", \"on-space\"], \"a text wrap strategy\");\nvar TEXT_ALIGN = UNION([\"left\", \"center\", \"right\"], \"a text align\");\nvar VERTICAL_ALIGN = UNION([\"top\", \"middle\", \"bottom\"], \"a vertical align\");\nvar OVERFLOW_STRATEGY = UNION([\"ellipsis\", \"hide\"], \"an overflow strategy\");\nvar DIRECTION = UNION([\"horizontal\", \"vertical\"], \"a direction\");\nvar PLACEMENT = UNION([\"inside\", \"outside\"], \"a placement\");\nvar INTERACTION_RANGE = OR(UNION([\"exact\", \"nearest\"], \"interaction range\"), NUMBER);\nvar LABEL_PLACEMENT = UNION([\"top\", \"bottom\", \"left\", \"right\"]);\nfunction UNION(options, message = \"a\") {\n  return predicateWithMessage(\n    (v) => options.includes(v),\n    `${message} keyword such as ${joinUnionOptions(options)}`\n  );\n}\nvar MIN_SPACING = OR(AND(NUMBER.restrict({ min: 1 }), LESS_THAN(\"maxSpacing\")), NAN);\nvar MAX_SPACING = OR(AND(NUMBER.restrict({ min: 1 }), GREATER_THAN(\"minSpacing\")), NAN);\nfunction predicateWithMessage(predicate, message) {\n  predicate.message = message;\n  return predicate;\n}\nfunction joinUnionOptions(options) {\n  const values = options.map((option) => `'${option}'`);\n  if (values.length === 1) {\n    return values[0];\n  }\n  const lastValue = values.pop();\n  return `${values.join(\", \")} or ${lastValue}`;\n}\nfunction getPredicateMessage(predicate, ctx) {\n  return isFunction(predicate.message) ? predicate.message(ctx) : predicate.message;\n}\nfunction getPredicateMessageMapper(ctx) {\n  return (predicate) => getPredicateMessage(predicate, ctx);\n}\nfunction attachArrayRestrictions(predicate) {\n  return Object.assign(predicate, {\n    restrict({ length: length2, minLength } = {}) {\n      let message = \"an array\";\n      if (isNumber(minLength) && minLength > 0) {\n        message = \"a non-empty array\";\n      } else if (isNumber(length2)) {\n        message = `an array of length ${length2}`;\n      }\n      return predicateWithMessage(\n        (value) => isArray(value) && (isNumber(length2) ? value.length === length2 : true) && (isNumber(minLength) ? value.length >= minLength : true),\n        message\n      );\n    }\n  });\n}\nfunction attachNumberRestrictions(predicate) {\n  return Object.assign(predicate, {\n    restrict({ min, max } = {}) {\n      const message = [\"a number\"];\n      const hasMin = isNumber(min);\n      const hasMax = isNumber(max);\n      if (hasMin && hasMax) {\n        message.push(`between ${min} and ${max} inclusive`);\n      } else if (hasMin) {\n        message.push(`greater than or equal to ${min}`);\n      } else if (hasMax) {\n        message.push(`less than or equal to ${max}`);\n      }\n      return predicateWithMessage(\n        (value) => isFiniteNumber(value) && (hasMin ? value >= min : true) && (hasMax ? value <= max : true),\n        message.join(\" \")\n      );\n    }\n  });\n}\nfunction attachObjectRestrictions(predicate) {\n  return Object.assign(predicate, {\n    restrict(objectType) {\n      return predicateWithMessage(\n        (value) => value instanceof objectType,\n        (ctx) => getPredicateMessage(predicate, ctx) ?? `an instance of ${objectType.name}`\n      );\n    }\n  });\n}\nfunction stringify(value) {\n  if (typeof value === \"number\") {\n    if (isNaN(value))\n      return \"NaN\";\n    if (value === Infinity)\n      return \"Infinity\";\n    if (value === -Infinity)\n      return \"-Infinity\";\n  }\n  return JSON.stringify(value);\n}\n\n// packages/ag-charts-community/src/chart/chartAxisDirection.ts\nvar ChartAxisDirection = /* @__PURE__ */ ((ChartAxisDirection2) => {\n  ChartAxisDirection2[\"X\"] = \"x\";\n  ChartAxisDirection2[\"Y\"] = \"y\";\n  return ChartAxisDirection2;\n})(ChartAxisDirection || {});\n\n// packages/ag-charts-community/src/chart/chartOptions.ts\nvar JSON_APPLY_PLUGINS = {\n  constructedArrays: /* @__PURE__ */ new WeakMap()\n};\nfunction assignJsonApplyConstructedArray(array, ctor) {\n  JSON_APPLY_PLUGINS.constructedArrays?.set(array, ctor);\n}\n\n// packages/ag-charts-community/src/scale/continuousScale.ts\nvar _ContinuousScale = class _ContinuousScale {\n  constructor(domain, range3) {\n    this.invalid = true;\n    this.nice = false;\n    this.interval = void 0;\n    this.tickCount = _ContinuousScale.defaultTickCount;\n    this.minTickCount = 0;\n    this.maxTickCount = Infinity;\n    // TODO(olegat) should be of type D[]\n    this.niceDomain = [];\n    this.defaultClampMode = \"raw\";\n    this.domain = domain;\n    this.range = range3;\n  }\n  static is(value) {\n    return value instanceof _ContinuousScale;\n  }\n  transform(x) {\n    return x;\n  }\n  transformInvert(x) {\n    return x;\n  }\n  calcBandwidth(smallestInterval = 1) {\n    const domain = this.getDomain();\n    const rangeDistance = this.getPixelRange();\n    const intervals = Math.abs(domain[1] - domain[0]) / smallestInterval + 1;\n    const maxBands = Math.floor(rangeDistance);\n    const bands = Math.min(intervals, maxBands);\n    return rangeDistance / Math.max(1, bands);\n  }\n  getDomain() {\n    if (this.nice) {\n      this.refresh();\n      if (this.niceDomain.length) {\n        return this.niceDomain;\n      }\n    }\n    return this.domain;\n  }\n  convert(x, opts) {\n    const clampMode = opts?.clampMode ?? this.defaultClampMode;\n    if (!this.domain || this.domain.length < 2) {\n      return NaN;\n    }\n    this.refresh();\n    const domain = this.getDomain().map((d) => this.transform(d));\n    const [d0, d1] = domain;\n    const { range: range3 } = this;\n    const [r0, r1] = range3;\n    x = this.transform(x);\n    if (clampMode === \"clamped\") {\n      const [start, stop] = findMinMax(domain.map(Number));\n      if (Number(x) < start) {\n        return r0;\n      } else if (Number(x) > stop) {\n        return r1;\n      }\n    }\n    if (d0 === d1) {\n      return (r0 + r1) / 2;\n    } else if (x === d0) {\n      return r0;\n    } else if (x === d1) {\n      return r1;\n    }\n    return r0 + (Number(x) - Number(d0)) / (Number(d1) - Number(d0)) * (r1 - r0);\n  }\n  invert(x) {\n    this.refresh();\n    const domain = this.getDomain().map((d2) => this.transform(d2));\n    const [d0, d1] = domain;\n    const { range: range3 } = this;\n    const [r0, r1] = range3;\n    const isReversed = r0 > r1;\n    const rMin = isReversed ? r1 : r0;\n    const rMax = isReversed ? r0 : r1;\n    let d;\n    if (x < rMin) {\n      return isReversed ? d1 : d0;\n    } else if (x > rMax) {\n      return isReversed ? d0 : d1;\n    } else if (r0 === r1) {\n      d = this.toDomain((Number(d0) + Number(d1)) / 2);\n    } else {\n      d = this.toDomain(Number(d0) + (x - r0) / (r1 - r0) * (Number(d1) - Number(d0)));\n    }\n    return this.transformInvert(d);\n  }\n  refresh() {\n    if (!this.invalid)\n      return;\n    this.invalid = false;\n    this.update();\n    if (this.invalid) {\n      Logger.warnOnce(\"Expected update to not invalidate scale\");\n    }\n  }\n  getPixelRange() {\n    const [a, b] = this.range;\n    return Math.abs(b - a);\n  }\n};\n_ContinuousScale.defaultTickCount = 5;\n_ContinuousScale.defaultMaxTickCount = 6;\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"domain\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"range\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"nice\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"interval\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"tickCount\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"minTickCount\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"maxTickCount\", 2);\nvar ContinuousScale = _ContinuousScale;\n\n// packages/ag-charts-community/src/util/array.ts\nfunction times(n, callback) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(callback(i));\n  }\n  return results;\n}\nfunction extent(values) {\n  if (values.length === 0) {\n    return;\n  }\n  let min = Infinity;\n  let max = -Infinity;\n  for (let n of values) {\n    if (n instanceof Date) {\n      n = n.getTime();\n    }\n    if (typeof n !== \"number\") {\n      continue;\n    }\n    if (n < min) {\n      min = n;\n    }\n    if (n > max) {\n      max = n;\n    }\n  }\n  const result = [min, max];\n  if (result.every(isFinite)) {\n    return result;\n  }\n}\nfunction normalisedExtent(d, min, max) {\n  return normalisedExtentWithMetadata(d, min, max).extent;\n}\nfunction normalisedExtentWithMetadata(d, min, max) {\n  let clipped = false;\n  if (d.length > 2) {\n    d = extent(d) ?? [NaN, NaN];\n  }\n  if (!isNaN(min)) {\n    clipped || (clipped = min > d[0]);\n    d = [min, d[1]];\n  }\n  if (!isNaN(max)) {\n    clipped || (clipped = max < d[1]);\n    d = [d[0], max];\n  }\n  if (d[0] > d[1]) {\n    d = [];\n  }\n  return { extent: d, clipped };\n}\nfunction arraysEqual(a, b) {\n  if (a == null || b == null || a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (Array.isArray(a[i]) && Array.isArray(b[i])) {\n      if (!arraysEqual(a[i], b[i])) {\n        return false;\n      }\n    } else if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction toArray(value) {\n  if (typeof value === \"undefined\") {\n    return [];\n  }\n  return Array.isArray(value) ? value : [value];\n}\nfunction unique(array) {\n  return Array.from(new Set(array));\n}\nfunction groupBy(array, iteratee) {\n  return array.reduce((result, item) => {\n    const groupKey = iteratee(item);\n    result[groupKey] ?? (result[groupKey] = []);\n    result[groupKey].push(item);\n    return result;\n  }, {});\n}\nfunction circularSliceArray(data, size, offset4 = 0) {\n  if (data.length === 0) {\n    return [];\n  }\n  const result = [];\n  for (let i = 0; i < size; i++) {\n    result.push(data.at((i + offset4) % data.length));\n  }\n  return result;\n}\nfunction bifurcate(isLeft, array) {\n  return array.reduce(\n    ([left, right], value) => isLeft(value) ? [[...left, value], right] : [left, [...right, value]],\n    [[], []]\n  );\n}\nfunction* mapIterable(src, predicate) {\n  for (const e of src) {\n    yield predicate(e);\n  }\n}\nfunction constStringsIncludes(array, value) {\n  const casting = array;\n  return casting.includes(value);\n}\nfunction isInStringUnion(unionValues, value) {\n  return constStringsIncludes(unionValues, value);\n}\nfunction allInStringUnion(unionValues, values) {\n  return !values.some((v) => !isInStringUnion(unionValues, v));\n}\n\n// packages/ag-charts-community/src/util/numberFormat.ts\nfunction parseFormat(format) {\n  let prefix;\n  let suffix;\n  const surrounded = surroundedRegEx.exec(format);\n  if (surrounded) {\n    [, prefix, format, suffix] = surrounded;\n  }\n  const match = formatRegEx.exec(format);\n  if (!match) {\n    throw new Error(`The number formatter is invalid: ${format}`);\n  }\n  const [, fill, align, sign, symbol, zero, width, comma, precision, trim, type] = match;\n  return {\n    fill,\n    align,\n    sign,\n    symbol,\n    zero,\n    width: parseInt(width),\n    comma,\n    precision: parseInt(precision),\n    trim: Boolean(trim),\n    type,\n    prefix,\n    suffix\n  };\n}\nfunction numberFormat(format) {\n  const options = typeof format === \"string\" ? parseFormat(format) : format;\n  const { fill, align, sign = \"-\", symbol, zero, width, comma, type, prefix = \"\", suffix = \"\", precision } = options;\n  let { trim } = options;\n  const precisionIsNaN = precision == null || isNaN(precision);\n  let formatBody;\n  if (!type) {\n    formatBody = decimalTypes[\"g\"];\n    trim = true;\n  } else if (type in decimalTypes && type in integerTypes) {\n    formatBody = precisionIsNaN ? integerTypes[type] : decimalTypes[type];\n  } else if (type in decimalTypes) {\n    formatBody = decimalTypes[type];\n  } else if (type in integerTypes) {\n    formatBody = integerTypes[type];\n  } else {\n    throw new Error(`The number formatter type is invalid: ${type}`);\n  }\n  let formatterPrecision;\n  if (precision == null || precisionIsNaN) {\n    formatterPrecision = type ? 6 : 12;\n  } else {\n    formatterPrecision = precision;\n  }\n  return (n) => {\n    let result = formatBody(n, formatterPrecision);\n    if (trim) {\n      result = removeTrailingZeros(result);\n    }\n    if (comma) {\n      result = insertSeparator(result, comma);\n    }\n    result = addSign(n, result, sign);\n    if (symbol && symbol !== \"#\") {\n      result = `${symbol}${result}`;\n    }\n    if (symbol === \"#\" && type === \"x\") {\n      result = `0x${result}`;\n    }\n    if (type === \"s\") {\n      result = `${result}${getSIPrefix(n)}`;\n    }\n    if (type === \"%\" || type === \"p\") {\n      result = `${result}%`;\n    }\n    if (width != null && !isNaN(width)) {\n      result = addPadding(result, width, fill ?? zero, align);\n    }\n    result = `${prefix}${result}${suffix}`;\n    return result;\n  };\n}\nvar formatRegEx = /^(?:(.)?([<>=^]))?([+\\-( ])?([$€£¥₣₹#])?(0)?(\\d+)?(,)?(?:\\.(\\d+))?(~)?([%a-z])?$/i;\nvar surroundedRegEx = /^((?:[^#]|#[^{])*)#{([^}]+)}(.*)$/;\nvar integerTypes = {\n  b: (n) => absFloor(n).toString(2),\n  c: (n) => String.fromCharCode(n),\n  d: (n) => Math.round(Math.abs(n)).toFixed(0),\n  o: (n) => absFloor(n).toString(8),\n  x: (n) => absFloor(n).toString(16),\n  X: (n) => integerTypes.x(n).toUpperCase(),\n  n: (n) => integerTypes.d(n),\n  \"%\": (n) => `${absFloor(n * 100).toFixed(0)}`\n};\nvar decimalTypes = {\n  e: (n, f) => Math.abs(n).toExponential(f),\n  E: (n, f) => decimalTypes.e(n, f).toUpperCase(),\n  f: (n, f) => Math.abs(n).toFixed(f),\n  F: (n, f) => decimalTypes.f(n, f).toUpperCase(),\n  g: (n, f) => {\n    if (n === 0) {\n      return \"0\";\n    }\n    const a = Math.abs(n);\n    const p = Math.floor(Math.log10(a));\n    if (p >= -4 && p < f) {\n      return a.toFixed(f - 1 - p);\n    }\n    return a.toExponential(f - 1);\n  },\n  G: (n, f) => decimalTypes.g(n, f).toUpperCase(),\n  n: (n, f) => decimalTypes.g(n, f),\n  p: (n, f) => decimalTypes.r(n * 100, f),\n  r: (n, f) => {\n    if (n === 0) {\n      return \"0\";\n    }\n    const a = Math.abs(n);\n    const p = Math.floor(Math.log10(a));\n    const q = p - (f - 1);\n    if (q <= 0) {\n      return a.toFixed(-q);\n    }\n    const x = 10 ** q;\n    return (Math.round(a / x) * x).toFixed();\n  },\n  s: (n, f) => {\n    const p = getSIPrefixPower(n);\n    return decimalTypes.r(n / 10 ** p, f);\n  },\n  \"%\": (n, f) => decimalTypes.f(n * 100, f)\n};\nvar minSIPrefix = -24;\nvar maxSIPrefix = 24;\nvar siPrefixes = {\n  [minSIPrefix]: \"y\",\n  [-21]: \"z\",\n  [-18]: \"a\",\n  [-15]: \"f\",\n  [-12]: \"p\",\n  [-9]: \"n\",\n  [-6]: \"\\xB5\",\n  [-3]: \"m\",\n  [0]: \"\",\n  [3]: \"k\",\n  [6]: \"M\",\n  [9]: \"G\",\n  [12]: \"T\",\n  [15]: \"P\",\n  [18]: \"E\",\n  [21]: \"Z\",\n  [maxSIPrefix]: \"Y\"\n};\nvar minusSign = \"\\u2212\";\nfunction absFloor(n) {\n  return Math.floor(Math.abs(n));\n}\nfunction removeTrailingZeros(numString) {\n  return numString.replace(/\\.0+$/, \"\").replace(/(\\.[1-9])0+$/, \"$1\");\n}\nfunction insertSeparator(numString, separator) {\n  let dotIndex = numString.indexOf(\".\");\n  if (dotIndex < 0) {\n    dotIndex = numString.length;\n  }\n  const integerChars = numString.substring(0, dotIndex).split(\"\");\n  const fractionalPart = numString.substring(dotIndex);\n  for (let i = integerChars.length - 3; i > 0; i -= 3) {\n    integerChars.splice(i, 0, separator);\n  }\n  return `${integerChars.join(\"\")}${fractionalPart}`;\n}\nfunction getSIPrefix(n) {\n  return siPrefixes[getSIPrefixPower(n)];\n}\nfunction getSIPrefixPower(n) {\n  return clamp(minSIPrefix, n ? Math.floor(Math.log10(Math.abs(n)) / 3) * 3 : 0, maxSIPrefix);\n}\nfunction addSign(num, numString, signType = \"\") {\n  if (signType === \"(\") {\n    return num >= 0 ? numString : `(${numString})`;\n  }\n  const plusSign = signType === \"+\" ? \"+\" : \"\";\n  return `${num >= 0 ? plusSign : minusSign}${numString}`;\n}\nfunction addPadding(numString, width, fill = \" \", align = \">\") {\n  let result = numString;\n  if (align === \">\" || !align) {\n    result = result.padStart(width, fill);\n  } else if (align === \"<\") {\n    result = result.padEnd(width, fill);\n  } else if (align === \"^\") {\n    const padWidth = Math.max(0, width - result.length);\n    const padLeft = Math.ceil(padWidth / 2);\n    const padRight = Math.floor(padWidth / 2);\n    result = result.padStart(padLeft + result.length, fill);\n    result = result.padEnd(padRight + result.length, fill);\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/util/ticks.ts\nvar tInterval = (timeInterval, baseDuration, step) => ({\n  duration: baseDuration * step,\n  timeInterval,\n  step\n});\nvar TickIntervals = [\n  tInterval(second_default, durationSecond, 1),\n  tInterval(second_default, durationSecond, 5),\n  tInterval(second_default, durationSecond, 15),\n  tInterval(second_default, durationSecond, 30),\n  tInterval(minute_default, durationMinute, 1),\n  tInterval(minute_default, durationMinute, 5),\n  tInterval(minute_default, durationMinute, 15),\n  tInterval(minute_default, durationMinute, 30),\n  tInterval(hour_default, durationHour, 1),\n  tInterval(hour_default, durationHour, 3),\n  tInterval(hour_default, durationHour, 6),\n  tInterval(hour_default, durationHour, 12),\n  tInterval(day_default, durationDay, 1),\n  tInterval(day_default, durationDay, 2),\n  tInterval(week_default, durationWeek, 1),\n  tInterval(week_default, durationWeek, 2),\n  tInterval(week_default, durationWeek, 3),\n  tInterval(month_default, durationMonth, 1),\n  tInterval(month_default, durationMonth, 2),\n  tInterval(month_default, durationMonth, 3),\n  tInterval(month_default, durationMonth, 4),\n  tInterval(month_default, durationMonth, 6),\n  tInterval(year_default, durationYear, 1)\n];\nvar TickMultipliers = [1, 2, 5, 10];\nfunction createTicks(start, stop, count, minCount, maxCount) {\n  if (count < 2) {\n    return range(start, stop, stop - start);\n  }\n  const step = tickStep(start, stop, count, minCount, maxCount);\n  if (isNaN(step)) {\n    return [];\n  }\n  start = Math.ceil(start / step) * step;\n  stop = Math.floor(stop / step) * step;\n  return range(start, stop, step);\n}\nfunction getTickInterval(start, stop, count, minCount, maxCount, targetInterval) {\n  const target = targetInterval ?? Math.abs(stop - start) / Math.max(count, 1);\n  let i = 0;\n  for (const tickInterval of TickIntervals) {\n    if (target <= tickInterval.duration)\n      break;\n    i++;\n  }\n  if (i === 0) {\n    const step2 = Math.max(tickStep(start, stop, count, minCount, maxCount), 1);\n    return millisecond_default.every(step2);\n  } else if (i === TickIntervals.length) {\n    const step2 = targetInterval == null ? tickStep(start / durationYear, stop / durationYear, count, minCount, maxCount) : 1;\n    return year_default.every(step2);\n  }\n  const i0 = TickIntervals[i - 1];\n  const i1 = TickIntervals[i];\n  const { timeInterval, step } = target - i0.duration < i1.duration - target ? i0 : i1;\n  return timeInterval.every(step);\n}\nfunction tickStep(start, end, count, minCount = 0, maxCount = Infinity) {\n  if (start === end) {\n    return 1;\n  }\n  if (count < 1) {\n    return NaN;\n  }\n  const extent2 = Math.abs(end - start);\n  const step = 10 ** Math.floor(Math.log10(extent2 / count));\n  let m = NaN, minDiff = Infinity, isInBounds = false;\n  for (const multiplier of TickMultipliers) {\n    const c = Math.ceil(extent2 / (multiplier * step));\n    const validBounds = c >= minCount && c <= maxCount;\n    if (isInBounds && !validBounds)\n      continue;\n    const diffCount = Math.abs(c - count);\n    if (minDiff > diffCount || isInBounds !== validBounds) {\n      isInBounds || (isInBounds = validBounds);\n      minDiff = diffCount;\n      m = multiplier;\n    }\n  }\n  return m * step;\n}\nfunction decimalPlaces(decimal) {\n  for (let i = decimal.length - 1; i >= 0; i -= 1) {\n    if (decimal[i] !== \"0\") {\n      return i + 1;\n    }\n  }\n  return 0;\n}\nfunction tickFormat(ticks, format) {\n  const options = parseFormat(format ?? \",f\");\n  if (options.precision == null || isNaN(options.precision)) {\n    if (!options.type || \"eEFgGnprs\".includes(options.type)) {\n      options.precision = Math.max(\n        ...ticks.map((x) => {\n          if (!Number.isFinite(x))\n            return 0;\n          const [integer, decimal] = x.toExponential((options.type ? 6 : 12) - 1).split(/\\.|e/g);\n          return (integer !== \"1\" && integer !== \"-1\" ? 1 : 0) + decimalPlaces(decimal) + 1;\n        })\n      );\n    } else if (\"f%\".includes(options.type)) {\n      options.precision = Math.max(\n        ...ticks.map((x) => {\n          if (!Number.isFinite(x) || x === 0)\n            return 0;\n          const l = Math.floor(Math.log10(Math.abs(x)));\n          const digits = options.type ? 6 : 12;\n          const [_integer, decimal] = x.toExponential(digits - 1).split(/\\.|e/g);\n          const decimalLength = decimalPlaces(decimal);\n          return Math.max(0, decimalLength - l);\n        })\n      );\n    }\n  }\n  const formatter = numberFormat(options);\n  return (n) => formatter(Number(n));\n}\nfunction range(start, end, step) {\n  const n = Math.ceil(Math.abs(end - start) / step);\n  const f = 10 ** countFractionDigits(step);\n  const d0 = Math.min(start, end);\n  return times(n + 1, (i) => Math.round((d0 + step * i) * f) / f);\n}\nfunction isDenseInterval(count, availableRange) {\n  if (count >= availableRange) {\n    Logger.warnOnce(\n      `the configured interval results in more than 1 item per pixel, ignoring. Supply a larger interval or omit this configuration`\n    );\n    return true;\n  }\n  return false;\n}\nfunction niceTicksDomain(start, end) {\n  const extent2 = Math.abs(end - start);\n  const step = 10 ** Math.floor(Math.log10(extent2));\n  let minError = Infinity, ticks = [start, end];\n  for (const multiplier of TickMultipliers) {\n    const m = multiplier * step;\n    const d0 = Math.floor(start / m) * m;\n    const d1 = Math.ceil(end / m) * m;\n    const error = 1 - extent2 / Math.abs(d1 - d0);\n    if (minError > error) {\n      minError = error;\n      ticks = [d0, d1];\n    }\n  }\n  return ticks;\n}\n\n// packages/ag-charts-community/src/scale/timeScale.ts\nvar TimeScale = class _TimeScale extends ContinuousScale {\n  constructor() {\n    super([], [0, 1]);\n    this.type = \"time\";\n  }\n  toDomain(d) {\n    return new Date(d);\n  }\n  convert(x, opts) {\n    return super.convert(new Date(x), opts);\n  }\n  invert(y) {\n    return new Date(super.invert(y));\n  }\n  /**\n   * Returns uniformly-spaced dates that represent the scale's domain.\n   */\n  ticks() {\n    if (!this.domain || this.domain.length < 2) {\n      return [];\n    }\n    this.refresh();\n    const { interval, nice, tickCount, minTickCount, maxTickCount } = this;\n    const [start, stop] = findMinMax(this.getDomain().map(dateToNumber));\n    if (interval != null) {\n      return _TimeScale.getTicksForInterval({ start, stop, interval, availableRange: this.getPixelRange() }) ?? _TimeScale.getDefaultTicks({ start, stop, tickCount, minTickCount, maxTickCount });\n    } else if (nice && tickCount === 2) {\n      return this.niceDomain;\n    } else if (nice && tickCount === 1) {\n      return this.niceDomain.slice(0, 1);\n    }\n    return _TimeScale.getDefaultTicks({ start, stop, tickCount, minTickCount, maxTickCount });\n  }\n  static getDefaultTicks({\n    start,\n    stop,\n    tickCount,\n    minTickCount,\n    maxTickCount\n  }) {\n    const t = getTickInterval(start, stop, tickCount, minTickCount, maxTickCount);\n    return t ? t.range(new Date(start), new Date(stop)) : [];\n  }\n  static getTicksForInterval({\n    start,\n    stop,\n    interval,\n    availableRange\n  }) {\n    if (!interval) {\n      return [];\n    }\n    if (interval instanceof TimeInterval) {\n      const ticks2 = interval.range(new Date(start), new Date(stop));\n      if (isDenseInterval(ticks2.length, availableRange)) {\n        return;\n      }\n      return ticks2;\n    }\n    const absInterval = Math.abs(interval);\n    if (isDenseInterval((stop - start) / absInterval, availableRange))\n      return;\n    const reversedInterval = [...TickIntervals].reverse();\n    const timeInterval = reversedInterval.find((tickInterval) => absInterval % tickInterval.duration === 0);\n    if (timeInterval) {\n      const i = timeInterval.timeInterval.every(absInterval / (timeInterval.duration / timeInterval.step));\n      return i.range(new Date(start), new Date(stop));\n    }\n    let date = new Date(start);\n    const stopDate = new Date(stop);\n    const ticks = [];\n    while (date <= stopDate) {\n      ticks.push(date);\n      date = new Date(date);\n      date.setMilliseconds(date.getMilliseconds() + absInterval);\n    }\n    return ticks;\n  }\n  /**\n   * Returns a time format function suitable for displaying tick values.\n   * @param specifier If the specifier string is provided, this method is equivalent to\n   * the {@link TimeLocaleObject.format} method.\n   * If no specifier is provided, this method returns the default time format function.\n   */\n  tickFormat({\n    ticks,\n    domain,\n    specifier,\n    formatOffset\n  }) {\n    return specifier == null ? defaultTimeTickFormat(ticks, domain, formatOffset) : buildFormatter(specifier);\n  }\n  update() {\n    if (!this.domain || this.domain.length < 2) {\n      return;\n    }\n    if (this.nice) {\n      this.updateNiceDomain();\n    }\n  }\n  /**\n   * Extends the domain so that it starts and ends on nice round values.\n   * This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value.\n   */\n  updateNiceDomain() {\n    const maxAttempts = 4;\n    let [d0, d1] = this.domain;\n    for (let i = 0; i < maxAttempts; i++) {\n      this.updateNiceDomainIteration(d0, d1);\n      const [n0, n1] = this.niceDomain;\n      if (dateToNumber(d0) === dateToNumber(n0) && dateToNumber(d1) === dateToNumber(n1)) {\n        break;\n      }\n      d0 = n0;\n      d1 = n1;\n    }\n  }\n  updateNiceDomainIteration(d0, d1) {\n    const start = Math.min(dateToNumber(d0), dateToNumber(d1));\n    const stop = Math.max(dateToNumber(d0), dateToNumber(d1));\n    const isReversed = d0 > d1;\n    const { interval } = this;\n    let i;\n    if (interval instanceof TimeInterval) {\n      i = interval;\n    } else {\n      const tickCount = typeof interval === \"number\" ? (stop - start) / Math.max(interval, 1) : this.tickCount;\n      i = getTickInterval(start, stop, tickCount, this.minTickCount, this.maxTickCount);\n    }\n    if (i) {\n      const intervalRange = i.range(new Date(start), new Date(stop), true);\n      const domain = isReversed ? [...intervalRange].reverse() : intervalRange;\n      const n0 = domain[0];\n      const n1 = domain.at(-1);\n      this.niceDomain = [n0, n1];\n    }\n  }\n};\n\n// packages/ag-charts-community/src/scale/ordinalTimeScale.ts\nfunction compareNumbers(a, b) {\n  return a - b;\n}\nvar _OrdinalTimeScale = class _OrdinalTimeScale extends BandScale {\n  constructor() {\n    super(...arguments);\n    this.type = \"ordinal-time\";\n    this.tickCount = ContinuousScale.defaultTickCount;\n    this.minTickCount = 0;\n    this.maxTickCount = Infinity;\n    this.interval = void 0;\n    this._domain = [];\n    this.timestamps = [];\n    this.sortedTimestamps = [];\n    this.visibleRange = [0, 1];\n  }\n  static is(value) {\n    return value instanceof _OrdinalTimeScale;\n  }\n  setVisibleRange(visibleRange) {\n    this.visibleRange = visibleRange;\n  }\n  set domain(values) {\n    this.invalid = true;\n    if (values.length === 0) {\n      this._domain = [];\n      return;\n    }\n    this._domain = values;\n    this.timestamps = unique(values.map(dateToNumber));\n    this.sortedTimestamps = this.timestamps.slice().sort(compareNumbers);\n  }\n  get domain() {\n    return this._domain;\n  }\n  ticks() {\n    this.refresh();\n    const [t0, t1] = [this.timestamps[0], this.timestamps.at(-1)];\n    const start = Math.min(t0, t1);\n    const stop = Math.max(t0, t1);\n    const isReversed = t0 > t1;\n    let ticks;\n    if (this.interval == null) {\n      ticks = this.getDefaultTicks(this.maxTickCount, isReversed);\n    } else {\n      const [r0, r1] = this.range;\n      const availableRange = Math.abs(r1 - r0);\n      ticks = TimeScale.getTicksForInterval({ start, stop, interval: this.interval, availableRange }) ?? [];\n    }\n    const tickPositions = /* @__PURE__ */ new Set();\n    return ticks.filter((tick) => {\n      const position = this.convert(tick);\n      if (isNaN(position) || tickPositions.has(position)) {\n        return false;\n      }\n      tickPositions.add(position);\n      return true;\n    });\n  }\n  getDefaultTicks(maxTickCount, isReversed) {\n    const ticks = [];\n    const count = this.timestamps.length;\n    const tickEvery = Math.ceil(count * (this.visibleRange[1] - this.visibleRange[0]) / maxTickCount);\n    const tickOffset = Math.floor(tickEvery / 2);\n    for (const [index, value] of this.timestamps.entries()) {\n      if (tickEvery > 0 && (index + tickOffset) % tickEvery)\n        continue;\n      if (isReversed) {\n        ticks.push(new Date(this.timestamps[count - index - 1]));\n      } else {\n        ticks.push(new Date(value));\n      }\n    }\n    return ticks;\n  }\n  convert(d) {\n    this.refresh();\n    const n = Number(d);\n    if (n < this.sortedTimestamps[0]) {\n      return NaN;\n    }\n    let i = this.findInterval(n);\n    if (this.timestamps[0] !== this.sortedTimestamps[0]) {\n      i = this.timestamps.length - i - 1;\n    }\n    return this.ordinalRange[i] ?? NaN;\n  }\n  findInterval(target) {\n    const { sortedTimestamps } = this;\n    let low = 0;\n    let high = sortedTimestamps.length - 1;\n    while (low <= high) {\n      const mid = Math.floor((low + high) / 2);\n      if (sortedTimestamps[mid] === target) {\n        return mid;\n      } else if (sortedTimestamps[mid] < target) {\n        low = mid + 1;\n      } else {\n        high = mid - 1;\n      }\n    }\n    return low;\n  }\n  /**\n   * Returns a time format function suitable for displaying tick values.\n   * @param specifier If the specifier string is provided, this method is equivalent to\n   * the {@link TimeLocaleObject.format} method.\n   * If no specifier is provided, this method returns the default time format function.\n   */\n  tickFormat({\n    ticks,\n    domain,\n    specifier\n  }) {\n    return specifier == null ? defaultTimeTickFormat(ticks, domain) : buildFormatter(specifier);\n  }\n  invert(position) {\n    this.refresh();\n    const index = this.ordinalRange.findIndex((p) => position <= p);\n    return this.domain[index];\n  }\n  invertNearest(y) {\n    return new Date(super.invertNearest(y));\n  }\n};\n__decorateClass([\n  Invalidating\n], _OrdinalTimeScale.prototype, \"tickCount\", 2);\n__decorateClass([\n  Invalidating\n], _OrdinalTimeScale.prototype, \"minTickCount\", 2);\n__decorateClass([\n  Invalidating\n], _OrdinalTimeScale.prototype, \"maxTickCount\", 2);\n__decorateClass([\n  Invalidating\n], _OrdinalTimeScale.prototype, \"interval\", 2);\nvar OrdinalTimeScale = _OrdinalTimeScale;\n\n// packages/ag-charts-community/src/util/compare.ts\nfunction ascendingStringNumberUndefined(a, b) {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return a - b;\n  } else if (typeof a === \"string\" && typeof b === \"string\") {\n    return a.localeCompare(b);\n  } else if (a == null && b == null) {\n    return 0;\n  } else if (a == null) {\n    return -1;\n  } else if (b == null) {\n    return 1;\n  }\n  return String(a).localeCompare(String(b));\n}\nfunction toLiteral(v) {\n  return typeof v === \"function\" ? v() : v;\n}\nfunction compoundAscending(a, b, comparator) {\n  for (const idx in a) {\n    const diff2 = comparator(toLiteral(a[idx]), toLiteral(b[idx]));\n    if (diff2 !== 0) {\n      return diff2;\n    }\n  }\n  return 0;\n}\n\n// packages/ag-charts-community/src/scene/group.ts\nvar _Group = class _Group extends Node {\n  constructor(opts) {\n    super({ isVirtual: opts?.isVirtual });\n    this.opts = opts;\n    this.opacity = 1;\n    this.lastBBox = void 0;\n    const { zIndex, zIndexSubOrder } = opts ?? {};\n    this.isContainerNode = true;\n    if (zIndex !== void 0) {\n      this.zIndex = zIndex;\n    }\n    if (zIndexSubOrder !== void 0) {\n      this.zIndexSubOrder = zIndexSubOrder;\n    }\n    this.name = this.opts?.name;\n  }\n  static is(value) {\n    return value instanceof _Group;\n  }\n  onZIndexChange() {\n    super.onZIndexChange();\n    if (this.layer) {\n      this._layerManager?.moveLayer(this.layer, this.zIndex, this.zIndexSubOrder);\n    }\n  }\n  isLayer() {\n    return this.layer != null;\n  }\n  _setLayerManager(layersManager) {\n    if (this._layerManager && this.layer) {\n      this._layerManager.removeLayer(this.layer);\n      this.layer = void 0;\n    }\n    if (this.layer) {\n      throw new Error(\"AG Charts - unable to deregister scene rendering layer!\");\n    }\n    super._setLayerManager(layersManager);\n  }\n  initialiseLayer() {\n    if (this.layer)\n      return;\n    if (!this._layerManager || this.opts?.layer !== true)\n      return;\n    this.layer = this._layerManager.addLayer({\n      name: this.name,\n      zIndex: this.zIndex,\n      zIndexSubOrder: this.zIndexSubOrder,\n      getComputedOpacity: () => this.getComputedOpacity(),\n      getVisibility: () => this.getVisibility()\n    });\n  }\n  getComputedOpacity() {\n    let opacity = 1;\n    for (const node of this.traverseUp()) {\n      if (node instanceof _Group) {\n        opacity *= node.opacity;\n      }\n    }\n    return opacity;\n  }\n  getVisibility() {\n    for (const node of this.traverseUp()) {\n      if (!node.visible) {\n        return false;\n      }\n    }\n    return true;\n  }\n  onVisibleChange() {\n    if (this.layer) {\n      this.layer.enabled = this.visible;\n    }\n  }\n  markDirty(source, type = 1 /* TRIVIAL */) {\n    if (this.isVirtual) {\n      super.markDirty(source, type);\n      return;\n    }\n    let parentType = type;\n    if (type < 2 /* MINOR */ || this.layer != null) {\n      parentType = 1 /* TRIVIAL */;\n    }\n    super.markDirty(source, type, parentType);\n  }\n  // We consider a group to be boundless, thus any point belongs to it.\n  containsPoint(_x, _y) {\n    return true;\n  }\n  computeBBox() {\n    this.computeTransformMatrix();\n    return _Group.computeBBox(this.children);\n  }\n  computeTransformedBBox() {\n    return this.computeBBox();\n  }\n  computeTransformedRegionBBox() {\n    if (this.clipRect) {\n      this.computeTransformMatrix();\n      return this.matrix.transformBBox(this.clipRect);\n    }\n    return this.computeTransformedBBox();\n  }\n  preRender() {\n    const counts = super.preRender();\n    counts.groups += 1;\n    counts.nonGroups -= 1;\n    if (this.opts?.layer !== true || this.layer != null)\n      return counts;\n    if (counts.nonGroups > 0) {\n      this.initialiseLayer();\n    }\n    if (this.opts?.nonEmptyChildDerivedZIndex && counts.nonGroups > 0) {\n      this.deriveZIndexFromChildren();\n    }\n    return counts;\n  }\n  deriveZIndexFromChildren() {\n    const children = this.children.filter((c) => c._childNodeCounts.nonGroups > 0);\n    this.sortChildren(children);\n    const lastChild = children.at(-1);\n    this.zIndex = lastChild?.zIndex ?? -Infinity;\n    this.zIndexSubOrder = lastChild?.zIndexSubOrder;\n  }\n  render(renderCtx) {\n    const { opts: { name = void 0 } = {}, _debug: debug3 } = this;\n    const { dirty, dirtyZIndex, layer, children, clipRect, dirtyTransform } = this;\n    let { ctx, forceRender, clipBBox } = renderCtx;\n    const { resized, stats } = renderCtx;\n    const canvasCtxTransform = ctx.getTransform();\n    const isDirty = dirty >= 2 /* MINOR */ || dirtyZIndex || resized;\n    let isChildDirty = isDirty;\n    let isChildLayerDirty = false;\n    for (const child of children) {\n      isChildDirty || (isChildDirty = child.layerManager == null && child.dirty >= 1 /* TRIVIAL */);\n      isChildLayerDirty || (isChildLayerDirty = child.layerManager != null && child.dirty >= 1 /* TRIVIAL */);\n      if (isChildDirty) {\n        break;\n      }\n    }\n    if (name) {\n      debug3?.({ name, group: this, isDirty, isChildDirty, dirtyTransform, renderCtx, forceRender });\n    }\n    if (dirtyTransform) {\n      forceRender = \"dirtyTransform\";\n    } else if (layer) {\n      const currentBBox = this.computeBBox();\n      if (this.lastBBox === void 0 || !this.lastBBox.equals(currentBBox)) {\n        forceRender = \"dirtyTransform\";\n        this.lastBBox = currentBBox;\n      }\n    }\n    if (!isDirty && !isChildDirty && !isChildLayerDirty && !forceRender) {\n      if (name && stats) {\n        debug3?.({ name, result: \"skipping\", renderCtx, counts: this.nodeCount, group: this });\n      }\n      if (layer && stats) {\n        stats.layersSkipped++;\n        stats.nodesSkipped += this.nodeCount.count;\n      }\n      this.markClean({ recursive: false });\n      return;\n    }\n    const groupVisible = this.visible;\n    if (layer) {\n      ctx = layer.context;\n      ctx.save();\n      ctx.setTransform(layer.pixelRatio, 0, 0, layer.pixelRatio, 0, 0);\n      if (forceRender !== \"dirtyTransform\") {\n        forceRender = isChildDirty || dirtyZIndex;\n      }\n      if (forceRender)\n        layer.clear();\n      if (clipBBox) {\n        const { width, height, x, y } = clipBBox;\n        debug3?.(() => ({\n          name,\n          clipBBox,\n          ctxTransform: ctx.getTransform(),\n          renderCtx,\n          group: this\n        }));\n        ctx.beginPath();\n        ctx.rect(x, y, width, height);\n        ctx.clip();\n      }\n      ctx.setTransform(canvasCtxTransform);\n    } else {\n      ctx.globalAlpha *= this.opacity;\n    }\n    this.computeTransformMatrix();\n    this.matrix.toContext(ctx);\n    if (clipRect) {\n      const { x, y, width, height } = clipRect;\n      ctx.save();\n      debug3?.(() => ({ name, clipRect, ctxTransform: ctx.getTransform(), renderCtx, group: this }));\n      ctx.beginPath();\n      ctx.rect(x, y, width, height);\n      ctx.clip();\n      clipBBox = this.matrix.transformBBox(clipRect);\n    }\n    const hasVirtualChildren = this.hasVirtualChildren();\n    if (dirtyZIndex) {\n      this.sortChildren(children);\n      if (forceRender !== \"dirtyTransform\")\n        forceRender = true;\n    } else if (hasVirtualChildren) {\n      this.sortChildren(children);\n    }\n    const renderContextChanged = forceRender !== renderCtx.forceRender || clipBBox !== renderCtx.clipBBox || ctx !== renderCtx.ctx;\n    const childRenderContext = renderContextChanged ? { ...renderCtx, ctx, forceRender, clipBBox } : renderCtx;\n    let skipped = 0;\n    for (const child of children) {\n      if (!child.visible || !groupVisible) {\n        child.markClean();\n        if (stats)\n          skipped += child.nodeCount.count;\n        continue;\n      }\n      if (!forceRender && child.dirty === 0 /* NONE */) {\n        if (stats)\n          skipped += child.nodeCount.count;\n        continue;\n      }\n      ctx.save();\n      child.render(childRenderContext);\n      ctx.restore();\n    }\n    if (stats)\n      stats.nodesSkipped += skipped;\n    super.render(renderCtx);\n    if (clipRect) {\n      ctx.restore();\n    }\n    if (hasVirtualChildren) {\n      for (const child of this.virtualChildren) {\n        child.markClean({ recursive: \"virtual\" });\n      }\n    }\n    if (layer) {\n      if (stats)\n        stats.layersRendered++;\n      ctx.restore();\n      if (forceRender)\n        layer.snapshot();\n      layer.context.verifyDepthZero?.();\n    }\n    if (name && stats) {\n      debug3?.({ name, result: \"rendered\", skipped, renderCtx, counts: this.nodeCount, group: this });\n    }\n  }\n  sortChildren(children) {\n    this.dirtyZIndex = false;\n    children.sort(\n      (a, b) => compoundAscending(\n        [a.zIndex, ...a.zIndexSubOrder ?? [void 0, void 0], a.serialNumber],\n        [b.zIndex, ...b.zIndexSubOrder ?? [void 0, void 0], b.serialNumber],\n        ascendingStringNumberUndefined\n      )\n    );\n  }\n  static computeBBox(nodes) {\n    let left = Infinity;\n    let right = -Infinity;\n    let top = Infinity;\n    let bottom = -Infinity;\n    for (const n of nodes) {\n      if (!n.visible)\n        continue;\n      const bbox = n.computeTransformedBBox();\n      if (!bbox)\n        continue;\n      const { x, y, width, height } = bbox;\n      if (x < left) {\n        left = x;\n      }\n      if (y < top) {\n        top = y;\n      }\n      if (x + width > right) {\n        right = x + width;\n      }\n      if (y + height > bottom) {\n        bottom = y + height;\n      }\n    }\n    return new BBox(left, top, right - left, bottom - top);\n  }\n  /**\n   * Transforms bbox given in the canvas coordinate space to bbox in this group's coordinate space and\n   * sets this group's clipRect to the transformed bbox.\n   * @param bbox clipRect bbox in the canvas coordinate space.\n   */\n  setClipRectInGroupCoordinateSpace(bbox) {\n    this.clipRect = bbox ? this.transformBBox(bbox) : void 0;\n  }\n};\n_Group.className = \"Group\";\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 3 /* MAJOR */,\n    convertor: (v) => clamp(0, v, 1)\n  })\n], _Group.prototype, \"opacity\", 2);\nvar Group = _Group;\n\n// packages/ag-charts-community/src/util/angle.ts\nvar twoPi = Math.PI * 2;\nfunction normalizeAngle360(radians) {\n  radians %= twoPi;\n  radians += twoPi;\n  radians %= twoPi;\n  return radians;\n}\nfunction normalizeAngle360Inclusive(radians) {\n  radians %= twoPi;\n  radians += twoPi;\n  if (radians !== twoPi) {\n    radians %= twoPi;\n  }\n  return radians;\n}\nfunction normalizeAngle180(radians) {\n  radians %= twoPi;\n  if (radians < -Math.PI) {\n    radians += twoPi;\n  } else if (radians >= Math.PI) {\n    radians -= twoPi;\n  }\n  return radians;\n}\nfunction isBetweenAngles(targetAngle, startAngle, endAngle) {\n  const t = normalizeAngle360(targetAngle);\n  const a0 = normalizeAngle360(startAngle);\n  const a1 = normalizeAngle360(endAngle);\n  if (a0 < a1) {\n    return a0 <= t && t <= a1;\n  } else if (a0 > a1) {\n    return a0 <= t || t <= a1;\n  } else {\n    return true;\n  }\n}\nfunction toRadians(degrees) {\n  return degrees / 180 * Math.PI;\n}\nfunction toDegrees(radians) {\n  return radians / Math.PI * 180;\n}\nfunction angleDiff(angle0, angle1, counterClockwise) {\n  if (counterClockwise) {\n    [angle0, angle1] = [angle1, angle0];\n  }\n  const a0 = normalizeAngle360(angle0);\n  const a1 = normalizeAngle360(angle1) + twoPi;\n  return (a1 - a0) % twoPi;\n}\nfunction angleBetween(angle0, angle1) {\n  angle0 = normalizeAngle360(angle0);\n  angle1 = normalizeAngle360(angle1);\n  return angle1 - angle0 + (angle0 > angle1 ? 2 * Math.PI : 0);\n}\nfunction displacePointFromVector(centerX, centerY, radius, angle2) {\n  const x = centerX + radius * Math.cos(angle2);\n  const y = centerY + radius * Math.sin(angle2);\n  return { x, y };\n}\n\n// packages/ag-charts-community/src/scene/gradient/gradient.ts\nvar Gradient = class {\n  constructor(stops = []) {\n    this.stops = stops;\n  }\n};\n\n// packages/ag-charts-community/src/scene/gradient/linearGradient.ts\nvar LinearGradient = class extends Gradient {\n  constructor(stops, angle2 = 0) {\n    super(stops);\n    this.angle = angle2;\n  }\n  createGradient(ctx, bbox) {\n    const angleOffset = 90;\n    const { stops, angle: angle2 } = this;\n    const radians = normalizeAngle360(toRadians(angle2 + angleOffset));\n    const cos = Math.cos(radians);\n    const sin = Math.sin(radians);\n    const w = bbox.width;\n    const h = bbox.height;\n    const cx = bbox.x + w * 0.5;\n    const cy = bbox.y + h * 0.5;\n    if (w > 0 && h > 0) {\n      const diagonal = Math.sqrt(h * h + w * w) / 2;\n      const diagonalAngle = Math.atan2(h, w);\n      let quarteredAngle;\n      if (radians < Math.PI / 2) {\n        quarteredAngle = radians;\n      } else if (radians < Math.PI) {\n        quarteredAngle = Math.PI - radians;\n      } else if (radians < 1.5 * Math.PI) {\n        quarteredAngle = radians - Math.PI;\n      } else {\n        quarteredAngle = 2 * Math.PI - radians;\n      }\n      const l = diagonal * Math.abs(Math.cos(quarteredAngle - diagonalAngle));\n      const gradient = ctx.createLinearGradient(cx + cos * l, cy + sin * l, cx - cos * l, cy - sin * l);\n      for (const stop of stops) {\n        gradient.addColorStop(stop.offset, stop.color);\n      }\n      return gradient;\n    }\n    return \"black\";\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/shape.ts\nvar LINEAR_GRADIENT_REGEXP = /^linear-gradient\\((-?[\\d.]+)deg,(.*?)\\)$/i;\nvar _Shape = class _Shape extends Node {\n  constructor() {\n    super(...arguments);\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.fill = _Shape.defaultStyles.fill;\n    this.stroke = _Shape.defaultStyles.stroke;\n    this.strokeWidth = _Shape.defaultStyles.strokeWidth;\n    this.lineDash = _Shape.defaultStyles.lineDash;\n    this.lineDashOffset = _Shape.defaultStyles.lineDashOffset;\n    this.lineCap = _Shape.defaultStyles.lineCap;\n    this.lineJoin = _Shape.defaultStyles.lineJoin;\n    this.miterLimit = void 0;\n    this.opacity = _Shape.defaultStyles.opacity;\n    this.fillShadow = _Shape.defaultStyles.fillShadow;\n  }\n  /**\n   * Restores the default styles introduced by this subclass.\n   */\n  restoreOwnStyles() {\n    const { defaultStyles } = this.constructor;\n    Object.assign(this, defaultStyles);\n  }\n  onFillChange() {\n    const { fill } = this;\n    let linearGradientMatch;\n    if (fill?.startsWith(\"linear-gradient\") && (linearGradientMatch = LINEAR_GRADIENT_REGEXP.exec(fill))) {\n      const angle2 = parseFloat(linearGradientMatch[1]);\n      const colors = [];\n      const colorsPart = linearGradientMatch[2];\n      const colorRegex = /(#[0-9a-f]+)|(rgba?\\(.+?\\))|([a-z]+)/gi;\n      let c;\n      while (c = colorRegex.exec(colorsPart)) {\n        colors.push(c[0]);\n      }\n      this.gradient = new LinearGradient(\n        colors.map((color, index) => ({ color, offset: index / (colors.length - 1) })),\n        angle2\n      );\n    } else {\n      this.gradient = void 0;\n    }\n  }\n  /**\n   * Returns a device-pixel aligned coordinate (or length if length is supplied).\n   *\n   * NOTE: Not suitable for strokes, since the stroke needs to be offset to the middle\n   * of a device pixel.\n   */\n  align(start, length2) {\n    const pixelRatio = this.layerManager?.canvas?.pixelRatio ?? 1;\n    const alignedStart = Math.round(start * pixelRatio) / pixelRatio;\n    if (length2 == null) {\n      return alignedStart;\n    } else if (length2 === 0) {\n      return 0;\n    } else if (length2 < 1) {\n      return Math.ceil(length2 * pixelRatio) / pixelRatio;\n    }\n    return Math.round((length2 + start) * pixelRatio) / pixelRatio - alignedStart;\n  }\n  fillStroke(ctx, path) {\n    this.renderFill(ctx, path);\n    this.renderStroke(ctx, path);\n  }\n  renderFill(ctx, path) {\n    if (this.fill) {\n      const { globalAlpha } = ctx;\n      this.applyFill(ctx);\n      this.applyFillAlpha(ctx);\n      this.applyShadow(ctx);\n      this.executeFill(ctx, path);\n      ctx.globalAlpha = globalAlpha;\n    }\n    ctx.shadowColor = \"rgba(0, 0, 0, 0)\";\n  }\n  executeFill(ctx, path) {\n    path ? ctx.fill(path) : ctx.fill();\n  }\n  applyFill(ctx) {\n    ctx.fillStyle = this.gradient?.createGradient(ctx, this.computeBBox()) ?? this.fill;\n  }\n  applyFillAlpha(ctx) {\n    ctx.globalAlpha *= this.opacity * this.fillOpacity;\n  }\n  applyShadow(ctx) {\n    const pixelRatio = this.layerManager?.canvas.pixelRatio ?? 1;\n    const fillShadow = this.fillShadow;\n    if (fillShadow?.enabled) {\n      ctx.shadowColor = fillShadow.color;\n      ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\n      ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\n      ctx.shadowBlur = fillShadow.blur * pixelRatio;\n    }\n  }\n  renderStroke(ctx, path) {\n    if (this.stroke && this.strokeWidth) {\n      const { globalAlpha } = ctx;\n      ctx.strokeStyle = this.stroke;\n      ctx.globalAlpha *= this.opacity * this.strokeOpacity;\n      ctx.lineWidth = this.strokeWidth;\n      if (this.lineDash) {\n        ctx.setLineDash(this.lineDash);\n      }\n      if (this.lineDashOffset) {\n        ctx.lineDashOffset = this.lineDashOffset;\n      }\n      if (this.lineCap) {\n        ctx.lineCap = this.lineCap;\n      }\n      if (this.lineJoin) {\n        ctx.lineJoin = this.lineJoin;\n      }\n      if (this.miterLimit != null) {\n        ctx.miterLimit = this.miterLimit;\n      }\n      this.executeStroke(ctx, path);\n      ctx.globalAlpha = globalAlpha;\n    }\n  }\n  executeStroke(ctx, path) {\n    path ? ctx.stroke(path) : ctx.stroke();\n  }\n  containsPoint(x, y) {\n    return this.isPointInPath(x, y);\n  }\n};\n/**\n * Defaults for style properties. Note that properties that affect the position\n * and shape of the node are not considered style properties, for example:\n * `x`, `y`, `width`, `height`, `radius`, `rotation`, etc.\n * Can be used to reset to the original styling after some custom styling\n * has been applied (using the `restoreOwnStyles` method).\n * These static defaults are meant to be inherited by subclasses.\n */\n_Shape.defaultStyles = {\n  fill: \"black\",\n  stroke: void 0,\n  strokeWidth: 0,\n  lineDash: void 0,\n  lineDashOffset: 0,\n  lineCap: void 0,\n  lineJoin: void 0,\n  opacity: 1,\n  fillShadow: void 0\n};\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */, changeCb: (s) => s.onFillChange() })\n], _Shape.prototype, \"fill\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"stroke\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"lineDash\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"lineCap\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"lineJoin\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"miterLimit\", 2);\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 2 /* MINOR */,\n    convertor: (v) => clamp(0, v, 1)\n  })\n], _Shape.prototype, \"opacity\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */, checkDirtyOnAssignment: true })\n], _Shape.prototype, \"fillShadow\", 2);\nvar Shape = _Shape;\n\n// packages/ag-charts-community/src/scene/shape/range.ts\nvar Range = class extends Shape {\n  constructor(opts = {}) {\n    super(opts);\n    this.x1 = 0;\n    this.y1 = 0;\n    this.x2 = 0;\n    this.y2 = 0;\n    this.startLine = false;\n    this.endLine = false;\n    this.isRange = false;\n    this.restoreOwnStyles();\n  }\n  computeBBox() {\n    return new BBox(this.x1, this.y1, this.x2 - this.x1, this.y2 - this.y1);\n  }\n  isPointInPath(_x, _y) {\n    return false;\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    this.computeTransformMatrix();\n    this.matrix.toContext(ctx);\n    let { x1, y1, x2, y2 } = this;\n    x1 = this.align(x1);\n    y1 = this.align(y1);\n    x2 = this.align(x2);\n    y2 = this.align(y2);\n    const { fill, opacity, isRange } = this;\n    const fillActive = !!(isRange && fill);\n    if (fillActive) {\n      const { fillOpacity } = this;\n      ctx.fillStyle = fill;\n      ctx.globalAlpha = opacity * fillOpacity;\n      ctx.beginPath();\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x2, y1);\n      ctx.lineTo(x2, y2);\n      ctx.lineTo(x1, y2);\n      ctx.closePath();\n      ctx.fill();\n    }\n    const { stroke, strokeWidth, startLine, endLine } = this;\n    const strokeActive = !!((startLine || endLine) && stroke && strokeWidth);\n    if (strokeActive) {\n      const { strokeOpacity, lineDash, lineDashOffset, lineCap, lineJoin } = this;\n      ctx.strokeStyle = stroke;\n      ctx.globalAlpha = opacity * strokeOpacity;\n      ctx.lineWidth = strokeWidth;\n      if (lineDash) {\n        ctx.setLineDash(lineDash);\n      }\n      if (lineDashOffset) {\n        ctx.lineDashOffset = lineDashOffset;\n      }\n      if (lineCap) {\n        ctx.lineCap = lineCap;\n      }\n      if (lineJoin) {\n        ctx.lineJoin = lineJoin;\n      }\n      ctx.beginPath();\n      if (startLine) {\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y1);\n      }\n      if (endLine) {\n        ctx.moveTo(x2, y2);\n        ctx.lineTo(x1, y2);\n      }\n      ctx.stroke();\n    }\n    this.fillShadow?.markClean();\n    super.render(renderCtx);\n  }\n};\nRange.className = \"Range\";\nRange.defaultStyles = {\n  ...Shape.defaultStyles,\n  strokeWidth: 1\n};\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"x1\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"y1\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"x2\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"y2\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"startLine\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"endLine\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"isRange\", 2);\n\n// packages/ag-charts-community/src/util/memo.ts\nvar memorizedFns = /* @__PURE__ */ new WeakMap();\nvar memorizedMap = /* @__PURE__ */ new WeakMap();\nfunction memo(params, fnGenerator) {\n  const serialisedParams = JSON.stringify(params, null, 0);\n  if (!memorizedFns.has(fnGenerator)) {\n    memorizedFns.set(fnGenerator, /* @__PURE__ */ new Map());\n  }\n  if (!memorizedFns.get(fnGenerator)?.has(serialisedParams)) {\n    memorizedFns.get(fnGenerator)?.set(serialisedParams, fnGenerator(params));\n  }\n  return memorizedFns.get(fnGenerator)?.get(serialisedParams);\n}\nfunction memoizeFunction(baseFn) {\n  return (params, ...rest) => {\n    const serialisedParams = JSON.stringify(params, null, 0);\n    if (!memorizedMap.has(baseFn)) {\n      memorizedMap.set(baseFn, /* @__PURE__ */ new Map());\n    }\n    if (!memorizedMap.get(baseFn)?.has(serialisedParams)) {\n      memorizedMap.get(baseFn)?.set(serialisedParams, baseFn(params, ...rest));\n    }\n    return memorizedMap.get(baseFn)?.get(serialisedParams);\n  };\n}\n\n// packages/ag-charts-community/src/util/canvas.util.ts\nfunction createCanvasContext(width = 0, height = 0) {\n  return new OffscreenCanvas(width, height).getContext(\"2d\");\n}\n\n// packages/ag-charts-community/src/util/textMeasurer.ts\nvar TextMeasurer = class {\n  constructor(ctx) {\n    this.ctx = ctx;\n    // local chars width cache per TextMeasurer\n    this.charMap = /* @__PURE__ */ new Map();\n  }\n  // Creates or retrieves a TextMeasurer instance for a specific font.\n  static createFontMeasurer(font) {\n    const ctx = createCanvasContext();\n    const measurer = new this(ctx);\n    this.instanceMap.set(font, measurer);\n    ctx.font = font;\n    return measurer;\n  }\n  // Gets a TextMeasurer instance, configuring text alignment and baseline if provided.\n  static getFontMeasurer(options) {\n    const measurer = this.instanceMap.get(options.font) ?? this.createFontMeasurer(options.font);\n    if (options.textAlign) {\n      measurer.ctx.textAlign = options.textAlign;\n    }\n    if (options.textBaseline) {\n      measurer.ctx.textBaseline = options.textBaseline;\n    }\n    return measurer;\n  }\n  // Measures the dimensions of the provided text, handling multiline if needed.\n  static measureText(text, options) {\n    const { ctx } = this.getFontMeasurer(options);\n    return this.getMetrics(ctx, text);\n  }\n  static measureLines(text, options) {\n    const { ctx } = this.getFontMeasurer(options);\n    const lines = typeof text === \"string\" ? text.split(this.lineSplitter) : text;\n    return this.getMultilineMetrics(ctx, lines);\n  }\n  static wrapText(text, options) {\n    return this.wrapLines(text, options).join(\"\\n\");\n  }\n  static wrapLines(text, options) {\n    const lines = text.split(this.lineSplitter);\n    const measurer = this.getFontMeasurer(options);\n    if (options.textWrap === \"never\") {\n      return lines.map((line) => this.truncateLine(line.trimEnd(), measurer, options.maxWidth));\n    }\n    const result = [];\n    const wrapHyphenate = options.textWrap === \"hyphenate\";\n    const wrapOnSpace = options.textWrap === \"on-space\";\n    for (let line of lines) {\n      line = line.trimEnd();\n      for (let i = 0, estimatedWidth = 0, lastSpaceIndex = 0; i < line.length; i++) {\n        const char = line.charAt(i);\n        estimatedWidth += measurer.textWidth(char);\n        if (char === \" \") {\n          lastSpaceIndex = i;\n        }\n        if (estimatedWidth > options.maxWidth) {\n          if (i === 0)\n            break;\n          if (lastSpaceIndex) {\n            const nextWord = this.getWordAt(line, lastSpaceIndex + 1);\n            const textWidth = measurer.textWidth(nextWord);\n            if (textWidth <= options.maxWidth) {\n              result.push(line.slice(0, lastSpaceIndex).trimEnd());\n              line = line.slice(lastSpaceIndex).trimStart();\n              i = -1;\n              estimatedWidth = 0;\n              lastSpaceIndex = 0;\n              continue;\n            } else if (wrapOnSpace && textWidth > options.maxWidth) {\n              result.push(\n                line.slice(0, lastSpaceIndex).trimEnd(),\n                this.truncateLine(\n                  line.slice(lastSpaceIndex).trimStart(),\n                  measurer,\n                  options.maxWidth,\n                  true\n                )\n              );\n            }\n          } else if (wrapOnSpace) {\n            result.push(this.truncateLine(line, measurer, options.maxWidth, true));\n          }\n          if (wrapOnSpace) {\n            line = \"\";\n            break;\n          }\n          const postfix = wrapHyphenate ? \"-\" : \"\";\n          let newLine = line.slice(0, i).trim();\n          while (newLine.length && measurer.textWidth(newLine + postfix) > options.maxWidth) {\n            newLine = newLine.slice(0, -1).trimEnd();\n          }\n          result.push(newLine + postfix);\n          if (!newLine.length) {\n            line = \"\";\n            break;\n          }\n          line = line.slice(newLine.length).trimStart();\n          i = -1;\n          estimatedWidth = 0;\n          lastSpaceIndex = 0;\n        }\n      }\n      if (line) {\n        result.push(line);\n      }\n    }\n    this.avoidOrphans(result, measurer, options);\n    return this.clipLines(result, measurer, options);\n  }\n  static getWordAt(text, position) {\n    const nextSpaceIndex = text.indexOf(\" \", position);\n    return nextSpaceIndex === -1 ? text.slice(position) : text.slice(position, nextSpaceIndex);\n  }\n  static clipLines(lines, measurer, options) {\n    if (!options.maxHeight) {\n      return lines;\n    }\n    const { height, lineMetrics } = this.measureLines(lines, options);\n    if (height <= options.maxHeight) {\n      return lines;\n    }\n    for (let i = 0, cumulativeHeight = 0; i < lineMetrics.length; i++) {\n      const { lineHeight } = lineMetrics[i];\n      cumulativeHeight += lineHeight;\n      if (cumulativeHeight > options.maxHeight) {\n        const clippedResults = lines.slice(0, Math.max(i, 1));\n        const lastLine = clippedResults.pop();\n        return clippedResults.concat(this.truncateLine(lastLine, measurer, options.maxWidth, true));\n      }\n    }\n    return lines;\n  }\n  static avoidOrphans(lines, measurer, options) {\n    if (lines.length < 2)\n      return;\n    const { length: length2 } = lines;\n    const lastLine = lines[length2 - 1];\n    const beforeLast = lines[length2 - 2];\n    if (beforeLast.length < lastLine.length)\n      return;\n    const lastSpaceIndex = beforeLast.lastIndexOf(\" \");\n    if (lastSpaceIndex === -1 || lastSpaceIndex === beforeLast.indexOf(\" \") || lastLine.includes(\" \"))\n      return;\n    const lastWord = beforeLast.slice(lastSpaceIndex + 1);\n    if (measurer.textWidth(lastLine + lastWord) <= options.maxWidth) {\n      lines[length2 - 2] = beforeLast.slice(0, lastSpaceIndex);\n      lines[length2 - 1] = lastWord + \" \" + lastLine;\n    }\n  }\n  static truncateLine(text, measurer, maxWidth, ellipsisForce) {\n    const ellipsisWidth = measurer.textWidth(this.EllipsisChar);\n    let estimatedWidth = 0;\n    let i = 0;\n    for (; i < text.length; i++) {\n      const charWidth = measurer.textWidth(text.charAt(i));\n      if (estimatedWidth + charWidth > maxWidth)\n        break;\n      estimatedWidth += charWidth;\n    }\n    if (text.length === i && (!ellipsisForce || estimatedWidth + ellipsisWidth <= maxWidth)) {\n      return ellipsisForce ? text + this.EllipsisChar : text;\n    }\n    text = text.slice(0, i).trimEnd();\n    while (text.length && measurer.textWidth(text) + ellipsisWidth > maxWidth) {\n      text = text.slice(0, -1).trimEnd();\n    }\n    return text + this.EllipsisChar;\n  }\n  // Measures metrics for a single line of text.\n  static getMetrics(ctx, text) {\n    const m = ctx.measureText(text);\n    m.fontBoundingBoxAscent ?? (m.fontBoundingBoxAscent = m.emHeightAscent);\n    m.fontBoundingBoxDescent ?? (m.fontBoundingBoxDescent = m.emHeightDescent);\n    return {\n      width: m.width,\n      height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent,\n      lineHeight: m.fontBoundingBoxAscent + m.fontBoundingBoxDescent,\n      offsetTop: m.actualBoundingBoxAscent,\n      offsetLeft: m.actualBoundingBoxLeft\n    };\n  }\n  // Calculates aggregated metrics for multiline text.\n  static getMultilineMetrics(ctx, lines) {\n    let width = 0;\n    let height = 0;\n    let offsetTop = 0;\n    let offsetLeft = 0;\n    let baselineDistance = 0;\n    const verticalModifier = this.getVerticalModifier(ctx.textBaseline);\n    const lineMetrics = lines.map((line, index, { length: length2 }) => {\n      const m = ctx.measureText(line);\n      m.fontBoundingBoxAscent ?? (m.fontBoundingBoxAscent = m.emHeightAscent);\n      m.fontBoundingBoxDescent ?? (m.fontBoundingBoxDescent = m.emHeightDescent);\n      if (width < m.width) {\n        width = m.width;\n      }\n      if (offsetLeft < m.actualBoundingBoxLeft) {\n        offsetLeft = m.actualBoundingBoxLeft;\n      }\n      if (index === 0) {\n        height += m.actualBoundingBoxAscent;\n        offsetTop += m.actualBoundingBoxAscent;\n      } else {\n        baselineDistance += m.fontBoundingBoxAscent;\n      }\n      if (index === length2 - 1) {\n        height += m.actualBoundingBoxDescent;\n      } else {\n        baselineDistance += m.fontBoundingBoxDescent;\n      }\n      return {\n        text: line,\n        width: m.width,\n        height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent,\n        lineHeight: m.fontBoundingBoxAscent + m.fontBoundingBoxDescent,\n        offsetTop: m.actualBoundingBoxAscent,\n        offsetLeft: m.actualBoundingBoxLeft\n      };\n    });\n    height += baselineDistance;\n    offsetTop += baselineDistance * verticalModifier;\n    return { width, height, offsetTop, offsetLeft, lineMetrics };\n  }\n  // Determines vertical offset modifier based on text baseline.\n  static getVerticalModifier(textBaseline) {\n    switch (textBaseline) {\n      case \"hanging\":\n      case \"top\":\n        return 0;\n      case \"middle\":\n        return 0.5;\n      case \"alphabetic\":\n      case \"bottom\":\n      case \"ideographic\":\n      default:\n        return 1;\n    }\n  }\n  textWidth(text, estimate) {\n    if (estimate) {\n      let estimatedWidth = 0;\n      for (let i = 0; i < text.length; i++) {\n        estimatedWidth += this.textWidth(text.charAt(i));\n      }\n      return estimatedWidth;\n    }\n    if (text.length > 1) {\n      return this.ctx.measureText(text).width;\n    }\n    return this.charMap.get(text) ?? this.charWidth(text);\n  }\n  charWidth(char) {\n    const { width } = this.ctx.measureText(char);\n    this.charMap.set(char, width);\n    return width;\n  }\n};\nTextMeasurer.EllipsisChar = \"\\u2026\";\n// Representation for text clipping.\nTextMeasurer.instanceMap = /* @__PURE__ */ new Map();\nTextMeasurer.lineSplitter = /\\r?\\n/g;\n\n// packages/ag-charts-community/src/scene/shape/text.ts\nvar ellipsis = \"\\u2026\";\nfunction SceneFontChangeDetection(opts) {\n  const { redraw = 3 /* MAJOR */, changeCb } = opts ?? {};\n  return SceneChangeDetection({ redraw, type: \"font\", changeCb });\n}\nvar _Text = class _Text extends Shape {\n  constructor() {\n    super(...arguments);\n    this.x = 0;\n    this.y = 0;\n    this.lines = [];\n    this.text = void 0;\n    this._dirtyFont = true;\n    this.fontSize = 10;\n    this.fontFamily = \"sans-serif\";\n    this.textAlign = _Text.defaultStyles.textAlign;\n    this.textBaseline = _Text.defaultStyles.textBaseline;\n  }\n  onTextChange() {\n    this.lines = this.text?.split(\"\\n\").map((s) => s.trim()) ?? [];\n  }\n  get font() {\n    if (this._font == null || this._dirtyFont) {\n      this._dirtyFont = false;\n      this._font = getFont(this);\n    }\n    return this._font;\n  }\n  computeBBox() {\n    const { x, y, lines, textBaseline, textAlign } = this;\n    const { offsetTop, offsetLeft, width, height } = TextMeasurer.measureLines(lines, {\n      font: getFont(this),\n      textBaseline,\n      textAlign\n    });\n    return new BBox(x - offsetLeft, y - offsetTop, width, height);\n  }\n  getLineHeight(line) {\n    return this.lineHeight ?? TextMeasurer.measureText(line, this).lineHeight;\n  }\n  isPointInPath(x, y) {\n    const point = this.transformPoint(x, y);\n    const bbox = this.computeBBox();\n    return bbox ? bbox.containsPoint(point.x, point.y) : false;\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    if (!this.lines.length || !this.layerManager) {\n      if (stats)\n        stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    this.computeTransformMatrix();\n    this.matrix.toContext(ctx);\n    const { fill, stroke, strokeWidth } = this;\n    const { pixelRatio } = this.layerManager.canvas;\n    ctx.font = this.font;\n    ctx.textAlign = this.textAlign;\n    ctx.textBaseline = this.textBaseline;\n    if (fill) {\n      ctx.fillStyle = fill;\n      ctx.globalAlpha *= this.opacity * this.fillOpacity;\n      const { fillShadow } = this;\n      if (fillShadow?.enabled) {\n        ctx.shadowColor = fillShadow.color;\n        ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\n        ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\n        ctx.shadowBlur = fillShadow.blur * pixelRatio;\n      }\n      this.renderLines((line, x, y) => ctx.fillText(line, x, y));\n    }\n    if (stroke && strokeWidth) {\n      ctx.strokeStyle = stroke;\n      ctx.lineWidth = strokeWidth;\n      ctx.globalAlpha *= this.opacity * this.strokeOpacity;\n      const { lineDash, lineDashOffset, lineCap, lineJoin } = this;\n      if (lineDash) {\n        ctx.setLineDash(lineDash);\n      }\n      if (lineDashOffset) {\n        ctx.lineDashOffset = lineDashOffset;\n      }\n      if (lineCap) {\n        ctx.lineCap = lineCap;\n      }\n      if (lineJoin) {\n        ctx.lineJoin = lineJoin;\n      }\n      this.renderLines((line, x, y) => ctx.strokeText(line, x, y));\n    }\n    super.render(renderCtx);\n  }\n  renderLines(renderCallback) {\n    const { lines, x, y } = this;\n    const lineHeights = lines.map((line) => this.getLineHeight(line));\n    const totalHeight = lineHeights.reduce((a, b) => a + b, 0);\n    let offsetY = (lineHeights[0] - totalHeight) * _Text.getVerticalModifier(this.textBaseline);\n    for (let i = 0; i < lines.length; i++) {\n      renderCallback(lines[i], x, y + offsetY);\n      offsetY += lineHeights[i];\n    }\n  }\n  static wrapLines(text, maxWidth, maxHeight, textProps, wrapping, overflow) {\n    const result = TextMeasurer.wrapLines(text, {\n      maxWidth,\n      maxHeight,\n      font: getFont(textProps),\n      textAlign: textProps.textAlign,\n      textBaseline: textProps.textBaseline,\n      textWrap: wrapping\n    });\n    if (overflow === \"hide\" && result.some((l) => l.endsWith(TextMeasurer.EllipsisChar))) {\n      return;\n    }\n    return result;\n  }\n  static wrap(text, maxWidth, maxHeight, textProps, wrapping, overflow = \"ellipsis\") {\n    const lines = _Text.wrapLines(text, maxWidth, maxHeight, textProps, wrapping, overflow);\n    return lines?.join(\"\\n\").trim() ?? \"\";\n  }\n  setFont(props) {\n    this.fontFamily = props.fontFamily;\n    this.fontSize = props.fontSize;\n    this.fontStyle = props.fontStyle;\n    this.fontWeight = props.fontWeight;\n  }\n  setAlign(props) {\n    this.textAlign = props.textAlign;\n    this.textBaseline = props.textBaseline;\n  }\n  static getVerticalModifier(textBaseline) {\n    switch (textBaseline) {\n      case \"top\":\n      case \"hanging\":\n        return 0;\n      case \"bottom\":\n      case \"alphabetic\":\n      case \"ideographic\":\n        return 1;\n      case \"middle\":\n        return 0.5;\n    }\n  }\n  static measureText(text, font, textBaseline, textAlign) {\n    return this._measureText({ text, font, textBaseline, textAlign });\n  }\n  /**\n   * Returns the width and height of the measured text.\n   * @param text The single-line text to measure.\n   * @param font The font shorthand string.\n   */\n  static getTextSize(text, font) {\n    return this._getTextSize({ text, font });\n  }\n  static getTextSizeMultiline(lines, font, textBaseline = _Text.defaultStyles.textBaseline, textAlign = _Text.defaultStyles.textAlign) {\n    const r = TextMeasurer.measureLines(lines, { font, textBaseline, textAlign });\n    return { top: r.offsetTop, left: r.offsetLeft, width: r.width, height: r.height };\n  }\n};\n_Text.className = \"Text\";\n// The default line spacing for document editors is usually 1.15\n_Text.defaultLineHeightRatio = 1.15;\n_Text.defaultStyles = Object.assign({}, Shape.defaultStyles, {\n  textAlign: \"start\",\n  fontStyle: void 0,\n  fontWeight: void 0,\n  fontSize: 10,\n  fontFamily: \"sans-serif\",\n  textBaseline: \"alphabetic\"\n});\n_Text.ellipsis = ellipsis;\n_Text._measureText = memoizeFunction(\n  ({\n    text,\n    font,\n    textBaseline,\n    textAlign\n  }) => TextMeasurer.measureText(text, { font, textBaseline, textAlign })\n);\n_Text._getTextSize = memoizeFunction(\n  ({ text, font }) => TextMeasurer.measureText(text, { font })\n);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"x\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"y\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */, changeCb: (o) => o.onTextChange() })\n], _Text.prototype, \"text\", 2);\n__decorateClass([\n  SceneFontChangeDetection()\n], _Text.prototype, \"fontStyle\", 2);\n__decorateClass([\n  SceneFontChangeDetection()\n], _Text.prototype, \"fontWeight\", 2);\n__decorateClass([\n  SceneFontChangeDetection()\n], _Text.prototype, \"fontSize\", 2);\n__decorateClass([\n  SceneFontChangeDetection()\n], _Text.prototype, \"fontFamily\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"textAlign\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"textBaseline\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"lineHeight\", 2);\nvar Text = _Text;\nfunction getFont(fontProps) {\n  const { fontFamily, fontSize, fontStyle, fontWeight } = fontProps;\n  return [fontStyle ?? \"\", fontWeight ?? \"\", fontSize + \"px\", fontFamily].join(\" \").trim();\n}\n\n// packages/ag-charts-community/src/chart/label.ts\nvar Label = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n  }\n  getFont() {\n    return getFont(this);\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], Label.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], Label.prototype, \"color\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], Label.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], Label.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Label.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], Label.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], Label.prototype, \"formatter\", 2);\nfunction calculateLabelRotation(opts) {\n  const { parallelFlipRotation = 0, regularFlipRotation = 0 } = opts;\n  const configuredRotation = opts.rotation ? normalizeAngle360(toRadians(opts.rotation)) : 0;\n  const parallelFlipFlag = !configuredRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\n  const regularFlipFlag = !configuredRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\n  let defaultRotation = 0;\n  if (opts.parallel) {\n    defaultRotation = parallelFlipFlag * Math.PI / 2;\n  } else if (regularFlipFlag === -1) {\n    defaultRotation = Math.PI;\n  }\n  return { configuredRotation, defaultRotation, parallelFlipFlag, regularFlipFlag };\n}\nfunction getLabelSpacing(minSpacing, rotated) {\n  if (!isNaN(minSpacing)) {\n    return minSpacing;\n  }\n  return rotated ? 0 : 10;\n}\nfunction getTextBaseline(parallel, labelRotation, sideFlag, parallelFlipFlag) {\n  if (parallel && !labelRotation) {\n    return sideFlag * parallelFlipFlag === -1 ? \"hanging\" : \"bottom\";\n  }\n  return \"middle\";\n}\nfunction getTextAlign(parallel, labelRotation, labelAutoRotation, sideFlag, regularFlipFlag) {\n  const labelRotated = labelRotation > 0 && labelRotation <= Math.PI;\n  const labelAutoRotated = labelAutoRotation > 0 && labelAutoRotation <= Math.PI;\n  const alignFlag = labelRotated || labelAutoRotated ? -1 : 1;\n  if (parallel) {\n    if (labelRotation || labelAutoRotation) {\n      if (sideFlag * alignFlag === -1) {\n        return \"end\";\n      }\n    } else {\n      return \"center\";\n    }\n  } else if (sideFlag * regularFlipFlag === -1) {\n    return \"end\";\n  }\n  return \"start\";\n}\nfunction calculateLabelBBox(text, bbox, labelX, labelY, labelMatrix) {\n  const { width, height } = bbox;\n  const translatedBBox = new BBox(labelX, labelY, 0, 0);\n  labelMatrix.transformBBox(translatedBBox, bbox);\n  const { x, y } = bbox;\n  bbox.width = width;\n  bbox.height = height;\n  return {\n    point: { x, y },\n    label: { text, width, height }\n  };\n}\n\n// packages/ag-charts-community/src/chart/layers.ts\nvar Layers = /* @__PURE__ */ ((Layers2) => {\n  Layers2[Layers2[\"SERIES_BACKGROUND_ZINDEX\"] = 0] = \"SERIES_BACKGROUND_ZINDEX\";\n  Layers2[Layers2[\"AXIS_GRID_ZINDEX\"] = 1] = \"AXIS_GRID_ZINDEX\";\n  Layers2[Layers2[\"AXIS_ZINDEX\"] = 2] = \"AXIS_ZINDEX\";\n  Layers2[Layers2[\"SERIES_CROSSLINE_RANGE_ZINDEX\"] = 3] = \"SERIES_CROSSLINE_RANGE_ZINDEX\";\n  Layers2[Layers2[\"SERIES_LAYER_ZINDEX\"] = 4] = \"SERIES_LAYER_ZINDEX\";\n  Layers2[Layers2[\"SERIES_HIGHLIGHT_ZINDEX\"] = 5] = \"SERIES_HIGHLIGHT_ZINDEX\";\n  Layers2[Layers2[\"AXIS_FOREGROUND_ZINDEX\"] = 6] = \"AXIS_FOREGROUND_ZINDEX\";\n  Layers2[Layers2[\"SERIES_CROSSHAIR_ZINDEX\"] = 7] = \"SERIES_CROSSHAIR_ZINDEX\";\n  Layers2[Layers2[\"SERIES_LABEL_ZINDEX\"] = 8] = \"SERIES_LABEL_ZINDEX\";\n  Layers2[Layers2[\"SERIES_CROSSLINE_LINE_ZINDEX\"] = 9] = \"SERIES_CROSSLINE_LINE_ZINDEX\";\n  Layers2[Layers2[\"SERIES_ANNOTATION_ZINDEX\"] = 10] = \"SERIES_ANNOTATION_ZINDEX\";\n  Layers2[Layers2[\"LEGEND_ZINDEX\"] = 11] = \"LEGEND_ZINDEX\";\n  Layers2[Layers2[\"NAVIGATOR_ZINDEX\"] = 12] = \"NAVIGATOR_ZINDEX\";\n  return Layers2;\n})(Layers || {});\n\n// packages/ag-charts-community/src/util/value.ts\nfunction isStringObject(value) {\n  return value != null && Object.hasOwn(value, \"toString\") && isString(value.toString());\n}\nfunction isNumberObject(value) {\n  return value != null && Object.hasOwn(value, \"valueOf\") && isFiniteNumber(value.valueOf());\n}\nfunction isContinuous(value) {\n  return isFiniteNumber(value) || isValidDate(value) || isNumberObject(value);\n}\nfunction checkDatum(value, isContinuousScale) {\n  return value != null && (!isContinuousScale || isContinuous(value));\n}\nfunction transformIntegratedCategoryValue(value) {\n  if (isStringObject(value) && Object.hasOwn(value, \"id\")) {\n    return value.id;\n  }\n  return value;\n}\n\n// packages/ag-charts-community/src/chart/crossline/crossLine.ts\nvar MATCHING_CROSSLINE_TYPE = (property) => {\n  return property === \"value\" ? predicateWithMessage(\n    (_, ctx) => ctx.target[\"type\"] === \"line\",\n    (ctx) => ctx.target[\"type\"] === \"range\" ? `crossLine type 'range' to have a 'range' property instead of 'value'` : `crossLine property 'type' to be 'line'`\n  ) : predicateWithMessage(\n    (_, ctx) => ctx.target[\"type\"] === \"range\",\n    (ctx) => ctx.target.type === \"line\" ? `crossLine type 'line' to have a 'value' property instead of 'range'` : `crossLine property 'type' to be 'range'`\n  );\n};\nvar validateCrossLineValues = (type, value, range3, scale2) => {\n  const lineCrossLine = type === \"line\" && value !== void 0;\n  const rangeCrossLine = type === \"range\" && range3 !== void 0;\n  if (!lineCrossLine && !rangeCrossLine) {\n    return true;\n  }\n  const [start, end] = range3 ?? [value, void 0];\n  const isContinuous2 = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n  const validStart = checkDatum(start, isContinuous2) && !isNaN(scale2.convert(start));\n  const validEnd = checkDatum(end, isContinuous2) && !isNaN(scale2.convert(end));\n  if (lineCrossLine && validStart || rangeCrossLine && validStart && validEnd) {\n    return true;\n  }\n  const message = [`Expecting crossLine`];\n  if (rangeCrossLine) {\n    if (!validStart) {\n      message.push(`range start ${stringify(start)}`);\n    }\n    if (!validEnd) {\n      message.push(`${validStart ? \"\" : \"and \"}range end ${stringify(end)}`);\n    }\n  } else {\n    message.push(`value ${stringify(start)}`);\n  }\n  message.push(`to match the axis scale domain.`);\n  Logger.warnOnce(message.join(\" \"));\n  return false;\n};\n\n// packages/ag-charts-community/src/chart/crossline/crossLineLabelPosition.ts\nvar horizontalCrosslineTranslationDirections = {\n  top: { xTranslationDirection: 0, yTranslationDirection: -1 },\n  bottom: { xTranslationDirection: 0, yTranslationDirection: 1 },\n  left: { xTranslationDirection: -1, yTranslationDirection: 0 },\n  right: { xTranslationDirection: 1, yTranslationDirection: 0 },\n  topLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },\n  topRight: { xTranslationDirection: -1, yTranslationDirection: -1 },\n  bottomLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },\n  bottomRight: { xTranslationDirection: -1, yTranslationDirection: 1 },\n  inside: { xTranslationDirection: 0, yTranslationDirection: 0 },\n  insideLeft: { xTranslationDirection: 1, yTranslationDirection: 0 },\n  insideRight: { xTranslationDirection: -1, yTranslationDirection: 0 },\n  insideTop: { xTranslationDirection: 0, yTranslationDirection: 1 },\n  insideBottom: { xTranslationDirection: 0, yTranslationDirection: -1 },\n  insideTopLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },\n  insideBottomLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },\n  insideTopRight: { xTranslationDirection: -1, yTranslationDirection: 1 },\n  insideBottomRight: { xTranslationDirection: -1, yTranslationDirection: -1 }\n};\nvar verticalCrossLineTranslationDirections = {\n  top: { xTranslationDirection: 1, yTranslationDirection: 0 },\n  bottom: { xTranslationDirection: -1, yTranslationDirection: 0 },\n  left: { xTranslationDirection: 0, yTranslationDirection: -1 },\n  right: { xTranslationDirection: 0, yTranslationDirection: 1 },\n  topLeft: { xTranslationDirection: -1, yTranslationDirection: -1 },\n  topRight: { xTranslationDirection: -1, yTranslationDirection: 1 },\n  bottomLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },\n  bottomRight: { xTranslationDirection: 1, yTranslationDirection: 1 },\n  inside: { xTranslationDirection: 0, yTranslationDirection: 0 },\n  insideLeft: { xTranslationDirection: 0, yTranslationDirection: 1 },\n  insideRight: { xTranslationDirection: 0, yTranslationDirection: -1 },\n  insideTop: { xTranslationDirection: -1, yTranslationDirection: 0 },\n  insideBottom: { xTranslationDirection: 1, yTranslationDirection: 0 },\n  insideTopLeft: { xTranslationDirection: -1, yTranslationDirection: 1 },\n  insideBottomLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },\n  insideTopRight: { xTranslationDirection: -1, yTranslationDirection: -1 },\n  insideBottomRight: { xTranslationDirection: 1, yTranslationDirection: -1 }\n};\nfunction calculateLabelTranslation({\n  yDirection,\n  padding = 0,\n  position = \"top\",\n  bbox\n}) {\n  const crossLineTranslationDirections = yDirection ? horizontalCrosslineTranslationDirections : verticalCrossLineTranslationDirections;\n  const { xTranslationDirection, yTranslationDirection } = crossLineTranslationDirections[position];\n  const w = yDirection ? bbox.width : bbox.height;\n  const h = yDirection ? bbox.height : bbox.width;\n  const xTranslation = xTranslationDirection * (padding + w / 2);\n  const yTranslation = yTranslationDirection * (padding + h / 2);\n  return {\n    xTranslation,\n    yTranslation\n  };\n}\nfunction calculateLabelChartPadding({\n  yDirection,\n  bbox,\n  padding = 0,\n  position = \"top\"\n}) {\n  const chartPadding = {};\n  if (position.startsWith(\"inside\"))\n    return chartPadding;\n  if (position === \"top\" && !yDirection) {\n    chartPadding.top = padding + bbox.height;\n  } else if (position === \"bottom\" && !yDirection) {\n    chartPadding.bottom = padding + bbox.height;\n  } else if (position === \"left\" && yDirection) {\n    chartPadding.left = padding + bbox.width;\n  } else if (position === \"right\" && yDirection) {\n    chartPadding.right = padding + bbox.width;\n  }\n  return chartPadding;\n}\nvar POSITION_TOP_COORDINATES = ({ yDirection, xEnd, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xEnd / 2, y: yStart };\n  } else {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  }\n};\nvar POSITION_LEFT_COORDINATES = ({ yDirection, xStart, xEnd, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  } else {\n    return { x: xEnd / 2, y: yStart };\n  }\n};\nvar POSITION_RIGHT_COORDINATES = ({ yDirection, xEnd, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  } else {\n    return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : yEnd };\n  }\n};\nvar POSITION_BOTTOM_COORDINATES = ({ yDirection, xStart, xEnd, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : yEnd };\n  } else {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  }\n};\nvar POSITION_INSIDE_COORDINATES = ({ xEnd, yStart, yEnd }) => {\n  return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n};\nvar POSITION_TOP_LEFT_COORDINATES = ({ yDirection, xStart, xEnd, yStart }) => {\n  if (yDirection) {\n    return { x: xStart / 2, y: yStart };\n  } else {\n    return { x: xEnd, y: yStart };\n  }\n};\nvar POSITION_BOTTOM_LEFT_COORDINATES = ({ yDirection, xStart, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : yEnd };\n  } else {\n    return { x: xStart, y: yStart };\n  }\n};\nvar POSITION_TOP_RIGHT_COORDINATES = ({ yDirection, xEnd, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xEnd, y: yStart };\n  } else {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : yEnd };\n  }\n};\nvar POSITION_BOTTOM_RIGHT_COORDINATES = ({ yDirection, xStart, xEnd, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : yEnd };\n  } else {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : yEnd };\n  }\n};\nvar labelDirectionHandling = {\n  top: { c: POSITION_TOP_COORDINATES },\n  bottom: { c: POSITION_BOTTOM_COORDINATES },\n  left: { c: POSITION_LEFT_COORDINATES },\n  right: { c: POSITION_RIGHT_COORDINATES },\n  topLeft: { c: POSITION_TOP_LEFT_COORDINATES },\n  topRight: { c: POSITION_TOP_RIGHT_COORDINATES },\n  bottomLeft: { c: POSITION_BOTTOM_LEFT_COORDINATES },\n  bottomRight: { c: POSITION_BOTTOM_RIGHT_COORDINATES },\n  inside: { c: POSITION_INSIDE_COORDINATES },\n  insideLeft: { c: POSITION_LEFT_COORDINATES },\n  insideRight: { c: POSITION_RIGHT_COORDINATES },\n  insideTop: { c: POSITION_TOP_COORDINATES },\n  insideBottom: { c: POSITION_BOTTOM_COORDINATES },\n  insideTopLeft: { c: POSITION_TOP_LEFT_COORDINATES },\n  insideBottomLeft: { c: POSITION_BOTTOM_LEFT_COORDINATES },\n  insideTopRight: { c: POSITION_TOP_RIGHT_COORDINATES },\n  insideBottomRight: { c: POSITION_BOTTOM_RIGHT_COORDINATES }\n};\n\n// packages/ag-charts-community/src/chart/crossline/cartesianCrossLine.ts\nvar CROSSLINE_LABEL_POSITION = UNION(\n  [\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    \"topLeft\",\n    \"topRight\",\n    \"bottomLeft\",\n    \"bottomRight\",\n    \"inside\",\n    \"insideLeft\",\n    \"insideRight\",\n    \"insideTop\",\n    \"insideBottom\",\n    \"insideTopLeft\",\n    \"insideBottomLeft\",\n    \"insideTopRight\",\n    \"insideBottomRight\"\n  ],\n  \"crossLine label position\"\n);\nvar CartesianCrossLineLabel = class {\n  constructor() {\n    this.enabled = void 0;\n    this.text = void 0;\n    this.fontStyle = void 0;\n    this.fontWeight = void 0;\n    this.fontSize = 14;\n    this.fontFamily = \"Verdana, sans-serif\";\n    this.padding = 5;\n    this.color = \"rgba(87, 87, 87, 1)\";\n    this.position = void 0;\n    this.rotation = void 0;\n    this.parallel = void 0;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianCrossLineLabel.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], CartesianCrossLineLabel.prototype, \"text\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], CartesianCrossLineLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], CartesianCrossLineLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], CartesianCrossLineLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], CartesianCrossLineLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], CartesianCrossLineLabel.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], CartesianCrossLineLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(CROSSLINE_LABEL_POSITION, { optional: true })\n], CartesianCrossLineLabel.prototype, \"position\", 2);\n__decorateClass([\n  Validate(DEGREE, { optional: true })\n], CartesianCrossLineLabel.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianCrossLineLabel.prototype, \"parallel\", 2);\nvar _CartesianCrossLine = class _CartesianCrossLine {\n  constructor() {\n    this.id = createId(this);\n    this.enabled = void 0;\n    this.type = void 0;\n    this.range = void 0;\n    this.value = void 0;\n    this.fill = void 0;\n    this.fillOpacity = void 0;\n    this.stroke = void 0;\n    this.strokeWidth = void 0;\n    this.strokeOpacity = void 0;\n    this.lineDash = void 0;\n    this.label = new CartesianCrossLineLabel();\n    this.scale = void 0;\n    this.clippedRange = [-Infinity, Infinity];\n    this.gridLength = 0;\n    this.sideFlag = -1;\n    this.parallelFlipRotation = 0;\n    this.regularFlipRotation = 0;\n    this.direction = \"x\" /* X */;\n    this.group = new Group({ name: `${this.id}`, layer: true, zIndex: _CartesianCrossLine.LINE_LAYER_ZINDEX });\n    this.labelGroup = new Group({ name: `${this.id}`, layer: true, zIndex: _CartesianCrossLine.LABEL_LAYER_ZINDEX });\n    this.crossLineRange = new Range();\n    this.crossLineLabel = new Text();\n    this.labelPoint = void 0;\n    this.data = [];\n    this.startLine = false;\n    this.endLine = false;\n    this.isRange = false;\n    const { group, labelGroup, crossLineRange, crossLineLabel } = this;\n    group.append(crossLineRange);\n    labelGroup.append(crossLineLabel);\n    crossLineRange.pointerEvents = 1 /* None */;\n  }\n  update(visible) {\n    const { enabled, data, type, value, range: range3, scale: scale2 } = this;\n    if (!type || !scale2 || !enabled || !visible || !validateCrossLineValues(type, value, range3, scale2) || data.length === 0) {\n      this.group.visible = false;\n      this.labelGroup.visible = false;\n      return;\n    }\n    this.group.visible = visible;\n    this.labelGroup.visible = visible;\n    this.group.zIndex = this.getZIndex(this.isRange);\n    this.updateNodes();\n  }\n  calculateLayout(visible, reversedAxis) {\n    if (!visible) {\n      return;\n    }\n    const dataCreated = this.createNodeData(reversedAxis);\n    if (!dataCreated) {\n      return;\n    }\n    const { sideFlag, gridLength, data } = this;\n    const boxes = [];\n    const x1 = 0;\n    const x2 = sideFlag * gridLength;\n    const y1 = data[0];\n    const y2 = data[1];\n    const crossLineBox = new BBox(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x1 - x2), Math.abs(y1 - y2));\n    boxes.push(crossLineBox);\n    const labelBox = this.computeLabelBBox();\n    if (labelBox) {\n      boxes.push(labelBox);\n    }\n    return BBox.merge(boxes);\n  }\n  updateNodes() {\n    this.updateRangeNode();\n    if (this.label.enabled) {\n      this.updateLabel();\n      this.positionLabel();\n    }\n  }\n  createNodeData(reversedAxis) {\n    const {\n      scale: scale2,\n      gridLength,\n      sideFlag,\n      direction,\n      label: { position = \"top\" },\n      clippedRange,\n      strokeWidth = 0\n    } = this;\n    this.data = [];\n    if (!scale2) {\n      return false;\n    }\n    const bandwidth = scale2.bandwidth ?? 0;\n    const step = scale2.step ?? 0;\n    const padding = (reversedAxis ? -1 : 1) * (scale2 instanceof BandScale ? (step - bandwidth) / 2 : 0);\n    const [xStart, xEnd] = [0, sideFlag * gridLength];\n    let [yStart, yEnd] = this.getRange();\n    const ordinalTimeScalePadding = yEnd === void 0 && OrdinalTimeScale.is(scale2) ? bandwidth / 2 + padding : 0;\n    let [clampedYStart, clampedYEnd] = [\n      Number(scale2.convert(yStart, { clampMode: \"clamped\" })) - padding + ordinalTimeScalePadding,\n      scale2.convert(yEnd, { clampMode: \"clamped\" }) + bandwidth + padding\n    ];\n    clampedYStart = clampArray(clampedYStart, clippedRange);\n    clampedYEnd = clampArray(clampedYEnd, clippedRange);\n    [yStart, yEnd] = [Number(scale2.convert(yStart)) + ordinalTimeScalePadding, scale2.convert(yEnd) + bandwidth];\n    const validRange = (yStart === clampedYStart || yEnd === clampedYEnd || clampedYStart !== clampedYEnd) && Math.abs(clampedYEnd - clampedYStart) > 0;\n    if (validRange && clampedYStart > clampedYEnd) {\n      [clampedYStart, clampedYEnd] = [clampedYEnd, clampedYStart];\n      [yStart, yEnd] = [yEnd, yStart];\n    }\n    if (yStart - padding >= clampedYStart)\n      yStart -= padding;\n    if (yEnd + padding <= clampedYEnd)\n      yEnd += padding;\n    this.isRange = validRange;\n    this.startLine = strokeWidth > 0 && yStart >= clampedYStart && yStart <= clampedYStart + padding;\n    this.endLine = strokeWidth > 0 && yEnd >= clampedYEnd - bandwidth - padding && yEnd <= clampedYEnd;\n    if (!validRange && !this.startLine && !this.endLine) {\n      return false;\n    }\n    this.data = [clampedYStart, clampedYEnd];\n    if (this.label.enabled) {\n      const yDirection = direction === \"y\" /* Y */;\n      const { c = POSITION_TOP_COORDINATES } = labelDirectionHandling[position] ?? {};\n      const { x: labelX, y: labelY } = c({\n        yDirection,\n        xStart,\n        xEnd,\n        yStart: clampedYStart,\n        yEnd: clampedYEnd\n      });\n      this.labelPoint = {\n        x: labelX,\n        y: labelY\n      };\n    }\n    return true;\n  }\n  updateRangeNode() {\n    const {\n      crossLineRange,\n      sideFlag,\n      gridLength,\n      data,\n      startLine,\n      endLine,\n      isRange,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      lineDash\n    } = this;\n    crossLineRange.x1 = 0;\n    crossLineRange.x2 = sideFlag * gridLength;\n    crossLineRange.y1 = data[0];\n    crossLineRange.y2 = data[1];\n    crossLineRange.startLine = startLine;\n    crossLineRange.endLine = endLine;\n    crossLineRange.isRange = isRange;\n    crossLineRange.fill = fill;\n    crossLineRange.fillOpacity = fillOpacity ?? 1;\n    crossLineRange.stroke = stroke;\n    crossLineRange.strokeWidth = strokeWidth ?? 1;\n    crossLineRange.strokeOpacity = this.strokeOpacity ?? 1;\n    crossLineRange.lineDash = lineDash;\n  }\n  updateLabel() {\n    const { crossLineLabel, label } = this;\n    if (!label.text) {\n      return;\n    }\n    crossLineLabel.fontStyle = label.fontStyle;\n    crossLineLabel.fontWeight = label.fontWeight;\n    crossLineLabel.fontSize = label.fontSize;\n    crossLineLabel.fontFamily = label.fontFamily;\n    crossLineLabel.fill = label.color;\n    crossLineLabel.text = label.text;\n  }\n  positionLabel() {\n    const {\n      crossLineLabel,\n      labelPoint: { x = void 0, y = void 0 } = {},\n      label: { parallel, rotation, position = \"top\", padding = 0 },\n      direction,\n      parallelFlipRotation,\n      regularFlipRotation\n    } = this;\n    if (x === void 0 || y === void 0) {\n      return;\n    }\n    const { defaultRotation, configuredRotation } = calculateLabelRotation({\n      rotation,\n      parallel,\n      regularFlipRotation,\n      parallelFlipRotation\n    });\n    crossLineLabel.rotation = defaultRotation + configuredRotation;\n    crossLineLabel.textBaseline = \"middle\";\n    crossLineLabel.textAlign = \"center\";\n    const bbox = crossLineLabel.computeTransformedBBox();\n    if (!bbox) {\n      return;\n    }\n    const yDirection = direction === \"y\" /* Y */;\n    const { xTranslation, yTranslation } = calculateLabelTranslation({\n      yDirection,\n      padding,\n      position,\n      bbox\n    });\n    crossLineLabel.translationX = x + xTranslation;\n    crossLineLabel.translationY = y + yTranslation;\n  }\n  getZIndex(isRange = false) {\n    if (isRange) {\n      return _CartesianCrossLine.RANGE_LAYER_ZINDEX;\n    }\n    return _CartesianCrossLine.LINE_LAYER_ZINDEX;\n  }\n  getRange() {\n    const { value, range: range3, scale: scale2 } = this;\n    const isContinuous2 = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const start = range3?.[0] ?? value;\n    let end = range3?.[1];\n    if (!isContinuous2 && end === void 0) {\n      end = start;\n    }\n    if (isContinuous2 && start === end) {\n      end = void 0;\n    }\n    return [start, end];\n  }\n  computeLabelBBox() {\n    const { label } = this;\n    if (!label.enabled) {\n      return;\n    }\n    const tempText = new Text();\n    tempText.fontFamily = label.fontFamily;\n    tempText.fontSize = label.fontSize;\n    tempText.fontStyle = label.fontStyle;\n    tempText.fontWeight = label.fontWeight;\n    tempText.text = label.text;\n    const {\n      labelPoint: { x = void 0, y = void 0 } = {},\n      label: { parallel, rotation, position = \"top\", padding = 0 },\n      direction,\n      parallelFlipRotation,\n      regularFlipRotation\n    } = this;\n    if (x === void 0 || y === void 0) {\n      return;\n    }\n    const { configuredRotation } = calculateLabelRotation({\n      rotation,\n      parallel,\n      regularFlipRotation,\n      parallelFlipRotation\n    });\n    tempText.rotation = configuredRotation;\n    tempText.textBaseline = \"middle\";\n    tempText.textAlign = \"center\";\n    const bbox = tempText.computeTransformedBBox();\n    if (!bbox) {\n      return;\n    }\n    const yDirection = direction === \"y\" /* Y */;\n    const { xTranslation, yTranslation } = calculateLabelTranslation({\n      yDirection,\n      padding,\n      position,\n      bbox\n    });\n    tempText.translationX = x + xTranslation;\n    tempText.translationY = y + yTranslation;\n    return tempText.computeTransformedBBox();\n  }\n  calculatePadding(padding) {\n    const {\n      isRange,\n      startLine,\n      endLine,\n      direction,\n      label: { padding: labelPadding = 0, position = \"top\" }\n    } = this;\n    if (!isRange && !startLine && !endLine) {\n      return;\n    }\n    const crossLineLabelBBox = this.computeLabelBBox();\n    if (crossLineLabelBBox?.x == null || crossLineLabelBBox?.y == null) {\n      return;\n    }\n    const chartPadding = calculateLabelChartPadding({\n      yDirection: direction === \"y\" /* Y */,\n      padding: labelPadding,\n      position,\n      bbox: crossLineLabelBBox\n    });\n    padding.left = Math.max(padding.left ?? 0, chartPadding.left ?? 0);\n    padding.right = Math.max(padding.right ?? 0, chartPadding.right ?? 0);\n    padding.top = Math.max(padding.top ?? 0, chartPadding.top ?? 0);\n    padding.bottom = Math.max(padding.bottom ?? 0, chartPadding.bottom ?? 0);\n  }\n};\n_CartesianCrossLine.LINE_LAYER_ZINDEX = 9 /* SERIES_CROSSLINE_LINE_ZINDEX */;\n_CartesianCrossLine.RANGE_LAYER_ZINDEX = 3 /* SERIES_CROSSLINE_RANGE_ZINDEX */;\n_CartesianCrossLine.LABEL_LAYER_ZINDEX = 8 /* SERIES_LABEL_ZINDEX */;\n_CartesianCrossLine.className = \"CrossLine\";\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], _CartesianCrossLine.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(UNION([\"range\", \"line\"], \"a crossLine type\"), { optional: true })\n], _CartesianCrossLine.prototype, \"type\", 2);\n__decorateClass([\n  Validate(AND(MATCHING_CROSSLINE_TYPE(\"range\"), ARRAY.restrict({ length: 2 })), {\n    optional: true\n  })\n], _CartesianCrossLine.prototype, \"range\", 2);\n__decorateClass([\n  Validate(MATCHING_CROSSLINE_TYPE(\"value\"), { optional: true })\n], _CartesianCrossLine.prototype, \"value\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], _CartesianCrossLine.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], _CartesianCrossLine.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], _CartesianCrossLine.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(NUMBER, { optional: true })\n], _CartesianCrossLine.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], _CartesianCrossLine.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH, { optional: true })\n], _CartesianCrossLine.prototype, \"lineDash\", 2);\nvar CartesianCrossLine = _CartesianCrossLine;\n\n// packages/ag-charts-community/src/module/moduleMap.ts\nvar ModuleMap = class {\n  constructor() {\n    this.moduleMap = /* @__PURE__ */ new Map();\n  }\n  *modules() {\n    const sequencedModules = [\"toolbar\", \"navigator\"];\n    for (const m of this.moduleMap.values()) {\n      if (sequencedModules.includes(m.module.optionsKey)) {\n        continue;\n      }\n      yield m.moduleInstance;\n    }\n    for (const key of sequencedModules) {\n      const module = this.moduleMap.get(key);\n      if (module) {\n        yield module.moduleInstance;\n      }\n    }\n  }\n  addModule(module, moduleFactory) {\n    if (this.moduleMap.has(module.optionsKey)) {\n      throw new Error(`AG Charts - module already initialised: ${module.optionsKey}`);\n    }\n    this.moduleMap.set(module.optionsKey, { module, moduleInstance: moduleFactory(module) });\n  }\n  removeModule(module) {\n    const moduleKey = isString(module) ? module : module.optionsKey;\n    this.moduleMap.get(moduleKey)?.moduleInstance.destroy();\n    this.moduleMap.delete(moduleKey);\n  }\n  getModule(module) {\n    return this.moduleMap.get(isString(module) ? module : module.optionsKey)?.moduleInstance;\n  }\n  isEnabled(module) {\n    return this.moduleMap.has(isString(module) ? module : module.optionsKey);\n  }\n  mapModules(callback) {\n    return Array.from(this.moduleMap.values(), (m, i) => callback(m.moduleInstance, i));\n  }\n  destroy() {\n    for (const moduleKey of this.moduleMap.keys()) {\n      this.moduleMap.get(moduleKey)?.moduleInstance.destroy();\n    }\n    this.moduleMap.clear();\n  }\n};\n\n// packages/ag-charts-community/src/motion/resetMotion.ts\nvar resetMotion_exports = {};\n__export(resetMotion_exports, {\n  resetMotion: () => resetMotion\n});\nfunction resetMotion(selectionsOrNodes, propsFn) {\n  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);\n  for (const selection of selections) {\n    for (const node of selection.nodes()) {\n      const from2 = propsFn(node, node.datum);\n      node.setProperties(from2);\n    }\n    selection.cleanup();\n  }\n  for (const node of nodes) {\n    const from2 = propsFn(node, node.datum);\n    node.setProperties(from2);\n  }\n}\n\n// packages/ag-charts-community/src/scale/logScale.ts\nvar _LogScale = class _LogScale extends ContinuousScale {\n  constructor() {\n    super([1, 10], [0, 1]);\n    this.type = \"log\";\n    this.base = 10;\n    this.baseLog = identity;\n    this.basePow = identity;\n    this.log = (x) => {\n      const start = Math.min(...this.domain);\n      return start >= 0 ? this.baseLog(x) : -this.baseLog(-x);\n    };\n    this.pow = (x) => {\n      const start = Math.min(...this.domain);\n      return start >= 0 ? this.basePow(x) : -this.basePow(-x);\n    };\n    this.defaultClampMode = \"clamped\";\n  }\n  toDomain(d) {\n    return d;\n  }\n  transform(x) {\n    const start = Math.min(...this.domain);\n    return start >= 0 ? Math.log(x) : -Math.log(-x);\n  }\n  transformInvert(x) {\n    const start = Math.min(...this.domain);\n    return start >= 0 ? Math.exp(x) : -Math.exp(-x);\n  }\n  refresh() {\n    if (this.base <= 0) {\n      this.base = 0;\n      Logger.warnOnce(\"expecting a finite Number greater than to 0\");\n    }\n    super.refresh();\n  }\n  update() {\n    if (!this.domain || this.domain.length < 2) {\n      return;\n    }\n    this.baseLog = _LogScale.getBaseLogMethod(this.base);\n    this.basePow = _LogScale.getBasePowerMethod(this.base);\n    if (this.nice) {\n      this.updateNiceDomain();\n    }\n  }\n  updateNiceDomain() {\n    const [d0, d1] = this.domain;\n    const roundStart = d0 > d1 ? Math.ceil : Math.floor;\n    const roundStop = d0 > d1 ? Math.floor : Math.ceil;\n    const n0 = this.pow(roundStart(this.log(d0)));\n    const n1 = this.pow(roundStop(this.log(d1)));\n    this.niceDomain = [n0, n1];\n  }\n  ticks() {\n    const count = this.tickCount ?? 10;\n    if (!this.domain || this.domain.length < 2 || count < 1) {\n      return [];\n    }\n    this.refresh();\n    const base = this.base;\n    const [d0, d1] = this.getDomain();\n    const start = Math.min(d0, d1);\n    const stop = Math.max(d0, d1);\n    let p0 = this.log(start);\n    let p1 = this.log(stop);\n    if (this.interval) {\n      const inBounds = (tick) => tick >= start && tick <= stop;\n      const step = Math.min(Math.abs(this.interval), Math.abs(p1 - p0));\n      const ticks2 = range(p0, p1, step).map(this.pow).filter(inBounds);\n      if (!isDenseInterval(ticks2.length, this.getPixelRange())) {\n        return ticks2;\n      }\n    }\n    const isBaseInteger = base % 1 === 0;\n    const isDiffLarge = p1 - p0 >= count;\n    if (!isBaseInteger || isDiffLarge) {\n      return createTicks(p0, p1, Math.min(p1 - p0, count)).map(this.pow);\n    }\n    const ticks = [];\n    const isPositive = start > 0;\n    p0 = Math.floor(p0) - 1;\n    p1 = Math.round(p1) + 1;\n    const availableSpacing = findRangeExtent(this.range) / count;\n    let lastTickPosition = Infinity;\n    for (let p = p0; p <= p1; p++) {\n      const nextMagnitudeTickPosition = this.convert(this.pow(p + 1));\n      for (let k = 1; k < base; k++) {\n        const q = isPositive ? k : base - k + 1;\n        const t = this.pow(p) * q;\n        const tickPosition = this.convert(t);\n        const prevSpacing = Math.abs(lastTickPosition - tickPosition);\n        const nextSpacing = Math.abs(tickPosition - nextMagnitudeTickPosition);\n        const fits = prevSpacing >= availableSpacing && nextSpacing >= availableSpacing;\n        if (t >= start && t <= stop && (k === 1 || fits || ticks.length === 0)) {\n          ticks.push(t);\n          lastTickPosition = tickPosition;\n        }\n      }\n    }\n    return ticks;\n  }\n  tickFormat({\n    count,\n    ticks,\n    specifier\n  }) {\n    if (count !== Infinity && ticks == null) {\n      this.ticks();\n    }\n    specifier ?? (specifier = this.base === 10 ? \".0e\" : \",\");\n    return isString(specifier) ? numberFormat(specifier) : specifier;\n  }\n  static getBaseLogMethod(base) {\n    switch (base) {\n      case 10:\n        return Math.log10;\n      case Math.E:\n        return Math.log;\n      case 2:\n        return Math.log2;\n      default:\n        const logBase = Math.log(base);\n        return (x) => Math.log(x) / logBase;\n    }\n  }\n  static getBasePowerMethod(base) {\n    switch (base) {\n      case 10:\n        return (x) => x >= 0 ? 10 ** x : 1 / 10 ** -x;\n      case Math.E:\n        return Math.exp;\n      default:\n        return (x) => base ** x;\n    }\n  }\n};\n__decorateClass([\n  Invalidating\n], _LogScale.prototype, \"base\", 2);\nvar LogScale = _LogScale;\n\n// packages/ag-charts-community/src/util/dom.ts\nvar verifiedGlobals = {};\nif (typeof window !== \"undefined\") {\n  verifiedGlobals.window = window;\n} else if (typeof global !== \"undefined\") {\n  verifiedGlobals.window = global.window;\n}\nif (typeof document !== \"undefined\") {\n  verifiedGlobals.document = document;\n} else if (typeof global !== \"undefined\") {\n  verifiedGlobals.document = global.document;\n}\nfunction getDocument(propertyName) {\n  return propertyName ? verifiedGlobals.document?.[propertyName] : verifiedGlobals.document;\n}\nfunction getWindow(propertyName) {\n  return propertyName ? verifiedGlobals.window?.[propertyName] : verifiedGlobals.window;\n}\nfunction createElement(tagName, className, style) {\n  const element2 = getDocument().createElement(tagName);\n  if (typeof className === \"object\") {\n    style = className;\n    className = void 0;\n  }\n  if (className) {\n    element2.classList.add(className);\n  }\n  if (style) {\n    Object.assign(element2.style, style);\n  }\n  return element2;\n}\nfunction downloadUrl(dataUrl, fileName) {\n  const { body } = getDocument();\n  const element2 = createElement(\"a\", { display: \"none\" });\n  element2.href = dataUrl;\n  element2.download = fileName;\n  body.appendChild(element2);\n  element2.click();\n  setTimeout(() => body.removeChild(element2));\n}\nfunction setDocument(document2) {\n  verifiedGlobals.document = document2;\n}\nfunction setWindow(window2) {\n  verifiedGlobals.window = window2;\n}\nfunction setElementBBox(element2, bbox) {\n  if (element2) {\n    element2.style.width = `${bbox.width}px`;\n    element2.style.height = `${bbox.height}px`;\n    element2.style.left = `${bbox.x}px`;\n    element2.style.top = `${bbox.y}px`;\n  }\n}\n\n// packages/ag-charts-community/src/util/debug.ts\nvar LONG_TIME_PERIOD_THRESHOLD = 2e3;\nvar timeOfLastLog = Date.now();\nvar logTimeGap = () => {\n  const timeSinceLastLog = Date.now() - timeOfLastLog;\n  if (timeSinceLastLog > LONG_TIME_PERIOD_THRESHOLD) {\n    const prettyDuration = (Math.floor(timeSinceLastLog / 100) / 10).toFixed(1);\n    Logger.log(`**** ${prettyDuration}s since last log message ****`);\n  }\n  timeOfLastLog = Date.now();\n};\nvar Debug = {\n  create(...debugSelectors) {\n    const resultFn = (...logContent) => {\n      if (Debug.check(...debugSelectors)) {\n        if (typeof logContent[0] === \"function\") {\n          logContent = toArray(logContent[0]());\n        }\n        logTimeGap();\n        Logger.log(...logContent);\n      }\n    };\n    return Object.assign(resultFn, { check: () => Debug.check(...debugSelectors) });\n  },\n  check(...debugSelectors) {\n    if (debugSelectors.length === 0) {\n      debugSelectors.push(true);\n    }\n    const chartDebug = toArray(getWindow(\"agChartsDebug\"));\n    return chartDebug.some((selector) => debugSelectors.includes(selector));\n  }\n};\n\n// packages/ag-charts-community/src/scene/selection.ts\nvar Selection = class _Selection {\n  constructor(parentNode, classOrFactory, autoCleanup = true) {\n    this.parentNode = parentNode;\n    this.autoCleanup = autoCleanup;\n    this.garbageBin = /* @__PURE__ */ new Set();\n    this._nodesMap = /* @__PURE__ */ new Map();\n    this._nodes = [];\n    this.data = [];\n    this.debug = Debug.create(true, \"scene\", \"scene:selections\");\n    this.nodeFactory = Object.prototype.isPrototypeOf.call(Node, classOrFactory) ? () => new classOrFactory() : classOrFactory;\n  }\n  static select(parent, classOrFactory, garbageCollection = true) {\n    return new _Selection(parent, classOrFactory, garbageCollection);\n  }\n  static selectAll(parent, predicate) {\n    const results = [];\n    const traverse = (node) => {\n      if (predicate(node)) {\n        results.push(node);\n      }\n      node.children.forEach(traverse);\n    };\n    traverse(parent);\n    return results;\n  }\n  static selectByClass(node, Class, ...ExtraClasses) {\n    return _Selection.selectAll(node, (n) => {\n      return n instanceof Class || ExtraClasses.some((C) => n instanceof C);\n    });\n  }\n  static selectByTag(node, tag) {\n    return _Selection.selectAll(node, (n) => n.tag === tag);\n  }\n  createNode(datum, initializer, idx) {\n    const node = this.nodeFactory(datum);\n    node.datum = datum;\n    initializer?.(node);\n    if (idx == null) {\n      this._nodes.push(node);\n    } else {\n      this._nodes.splice(idx, 0, node);\n    }\n    this.parentNode.appendChild(node);\n    return node;\n  }\n  /**\n   * Update the data in a selection. If an `getDatumId()` function is provided, maintain a list of ids related to\n   * the nodes. Otherwise, take the more efficient route of simply creating and destroying nodes at the end\n   * of the array.\n   */\n  update(data, initializer, getDatumId) {\n    if (this.garbageBin.size > 0) {\n      this.debug(`Selection - update() called with pending garbage: ${data}`);\n    }\n    if (getDatumId) {\n      const dataMap = new Map(\n        data.map((datum, idx) => [getDatumId(datum), [datum, idx]])\n      );\n      for (const [node, datumId] of this._nodesMap.entries()) {\n        if (dataMap.has(datumId)) {\n          const [newDatum] = dataMap.get(datumId);\n          node.datum = newDatum;\n          this.garbageBin.delete(node);\n          dataMap.delete(datumId);\n        } else {\n          this.garbageBin.add(node);\n        }\n      }\n      for (const [datumId, [datum, idx]] of dataMap.entries()) {\n        this._nodesMap.set(this.createNode(datum, initializer, idx), datumId);\n      }\n    } else {\n      const maxLength = Math.max(data.length, this.data.length);\n      for (let i = 0; i < maxLength; i++) {\n        if (i >= data.length) {\n          this.garbageBin.add(this._nodes[i]);\n        } else if (i >= this._nodes.length) {\n          this.createNode(data[i], initializer);\n        } else {\n          this._nodes[i].datum = data[i];\n          this.garbageBin.delete(this._nodes[i]);\n        }\n      }\n    }\n    this.data = data.slice();\n    if (this.autoCleanup) {\n      this.cleanup();\n    }\n    return this;\n  }\n  cleanup() {\n    if (this.garbageBin.size === 0) {\n      return this;\n    }\n    this._nodes = this._nodes.filter((node) => {\n      if (this.garbageBin.has(node)) {\n        this._nodesMap.delete(node);\n        this.garbageBin.delete(node);\n        node.destroy();\n        return false;\n      }\n      return true;\n    });\n    return this;\n  }\n  clear() {\n    this.update([]);\n    return this;\n  }\n  isGarbage(node) {\n    return this.garbageBin.has(node);\n  }\n  hasGarbage() {\n    return this.garbageBin.size > 0;\n  }\n  each(iterate2) {\n    for (const entry of this._nodes.entries()) {\n      iterate2(entry[1], entry[1].datum, entry[0]);\n    }\n    return this;\n  }\n  *[Symbol.iterator]() {\n    for (let index = 0; index < this._nodes.length; index++) {\n      const node = this._nodes[index];\n      const datum = this._nodes[index].datum;\n      yield { node, datum, index };\n    }\n  }\n  select(predicate) {\n    return _Selection.selectAll(this.parentNode, predicate);\n  }\n  selectByClass(Class) {\n    return _Selection.selectByClass(this.parentNode, Class);\n  }\n  selectByTag(tag) {\n    return _Selection.selectByTag(this.parentNode, tag);\n  }\n  nodes() {\n    return this._nodes;\n  }\n};\n\n// packages/ag-charts-community/src/util/distance.ts\nfunction pointsDistanceSquared(x1, y1, x2, y2) {\n  const dx = x1 - x2;\n  const dy = y1 - y2;\n  return dx * dx + dy * dy;\n}\nfunction lineDistanceSquared(x, y, x1, y1, x2, y2, best) {\n  if (x1 === x2 && y1 === y2) {\n    return Math.min(best, pointsDistanceSquared(x, y, x1, y1));\n  }\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const t = Math.max(0, Math.min(1, ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy)));\n  const ix = x1 + t * dx;\n  const iy = y1 + t * dy;\n  return Math.min(best, pointsDistanceSquared(x, y, ix, iy));\n}\nfunction arcDistanceSquared(x, y, cx, cy, radius, startAngle, endAngle, counterClockwise, best) {\n  if (counterClockwise) {\n    [endAngle, startAngle] = [startAngle, endAngle];\n  }\n  const angle2 = Math.atan2(y - cy, x - cx);\n  if (!isBetweenAngles(angle2, startAngle, endAngle)) {\n    const startX = cx + Math.cos(startAngle) * radius;\n    const startY = cy + Math.sin(startAngle) * radius;\n    const endX = cx + Math.cos(startAngle) * radius;\n    const endY = cy + Math.sin(startAngle) * radius;\n    return Math.min(best, pointsDistanceSquared(x, y, startX, startY), pointsDistanceSquared(x, y, endX, endY));\n  }\n  const distToArc = radius - Math.sqrt(pointsDistanceSquared(x, y, cx, cy));\n  return Math.min(best, distToArc * distToArc);\n}\n\n// packages/ag-charts-community/src/scene/shape/line.ts\nvar Line = class extends Shape {\n  constructor(opts = {}) {\n    super(opts);\n    this.x1 = 0;\n    this.y1 = 0;\n    this.x2 = 0;\n    this.y2 = 0;\n    this.restoreOwnStyles();\n  }\n  set x(value) {\n    this.x1 = value;\n    this.x2 = value;\n  }\n  set y(value) {\n    this.y1 = value;\n    this.y2 = value;\n  }\n  computeBBox() {\n    return new BBox(\n      Math.min(this.x1, this.x2),\n      Math.min(this.y1, this.y2),\n      Math.abs(this.x2 - this.x1),\n      Math.abs(this.y2 - this.y1)\n    );\n  }\n  isPointInPath(px, py) {\n    if (this.x1 === this.x2 || this.y1 === this.y2) {\n      const { x, y } = this.transformPoint(px, py);\n      return this.computeBBox().grow(this.strokeWidth / 2).containsPoint(x, y);\n    }\n    return false;\n  }\n  distanceSquared(px, py) {\n    const { x1, y1, x2, y2 } = this;\n    return lineDistanceSquared(px, py, x1, y1, x2, y2, Infinity);\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats, devicePixelRatio } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    this.computeTransformMatrix();\n    this.matrix.toContext(ctx);\n    let { x1, y1, x2, y2 } = this;\n    if (x1 === x2) {\n      const { strokeWidth } = this;\n      const x = Math.round(x1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);\n      x1 = x;\n      x2 = x;\n    } else if (y1 === y2) {\n      const { strokeWidth } = this;\n      const y = Math.round(y1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);\n      y1 = y;\n      y2 = y;\n    }\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    this.fillStroke(ctx);\n    this.fillShadow?.markClean();\n    super.render(renderCtx);\n  }\n};\nLine.className = \"Line\";\nLine.defaultStyles = Object.assign({}, Shape.defaultStyles, {\n  fill: void 0,\n  strokeWidth: 1\n});\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Line.prototype, \"x1\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Line.prototype, \"y1\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Line.prototype, \"x2\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Line.prototype, \"y2\", 2);\n\n// packages/ag-charts-community/src/scene/util/labelPlacement.ts\nfunction circleRectOverlap(c, unitCenter, x, y, w, h) {\n  if (c.size === 0)\n    return false;\n  let cx = c.x;\n  let cy = c.y;\n  if (unitCenter != null) {\n    cx -= (unitCenter.x - 0.5) * c.size;\n    cy -= (unitCenter.y - 0.5) * c.size;\n  }\n  let edgeX = cx;\n  if (cx < x) {\n    edgeX = x;\n  } else if (cx > x + w) {\n    edgeX = x + w;\n  }\n  let edgeY = cy;\n  if (cy < y) {\n    edgeY = y;\n  } else if (cy > y + h) {\n    edgeY = y + h;\n  }\n  const dx = cx - edgeX;\n  const dy = cy - edgeY;\n  const d = Math.sqrt(dx * dx + dy * dy);\n  return d <= c.size * 0.5;\n}\nfunction rectRectOverlap(r1, x2, y2, w2, h2) {\n  const xOverlap = r1.x + r1.width > x2 && r1.x < x2 + w2;\n  const yOverlap = r1.y + r1.height > y2 && r1.y < y2 + h2;\n  return xOverlap && yOverlap;\n}\nfunction rectContainsRect(r1, r2x, r2y, r2w, r2h) {\n  return r2x + r2w < r1.x + r1.width && r2x > r1.x && r2y > r1.y && r2y + r2h < r1.y + r1.height;\n}\nfunction isPointLabelDatum(x) {\n  return x != null && typeof x.point === \"object\" && typeof x.label === \"object\";\n}\nvar labelPlacements = {\n  top: { x: 0, y: -1 },\n  bottom: { x: 0, y: 1 },\n  left: { x: -1, y: 0 },\n  right: { x: 1, y: 0 }\n};\nfunction placeLabels(data, bounds, padding = 5) {\n  const result = [];\n  data = data.map((d) => d.slice().sort((a, b) => b.point.size - a.point.size));\n  for (let j = 0; j < data.length; j++) {\n    const labels = result[j] = [];\n    const datum = data[j];\n    if (!(datum?.length && datum[0].label)) {\n      continue;\n    }\n    for (let i = 0, ln = datum.length; i < ln; i++) {\n      const d = datum[i];\n      const { point, label, marker } = d;\n      const { text, width, height } = label;\n      const r = point.size * 0.5;\n      let dx = 0;\n      let dy = 0;\n      if (r > 0 && d.placement != null) {\n        const placement = labelPlacements[d.placement];\n        dx = (width * 0.5 + r + padding) * placement.x;\n        dy = (height * 0.5 + r + padding) * placement.y;\n      }\n      const x = point.x - width * 0.5 + dx - ((marker?.center.x ?? 0.5) - 0.5) * point.size;\n      const y = point.y - height * 0.5 + dy - ((marker?.center.y ?? 0.5) - 0.5) * point.size;\n      const withinBounds = !bounds || rectContainsRect(bounds, x, y, width, height);\n      if (!withinBounds) {\n        continue;\n      }\n      const overlapPoints = data.some(\n        (dataDatums) => dataDatums.some(\n          (dataDatum) => circleRectOverlap(dataDatum.point, dataDatum.marker?.center, x, y, width, height)\n        )\n      );\n      if (overlapPoints) {\n        continue;\n      }\n      const overlapLabels = result.some((l2) => l2.some((l3) => rectRectOverlap(l3, x, y, width, height)));\n      if (overlapLabels) {\n        continue;\n      }\n      labels.push({\n        index: i,\n        text,\n        x,\n        y,\n        width,\n        height,\n        datum: d\n      });\n    }\n  }\n  return result;\n}\nfunction axisLabelsOverlap(data, padding) {\n  const result = [];\n  for (let i = 0; i < data.length; i++) {\n    const datum = data[i];\n    const {\n      point: { x, y },\n      label: { text }\n    } = datum;\n    let {\n      label: { width, height }\n    } = datum;\n    width += padding ?? 0;\n    height += padding ?? 0;\n    const overlapLabels = result.some((l) => {\n      return rectRectOverlap(l, x, y, width, height);\n    });\n    if (overlapLabels) {\n      return true;\n    }\n    result.push({\n      index: i,\n      text,\n      x,\n      y,\n      width,\n      height,\n      datum\n    });\n  }\n  return false;\n}\n\n// packages/ag-charts-community/src/util/equal.ts\nfunction areArrayItemsStrictlyEqual(arrA, arrB) {\n  return arrA.length === arrB.length && arrA.every((a, i) => {\n    const b = arrB[i];\n    if (Array.isArray(a) && Array.isArray(b)) {\n      return areArrayItemsStrictlyEqual(a, b);\n    }\n    return a === b;\n  });\n}\nfunction areArrayNumbersEqual(arrA, arrB) {\n  return arrA.length === arrB.length && arrA.every((item, i) => Number(item) === Number(arrB[i]));\n}\n\n// packages/ag-charts-community/src/util/proxy.ts\nfunction ProxyProperty(proxyPath, configMetadata) {\n  const pathArray = isArray(proxyPath) ? proxyPath : proxyPath.split(\".\");\n  if (pathArray.length === 1) {\n    const [property] = pathArray;\n    return addTransformToInstanceProperty(\n      (target, _, value) => target[property] = value,\n      (target) => target[property],\n      configMetadata\n    );\n  }\n  return addTransformToInstanceProperty(\n    (target, _, value) => setPath(target, pathArray, value),\n    (target) => getPath(target, pathArray),\n    configMetadata\n  );\n}\nfunction ProxyOnWrite(proxyProperty) {\n  return addTransformToInstanceProperty((target, _, value) => target[proxyProperty] = value);\n}\nfunction ProxyPropertyOnWrite(childName, childProperty) {\n  return addTransformToInstanceProperty((target, key, value) => target[childName][childProperty ?? key] = value);\n}\nfunction ActionOnSet(opts) {\n  const { newValue: newValueFn, oldValue: oldValueFn, changeValue: changeValueFn } = opts;\n  return addTransformToInstanceProperty((target, _, newValue, oldValue) => {\n    if (newValue !== oldValue) {\n      if (oldValue !== void 0) {\n        oldValueFn?.call(target, oldValue);\n      }\n      if (newValue !== void 0) {\n        newValueFn?.call(target, newValue);\n      }\n      changeValueFn?.call(target, newValue, oldValue);\n    }\n    return newValue;\n  });\n}\nfunction ObserveChanges(observerFn) {\n  return addObserverToInstanceProperty(observerFn);\n}\n\n// packages/ag-charts-community/src/util/stateMachine.ts\nvar debugColor = \"color: green\";\nvar StateMachine = class _StateMachine {\n  constructor(defaultState, states, enterEach) {\n    this.defaultState = defaultState;\n    this.states = states;\n    this.enterEach = enterEach;\n    this.debug = Debug.create(true, \"animation\");\n    this.state = defaultState;\n    this.debug(`%c${this.constructor.name} | init -> ${defaultState}`, debugColor);\n  }\n  is(value) {\n    if (this.state === \"__child\" && this.childState) {\n      return this.childState.is(value);\n    }\n    return this.state === value;\n  }\n  transition(event, data) {\n    const shouldTransitionSelf = this.transitionChild(event, data);\n    if (!shouldTransitionSelf || this.state === \"__child\" || this.state === \"__parent\") {\n      return;\n    }\n    const currentStateConfig = this.states[this.state];\n    const destinationTransition = currentStateConfig?.[event];\n    if (!destinationTransition) {\n      this.debug(`%c${this.constructor.name} | ${this.state} -> ${event} -> ${this.state}`, \"color: grey\");\n      return;\n    }\n    const destinationState = this.getDestinationState(destinationTransition);\n    const exitFn = destinationState === this.state ? void 0 : currentStateConfig.onExit;\n    this.debug(`%c${this.constructor.name} | ${this.state} -> ${event} -> ${destinationState}`, debugColor);\n    this.enterEach?.(this.state, destinationState);\n    if (destinationState !== \"__child\" && destinationState !== \"__parent\") {\n      this.states[destinationState].onEnter?.();\n    }\n    this.state = destinationState;\n    if (typeof destinationTransition === \"function\") {\n      destinationTransition(data);\n    } else if (typeof destinationTransition === \"object\" && !(destinationTransition instanceof _StateMachine)) {\n      destinationTransition.action?.(data);\n    }\n    exitFn?.();\n  }\n  resetHierarchy() {\n    this.debug(\n      `%c${this.constructor.name} | ${this.state} -> [resetHierarchy] -> ${this.defaultState}`,\n      \"color: green\"\n    );\n    this.state = this.defaultState;\n  }\n  transitionChild(event, data) {\n    if (this.state !== \"__child\" || !this.childState)\n      return true;\n    this.childState.transition(event, data);\n    if (!this.childState.is(\"__parent\"))\n      return true;\n    this.debug(`%c${this.constructor.name} | ${this.state} -> ${event} -> ${this.defaultState}`, debugColor);\n    this.state = this.defaultState;\n    this.states[this.state].onEnter?.();\n    this.childState.resetHierarchy();\n    return false;\n  }\n  getDestinationState(transition) {\n    let state = this.state;\n    if (typeof transition === \"string\") {\n      state = transition;\n    } else if (transition instanceof _StateMachine) {\n      this.childState = transition;\n      state = \"__child\";\n    } else if (typeof transition === \"object\") {\n      if (transition.target instanceof _StateMachine) {\n        this.childState = transition.target;\n        state = \"__child\";\n      } else {\n        state = transition.target;\n      }\n    }\n    return state;\n  }\n};\n\n// packages/ag-charts-community/src/util/attributeUtil.ts\nfunction setAttribute(e, qualifiedName, value) {\n  if (value === void 0 || value === \"\") {\n    e?.removeAttribute(qualifiedName);\n  } else {\n    e?.setAttribute(qualifiedName, value.toString());\n  }\n}\n\n// packages/ag-charts-community/src/util/placement.ts\nfunction calculatePlacement(naturalWidth, naturalHeight, containerWidth, containerHeight, bounds) {\n  let { top, right, bottom, left, width, height } = bounds;\n  if (left != null) {\n    if (width != null) {\n      right = containerWidth - left + width;\n    } else if (right != null) {\n      width = containerWidth - left - right;\n    }\n  } else if (right != null && width != null) {\n    left = containerWidth - right - width;\n  }\n  if (top != null) {\n    if (height != null) {\n      bottom = containerHeight - top - height;\n    } else if (bottom != null) {\n      height = containerHeight - bottom - top;\n    }\n  } else if (bottom != null && height != null) {\n    top = containerHeight - bottom - height;\n  }\n  if (width == null) {\n    if (height == null) {\n      width = naturalWidth;\n      height = naturalHeight;\n    } else {\n      width = Math.ceil(naturalWidth * height / naturalHeight);\n    }\n  } else if (height == null) {\n    height = Math.ceil(naturalHeight * width / naturalWidth);\n  }\n  if (left == null) {\n    if (right == null) {\n      left = Math.floor((containerWidth - width) / 2);\n    } else {\n      left = containerWidth - right - width;\n    }\n  }\n  if (top == null) {\n    if (bottom == null) {\n      top = Math.floor((containerHeight - height) / 2);\n    } else {\n      top = containerHeight - height - bottom;\n    }\n  }\n  return { x: left, y: top, width, height };\n}\n\n// packages/ag-charts-community/src/chart/tooltip/tooltip.ts\nvar DEFAULT_TOOLTIP_CLASS = \"ag-chart-tooltip\";\nvar DEFAULT_TOOLTIP_DARK_CLASS = \"ag-chart-dark-tooltip\";\nvar EMPTY_TOOLTIP_CONTENT = { html: \"\", ariaLabel: \"\" };\nfunction toAccessibleText(inputHtml) {\n  const lineConverter = (_match, offset4, str) => {\n    if (offset4 === 0 || str[offset4 - 1] !== \".\") {\n      return \". \";\n    }\n    return \" \";\n  };\n  return inputHtml.replace(/<br\\s*\\/?>/g, lineConverter).replace(/<\\/p\\s+>/g, lineConverter).replace(/<\\/li\\s*>/g, lineConverter).replace(/<[^<>]+>/g, \"\").replace(/\\n+/g, \" \").replace(/\\s+/g, \" \");\n}\nfunction toTooltipHtml(input, defaults) {\n  if (typeof input === \"string\") {\n    return { html: input, ariaLabel: input };\n  }\n  const {\n    content = defaults?.content ?? \"\",\n    title = defaults?.title,\n    color = defaults?.color ?? \"white\",\n    backgroundColor = defaults?.backgroundColor ?? \"#888\"\n  } = input;\n  const titleHtml = title ? `<div class=\"${DEFAULT_TOOLTIP_CLASS}-title\"\n        style=\"color: ${color}; background-color: ${backgroundColor}\">${title}</div>` : \"\";\n  const titleAria = title ? `${title}: ` : \"\";\n  const contentHtml = content ? `<div class=\"${DEFAULT_TOOLTIP_CLASS}-content\">${content}</div>` : \"\";\n  return {\n    html: `${titleHtml}${contentHtml}`,\n    ariaLabel: toAccessibleText(`${titleAria}${content}`)\n  };\n}\nvar TooltipPosition = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    /** The type of positioning for the tooltip. By default, the tooltip follows the pointer. */\n    this.type = \"pointer\";\n    /** The horizontal offset in pixels for the position of the tooltip. */\n    this.xOffset = 0;\n    /** The vertical offset in pixels for the position of the tooltip. */\n    this.yOffset = 0;\n  }\n};\n__decorateClass([\n  Validate(\n    UNION(\n      [\n        \"pointer\",\n        \"node\",\n        \"top\",\n        \"right\",\n        \"bottom\",\n        \"left\",\n        \"top-left\",\n        \"top-right\",\n        \"bottom-right\",\n        \"bottom-left\"\n      ],\n      \"a position type\"\n    )\n  )\n], TooltipPosition.prototype, \"type\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], TooltipPosition.prototype, \"xOffset\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], TooltipPosition.prototype, \"yOffset\", 2);\nvar Tooltip = class extends BaseProperties {\n  constructor() {\n    super();\n    this.enabled = true;\n    this.delay = 0;\n    this.range = void 0;\n    this.wrapping = \"hyphenate\";\n    this.position = new TooltipPosition();\n    this.darkTheme = false;\n    this.nestedDOM = true;\n    this.enableInteraction = false;\n    this.lastVisibilityChange = Date.now();\n    this.wrapTypes = [\"always\", \"hyphenate\", \"on-space\", \"never\"];\n    this.showTimeout = 0;\n    this._showArrow = true;\n  }\n  get interactive() {\n    return this.enableInteraction;\n  }\n  setup(domManager) {\n    this.element = domManager.addChild(\"canvas-overlay\", DEFAULT_TOOLTIP_CLASS);\n    this.element.classList.add(DEFAULT_TOOLTIP_CLASS);\n    setAttribute(this.element, \"aria-hidden\", true);\n  }\n  destroy(domManager) {\n    domManager.removeChild(\"canvas-overlay\", DEFAULT_TOOLTIP_CLASS);\n  }\n  isVisible() {\n    return !this.element?.classList.contains(DEFAULT_TOOLTIP_CLASS + \"-hidden\");\n  }\n  /**\n   * Shows tooltip at the given event's coordinates.\n   * If the `html` parameter is missing, moves the existing tooltip to the new position.\n   */\n  show(canvasRect, meta, content, instantly = false) {\n    const { element: element2 } = this;\n    if (content != null && element2 != null) {\n      element2.innerHTML = content.html;\n    } else if (!element2?.innerHTML) {\n      this.toggle(false);\n      return;\n    }\n    const positionType = meta.position?.type ?? this.position.type;\n    const xOffset = meta.position?.xOffset ?? 0;\n    const yOffset = meta.position?.yOffset ?? 0;\n    const tooltipBounds = this.getTooltipBounds({ positionType, meta, yOffset, xOffset, canvasRect });\n    const position = calculatePlacement(\n      element2.clientWidth,\n      element2.clientHeight,\n      canvasRect.width,\n      canvasRect.height,\n      tooltipBounds\n    );\n    const windowBounds = this.nestedDOM ? canvasRect : this.getWindowSize();\n    const minX = this.nestedDOM ? 0 : -canvasRect.left;\n    const minY = this.nestedDOM ? 0 : -canvasRect.top;\n    const maxX = windowBounds.width - element2.clientWidth - 1 + minX;\n    const maxY = windowBounds.height - element2.clientHeight + minY;\n    const left = clamp(minX, position.x, maxX);\n    const top = clamp(minY, position.y, maxY);\n    const constrained = left !== position.x || top !== position.y;\n    const defaultShowArrow = (positionType === \"node\" || positionType === \"pointer\") && !constrained && !xOffset && !yOffset;\n    const showArrow = meta.showArrow ?? this.showArrow ?? defaultShowArrow;\n    this.updateShowArrow(showArrow);\n    element2.style.transform = `translate(${Math.round(left)}px, ${Math.round(top)}px)`;\n    this.enableInteraction = meta.enableInteraction ?? false;\n    if (this.delay > 0 && !instantly) {\n      this.toggle(false);\n      this.showTimeout = setTimeout(() => {\n        this.toggle(true);\n      }, this.delay);\n    } else {\n      this.toggle(true);\n    }\n  }\n  getWindowSize() {\n    const { innerWidth, innerHeight } = getWindow();\n    return { width: innerWidth, height: innerHeight };\n  }\n  toggle(visible) {\n    if (!this.element)\n      return;\n    const { classList } = this.element;\n    const toggleClass = (name, include) => classList.toggle(`${DEFAULT_TOOLTIP_CLASS}-${name}`, include);\n    const wasVisible = this.isVisible();\n    let timeSinceLastVisibilityChangeMs = Infinity;\n    if (!visible) {\n      clearTimeout(this.showTimeout);\n    }\n    if (wasVisible !== visible) {\n      const now = Date.now();\n      timeSinceLastVisibilityChangeMs = now - this.lastVisibilityChange;\n      this.lastVisibilityChange = now;\n    }\n    const animatedMoveThresholdMs = 100;\n    const thrashingThresholdMs = 5;\n    const noAnimation = !wasVisible && visible && timeSinceLastVisibilityChangeMs > animatedMoveThresholdMs;\n    if (timeSinceLastVisibilityChangeMs > thrashingThresholdMs) {\n      toggleClass(\"no-animation\", noAnimation);\n    }\n    toggleClass(\"no-interaction\", !this.enableInteraction);\n    toggleClass(\"hidden\", !visible);\n    toggleClass(\"arrow\", this._showArrow);\n    classList.toggle(DEFAULT_TOOLTIP_DARK_CLASS, this.darkTheme);\n    for (const wrapType of this.wrapTypes) {\n      classList.toggle(`${DEFAULT_TOOLTIP_CLASS}-wrap-${wrapType}`, wrapType === this.wrapping);\n    }\n  }\n  updateShowArrow(show) {\n    this._showArrow = show;\n  }\n  getTooltipBounds(opts) {\n    if (!this.element)\n      return {};\n    const { positionType, meta, yOffset, xOffset, canvasRect } = opts;\n    const { clientWidth: tooltipWidth, clientHeight: tooltipHeight } = this.element;\n    const bounds = { width: tooltipWidth, height: tooltipHeight };\n    switch (positionType) {\n      case \"node\":\n      case \"pointer\": {\n        bounds.top = meta.offsetY + yOffset - tooltipHeight - 8;\n        bounds.left = meta.offsetX + xOffset - tooltipWidth / 2;\n        return bounds;\n      }\n      case \"top\": {\n        bounds.top = yOffset;\n        bounds.left = canvasRect.width / 2 - tooltipWidth / 2 + xOffset;\n        return bounds;\n      }\n      case \"right\": {\n        bounds.top = canvasRect.height / 2 - tooltipHeight / 2 + yOffset;\n        bounds.left = canvasRect.width - tooltipWidth / 2 + xOffset;\n        return bounds;\n      }\n      case \"left\": {\n        bounds.top = canvasRect.height / 2 - tooltipHeight / 2 + yOffset;\n        bounds.left = xOffset;\n        return bounds;\n      }\n      case \"bottom\": {\n        bounds.top = canvasRect.height - tooltipHeight + yOffset;\n        bounds.left = canvasRect.width / 2 - tooltipWidth / 2 + xOffset;\n        return bounds;\n      }\n      case \"top-left\": {\n        bounds.top = yOffset;\n        bounds.left = xOffset;\n        return bounds;\n      }\n      case \"top-right\": {\n        bounds.top = yOffset;\n        bounds.left = canvasRect.width - tooltipWidth + xOffset;\n        return bounds;\n      }\n      case \"bottom-right\": {\n        bounds.top = canvasRect.height - tooltipHeight + yOffset;\n        bounds.left = canvasRect.width - tooltipWidth + xOffset;\n        return bounds;\n      }\n      case \"bottom-left\": {\n        bounds.top = canvasRect.height - tooltipHeight + yOffset;\n        bounds.left = xOffset;\n        return bounds;\n      }\n    }\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], Tooltip.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], Tooltip.prototype, \"showArrow\", 2);\n__decorateClass([\n  ObserveChanges((target, newValue, oldValue) => {\n    if (newValue) {\n      target.element?.classList.add(newValue);\n    }\n    if (oldValue) {\n      target.element?.classList.remove(oldValue);\n    }\n  }),\n  Validate(STRING, { optional: true })\n], Tooltip.prototype, \"class\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Tooltip.prototype, \"delay\", 2);\n__decorateClass([\n  Validate(INTERACTION_RANGE, { optional: true })\n], Tooltip.prototype, \"range\", 2);\n__decorateClass([\n  Validate(TEXT_WRAP)\n], Tooltip.prototype, \"wrapping\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Tooltip.prototype, \"position\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], Tooltip.prototype, \"darkTheme\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], Tooltip.prototype, \"nestedDOM\", 2);\n\n// packages/ag-charts-community/src/chart/caption.ts\nvar Caption = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.id = createId(this);\n    this.node = new Text({ zIndex: 1 }).setProperties({\n      textAlign: \"center\",\n      pointerEvents: 1 /* None */\n    });\n    this.enabled = false;\n    this.textAlign = \"center\";\n    this.fontSize = 10;\n    this.fontFamily = \"sans-serif\";\n    this.wrapping = \"always\";\n    this.truncated = false;\n    this.layoutStyle = \"block\";\n  }\n  registerInteraction(moduleCtx) {\n    const region = moduleCtx.regionManager.getRegion(\"root\");\n    const destroyFns = [\n      region.addListener(\"hover\", (event) => this.handleMouseMove(moduleCtx, event)),\n      region.addListener(\"leave\", (event) => this.handleMouseLeave(moduleCtx, event))\n    ];\n    return joinFunctions(...destroyFns);\n  }\n  computeTextWrap(containerWidth, containerHeight) {\n    const { text, wrapping } = this;\n    const maxWidth = Math.min(this.maxWidth ?? Infinity, containerWidth);\n    const maxHeight = this.maxHeight ?? containerHeight;\n    if (!isFinite(maxWidth) && !isFinite(maxHeight)) {\n      this.node.text = text;\n      return;\n    }\n    const wrappedText = Text.wrap(text ?? \"\", maxWidth, maxHeight, this, wrapping);\n    this.node.text = wrappedText;\n    this.truncated = wrappedText.includes(TextMeasurer.EllipsisChar);\n  }\n  handleMouseMove(moduleCtx, event) {\n    if (event !== void 0 && this.enabled && this.node.visible && this.truncated) {\n      const { offsetX, offsetY } = event;\n      moduleCtx.tooltipManager.updateTooltip(\n        this.id,\n        { offsetX, offsetY, lastPointerEvent: event, showArrow: false },\n        toTooltipHtml({ content: this.text })\n      );\n    }\n  }\n  handleMouseLeave(moduleCtx, _event) {\n    moduleCtx.tooltipManager.removeTooltip(this.id);\n  }\n};\nCaption.SMALL_PADDING = 10;\nCaption.LARGE_PADDING = 20;\n__decorateClass([\n  Validate(BOOLEAN)\n], Caption.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"text\", 2);\n__decorateClass([\n  Validate(TEXT_ALIGN, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"textAlign\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"node\", \"fill\")\n], Caption.prototype, \"color\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Caption.prototype, \"spacing\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Caption.prototype, \"lineHeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Caption.prototype, \"maxWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Caption.prototype, \"maxHeight\", 2);\n__decorateClass([\n  Validate(TEXT_WRAP)\n], Caption.prototype, \"wrapping\", 2);\n__decorateClass([\n  Validate(STRING)\n], Caption.prototype, \"layoutStyle\", 2);\n\n// packages/ag-charts-community/src/util/listeners.ts\nvar Listeners = class {\n  constructor() {\n    this.registeredListeners = /* @__PURE__ */ new Map();\n  }\n  addListener(eventType, handler) {\n    const record = { symbol: Symbol(eventType), handler };\n    if (this.registeredListeners.has(eventType)) {\n      this.registeredListeners.get(eventType).push(record);\n    } else {\n      this.registeredListeners.set(eventType, [record]);\n    }\n    return () => this.removeListener(record.symbol);\n  }\n  removeListener(eventSymbol) {\n    for (const [type, listeners] of this.registeredListeners.entries()) {\n      const matchIndex = listeners.findIndex((listener) => listener.symbol === eventSymbol);\n      if (matchIndex >= 0) {\n        listeners.splice(matchIndex, 1);\n        if (listeners.length === 0) {\n          this.registeredListeners.delete(type);\n        }\n        break;\n      }\n    }\n  }\n  dispatch(eventType, ...params) {\n    for (const listener of this.getListenersByType(eventType)) {\n      try {\n        listener.handler(...params);\n      } catch (e) {\n        Logger.errorOnce(e);\n      }\n    }\n  }\n  dispatchWrapHandlers(eventType, wrapFn, ...params) {\n    for (const listener of this.getListenersByType(eventType)) {\n      try {\n        wrapFn(listener.handler, ...params);\n      } catch (e) {\n        Logger.errorOnce(e);\n      }\n    }\n  }\n  getListenersByType(eventType) {\n    return this.registeredListeners.get(eventType) ?? [];\n  }\n  destroy() {\n    this.registeredListeners.clear();\n  }\n};\n\n// packages/ag-charts-community/src/chart/baseManager.ts\nvar BaseManager = class {\n  constructor() {\n    this.listeners = new Listeners();\n    this.destroyFns = [];\n  }\n  addListener(type, handler) {\n    return this.listeners.addListener(type, handler);\n  }\n  destroy() {\n    this.listeners.destroy();\n    this.destroyFns.forEach((fn) => fn());\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/preventableEvent.ts\nfunction buildPreventable(obj) {\n  const self = {\n    ...obj,\n    preventDefault() {\n      self.sourceEvent?.preventDefault();\n    }\n  };\n  return self;\n}\nfunction dispatchTypedEvent(listeners, event) {\n  listeners.dispatchWrapHandlers(event.type, (handler, e) => handler(e), buildPreventable(event));\n}\n\n// packages/ag-charts-community/src/chart/interaction/interactionManager.ts\nvar POINTER_INTERACTION_TYPES = [\n  \"click\",\n  \"dblclick\",\n  \"contextmenu\",\n  \"hover\",\n  \"drag-start\",\n  \"drag\",\n  \"drag-end\",\n  \"leave\",\n  \"enter\",\n  \"page-left\",\n  \"wheel\"\n];\nvar FOCUS_INTERACTION_TYPES = [\"blur\", \"focus\"];\nvar KEY_INTERACTION_TYPES = [\"keydown\", \"keyup\"];\nvar SHADOW_DOM_HANDLERS = [\"mousemove\", \"mouseup\"];\nvar WINDOW_EVENT_HANDLERS = [\"pagehide\", \"mousemove\", \"mouseup\"];\nvar EVENT_HANDLERS = [\n  \"click\",\n  \"dblclick\",\n  \"contextmenu\",\n  \"mousedown\",\n  \"mouseleave\",\n  \"mouseenter\",\n  \"touchstart\",\n  \"touchmove\",\n  \"touchend\",\n  \"touchcancel\",\n  \"wheel\",\n  \"blur\",\n  \"focus\",\n  \"keydown\",\n  \"keyup\"\n];\nvar InteractionState = /* @__PURE__ */ ((InteractionState2) => {\n  InteractionState2[InteractionState2[\"Default\"] = 16] = \"Default\";\n  InteractionState2[InteractionState2[\"ZoomDrag\"] = 8] = \"ZoomDrag\";\n  InteractionState2[InteractionState2[\"Annotations\"] = 4] = \"Annotations\";\n  InteractionState2[InteractionState2[\"ContextMenu\"] = 2] = \"ContextMenu\";\n  InteractionState2[InteractionState2[\"Animation\"] = 1] = \"Animation\";\n  InteractionState2[InteractionState2[\"All\"] = 31] = \"All\";\n  return InteractionState2;\n})(InteractionState || {});\nvar _InteractionManager = class _InteractionManager extends BaseManager {\n  constructor(keyboardOptions, domManager) {\n    super();\n    this.keyboardOptions = keyboardOptions;\n    this.domManager = domManager;\n    this.debug = Debug.create(true, \"interaction\");\n    this.eventHandler = (event) => this.processEvent(event);\n    this.mouseDown = false;\n    this.touchDown = false;\n    this.clickHistory = [{ offsetX: NaN, offsetY: NaN, type: \"mousedown\" }];\n    this.dblclickHistory = [\n      { offsetX: NaN, offsetY: NaN, type: \"mousedown\" },\n      { offsetX: NaN, offsetY: NaN, type: \"mouseup\" },\n      { offsetX: NaN, offsetY: NaN, type: \"mousedown\" }\n    ];\n    this.stateQueue = 16 /* Default */ | 1 /* Animation */;\n    this.rootElement = this.domManager.getDocumentRoot();\n    for (const type of EVENT_HANDLERS) {\n      if (type.startsWith(\"touch\") || type === \"wheel\") {\n        this.domManager.addEventListener(type, this.eventHandler, { passive: false });\n      } else {\n        this.domManager.addEventListener(type, this.eventHandler);\n      }\n    }\n    for (const type of WINDOW_EVENT_HANDLERS) {\n      getWindow().addEventListener(type, this.eventHandler);\n    }\n    this.containerChanged(true);\n    this.domManager.addListener(\"container-changed\", () => this.containerChanged());\n  }\n  containerChanged(force = false) {\n    const newRoot = this.domManager.getDocumentRoot();\n    if (!force && newRoot === this.rootElement)\n      return;\n    for (const type of SHADOW_DOM_HANDLERS) {\n      this.rootElement?.removeEventListener(type, this.eventHandler);\n    }\n    this.rootElement = newRoot;\n    this.debug(\"[InteractionManager] Switching rootElement to:\", this.rootElement);\n    for (const type of SHADOW_DOM_HANDLERS) {\n      this.rootElement?.addEventListener(type, this.eventHandler);\n    }\n  }\n  destroy() {\n    super.destroy();\n    for (const type of WINDOW_EVENT_HANDLERS) {\n      getWindow().removeEventListener(type, this.eventHandler);\n    }\n    for (const type of SHADOW_DOM_HANDLERS) {\n      this.rootElement?.removeEventListener(type, this.eventHandler);\n    }\n    for (const type of EVENT_HANDLERS) {\n      this.domManager.removeEventListener(type, this.eventHandler);\n    }\n    this.domManager.removeStyles(\"interactionManager\");\n  }\n  // Wrapper to only broadcast events when the InteractionManager is a given state.\n  addListener(type, handler, triggeringStates = 16 /* Default */) {\n    return super.addListener(type, (e) => {\n      const currentState = this.getState();\n      if (currentState & triggeringStates) {\n        handler(e);\n      }\n    });\n  }\n  pushState(state) {\n    this.stateQueue |= state;\n  }\n  popState(state) {\n    this.stateQueue &= ~state;\n  }\n  getState() {\n    return this.stateQueue & -this.stateQueue;\n  }\n  processEvent(event) {\n    const types = this.decideInteractionEventTypes(event);\n    const target = event.target;\n    if (event.type === \"click\" && target?.ariaDisabled === \"true\") {\n      event.preventDefault();\n      return;\n    }\n    if (types.length > 0) {\n      this.dispatchEvent(event, types).catch((e) => Logger.errorOnce(e));\n    }\n  }\n  async dispatchEvent(event, types) {\n    if (allInStringUnion(POINTER_INTERACTION_TYPES, types)) {\n      this.dispatchPointerEvent(event, types);\n      return;\n    }\n    const { relatedElement, targetElement } = this.extractElements(event);\n    if (allInStringUnion(FOCUS_INTERACTION_TYPES, types)) {\n      for (const type of types) {\n        const sourceEvent = event;\n        dispatchTypedEvent(this.listeners, { type, sourceEvent, relatedElement, targetElement });\n      }\n    } else if (allInStringUnion(KEY_INTERACTION_TYPES, types)) {\n      for (const type of types) {\n        const sourceEvent = event;\n        dispatchTypedEvent(this.listeners, { type, sourceEvent, relatedElement, targetElement });\n      }\n    }\n  }\n  extractElements(event) {\n    let relatedElement;\n    let targetElement;\n    if (\"relatedTarget\" in event && event[\"relatedTarget\"] instanceof HTMLElement) {\n      relatedElement = event[\"relatedTarget\"];\n    }\n    if (\"target\" in event && event[\"target\"] instanceof HTMLElement) {\n      targetElement = event[\"target\"];\n    }\n    return { relatedElement, targetElement };\n  }\n  dispatchPointerEvent(event, types) {\n    const coords = this.calculateCoordinates(event);\n    if (coords == null) {\n      return;\n    }\n    for (const type of types) {\n      dispatchTypedEvent(this.listeners, this.buildPointerEvent({ type, event, ...coords }));\n    }\n  }\n  getEventHTMLTarget(event) {\n    if (event.target instanceof HTMLElement) {\n      return event.target;\n    } else if (event.currentTarget instanceof HTMLElement) {\n      return event.currentTarget;\n    }\n    return void 0;\n  }\n  recordDown(event) {\n    if (event instanceof MouseEvent) {\n      partialAssign([\"offsetX\", \"offsetY\"], this.clickHistory[0], event);\n      partialAssign([\"offsetX\", \"offsetY\"], this.dblclickHistory[2], this.dblclickHistory[0]);\n      partialAssign([\"offsetX\", \"offsetY\"], this.dblclickHistory[0], event);\n    }\n    this.dragStartElement = this.getEventHTMLTarget(event);\n  }\n  recordUp(event) {\n    if (event instanceof MouseEvent) {\n      partialAssign([\"offsetX\", \"offsetY\"], this.dblclickHistory[1], event);\n    }\n    this.dragStartElement = void 0;\n  }\n  decideInteractionEventTypes(event) {\n    const dragStart = \"drag-start\";\n    switch (event.type) {\n      case \"blur\":\n      case \"focus\":\n      case \"keydown\":\n      case \"keyup\":\n        return this.keyboardOptions.enabled ? [event.type] : [];\n      case \"click\":\n      case \"dblclick\":\n      case \"contextmenu\":\n      case \"wheel\":\n        return [event.type];\n      case \"mousedown\":\n        if (!this.isEventOverElement(event) || !(\"button\" in event) || event.button !== 0) {\n          return [];\n        }\n        this.mouseDown = true;\n        this.recordDown(event);\n        return [dragStart];\n      case \"touchstart\":\n        if (!this.isEventOverElement(event)) {\n          return [];\n        }\n        this.touchDown = true;\n        this.recordDown(event);\n        return [dragStart];\n      case \"touchmove\":\n      case \"mousemove\":\n        if (!this.mouseDown && !this.touchDown && !this.isEventOverElement(event)) {\n          return [];\n        }\n        return this.mouseDown || this.touchDown ? [\"drag\"] : [\"hover\"];\n      case \"mouseup\":\n        if (!this.mouseDown && !this.isEventOverElement(event)) {\n          return [];\n        }\n        this.mouseDown = false;\n        this.recordUp(event);\n        return [\"drag-end\"];\n      case \"touchend\":\n        if (!this.touchDown && !this.isEventOverElement(event)) {\n          return [];\n        }\n        this.touchDown = false;\n        this.recordUp(event);\n        return [\"drag-end\"];\n      case \"mouseleave\":\n      case \"touchcancel\":\n        return [\"leave\"];\n      case \"mouseenter\":\n        const mouseButtonDown = event instanceof MouseEvent && (event.buttons & 1) === 1;\n        if (this.mouseDown !== mouseButtonDown) {\n          this.mouseDown = mouseButtonDown;\n          return [mouseButtonDown ? dragStart : \"drag-end\"];\n        }\n        return [\"enter\"];\n      case \"pagehide\":\n        return [\"page-left\"];\n    }\n    return [];\n  }\n  isEventOverElement(event) {\n    return this.domManager.isEventOverElement(event);\n  }\n  calculateCoordinates(event) {\n    if (event instanceof MouseEvent) {\n      return this.getMouseEventCoords(event);\n    } else if (typeof TouchEvent !== \"undefined\" && event instanceof TouchEvent) {\n      const lastTouch = event.touches[0] ?? event.changedTouches[0];\n      const { clientX, clientY, pageX, pageY } = lastTouch;\n      return { ..._InteractionManager.NULL_COORDS, clientX, clientY, pageX, pageY };\n    } else if (event instanceof PageTransitionEvent) {\n      if (event.persisted) {\n        return;\n      }\n      return _InteractionManager.NULL_COORDS;\n    }\n  }\n  getMouseEventCoords(event) {\n    const { clientX, clientY, pageX, pageY } = event;\n    let { offsetX, offsetY } = event;\n    const target = this.getEventHTMLTarget(event);\n    const { x = 0, y = 0 } = target ? this.domManager.calculateCanvasPosition(target) : {};\n    if (this.dragStartElement != null && event.target !== this.dragStartElement) {\n      const offsetDragStart = this.domManager.calculateCanvasPosition(this.dragStartElement);\n      offsetX -= offsetDragStart.x - x;\n      offsetY -= offsetDragStart.y - y;\n    } else {\n      offsetX += x;\n      offsetY += y;\n    }\n    return { clientX, clientY, pageX, pageY, offsetX, offsetY };\n  }\n  isWheelEvent(event) {\n    return event.type === \"wheel\";\n  }\n  buildPointerEvent(opts) {\n    const { type, event, clientX, clientY } = opts;\n    let { offsetX, offsetY, pageX, pageY } = opts;\n    if (!isFiniteNumber(offsetX) || !isFiniteNumber(offsetY)) {\n      const rect = this.domManager.getBoundingClientRect();\n      offsetX = clientX - rect.left;\n      offsetY = clientY - rect.top;\n    }\n    if (!isFiniteNumber(pageX) || !isFiniteNumber(pageY)) {\n      const pageRect = this.rootElement?.getBoundingClientRect();\n      pageX = clientX - (pageRect?.left ?? 0);\n      pageY = clientY - (pageRect?.top ?? 0);\n    }\n    let [deltaX, deltaY] = [NaN, NaN];\n    if (this.isWheelEvent(event)) {\n      const factor = event.deltaMode === 0 ? 0.01 : 1;\n      deltaX = event.deltaX * factor;\n      deltaY = event.deltaY * factor;\n    }\n    let pointerHistory = [];\n    if (event.type === \"click\") {\n      pointerHistory = this.clickHistory;\n    } else if (event.type === \"dblclick\") {\n      pointerHistory = this.dblclickHistory;\n    }\n    const { relatedElement, targetElement } = this.extractElements(event);\n    const builtEvent = {\n      type,\n      offsetX,\n      offsetY,\n      pageX,\n      pageY,\n      deltaX,\n      deltaY,\n      pointerHistory,\n      sourceEvent: event,\n      relatedElement,\n      targetElement\n    };\n    this.debug(\"InteractionManager - builtEvent: \", builtEvent);\n    return builtEvent;\n  }\n};\n_InteractionManager.NULL_COORDS = {\n  clientX: -Infinity,\n  clientY: -Infinity,\n  pageX: -Infinity,\n  pageY: -Infinity,\n  offsetX: -Infinity,\n  offsetY: -Infinity\n};\nvar InteractionManager = _InteractionManager;\n\n// packages/ag-charts-community/src/chart/interaction/regions.ts\nvar REGIONS = /* @__PURE__ */ ((REGIONS2) => {\n  REGIONS2[\"TITLE\"] = \"title\";\n  REGIONS2[\"SUBTITLE\"] = \"subtitle\";\n  REGIONS2[\"FOOTNOTE\"] = \"footnote\";\n  REGIONS2[\"LEGEND\"] = \"legend\";\n  REGIONS2[\"NAVIGATOR\"] = \"navigator\";\n  REGIONS2[\"PAGINATION\"] = \"pagination\";\n  REGIONS2[\"ROOT\"] = \"root\";\n  REGIONS2[\"SERIES\"] = \"series\";\n  REGIONS2[\"HORIZONTAL_AXES\"] = \"horizontal-axes\";\n  REGIONS2[\"VERTICAL_AXES\"] = \"vertical-axes\";\n  REGIONS2[\"TOOLBAR\"] = \"toolbar\";\n  return REGIONS2;\n})(REGIONS || {});\n\n// packages/ag-charts-community/src/chart/axis/axisGridLine.ts\nvar GRID_STYLE_KEYS = [\"stroke\", \"lineDash\"];\nvar GRID_STYLE = ARRAY_OF(\n  (value) => isObject(value) && Object.keys(value).every((key) => GRID_STYLE_KEYS.includes(key)),\n  \"objects with gridline style properties such as 'stroke' or 'lineDash'\"\n);\nvar AxisGridLine = class {\n  constructor() {\n    this.enabled = true;\n    this.width = 1;\n    this.style = [\n      {\n        stroke: void 0,\n        lineDash: []\n      }\n    ];\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisGridLine.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisGridLine.prototype, \"width\", 2);\n__decorateClass([\n  Validate(GRID_STYLE)\n], AxisGridLine.prototype, \"style\", 2);\n\n// packages/ag-charts-community/src/util/default.ts\nfunction Default(defaultValue, replaces = [void 0]) {\n  return addTransformToInstanceProperty((_, __, v) => {\n    if (replaces.includes(v)) {\n      return isFunction(defaultValue) ? defaultValue(v) : defaultValue;\n    }\n    return v;\n  });\n}\n\n// packages/ag-charts-community/src/chart/axis/axisInterval.ts\nvar TICK_INTERVAL = predicateWithMessage(\n  (value) => isFiniteNumber(value) && value > 0 || value instanceof TimeInterval,\n  `a non-zero positive Number value or, for a time axis, a Time Interval such as 'agCharts.time.month'`\n);\nvar AxisInterval = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.minSpacing = NaN;\n    this.maxSpacing = NaN;\n  }\n};\n__decorateClass([\n  Validate(TICK_INTERVAL, { optional: true })\n], AxisInterval.prototype, \"step\", 2);\n__decorateClass([\n  Validate(ARRAY, { optional: true })\n], AxisInterval.prototype, \"values\", 2);\n__decorateClass([\n  Validate(MIN_SPACING),\n  Default(NaN)\n], AxisInterval.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(MAX_SPACING),\n  Default(NaN)\n], AxisInterval.prototype, \"maxSpacing\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisLabel.ts\nvar AxisLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.autoWrap = false;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n    this.padding = 5;\n    this.minSpacing = NaN;\n    this.color = \"rgba(87, 87, 87, 1)\";\n    this.avoidCollisions = true;\n    this.mirrored = false;\n    this.parallel = false;\n  }\n  /**\n   * The side of the axis line to position the labels on.\n   * -1 = left (default)\n   * 1 = right\n   */\n  getSideFlag() {\n    return this.mirrored ? 1 : -1;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], AxisLabel.prototype, \"autoWrap\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], AxisLabel.prototype, \"maxWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], AxisLabel.prototype, \"maxHeight\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], AxisLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], AxisLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(NUMBER.restrict({ min: 1 }))\n], AxisLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], AxisLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisLabel.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(NUMBER_OR_NAN),\n  Default(NaN)\n], AxisLabel.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(DEGREE, { optional: true })\n], AxisLabel.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"avoidCollisions\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"mirrored\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"parallel\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], AxisLabel.prototype, \"formatter\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AxisLabel.prototype, \"format\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisLine.ts\nvar AxisLine = class {\n  constructor() {\n    this.enabled = true;\n    this.width = 1;\n    this.stroke = void 0;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLine.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisLine.prototype, \"width\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisLine.prototype, \"stroke\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisTick.ts\nvar AxisTick = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.width = 1;\n    this.size = 6;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisTick.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisTick.prototype, \"width\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisTick.prototype, \"size\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisTick.prototype, \"stroke\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisTitle.ts\nvar AxisTitle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = false;\n    this.spacing = Caption.SMALL_PADDING;\n    this.fontSize = 10;\n    this.fontFamily = \"sans-serif\";\n    this.wrapping = \"always\";\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisTitle.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AxisTitle.prototype, \"text\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], AxisTitle.prototype, \"spacing\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], AxisTitle.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], AxisTitle.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisTitle.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], AxisTitle.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisTitle.prototype, \"color\", 2);\n__decorateClass([\n  Validate(TEXT_WRAP)\n], AxisTitle.prototype, \"wrapping\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], AxisTitle.prototype, \"formatter\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisUtil.ts\nfunction prepareAxisAnimationContext(axis) {\n  const [requestedRangeMin, requestedRangeMax] = findMinMax(axis.range);\n  const min = Math.floor(requestedRangeMin);\n  const max = Math.ceil(requestedRangeMax);\n  return { min, max, visible: min !== max };\n}\nvar fullCircle = Math.PI * 2;\nvar halfCircle = fullCircle / 2;\nfunction normaliseEndRotation(start, end) {\n  const directDistance = Math.abs(end - start);\n  if (directDistance < halfCircle)\n    return end;\n  if (start > end)\n    return end + fullCircle;\n  return end - fullCircle;\n}\nfunction prepareAxisAnimationFunctions(ctx) {\n  const outOfBounds = (y, range3) => {\n    const [min = ctx.min, max = ctx.max] = findMinMax(range3 ?? []);\n    return y < min || y > max;\n  };\n  const tick = {\n    fromFn(node, datum, status) {\n      let y = node.y1 + node.translationY;\n      let opacity = node.opacity;\n      if (status === \"added\" || outOfBounds(node.datum.translationY, node.datum.range)) {\n        y = datum.translationY;\n        opacity = 0;\n      }\n      return { y: 0, translationY: y, opacity, phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status] };\n    },\n    toFn(_node, datum, status) {\n      const y = datum.translationY;\n      let opacity = 1;\n      if (status === \"removed\") {\n        opacity = 0;\n      }\n      return {\n        y: 0,\n        translationY: y,\n        opacity,\n        finish: {\n          // Set explicit y after animation so it's pixel aligned\n          y,\n          translationY: 0\n        }\n      };\n    },\n    intermediateFn(node, _datum, _status) {\n      return { visible: !outOfBounds(node.y) };\n    }\n  };\n  const label = {\n    fromFn(node, newDatum, status) {\n      const datum = node.previousDatum ?? newDatum;\n      const x = datum.x;\n      const y = datum.y;\n      const rotationCenterX = datum.rotationCenterX;\n      let translationY = Math.round(node.translationY);\n      let rotation = datum.rotation;\n      let opacity = node.opacity;\n      if (status === \"removed\" || outOfBounds(datum.y, datum.range)) {\n        rotation = newDatum.rotation;\n      } else if (status === \"added\" || outOfBounds(node.datum.y, node.datum.range)) {\n        translationY = Math.round(datum.translationY);\n        opacity = 0;\n        rotation = newDatum.rotation;\n      }\n      return {\n        x,\n        y,\n        rotationCenterX,\n        translationY,\n        rotation,\n        opacity,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]\n      };\n    },\n    toFn(node, datum, status) {\n      const x = datum.x;\n      const y = datum.y;\n      const rotationCenterX = datum.rotationCenterX;\n      const translationY = Math.round(datum.translationY);\n      let rotation = 0;\n      let opacity = 1;\n      if (status === \"added\") {\n        opacity = 1;\n        rotation = datum.rotation;\n      } else if (status === \"removed\") {\n        opacity = 0;\n        rotation = datum.rotation;\n      } else {\n        rotation = normaliseEndRotation(node.previousDatum?.rotation ?? datum.rotation, datum.rotation);\n      }\n      return { x, y, rotationCenterX, translationY, rotation, opacity, finish: { rotation: datum.rotation } };\n    }\n  };\n  const line = {\n    fromFn(node, datum) {\n      return {\n        ...node.previousDatum ?? datum,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[\"updated\"]\n      };\n    },\n    toFn(_node, datum) {\n      return { ...datum };\n    }\n  };\n  const group = {\n    fromFn(node, _datum) {\n      const { rotation, translationX, translationY } = node;\n      return {\n        rotation,\n        translationX,\n        translationY,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[\"updated\"]\n      };\n    },\n    toFn(_node, datum) {\n      const { rotation, translationX, translationY } = datum;\n      return {\n        rotation,\n        translationX,\n        translationY\n      };\n    }\n  };\n  return { tick, line, label, group };\n}\nfunction resetAxisGroupFn() {\n  return (_node, datum) => {\n    return {\n      rotation: datum.rotation,\n      rotationCenterX: datum.rotationCenterX,\n      rotationCenterY: datum.rotationCenterY,\n      translationX: datum.translationX,\n      translationY: datum.translationY\n    };\n  };\n}\nfunction resetAxisSelectionFn(ctx) {\n  const { visible: rangeVisible, min, max } = ctx;\n  return (_node, datum) => {\n    const y = datum.translationY;\n    const visible = rangeVisible && y >= min && y <= max;\n    return {\n      y,\n      translationY: 0,\n      opacity: 1,\n      visible\n    };\n  };\n}\nfunction resetAxisLabelSelectionFn() {\n  return (_node, datum) => {\n    return {\n      x: datum.x,\n      y: datum.y,\n      translationY: datum.translationY,\n      rotation: datum.rotation,\n      rotationCenterX: datum.rotationCenterX\n    };\n  };\n}\nfunction resetAxisLineSelectionFn() {\n  return (_node, datum) => {\n    return { ...datum };\n  };\n}\n\n// packages/ag-charts-community/src/chart/axis/axis.ts\nvar _Axis = class _Axis {\n  constructor(moduleCtx, scale2, options) {\n    this.moduleCtx = moduleCtx;\n    this.scale = scale2;\n    this.id = createId(this);\n    this.nice = true;\n    this.reverse = false;\n    this.keys = [];\n    this.interval = new AxisInterval();\n    this.disableZoom = false;\n    this.dataDomain = { domain: [], clipped: false };\n    this.layoutConstraints = {\n      stacked: true,\n      align: \"start\",\n      width: 100,\n      unit: \"percent\"\n    };\n    this.boundSeries = [];\n    this.includeInvisibleDomains = false;\n    this.interactionEnabled = true;\n    this.axisGroup = new Group({ name: `${this.id}-axis`, zIndex: 2 /* AXIS_ZINDEX */ });\n    this.lineNode = this.axisGroup.appendChild(new Line());\n    this.tickLineGroup = this.axisGroup.appendChild(\n      new Group({ name: `${this.id}-Axis-tick-lines`, zIndex: 2 /* AXIS_ZINDEX */ })\n    );\n    this.tickLabelGroup = this.axisGroup.appendChild(\n      new Group({ name: `${this.id}-Axis-tick-labels`, zIndex: 2 /* AXIS_ZINDEX */ })\n    );\n    this.crossLineGroup = new Group({ name: `${this.id}-CrossLines` });\n    this.labelGroup = new Group({ name: `${this.id}-Labels`, zIndex: 10 /* SERIES_ANNOTATION_ZINDEX */ });\n    this.gridGroup = new Group({ name: `${this.id}-Axis-grid` });\n    this.gridLineGroup = this.gridGroup.appendChild(\n      new Group({\n        name: `${this.id}-gridLines`,\n        zIndex: 1 /* AXIS_GRID_ZINDEX */\n      })\n    );\n    this.tickLineGroupSelection = Selection.select(this.tickLineGroup, Line, false);\n    this.tickLabelGroupSelection = Selection.select(this.tickLabelGroup, Text, false);\n    this.gridLineGroupSelection = Selection.select(this.gridLineGroup, Line, false);\n    this.line = new AxisLine();\n    this.tick = new AxisTick();\n    this.gridLine = new AxisGridLine();\n    this.label = this.createLabel();\n    this.defaultTickMinSpacing = _Axis.defaultTickMinSpacing;\n    this.translation = { x: 0, y: 0 };\n    this.rotation = 0;\n    // axis rotation angle in degrees\n    this.layout = {\n      label: {\n        fractionDigits: 0,\n        padding: this.label.padding,\n        format: this.label.format\n      }\n    };\n    this.destroyFns = [];\n    // eslint-disable-next-line @typescript-eslint/prefer-readonly\n    this.minRect = void 0;\n    this.range = [0, 1];\n    this.visibleRange = [0, 1];\n    this.title = new AxisTitle();\n    this._titleCaption = new Caption();\n    this.gridLength = 0;\n    /**\n     * The distance between the grid ticks and the axis ticks.\n     */\n    this.gridPadding = 0;\n    /**\n     * Is used to avoid collisions between axis labels and series.\n     */\n    this.seriesAreaPadding = 0;\n    this.tickGenerationResult = void 0;\n    this.maxThickness = Infinity;\n    this.moduleMap = new ModuleMap();\n    this.range = this.scale.range.slice();\n    this.crossLines?.forEach((crossLine) => this.initCrossLine(crossLine));\n    this.destroyFns.push(this._titleCaption.registerInteraction(this.moduleCtx));\n    this._titleCaption.node.rotation = -Math.PI / 2;\n    this.axisGroup.appendChild(this._titleCaption.node);\n    this.destroyFns.push(\n      moduleCtx.regionManager.getRegion(\"series\" /* SERIES */).addListener(\"hover\", (e) => this.checkAxisHover(e)),\n      moduleCtx.regionManager.getRegion(\"horizontal-axes\" /* HORIZONTAL_AXES */).addListener(\"hover\", (e) => this.checkAxisHover(e)),\n      moduleCtx.regionManager.getRegion(\"vertical-axes\" /* VERTICAL_AXES */).addListener(\"hover\", (e) => this.checkAxisHover(e))\n    );\n    this.animationManager = moduleCtx.animationManager;\n    this.animationState = new StateMachine(\"empty\", {\n      empty: {\n        update: {\n          target: \"ready\",\n          action: () => this.resetSelectionNodes()\n        },\n        reset: \"empty\"\n      },\n      ready: {\n        update: (data) => this.animateReadyUpdate(data),\n        resize: () => this.resetSelectionNodes(),\n        reset: \"empty\"\n      }\n    });\n    this._crossLines = [];\n    this.assignCrossLineArrayConstructor(this._crossLines);\n    let previousSize = void 0;\n    this.destroyFns.push(\n      moduleCtx.layoutService.addListener(\"layout-complete\", (e) => {\n        if (previousSize != null && jsonDiff(e.chart, previousSize) != null) {\n          this.animationState.transition(\"resize\");\n        }\n        previousSize = { ...e.chart };\n      })\n    );\n    if (options?.respondsToZoom !== false) {\n      this.destroyFns.push(\n        moduleCtx.updateService.addListener(\"update-complete\", (e) => {\n          this.minRect = e.minRect;\n        })\n      );\n    }\n  }\n  get type() {\n    return this.constructor.type ?? \"\";\n  }\n  set crossLines(value) {\n    this._crossLines?.forEach((crossLine) => this.detachCrossLine(crossLine));\n    if (value) {\n      this.assignCrossLineArrayConstructor(value);\n    }\n    this._crossLines = value;\n    this._crossLines?.forEach((crossLine) => {\n      this.attachCrossLine(crossLine);\n      this.initCrossLine(crossLine);\n    });\n  }\n  get crossLines() {\n    return this._crossLines;\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    }\n  }\n  attachCrossLine(crossLine) {\n    this.crossLineGroup.appendChild(crossLine.group);\n    this.crossLineGroup.appendChild(crossLine.labelGroup);\n  }\n  detachCrossLine(crossLine) {\n    this.crossLineGroup.removeChild(crossLine.group);\n    this.crossLineGroup.removeChild(crossLine.labelGroup);\n  }\n  destroy() {\n    this.moduleMap.destroy();\n    this.destroyFns.forEach((f) => f());\n  }\n  updateRange() {\n    const { range: rr, visibleRange: vr, scale: scale2 } = this;\n    const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n    const shift = span * vr[0];\n    const start = rr[0] - shift;\n    scale2.setVisibleRange?.(vr);\n    scale2.range = [start, start + span];\n    this.crossLines?.forEach((crossLine) => {\n      crossLine.clippedRange = [rr[0], rr[1]];\n    });\n  }\n  setCrossLinesVisible(visible) {\n    this.crossLineGroup.visible = visible;\n  }\n  attachAxis(axisNode, gridNode) {\n    gridNode.appendChild(this.gridGroup);\n    axisNode.appendChild(this.axisGroup);\n    axisNode.appendChild(this.crossLineGroup);\n    axisNode.appendChild(this.labelGroup);\n  }\n  attachLabel(axisLabelNode) {\n    this.labelGroup.append(axisLabelNode);\n  }\n  detachAxis(axisNode, gridNode) {\n    gridNode.removeChild(this.gridGroup);\n    axisNode.removeChild(this.axisGroup);\n    axisNode.removeChild(this.crossLineGroup);\n    axisNode.removeChild(this.labelGroup);\n  }\n  getAxisGroup() {\n    return this.axisGroup;\n  }\n  /**\n   * Checks if a point or an object is in range.\n   * @param x A point (or object's starting point).\n   * @param tolerance Expands the range on both ends by this amount.\n   */\n  inRange(x, tolerance = 0) {\n    const [min, max] = findMinMax(this.range);\n    return x >= min - tolerance && x <= max + tolerance;\n  }\n  onFormatChange(ticks, fractionDigits, _domain, format) {\n    const { scale: scale2 } = this;\n    const logScale = scale2 instanceof LogScale;\n    const defaultFormatter = (formatOffset) => logScale ? String : (x) => typeof x === \"number\" ? x.toFixed(fractionDigits + formatOffset) : String(x);\n    if (format && scale2 && scale2.tickFormat) {\n      try {\n        const formatter = scale2.tickFormat({ ticks, specifier: format });\n        this.labelFormatter = formatter;\n        this.datumFormatter = formatter;\n      } catch (e) {\n        this.labelFormatter = defaultFormatter(0);\n        this.datumFormatter = defaultFormatter(1);\n        Logger.warnOnce(`the axis label format string ${format} is invalid. No formatting will be applied`);\n      }\n    } else {\n      this.labelFormatter = defaultFormatter(0);\n      this.datumFormatter = defaultFormatter(1);\n    }\n  }\n  setTickInterval(interval) {\n    this.scale.interval = this.interval?.step ?? interval;\n  }\n  onGridLengthChange(value, prevValue) {\n    if (prevValue && !value || !prevValue && value) {\n      this.onGridVisibilityChange();\n    }\n    this.crossLines?.forEach((crossLine) => this.initCrossLine(crossLine));\n  }\n  onGridVisibilityChange() {\n    this.gridLineGroupSelection.clear();\n  }\n  createLabel() {\n    return new AxisLabel();\n  }\n  checkAxisHover(event) {\n    if (!this.interactionEnabled)\n      return;\n    const bbox = this.computeBBox();\n    const isInAxis = bbox.containsPoint(event.offsetX, event.offsetY);\n    if (!isInAxis)\n      return;\n    this.moduleCtx.chartEventManager.axisHover(this.id, this.direction);\n  }\n  /**\n   * Creates/removes/updates the scene graph nodes that constitute the axis.\n   */\n  update(_primaryTickCount = 0, animated = true) {\n    if (!this.tickGenerationResult) {\n      return;\n    }\n    const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();\n    const sideFlag = this.label.getSideFlag();\n    this.updatePosition();\n    const lineData = this.getAxisLineCoordinates();\n    const { tickData, combinedRotation, textBaseline, textAlign, primaryTickCount } = this.tickGenerationResult;\n    const previousTicks = this.tickLabelGroupSelection.nodes().map((node) => node.datum.tickId);\n    this.updateSelections(lineData, tickData.ticks, {\n      combinedRotation,\n      textAlign,\n      textBaseline,\n      range: this.scale.range\n    });\n    if (!animated || this.animationManager.isSkipped()) {\n      this.resetSelectionNodes();\n    } else {\n      const diff2 = this.calculateUpdateDiff(previousTicks, tickData);\n      this.animationState.transition(\"update\", diff2);\n    }\n    this.updateAxisLine();\n    this.updateLabels();\n    this.updateVisibility();\n    this.updateGridLines(sideFlag);\n    this.updateTickLines();\n    this.updateTitle({ anyTickVisible: tickData.ticks.length > 0 });\n    this.updateCrossLines({ rotation, parallelFlipRotation, regularFlipRotation });\n    this.updateLayoutState(tickData.fractionDigits);\n    return primaryTickCount;\n  }\n  getAxisLineCoordinates() {\n    const [min, max] = findMinMax(this.range);\n    return { x: 0, y1: min, y2: max };\n  }\n  getTickLineCoordinates(datum) {\n    const sideFlag = this.label.getSideFlag();\n    const x = sideFlag * this.getTickSize();\n    const x1 = Math.min(0, x);\n    const x2 = x1 + Math.abs(x);\n    const y = datum.translationY;\n    return { x1, x2, y };\n  }\n  getTickLabelProps(datum, params) {\n    const { label } = this;\n    const { combinedRotation, textBaseline, textAlign, range: range3 } = params;\n    const text = datum.tickLabel;\n    const sideFlag = label.getSideFlag();\n    const labelX = sideFlag * (this.getTickSize() + label.padding + this.seriesAreaPadding);\n    const visible = text !== \"\" && text != null;\n    return {\n      tickId: datum.tickId,\n      translationY: datum.translationY,\n      fill: label.color,\n      fontFamily: label.fontFamily,\n      fontSize: label.fontSize,\n      fontStyle: label.fontStyle,\n      fontWeight: label.fontWeight,\n      rotation: combinedRotation,\n      rotationCenterX: labelX,\n      text,\n      textAlign,\n      textBaseline,\n      visible,\n      x: labelX,\n      y: 0,\n      range: range3\n    };\n  }\n  getTickSize() {\n    return this.tick.enabled ? this.tick.size : 6;\n  }\n  setTitleProps(caption, params) {\n    const { title } = this;\n    if (!title.enabled) {\n      caption.enabled = false;\n      caption.node.visible = false;\n      return;\n    }\n    caption.color = title.color;\n    caption.fontFamily = title.fontFamily;\n    caption.fontSize = title.fontSize;\n    caption.fontStyle = title.fontStyle;\n    caption.fontWeight = title.fontWeight;\n    caption.enabled = title.enabled;\n    caption.wrapping = title.wrapping;\n    const titleNode = caption.node;\n    const padding = (title.spacing ?? 0) + params.spacing;\n    const sideFlag = this.label.getSideFlag();\n    const parallelFlipRotation = normalizeAngle360(this.rotation);\n    const titleRotationFlag = sideFlag === -1 && parallelFlipRotation > Math.PI && parallelFlipRotation < Math.PI * 2 ? -1 : 1;\n    const rotation = titleRotationFlag * sideFlag * Math.PI / 2;\n    const textBaseline = titleRotationFlag === 1 ? \"bottom\" : \"top\";\n    const { range: range3 } = this;\n    const x = Math.floor(titleRotationFlag * sideFlag * (range3[0] + range3[1]) / 2);\n    const y = sideFlag === -1 ? Math.floor(titleRotationFlag * -padding) : Math.floor(-padding);\n    const { callbackCache } = this.moduleCtx;\n    const { formatter = (p) => p.defaultValue } = title;\n    const text = callbackCache.call(formatter, this.getTitleFormatterParams());\n    titleNode.setProperties({\n      rotation,\n      text,\n      textBaseline,\n      visible: true,\n      x,\n      y\n    });\n  }\n  calculateLayout(primaryTickCount) {\n    const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();\n    const sideFlag = this.label.getSideFlag();\n    const labelX = sideFlag * (this.getTickSize() + this.label.padding + this.seriesAreaPadding);\n    this.updateScale();\n    this.tickGenerationResult = this.generateTicks({\n      primaryTickCount,\n      parallelFlipRotation,\n      regularFlipRotation,\n      labelX,\n      sideFlag\n    });\n    const { tickData, combinedRotation, textBaseline, textAlign, ...ticksResult } = this.tickGenerationResult;\n    this.updateLayoutState(tickData.fractionDigits);\n    const boxes = [];\n    const { x, y1, y2 } = this.getAxisLineCoordinates();\n    const lineBox = new BBox(\n      x + Math.min(sideFlag * this.seriesAreaPadding, 0),\n      y1,\n      this.seriesAreaPadding,\n      y2 - y1\n    );\n    boxes.push(lineBox);\n    if (this.tick.enabled) {\n      tickData.ticks.forEach((datum) => {\n        const { x1, x2, y } = this.getTickLineCoordinates(datum);\n        const tickLineBox = new BBox(x1, y, x2 - x1, 0);\n        boxes.push(tickLineBox);\n      });\n    }\n    if (this.label.enabled) {\n      const tempText = new Text();\n      tickData.ticks.forEach((datum) => {\n        const labelProps = this.getTickLabelProps(datum, {\n          combinedRotation,\n          textAlign,\n          textBaseline,\n          range: this.scale.range\n        });\n        if (!labelProps.visible) {\n          return;\n        }\n        tempText.setProperties({\n          ...labelProps,\n          translationY: Math.round(datum.translationY)\n        });\n        const box = tempText.computeTransformedBBox();\n        if (box) {\n          boxes.push(box);\n        }\n      });\n    }\n    const getTransformBox = (bbox2) => {\n      const matrix = new Matrix();\n      const {\n        rotation: axisRotation,\n        translationX,\n        translationY,\n        rotationCenterX,\n        rotationCenterY\n      } = this.getAxisTransform();\n      Matrix.updateTransformMatrix(matrix, 1, 1, axisRotation, translationX, translationY, {\n        scalingCenterX: 0,\n        scalingCenterY: 0,\n        rotationCenterX,\n        rotationCenterY\n      });\n      return matrix.transformBBox(bbox2);\n    };\n    if (this.title?.enabled) {\n      const caption = new Caption();\n      const spacing = BBox.merge(boxes).width;\n      this.setTitleProps(caption, { spacing });\n      const titleNode = caption.node;\n      const titleBox = titleNode.computeTransformedBBox();\n      if (titleBox) {\n        boxes.push(titleBox);\n      }\n    }\n    const bbox = BBox.merge(boxes);\n    const transformedBBox = getTransformBox(bbox);\n    const anySeriesActive = this.isAnySeriesActive();\n    this.crossLines?.forEach((crossLine) => {\n      var _a;\n      crossLine.sideFlag = -sideFlag;\n      crossLine.direction = rotation === -Math.PI / 2 ? \"x\" /* X */ : \"y\" /* Y */;\n      if (crossLine instanceof CartesianCrossLine) {\n        (_a = crossLine.label).parallel ?? (_a.parallel = this.label.parallel);\n      }\n      crossLine.parallelFlipRotation = parallelFlipRotation;\n      crossLine.regularFlipRotation = regularFlipRotation;\n      crossLine.calculateLayout(anySeriesActive, this.reverse);\n    });\n    primaryTickCount = ticksResult.primaryTickCount;\n    return { primaryTickCount, bbox: transformedBBox };\n  }\n  updateLayoutState(fractionDigits) {\n    this.layout.label = {\n      fractionDigits,\n      padding: this.label.padding,\n      format: this.label.format\n    };\n  }\n  setDomain(domain) {\n    this.dataDomain = this.normaliseDataDomain(domain);\n    if (this.reverse) {\n      this.dataDomain.domain.reverse();\n    }\n    this.scale.domain = this.dataDomain.domain;\n  }\n  updateScale() {\n    this.updateRange();\n    this.calculateDomain();\n    this.setTickInterval(this.interval.step);\n    const { scale: scale2, nice } = this;\n    if (!ContinuousScale.is(scale2)) {\n      return;\n    }\n    scale2.nice = nice;\n    scale2.update();\n  }\n  calculateRotations() {\n    const rotation = toRadians(this.rotation);\n    const parallelFlipRotation = normalizeAngle360(rotation);\n    const regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);\n    return { rotation, parallelFlipRotation, regularFlipRotation };\n  }\n  generateTicks({\n    primaryTickCount,\n    parallelFlipRotation,\n    regularFlipRotation,\n    labelX,\n    sideFlag\n  }) {\n    const {\n      scale: scale2,\n      interval: { minSpacing, maxSpacing },\n      label: { parallel, rotation, fontFamily, fontSize, fontStyle, fontWeight }\n    } = this;\n    const secondaryAxis = primaryTickCount !== void 0;\n    const { defaultRotation, configuredRotation, parallelFlipFlag, regularFlipFlag } = calculateLabelRotation({\n      rotation,\n      parallel,\n      regularFlipRotation,\n      parallelFlipRotation\n    });\n    const initialRotation = configuredRotation + defaultRotation;\n    const labelMatrix = new Matrix();\n    const { maxTickCount } = this.estimateTickCount({ minSpacing, maxSpacing });\n    const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;\n    let textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);\n    const textBaseline = getTextBaseline(parallel, configuredRotation, sideFlag, parallelFlipFlag);\n    const font = getFont({ fontFamily, fontSize, fontStyle, fontWeight });\n    const textProps = {\n      fontFamily,\n      fontSize,\n      fontStyle,\n      fontWeight,\n      textBaseline,\n      textAlign\n    };\n    let tickData = {\n      rawTicks: [],\n      fractionDigits: 0,\n      ticks: [],\n      labelCount: 0\n    };\n    let index = 0;\n    let autoRotation = 0;\n    let labelOverlap = true;\n    let terminate = false;\n    while (labelOverlap && index <= maxIterations) {\n      if (terminate) {\n        break;\n      }\n      autoRotation = 0;\n      textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);\n      const tickStrategies = this.getTickStrategies({ secondaryAxis, index });\n      for (const strategy of tickStrategies) {\n        ({ tickData, index, autoRotation, terminate } = strategy({\n          index,\n          tickData,\n          textProps,\n          labelOverlap,\n          terminate,\n          primaryTickCount\n        }));\n        const rotated = configuredRotation !== 0 || autoRotation !== 0;\n        const labelRotation = initialRotation + autoRotation;\n        textAlign = getTextAlign(parallel, configuredRotation, autoRotation, sideFlag, regularFlipFlag);\n        labelOverlap = this.label.avoidCollisions ? this.checkLabelOverlap(labelRotation, rotated, labelMatrix, tickData.ticks, labelX, { font }) : false;\n      }\n    }\n    const combinedRotation = defaultRotation + configuredRotation + autoRotation;\n    if (!secondaryAxis && tickData.rawTicks.length > 0) {\n      primaryTickCount = tickData.rawTicks.length;\n    }\n    return { tickData, primaryTickCount, combinedRotation, textBaseline, textAlign };\n  }\n  getTickStrategies({\n    index: iteration,\n    secondaryAxis\n  }) {\n    const { scale: scale2, label } = this;\n    const { minSpacing } = this.interval;\n    const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const avoidLabelCollisions = label.enabled && label.avoidCollisions;\n    const filterTicks = !continuous && iteration !== 0 && avoidLabelCollisions;\n    const autoRotate = label.autoRotate === true && label.rotation === void 0;\n    const strategies = [];\n    let tickGenerationType;\n    if (this.interval.values) {\n      tickGenerationType = 3 /* VALUES */;\n    } else if (secondaryAxis) {\n      tickGenerationType = 1 /* CREATE_SECONDARY */;\n    } else if (filterTicks) {\n      tickGenerationType = 2 /* FILTER */;\n    } else {\n      tickGenerationType = 0 /* CREATE */;\n    }\n    const tickGenerationStrategy = ({ index, tickData, primaryTickCount, terminate }) => this.createTickData(tickGenerationType, index, tickData, terminate, primaryTickCount);\n    strategies.push(tickGenerationStrategy);\n    if (!continuous && !isNaN(minSpacing)) {\n      const tickFilterStrategy = ({ index, tickData, primaryTickCount, terminate }) => this.createTickData(2 /* FILTER */, index, tickData, terminate, primaryTickCount);\n      strategies.push(tickFilterStrategy);\n    }\n    if (!avoidLabelCollisions) {\n      return strategies;\n    }\n    if (label.autoWrap) {\n      const autoWrapStrategy = ({ index, tickData, textProps }) => this.wrapLabels(tickData, index, textProps);\n      strategies.push(autoWrapStrategy);\n    } else if (autoRotate) {\n      const autoRotateStrategy = ({ index, tickData, labelOverlap, terminate }) => ({\n        index,\n        tickData,\n        autoRotation: this.getAutoRotation(labelOverlap),\n        terminate\n      });\n      strategies.push(autoRotateStrategy);\n    }\n    return strategies;\n  }\n  createTickData(tickGenerationType, index, tickData, terminate, primaryTickCount) {\n    const { scale: scale2 } = this;\n    const { step, values, minSpacing, maxSpacing } = this.interval;\n    const { maxTickCount, minTickCount, defaultTickCount } = this.estimateTickCount({ minSpacing, maxSpacing });\n    const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;\n    let tickCount = continuous ? Math.max(defaultTickCount - index, minTickCount) : maxTickCount;\n    const regenerateTicks = step === void 0 && values === void 0 && tickCount > minTickCount && (continuous || tickGenerationType === 2 /* FILTER */);\n    let unchanged = true;\n    while (unchanged && index <= maxIterations) {\n      const prevTicks = tickData.rawTicks;\n      tickCount = continuous ? Math.max(defaultTickCount - index, minTickCount) : maxTickCount;\n      const { rawTicks, fractionDigits, ticks, labelCount } = this.getTicks({\n        tickGenerationType,\n        previousTicks: prevTicks,\n        tickCount,\n        minTickCount,\n        maxTickCount,\n        primaryTickCount\n      });\n      tickData.rawTicks = rawTicks;\n      tickData.fractionDigits = fractionDigits;\n      tickData.ticks = ticks;\n      tickData.labelCount = labelCount;\n      unchanged = regenerateTicks ? areArrayNumbersEqual(rawTicks, prevTicks) : false;\n      index++;\n    }\n    const shouldTerminate = step !== void 0 || values !== void 0;\n    terminate || (terminate = shouldTerminate);\n    return { tickData, index, autoRotation: 0, terminate };\n  }\n  checkLabelOverlap(rotation, rotated, labelMatrix, tickData, labelX, textProps) {\n    Matrix.updateTransformMatrix(labelMatrix, 1, 1, rotation, 0, 0);\n    const labelData = this.createLabelData(tickData, labelX, textProps, labelMatrix);\n    const labelSpacing = getLabelSpacing(this.label.minSpacing, rotated);\n    return axisLabelsOverlap(labelData, labelSpacing);\n  }\n  createLabelData(tickData, labelX, textProps, labelMatrix) {\n    const labelData = [];\n    for (const { tickLabel, translationY } of tickData) {\n      if (!tickLabel)\n        continue;\n      const { width, height } = TextMeasurer.measureLines(tickLabel, textProps);\n      const bbox = new BBox(labelX, translationY, width, height);\n      const labelDatum = calculateLabelBBox(tickLabel, bbox, labelX, translationY, labelMatrix);\n      labelData.push(labelDatum);\n    }\n    return labelData;\n  }\n  getAutoRotation(labelOverlap) {\n    return labelOverlap ? normalizeAngle360(toRadians(this.label.autoRotateAngle ?? 0)) : 0;\n  }\n  getTicks({\n    tickGenerationType,\n    previousTicks,\n    tickCount,\n    minTickCount,\n    maxTickCount,\n    primaryTickCount\n  }) {\n    const { range: range3, scale: scale2, visibleRange } = this;\n    let rawTicks;\n    switch (tickGenerationType) {\n      case 3 /* VALUES */:\n        rawTicks = this.interval.values;\n        if (ContinuousScale.is(scale2)) {\n          const [d0, d1] = findMinMax(scale2.getDomain().map(Number));\n          rawTicks = rawTicks.filter((value) => value >= d0 && value <= d1).sort((a, b) => a - b);\n        }\n        break;\n      case 1 /* CREATE_SECONDARY */:\n        if (ContinuousScale.is(scale2)) {\n          rawTicks = this.updateSecondaryAxisTicks(primaryTickCount);\n        } else {\n          rawTicks = this.createTicks(tickCount, minTickCount, maxTickCount);\n        }\n        break;\n      case 2 /* FILTER */:\n        rawTicks = this.filterTicks(previousTicks, tickCount);\n        break;\n      default:\n        rawTicks = this.createTicks(tickCount, minTickCount, maxTickCount);\n        break;\n    }\n    const fractionDigits = rawTicks.reduce((max, tick) => Math.max(max, countFractionDigits(tick)), 0);\n    const halfBandwidth = (scale2.bandwidth ?? 0) / 2;\n    const ticks = [];\n    let labelCount = 0;\n    const tickIdCounts = /* @__PURE__ */ new Map();\n    const start = Math.max(0, Math.floor(visibleRange[0] * rawTicks.length));\n    const end = Math.min(rawTicks.length, Math.ceil(visibleRange[1] * rawTicks.length));\n    const filteredTicks = rawTicks.slice(start, end);\n    this.onFormatChange(filteredTicks, fractionDigits, rawTicks, this.label.format);\n    for (let i = 0; i < filteredTicks.length; i++) {\n      const tick = filteredTicks[i];\n      const translationY = scale2.convert(tick) + halfBandwidth;\n      if (range3.length > 0 && !this.inRange(translationY, 1e-3))\n        continue;\n      const tickLabel = this.formatTick(tick, fractionDigits, start + i);\n      let tickId = tickLabel;\n      if (tickIdCounts.has(tickId)) {\n        const count = tickIdCounts.get(tickId);\n        tickIdCounts.set(tickId, count + 1);\n        tickId = `${tickId}_${count}`;\n      } else {\n        tickIdCounts.set(tickId, 1);\n      }\n      ticks.push({ tick, tickId, tickLabel, translationY: Math.floor(translationY) });\n      if (tickLabel === \"\" || tickLabel == null) {\n        continue;\n      }\n      labelCount++;\n    }\n    return { rawTicks, fractionDigits, ticks, labelCount };\n  }\n  filterTicks(ticks, tickCount) {\n    const { minSpacing, maxSpacing } = this.interval;\n    const tickSpacing = !isNaN(minSpacing) || !isNaN(maxSpacing);\n    const keepEvery = tickSpacing ? Math.ceil(ticks.length / tickCount) : 2;\n    return ticks.filter((_, i) => i % keepEvery === 0);\n  }\n  createTicks(tickCount, minTickCount, maxTickCount) {\n    const { scale: scale2 } = this;\n    if (tickCount && (ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2))) {\n      if (typeof tickCount === \"number\") {\n        scale2.tickCount = tickCount;\n        scale2.minTickCount = minTickCount ?? 0;\n        scale2.maxTickCount = maxTickCount ?? Infinity;\n      } else if (scale2 instanceof TimeScale) {\n        this.setTickInterval(tickCount);\n      }\n    }\n    return scale2.ticks?.() ?? [];\n  }\n  estimateTickCount({ minSpacing, maxSpacing }) {\n    const {\n      minRect,\n      label: { avoidCollisions }\n    } = this;\n    if (!avoidCollisions) {\n      return {\n        minTickCount: ContinuousScale.defaultMaxTickCount,\n        maxTickCount: ContinuousScale.defaultMaxTickCount,\n        defaultTickCount: ContinuousScale.defaultMaxTickCount\n      };\n    }\n    const rangeWithBleed = this.calculateRangeWithBleed();\n    const defaultMinSpacing = Math.max(\n      this.defaultTickMinSpacing,\n      rangeWithBleed / ContinuousScale.defaultMaxTickCount\n    );\n    let clampMaxTickCount = !isNaN(maxSpacing);\n    if (isNaN(minSpacing)) {\n      minSpacing = defaultMinSpacing;\n    }\n    if (isNaN(maxSpacing)) {\n      maxSpacing = rangeWithBleed;\n    }\n    if (minSpacing > maxSpacing) {\n      if (minSpacing === defaultMinSpacing) {\n        minSpacing = maxSpacing;\n      } else {\n        maxSpacing = minSpacing;\n      }\n    }\n    let minRectDistance = 1;\n    if (minRect) {\n      minRectDistance = this.direction === \"x\" /* X */ ? minRect.width : minRect.height;\n    }\n    clampMaxTickCount && (clampMaxTickCount = minRectDistance < defaultMinSpacing);\n    const maxTickCount = clamp(\n      1,\n      Math.floor(rangeWithBleed / minSpacing),\n      clampMaxTickCount ? Math.min(Math.floor(rangeWithBleed / minRectDistance), 100) : 100\n    );\n    const minTickCount = Math.min(maxTickCount, Math.ceil(rangeWithBleed / maxSpacing));\n    const defaultTickCount = clamp(minTickCount, ContinuousScale.defaultTickCount, maxTickCount);\n    return { minTickCount, maxTickCount, defaultTickCount };\n  }\n  updateVisibility() {\n    if (this.moduleCtx.animationManager.isSkipped()) {\n      this.resetSelectionNodes();\n    }\n    this.tickLineGroup.visible = this.tick.enabled;\n    this.gridLineGroup.visible = this.gridLine.enabled;\n    this.tickLabelGroup.visible = this.label.enabled;\n  }\n  updateCrossLines({\n    rotation,\n    parallelFlipRotation,\n    regularFlipRotation\n  }) {\n    const sideFlag = this.label.getSideFlag();\n    const anySeriesActive = this.isAnySeriesActive();\n    this.crossLines?.forEach((crossLine) => {\n      crossLine.sideFlag = -sideFlag;\n      crossLine.direction = rotation === -Math.PI / 2 ? \"x\" /* X */ : \"y\" /* Y */;\n      if (crossLine instanceof CartesianCrossLine) {\n        crossLine.label.parallel = crossLine.label.parallel ?? this.label.parallel;\n      }\n      crossLine.parallelFlipRotation = parallelFlipRotation;\n      crossLine.regularFlipRotation = regularFlipRotation;\n      crossLine.update(anySeriesActive);\n    });\n  }\n  updateTickLines() {\n    const { tick, label } = this;\n    const sideFlag = label.getSideFlag();\n    this.tickLineGroupSelection.each((line) => {\n      line.strokeWidth = tick.width;\n      line.stroke = tick.stroke;\n      line.x1 = sideFlag * this.getTickSize();\n      line.x2 = 0;\n    });\n  }\n  calculateAvailableRange() {\n    return findRangeExtent(this.range);\n  }\n  /**\n   * Calculates the available range with an additional \"bleed\" beyond the canvas that encompasses the full axis when\n   * the visible range is only a portion of the axis.\n   */\n  calculateRangeWithBleed() {\n    const visibleScale = 1 / findRangeExtent(this.visibleRange);\n    return round(this.calculateAvailableRange() * visibleScale, 2);\n  }\n  calculateDomain() {\n    const visibleSeries = this.boundSeries.filter((s) => this.includeInvisibleDomains || s.isEnabled());\n    const domains = visibleSeries.flatMap((series) => series.getDomain(this.direction));\n    this.setDomain(domains);\n  }\n  getAxisTransform() {\n    return {\n      rotation: toRadians(this.rotation),\n      rotationCenterX: 0,\n      rotationCenterY: 0,\n      translationX: Math.floor(this.translation.x),\n      translationY: Math.floor(this.translation.y)\n    };\n  }\n  updatePosition() {\n    const { crossLineGroup, axisGroup, gridGroup, translation, gridLineGroupSelection, gridPadding, gridLength } = this;\n    const { rotation } = this.calculateRotations();\n    const sideFlag = this.label.getSideFlag();\n    const translationX = Math.floor(translation.x);\n    const translationY = Math.floor(translation.y);\n    crossLineGroup.setProperties({ rotation, translationX, translationY });\n    gridGroup.setProperties({ rotation, translationX, translationY });\n    axisGroup.datum = this.getAxisTransform();\n    gridLineGroupSelection.each((line) => {\n      line.x1 = gridPadding;\n      line.x2 = -sideFlag * gridLength + gridPadding;\n    });\n  }\n  updateSecondaryAxisTicks(_primaryTickCount) {\n    throw new Error(\"AG Charts - unexpected call to updateSecondaryAxisTicks() - check axes configuration.\");\n  }\n  updateSelections(lineData, data, params) {\n    this.lineNode.datum = lineData;\n    this.gridLineGroupSelection.update(\n      this.gridLength ? data : [],\n      (group) => group.append(new Line()),\n      (datum) => datum.tickId\n    );\n    this.tickLineGroupSelection.update(\n      data,\n      (group) => group.appendChild(new Line()),\n      (datum) => datum.tickId\n    );\n    this.tickLabelGroupSelection.update(\n      data.map((d) => this.getTickLabelProps(d, params)),\n      (group) => group.appendChild(new Text()),\n      (datum) => datum.tickId\n    );\n  }\n  updateAxisLine() {\n    const { line } = this;\n    const strokeWidth = line.enabled ? line.width : 0;\n    this.lineNode.setProperties({\n      stroke: line.stroke,\n      strokeWidth\n    });\n  }\n  updateGridLines(sideFlag) {\n    const {\n      gridLine: { style, width },\n      gridPadding,\n      gridLength\n    } = this;\n    if (gridLength === 0 || style.length === 0) {\n      return;\n    }\n    this.gridLineGroupSelection.each((line, _, index) => {\n      const { stroke, lineDash } = style[index % style.length];\n      line.setProperties({\n        x1: gridPadding,\n        x2: -sideFlag * gridLength + gridPadding,\n        fill: void 0,\n        stroke,\n        strokeWidth: width,\n        lineDash\n      });\n    });\n  }\n  updateLabels() {\n    const { label } = this;\n    if (!label.enabled) {\n      return;\n    }\n    this.tickLabelGroupSelection.each((node, datum) => {\n      node.setProperties(datum, [\n        \"fill\",\n        \"fontFamily\",\n        \"fontSize\",\n        \"fontStyle\",\n        \"fontWeight\",\n        \"text\",\n        \"textAlign\",\n        \"textBaseline\"\n      ]);\n    });\n  }\n  wrapLabels(tickData, index, labelProps) {\n    const { parallel, maxWidth, maxHeight } = this.label;\n    let defaultMaxWidth = this.maxThickness;\n    let defaultMaxHeight = Math.round(this.calculateAvailableRange() / tickData.labelCount);\n    if (parallel) {\n      [defaultMaxWidth, defaultMaxHeight] = [defaultMaxHeight, defaultMaxWidth];\n    }\n    tickData.ticks.forEach((tickDatum) => {\n      tickDatum.tickLabel = Text.wrap(\n        tickDatum.tickLabel,\n        maxWidth ?? defaultMaxWidth,\n        maxHeight ?? defaultMaxHeight,\n        labelProps,\n        \"hyphenate\"\n      );\n    });\n    return { tickData, index, autoRotation: 0, terminate: true };\n  }\n  updateTitle(params) {\n    const { rotation, title, _titleCaption, lineNode, tickLineGroup, tickLabelGroup } = this;\n    let spacing = 0;\n    if (title.enabled && params.anyTickVisible) {\n      const tickBBox = Group.computeBBox([tickLineGroup, tickLabelGroup, lineNode]);\n      const tickWidth = rotation === 0 ? tickBBox.width : tickBBox.height;\n      spacing += tickWidth + (this.tickLabelGroup.visible ? 0 : this.seriesAreaPadding);\n    }\n    this.setTitleProps(_titleCaption, { spacing });\n  }\n  // For formatting (nice rounded) tick values.\n  formatTick(datum, fractionDigits, index) {\n    return String(this.getFormatter(index, true)(datum, fractionDigits));\n  }\n  // For formatting arbitrary values between the ticks.\n  formatDatum(datum) {\n    return String(this.getFormatter()(datum));\n  }\n  getFormatter(index = 0, isTickLabel) {\n    const {\n      label,\n      labelFormatter,\n      datumFormatter,\n      moduleCtx: { callbackCache }\n    } = this;\n    if (label.formatter) {\n      return (datum, fractionDigits) => callbackCache.call(label.formatter, { value: datum, index, fractionDigits }) ?? datum;\n    } else if (!isTickLabel && datumFormatter) {\n      return (datum) => callbackCache.call(datumFormatter, datum) ?? String(datum);\n    } else if (labelFormatter) {\n      return (datum) => callbackCache.call(labelFormatter, datum) ?? String(datum);\n    }\n    return (datum) => String(datum);\n  }\n  computeBBox() {\n    return this.axisGroup.computeBBox();\n  }\n  initCrossLine(crossLine) {\n    crossLine.scale = this.scale;\n    crossLine.gridLength = this.gridLength;\n  }\n  isAnySeriesActive() {\n    return this.boundSeries.some((s) => this.includeInvisibleDomains || s.isEnabled());\n  }\n  clipTickLines(x, y, width, height) {\n    this.tickLineGroup.setClipRectInGroupCoordinateSpace(new BBox(x, y, width, height));\n  }\n  clipGrid(x, y, width, height) {\n    this.gridGroup.setClipRectInGroupCoordinateSpace(new BBox(x, y, width, height));\n  }\n  calculatePadding(min, max) {\n    const padding = Math.abs(this.reverse ? max : min) * 0.01;\n    return [padding, padding];\n  }\n  getTitleFormatterParams() {\n    const boundSeries = this.boundSeries.reduce((acc, next) => {\n      const keys = next.getKeys(this.direction);\n      const names = next.getNames(this.direction);\n      for (let idx = 0; idx < keys.length; idx++) {\n        acc.push({ key: keys[idx], name: names[idx] });\n      }\n      return acc;\n    }, []);\n    return {\n      direction: this.direction,\n      boundSeries,\n      defaultValue: this.title?.text\n    };\n  }\n  normaliseDataDomain(d) {\n    return { domain: [...d], clipped: false };\n  }\n  getLayoutState() {\n    return {\n      rect: this.computeBBox(),\n      gridPadding: this.gridPadding,\n      seriesAreaPadding: this.seriesAreaPadding,\n      tickSize: this.getTickSize(),\n      direction: this.direction,\n      domain: this.dataDomain.domain,\n      scale: this.scale,\n      ...this.layout\n    };\n  }\n  getModuleMap() {\n    return this.moduleMap;\n  }\n  createModuleContext() {\n    this.axisContext ?? (this.axisContext = this.createAxisContext());\n    return { ...this.moduleCtx, parent: this.axisContext };\n  }\n  createAxisContext() {\n    const { scale: scale2 } = this;\n    return {\n      axisId: this.id,\n      direction: this.direction,\n      continuous: ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2),\n      keys: () => this.boundSeries.flatMap((s) => s.getKeys(this.direction)),\n      seriesKeyProperties: () => this.boundSeries.reduce((keys, series) => {\n        const seriesKeys = series.getKeyProperties(this.direction);\n        seriesKeys.forEach((key) => {\n          if (keys.indexOf(key) < 0) {\n            keys.push(key);\n          }\n        });\n        return keys;\n      }, []),\n      scaleValueFormatter: (specifier) => specifier ? scale2.tickFormat?.({ specifier }) : this.getFormatter(),\n      scaleBandwidth: () => scale2.bandwidth ?? 0,\n      scaleDomain: () => scale2.getDomain?.(),\n      scaleConvert: (val) => scale2.convert(val),\n      scaleInvert: OrdinalTimeScale.is(scale2) ? (val) => scale2.invertNearest?.(val) : (val) => scale2.invert?.(val),\n      scaleInvertNearest: (val) => scale2.invertNearest?.(val),\n      attachLabel: (node) => this.attachLabel(node),\n      inRange: (x, tolerance) => this.inRange(x, tolerance)\n    };\n  }\n  animateReadyUpdate(diff2) {\n    const { animationManager } = this.moduleCtx;\n    const selectionCtx = prepareAxisAnimationContext(this);\n    const fns = prepareAxisAnimationFunctions(selectionCtx);\n    fromToMotion(this.id, \"axis-group\", animationManager, [this.axisGroup], fns.group);\n    fromToMotion(this.id, \"line\", animationManager, [this.lineNode], fns.line);\n    fromToMotion(\n      this.id,\n      \"line-paths\",\n      animationManager,\n      [this.gridLineGroupSelection, this.tickLineGroupSelection],\n      fns.tick,\n      (_, d) => d.tickId,\n      diff2\n    );\n    fromToMotion(\n      this.id,\n      \"tick-labels\",\n      animationManager,\n      [this.tickLabelGroupSelection],\n      fns.label,\n      (_, d) => d.tickId,\n      diff2\n    );\n  }\n  resetSelectionNodes() {\n    const { gridLineGroupSelection, tickLineGroupSelection, tickLabelGroupSelection, lineNode } = this;\n    const selectionCtx = prepareAxisAnimationContext(this);\n    resetMotion([this.axisGroup], resetAxisGroupFn());\n    resetMotion([gridLineGroupSelection, tickLineGroupSelection], resetAxisSelectionFn(selectionCtx));\n    resetMotion([tickLabelGroupSelection], resetAxisLabelSelectionFn());\n    resetMotion([lineNode], resetAxisLineSelectionFn());\n  }\n  calculateUpdateDiff(previous, tickData) {\n    const added = /* @__PURE__ */ new Set();\n    const removed = /* @__PURE__ */ new Set();\n    const tickMap = {};\n    const tickCount = Math.max(previous.length, tickData.ticks.length);\n    for (let i = 0; i < tickCount; i++) {\n      const tickDatum = tickData.ticks[i];\n      const prev = previous[i];\n      const tick = tickDatum?.tickId;\n      tickMap[tick ?? prev] = tickDatum;\n      if (prev === tick) {\n        continue;\n      }\n      if (removed.has(tick)) {\n        removed.delete(tick);\n      } else if (tick) {\n        added.add(tick);\n      }\n      if (added.has(prev)) {\n        added.delete(prev);\n      } else if (prev) {\n        removed.add(prev);\n      }\n    }\n    return { changed: added.size > 0 || removed.size > 0, added, removed };\n  }\n  isReversed() {\n    return this.reverse;\n  }\n};\n_Axis.defaultTickMinSpacing = 50;\n__decorateClass([\n  Validate(BOOLEAN)\n], _Axis.prototype, \"nice\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], _Axis.prototype, \"reverse\", 2);\n__decorateClass([\n  Validate(STRING_ARRAY)\n], _Axis.prototype, \"keys\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Axis.prototype, \"interval\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], _Axis.prototype, \"disableZoom\", 2);\n__decorateClass([\n  Validate(OBJECT, { optional: true })\n], _Axis.prototype, \"title\", 2);\n__decorateClass([\n  ObserveChanges((target, value, oldValue) => target.onGridLengthChange(value, oldValue))\n], _Axis.prototype, \"gridLength\", 2);\nvar Axis = _Axis;\n\n// packages/ag-charts-community/src/chart/axis/cartesianAxisLabel.ts\nvar CartesianAxisLabel = class extends AxisLabel {\n  constructor() {\n    super(...arguments);\n    this.autoRotateAngle = 335;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianAxisLabel.prototype, \"autoRotate\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], CartesianAxisLabel.prototype, \"autoRotateAngle\", 2);\n\n// packages/ag-charts-community/src/chart/axis/cartesianAxis.ts\nvar _CartesianAxis = class _CartesianAxis extends Axis {\n  constructor() {\n    super(...arguments);\n    this.thickness = 0;\n  }\n  static is(value) {\n    return value instanceof _CartesianAxis;\n  }\n  get direction() {\n    return [\"top\", \"bottom\"].includes(this.position) ? \"x\" /* X */ : \"y\" /* Y */;\n  }\n  updateDirection() {\n    switch (this.position) {\n      case \"top\":\n        this.rotation = -90;\n        this.label.mirrored = true;\n        this.label.parallel = true;\n        break;\n      case \"right\":\n        this.rotation = 0;\n        this.label.mirrored = true;\n        this.label.parallel = false;\n        break;\n      case \"bottom\":\n        this.rotation = -90;\n        this.label.mirrored = false;\n        this.label.parallel = true;\n        break;\n      case \"left\":\n        this.rotation = 0;\n        this.label.mirrored = false;\n        this.label.parallel = false;\n        break;\n    }\n    if (this.axisContext) {\n      this.axisContext.position = this.position;\n      this.axisContext.direction = this.direction;\n    }\n  }\n  update(primaryTickCount, animated) {\n    this.updateDirection();\n    return super.update(primaryTickCount, animated);\n  }\n  calculateLayout(primaryTickCount) {\n    this.updateDirection();\n    return super.calculateLayout(primaryTickCount);\n  }\n  createAxisContext() {\n    return {\n      ...super.createAxisContext(),\n      position: this.position\n    };\n  }\n  assignCrossLineArrayConstructor(crossLines) {\n    assignJsonApplyConstructedArray(crossLines, CartesianCrossLine);\n  }\n  createLabel() {\n    return new CartesianAxisLabel();\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], _CartesianAxis.prototype, \"thickness\", 2);\n__decorateClass([\n  Validate(POSITION)\n], _CartesianAxis.prototype, \"position\", 2);\nvar CartesianAxis = _CartesianAxis;\n\n// packages/ag-charts-community/src/chart/axis/categoryAxis.ts\nvar CategoryAxis = class extends CartesianAxis {\n  constructor(moduleCtx, scale2 = new BandScale()) {\n    super(moduleCtx, scale2);\n    this._paddingOverrideEnabled = false;\n    this.groupPaddingInner = 0.1;\n    this.includeInvisibleDomains = true;\n  }\n  set paddingInner(value) {\n    this._paddingOverrideEnabled = true;\n    this.scale.paddingInner = value;\n  }\n  get paddingInner() {\n    this._paddingOverrideEnabled = true;\n    return this.scale.paddingInner;\n  }\n  set paddingOuter(value) {\n    this.scale.paddingOuter = value;\n  }\n  get paddingOuter() {\n    return this.scale.paddingOuter;\n  }\n  normaliseDataDomain(d) {\n    const domain = [];\n    const uniqueValues = /* @__PURE__ */ new Set();\n    for (const v of d) {\n      const key = v instanceof Date ? v.getTime() : v;\n      if (!uniqueValues.has(key)) {\n        uniqueValues.add(key);\n        domain.push(v);\n      }\n    }\n    return { domain, clipped: false };\n  }\n  calculateDomain() {\n    if (!this._paddingOverrideEnabled) {\n      let paddingInner = Infinity;\n      let paddingOuter = -Infinity;\n      for (const s of this.boundSeries) {\n        const padding = s.getBandScalePadding?.();\n        if (padding == null)\n          continue;\n        paddingInner = Math.min(paddingInner, padding.inner);\n        paddingOuter = Math.max(paddingOuter, padding.outer);\n      }\n      this.scale.paddingInner = Number.isFinite(paddingInner) ? paddingInner : 0;\n      this.scale.paddingOuter = Number.isFinite(paddingOuter) ? paddingOuter : 0;\n    }\n    return super.calculateDomain();\n  }\n};\nCategoryAxis.className = \"CategoryAxis\";\nCategoryAxis.type = \"category\";\n__decorateClass([\n  Validate(RATIO)\n], CategoryAxis.prototype, \"groupPaddingInner\", 2);\n\n// packages/ag-charts-community/src/chart/axis/tree.ts\nvar TreeNode = class {\n  // current number in sibling group (index)\n  constructor(label = \"\", parent, number = 0) {\n    this.x = 0;\n    this.y = 0;\n    this.subtreeLeft = NaN;\n    this.subtreeRight = NaN;\n    this.screenX = 0;\n    this.screenY = 0;\n    this.children = [];\n    this.leafCount = 0;\n    this.prelim = 0;\n    this.mod = 0;\n    this.ancestor = this;\n    this.change = 0;\n    this.shift = 0;\n    this.label = label;\n    this.parent = parent;\n    this.depth = parent ? parent.depth + 1 : 0;\n    this.number = number;\n  }\n  getLeftSibling() {\n    return this.number > 0 && this.parent ? this.parent.children[this.number - 1] : void 0;\n  }\n  getLeftmostSibling() {\n    return this.number > 0 && this.parent ? this.parent.children[0] : void 0;\n  }\n  // traverse the left contour of a subtree, return the successor of v on this contour\n  nextLeft() {\n    return this.children ? this.children[0] : this.thread;\n  }\n  // traverse the right contour of a subtree, return the successor of v on this contour\n  nextRight() {\n    return this.children ? this.children[this.children.length - 1] : this.thread;\n  }\n  getSiblings() {\n    return this.parent ? this.parent.children.filter((_, i) => i !== this.number) : [];\n  }\n};\nfunction ticksToTree(ticks, pad2 = true) {\n  const root = new TreeNode();\n  let depth = 0;\n  if (pad2) {\n    ticks.forEach((tick) => depth = Math.max(depth, tick.labels.length));\n  }\n  ticks.forEach((tick) => {\n    if (pad2) {\n      while (tick.labels.length < depth) {\n        tick.labels.unshift(\"\");\n      }\n    }\n    insertTick(root, tick);\n  });\n  return root;\n}\nfunction insertTick(root, tick) {\n  const pathParts = tick.labels.slice().reverse();\n  const lastPartIndex = pathParts.length - 1;\n  pathParts.forEach((pathPart, partIndex) => {\n    const children = root.children;\n    const existingNode = children.find((child) => child.label === pathPart);\n    const isNotLeaf = partIndex !== lastPartIndex;\n    if (existingNode && isNotLeaf) {\n      root = existingNode;\n    } else {\n      const node = new TreeNode(pathPart, root);\n      node.number = children.length;\n      children.push(node);\n      if (isNotLeaf) {\n        root = node;\n      }\n    }\n  });\n}\nfunction moveSubtree(wm, wp, shift) {\n  const subtrees = wp.number - wm.number;\n  const ratio = shift / subtrees;\n  wp.change -= ratio;\n  wp.shift += shift;\n  wm.change += ratio;\n  wp.prelim += shift;\n  wp.mod += shift;\n}\nfunction ancestor(vim, v, defaultAncestor) {\n  return v.getSiblings().indexOf(vim.ancestor) >= 0 ? vim.ancestor : defaultAncestor;\n}\nfunction executeShifts(v) {\n  const children = v.children;\n  if (children) {\n    let shift = 0;\n    let change = 0;\n    for (let i = children.length - 1; i >= 0; i--) {\n      const w = children[i];\n      w.prelim += shift;\n      w.mod += shift;\n      change += w.change;\n      shift += w.shift + change;\n    }\n  }\n}\nfunction apportion(v, defaultAncestor, distance3) {\n  const w = v.getLeftSibling();\n  if (w) {\n    let vop = v;\n    let vip = v;\n    let vim = w;\n    let vom = vip.getLeftmostSibling();\n    let sip = vip.mod;\n    let sop = vop.mod;\n    let sim = vim.mod;\n    let som = vom.mod;\n    while (vim.nextRight() && vip.nextLeft()) {\n      vim = vim.nextRight();\n      vip = vip.nextLeft();\n      vom = vom.nextLeft();\n      vop = vop.nextRight();\n      vop.ancestor = v;\n      const shift = vim.prelim + sim - (vip.prelim + sip) + distance3;\n      if (shift > 0) {\n        moveSubtree(ancestor(vim, v, defaultAncestor), v, shift);\n        sip += shift;\n        sop += shift;\n      }\n      sim += vim.mod;\n      sip += vip.mod;\n      som += vom.mod;\n      sop += vop.mod;\n    }\n    if (vim.nextRight() && !vop.nextRight()) {\n      vop.thread = vim.nextRight();\n      vop.mod += sim - sop;\n    } else {\n      if (vip.nextLeft() && !vom.nextLeft()) {\n        vom.thread = vip.nextLeft();\n        vom.mod += sip - som;\n      }\n      defaultAncestor = v;\n    }\n  }\n  return defaultAncestor;\n}\nfunction firstWalk(node, distance3) {\n  const children = node.children;\n  if (children.length) {\n    let defaultAncestor = children[0];\n    children.forEach((child) => {\n      firstWalk(child, distance3);\n      defaultAncestor = apportion(child, defaultAncestor, distance3);\n    });\n    executeShifts(node);\n    const midpoint = (children[0].prelim + children.at(-1).prelim) / 2;\n    const leftSibling = node.getLeftSibling();\n    if (leftSibling) {\n      node.prelim = leftSibling.prelim + distance3;\n      node.mod = node.prelim - midpoint;\n    } else {\n      node.prelim = midpoint;\n    }\n  } else {\n    const leftSibling = node.getLeftSibling();\n    node.prelim = leftSibling ? leftSibling.prelim + distance3 : 0;\n  }\n}\nvar Dimensions = class {\n  constructor() {\n    this.top = Infinity;\n    this.right = -Infinity;\n    this.bottom = -Infinity;\n    this.left = Infinity;\n  }\n  update(node, xy) {\n    const { x, y } = xy(node);\n    if (x > this.right) {\n      this.right = x;\n    }\n    if (x < this.left) {\n      this.left = x;\n    }\n    if (y > this.bottom) {\n      this.bottom = y;\n    }\n    if (y < this.top) {\n      this.top = y;\n    }\n  }\n};\nfunction secondWalk(v, m, layout) {\n  v.x = v.prelim + m;\n  v.y = v.depth;\n  layout.update(v);\n  v.children.forEach((w) => secondWalk(w, m + v.mod, layout));\n}\nfunction thirdWalk(v) {\n  const children = v.children;\n  let leafCount = 0;\n  children.forEach((w) => {\n    thirdWalk(w);\n    if (w.children.length) {\n      leafCount += w.leafCount;\n    } else {\n      leafCount++;\n    }\n  });\n  v.leafCount = leafCount;\n  if (children.length) {\n    v.subtreeLeft = children[0].subtreeLeft;\n    v.subtreeRight = children[v.children.length - 1].subtreeRight;\n    v.x = (v.subtreeLeft + v.subtreeRight) / 2;\n  } else {\n    v.subtreeLeft = v.x;\n    v.subtreeRight = v.x;\n  }\n}\nfunction treeLayout(root) {\n  const layout = new TreeLayout();\n  firstWalk(root, 1);\n  secondWalk(root, -root.prelim, layout);\n  thirdWalk(root);\n  return layout;\n}\nvar TreeLayout = class {\n  constructor() {\n    this.dimensions = new Dimensions();\n    this.leafCount = 0;\n    this.nodes = [];\n    // One might want to process leaf nodes separately from the rest of the tree.\n    // For example, position labels corresponding to leafs vertically, rather than horizontally.\n    this.leafNodes = [];\n    this.nonLeafNodes = [];\n    this.depth = 0;\n  }\n  update(node) {\n    this.dimensions.update(node, (n) => ({ x: n.x, y: n.y }));\n    if (node.children.length) {\n      this.nonLeafNodes.push(node);\n    } else {\n      this.leafCount++;\n      this.leafNodes.push(node);\n    }\n    if (node.depth > this.depth) {\n      this.depth = node.depth;\n    }\n    this.nodes.push(node);\n  }\n  resize(width, height, shiftX = 0, shiftY = 0, flipX = false) {\n    const xSteps = this.leafCount - 1;\n    const ySteps = this.depth;\n    const dimensions = this.dimensions;\n    let scalingX = 1;\n    let scalingY = 1;\n    if (width > 0 && xSteps) {\n      const existingSpacingX = (dimensions.right - dimensions.left) / xSteps;\n      const desiredSpacingX = width / xSteps;\n      scalingX = desiredSpacingX / existingSpacingX;\n      if (flipX) {\n        scalingX = -scalingX;\n      }\n    }\n    if (height > 0 && ySteps) {\n      const existingSpacingY = (dimensions.bottom - dimensions.top) / ySteps;\n      const desiredSpacingY = height / ySteps;\n      scalingY = desiredSpacingY / existingSpacingY;\n    }\n    const screenDimensions = new Dimensions();\n    this.nodes.forEach((node) => {\n      node.screenX = node.x * scalingX;\n      node.screenY = node.y * scalingY;\n      screenDimensions.update(node, (n) => ({ x: n.screenX, y: n.screenY }));\n    });\n    const offsetX = -screenDimensions.left;\n    const offsetY = -screenDimensions.top;\n    this.nodes.forEach((node) => {\n      node.screenX += offsetX + shiftX;\n      node.screenY += offsetY + shiftY;\n    });\n  }\n};\n\n// packages/ag-charts-community/src/chart/axis/groupedCategoryAxis.ts\nvar GroupedCategoryAxisLabel = class extends AxisLabel {\n  constructor() {\n    super(...arguments);\n    this.grid = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], GroupedCategoryAxisLabel.prototype, \"grid\", 2);\nvar GroupedCategoryAxis = class extends CartesianAxis {\n  constructor(moduleCtx) {\n    const scale2 = new BandScale();\n    scale2.paddingOuter = 0.1;\n    scale2.paddingInner = scale2.paddingOuter * 2;\n    super(moduleCtx, scale2);\n    // Label scale (labels are positioned between ticks, tick count = label count + 1).\n    // We don't call is `labelScale` for consistency with other axes.\n    this.tickScale = new BandScale();\n    this.line = new AxisLine();\n    this.label = new GroupedCategoryAxisLabel();\n    this.labelColor = \"rgba(87, 87, 87, 1)\";\n    this.includeInvisibleDomains = true;\n    const { tickLineGroup, tickLabelGroup, gridLineGroup, tickScale } = this;\n    tickScale.paddingInner = 1;\n    tickScale.paddingOuter = 0;\n    this.gridLineSelection = Selection.select(gridLineGroup, Line);\n    this.axisLineSelection = Selection.select(tickLineGroup, Line);\n    this.separatorSelection = Selection.select(tickLineGroup, Line);\n    this.labelSelection = Selection.select(tickLabelGroup, Text);\n  }\n  updateRange() {\n    const { range: rr, visibleRange: vr, scale: scale2 } = this;\n    const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n    const shift = span * vr[0];\n    const start = rr[0] - shift;\n    this.tickScale.range = scale2.range = [start, start + span];\n    this.resizeTickTree();\n  }\n  resizeTickTree() {\n    const s = this.scale;\n    const range3 = s.domain.length ? [s.convert(s.domain[0]), s.convert(s.domain[s.domain.length - 1])] : s.range;\n    const layout = this.tickTreeLayout;\n    const lineHeight = this.lineHeight;\n    if (layout) {\n      layout.resize(\n        Math.abs(range3[1] - range3[0]),\n        layout.depth * lineHeight,\n        (Math.min(range3[0], range3[1]) || 0) + (s.bandwidth ?? 0) / 2,\n        -layout.depth * lineHeight,\n        range3[1] - range3[0] < 0\n      );\n    }\n  }\n  get lineHeight() {\n    return this.label.fontSize * 1.5;\n  }\n  /**\n   * The length of the grid. The grid is only visible in case of a non-zero value.\n   */\n  onGridVisibilityChange() {\n    this.gridLineSelection.clear();\n    this.labelSelection.clear();\n  }\n  calculateDomain() {\n    const { direction } = this;\n    let isNumericX = null;\n    const flatDomains = this.boundSeries.filter((s) => s.visible).flatMap((series) => {\n      if (direction === \"y\" /* Y */ || isNumericX) {\n        return series.getDomain(direction);\n      }\n      if (isNumericX === null) {\n        const domain2 = series.getDomain(direction);\n        isNumericX = isNumber(domain2[0]);\n        return domain2;\n      }\n      return [];\n    });\n    this.setDomain(extent(flatDomains) ?? unique(flatDomains));\n    const { domain } = this.dataDomain;\n    this.tickTreeLayout = treeLayout(ticksToTree(domain));\n    this.tickScale.domain = domain.concat(\"\");\n    this.resizeTickTree();\n  }\n  /**\n   * Creates/removes/updates the scene graph nodes that constitute the axis.\n   * Supposed to be called _manually_ after changing _any_ of the axis properties.\n   * This allows to bulk set axis properties before updating the nodes.\n   * The node changes made by this method are rendered on the next animation frame.\n   * We could schedule this method call automatically on the next animation frame\n   * when any of the axis properties change (the way we do when properties of scene graph's\n   * nodes change), but this will mean that we first wait for the next animation\n   * frame to make changes to the nodes of the axis, then wait for another animation\n   * frame to render those changes. It's nice to have everything update automatically,\n   * but this extra level of async indirection will not just introduce an unwanted delay,\n   * it will also make it harder to reason about the program.\n   */\n  update() {\n    if (!this.computedLayout) {\n      return;\n    }\n    this.updatePosition();\n    this.updateTitleCaption();\n    this.updateCategoryLabels();\n    this.updateSeparators();\n    this.updateAxisLines();\n    this.updateCategoryGridLines();\n    this.resetSelectionNodes();\n  }\n  updateTitleCaption() {\n    const { _titleCaption } = this;\n    _titleCaption.node.visible = false;\n  }\n  updateCategoryLabels() {\n    if (!this.computedLayout)\n      return;\n    const { tickLabelLayout } = this.computedLayout;\n    const labelSelection = this.labelSelection.update(tickLabelLayout);\n    labelSelection.each((node, datum) => {\n      node.setProperties(datum);\n    });\n  }\n  updateSeparators() {\n    if (!this.computedLayout)\n      return;\n    const { separatorLayout } = this.computedLayout;\n    const { range: range3 } = this;\n    const epsilon2 = 1e-7;\n    const separatorSelection = this.separatorSelection.update(separatorLayout);\n    separatorSelection.each((line, datum) => {\n      line.x1 = datum.x1;\n      line.x2 = datum.x2;\n      line.y1 = datum.y;\n      line.y2 = datum.y;\n      line.visible = datum.y >= range3[0] - epsilon2 && datum.y <= range3[1] + epsilon2;\n      line.stroke = this.tick.stroke;\n      line.fill = void 0;\n      line.strokeWidth = 1;\n    });\n  }\n  updateAxisLines() {\n    if (!this.computedLayout)\n      return;\n    const { axisLineLayout } = this.computedLayout;\n    const axisLineSelection = this.axisLineSelection.update(axisLineLayout);\n    axisLineSelection.each((line, datum) => {\n      line.setProperties({\n        ...datum,\n        stroke: this.line.stroke,\n        strokeWidth: this.line.width\n      });\n      line.x1 = datum.x;\n      line.x2 = datum.x;\n      line.y1 = datum.y1;\n      line.y2 = datum.y2;\n      line.strokeWidth = this.line.width;\n      line.stroke = this.line.stroke;\n    });\n  }\n  updateCategoryGridLines() {\n    const { gridLength, gridLine, label, range: range3, tickScale } = this;\n    const ticks = tickScale.ticks();\n    const sideFlag = label.getSideFlag();\n    const gridSelection = this.gridLineSelection.update(gridLength ? ticks : []);\n    if (gridLength) {\n      const { width, style } = gridLine;\n      const styleCount = style.length;\n      gridSelection.each((line, datum, index) => {\n        const y = Math.round(tickScale.convert(datum));\n        line.x1 = 0;\n        line.x2 = -sideFlag * gridLength;\n        line.y1 = y;\n        line.y2 = y;\n        line.visible = y >= range3[0] && y <= range3[1];\n        const { stroke, lineDash } = style[index % styleCount];\n        line.stroke = stroke;\n        line.strokeWidth = width;\n        line.lineDash = lineDash;\n        line.fill = void 0;\n      });\n    }\n  }\n  computeLayout() {\n    this.updateDirection();\n    this.calculateDomain();\n    this.updateRange();\n    const {\n      scale: scale2,\n      label,\n      label: { parallel },\n      moduleCtx: { callbackCache },\n      range: range3,\n      title,\n      title: { formatter = (p) => p.defaultValue } = {}\n    } = this;\n    const rangeStart = scale2.range[0];\n    const rangeEnd = scale2.range[1];\n    const rangeLength = Math.abs(rangeEnd - rangeStart);\n    const bandwidth = rangeLength / scale2.domain.length || 0;\n    const keepEvery = Math.ceil(label.fontSize / bandwidth);\n    const rotation = toRadians(this.rotation);\n    const isHorizontal = Math.abs(Math.cos(rotation)) < 1e-8;\n    const sideFlag = label.getSideFlag();\n    const lineHeight = this.lineHeight;\n    const tickTreeLayout = this.tickTreeLayout;\n    const labels = scale2.ticks();\n    const treeLabels = tickTreeLayout ? tickTreeLayout.nodes : [];\n    const isLabelTree = tickTreeLayout ? tickTreeLayout.depth > 1 : false;\n    const { defaultRotation, configuredRotation, parallelFlipFlag } = calculateLabelRotation({\n      rotation: label.rotation,\n      parallel,\n      regularFlipRotation: normalizeAngle360(rotation - Math.PI / 2),\n      parallelFlipRotation: normalizeAngle360(rotation)\n    });\n    const tickLabelLayout = [];\n    const copyLabelProps = (node) => {\n      return {\n        fill: node.fill,\n        fontFamily: node.fontFamily,\n        fontSize: node.fontSize,\n        fontStyle: node.fontStyle,\n        fontWeight: node.fontWeight,\n        rotation: node.rotation,\n        rotationCenterX: node.rotationCenterX,\n        rotationCenterY: node.rotationCenterY,\n        text: node.text,\n        textAlign: node.textAlign,\n        textBaseline: node.textBaseline,\n        translationX: node.translationX,\n        translationY: node.translationY,\n        visible: node.visible,\n        x: node.x,\n        y: node.y\n      };\n    };\n    const labelBBoxes = /* @__PURE__ */ new Map();\n    let maxLeafLabelWidth = 0;\n    const tempText = new Text();\n    const setLabelProps = (datum, index) => {\n      tempText.setProperties({\n        fill: label.color,\n        fontFamily: label.fontFamily,\n        fontSize: label.fontSize,\n        fontStyle: label.fontStyle,\n        fontWeight: label.fontWeight,\n        textAlign: \"center\",\n        textBaseline: parallelFlipFlag === -1 ? \"bottom\" : \"hanging\",\n        translationX: datum.screenY - label.fontSize * 0.25,\n        translationY: datum.screenX\n      });\n      if (index === 0) {\n        const isCaptionEnabled = title?.enabled && labels.length > 0;\n        if (!isCaptionEnabled) {\n          return false;\n        }\n        const text = callbackCache.call(formatter, this.getTitleFormatterParams());\n        tempText.setProperties({\n          fill: title.color,\n          fontFamily: title.fontFamily,\n          fontSize: title.fontSize,\n          fontStyle: title.fontStyle,\n          fontWeight: title.fontWeight,\n          text,\n          textBaseline: \"hanging\",\n          translationX: datum.screenY - label.fontSize * 0.25,\n          translationY: datum.screenX\n        });\n      } else if (index % keepEvery === 0) {\n        const isInRange = datum.screenX >= range3[0] && datum.screenX <= range3[1];\n        if (!isInRange) {\n          return false;\n        }\n        if (label.formatter) {\n          tempText.text = callbackCache.call(label.formatter, {\n            value: String(datum.label),\n            index\n          }) ?? String(datum.label);\n        } else {\n          tempText.text = String(datum.label);\n        }\n      } else {\n        return false;\n      }\n      return true;\n    };\n    treeLabels.forEach((datum, index) => {\n      const isVisible = setLabelProps(datum, index);\n      if (!isVisible)\n        return;\n      const bbox2 = tempText.computeTransformedBBox();\n      if (!bbox2)\n        return;\n      labelBBoxes.set(index, bbox2);\n      const isLeaf = !datum.children.length;\n      if (isLeaf && bbox2.width > maxLeafLabelWidth) {\n        maxLeafLabelWidth = bbox2.width;\n      }\n    });\n    const labelX = sideFlag * label.padding;\n    const labelGrid = this.label.grid;\n    const separatorData = [];\n    treeLabels.forEach((datum, index) => {\n      let visible = setLabelProps(datum, index);\n      const id = index;\n      tempText.x = labelX;\n      tempText.rotationCenterX = labelX;\n      const isLeaf = !datum.children.length;\n      if (isLeaf) {\n        tempText.rotation = configuredRotation;\n        tempText.textAlign = \"end\";\n        tempText.textBaseline = \"middle\";\n      } else {\n        tempText.translationX -= maxLeafLabelWidth - lineHeight + this.label.padding;\n        const availableRange = datum.leafCount * bandwidth;\n        const bbox2 = labelBBoxes.get(id);\n        if (bbox2 && bbox2.width > availableRange) {\n          visible = false;\n          labelBBoxes.delete(id);\n        } else if (isHorizontal) {\n          tempText.rotation = defaultRotation;\n        } else {\n          tempText.rotation = -Math.PI / 2;\n        }\n      }\n      if (datum.parent && isLabelTree) {\n        const y = isLeaf ? datum.screenX - bandwidth / 2 : datum.screenX - datum.leafCount * bandwidth / 2;\n        if (isLeaf) {\n          if (datum.number !== datum.children.length - 1 || labelGrid) {\n            separatorData.push({\n              y,\n              x1: 0,\n              x2: -maxLeafLabelWidth - this.label.padding * 2\n            });\n          }\n        } else {\n          const x = -maxLeafLabelWidth - this.label.padding * 2 + datum.screenY;\n          separatorData.push({\n            y,\n            x1: x + lineHeight,\n            x2: x\n          });\n        }\n      }\n      let props;\n      if (visible) {\n        const bbox2 = tempText.computeTransformedBBox();\n        if (bbox2) {\n          labelBBoxes.set(index, bbox2);\n        }\n        props = { ...copyLabelProps(tempText), visible };\n      } else {\n        labelBBoxes.delete(index);\n        props = { visible };\n      }\n      tickLabelLayout.push(props);\n    });\n    let minX = 0;\n    separatorData.forEach((d) => minX = Math.min(minX, d.x2));\n    separatorData.push({\n      y: Math.max(rangeStart, rangeEnd),\n      x1: 0,\n      x2: minX\n    });\n    const separatorLayout = [];\n    const separatorBoxes = [];\n    const epsilon2 = 1e-7;\n    separatorData.forEach((datum) => {\n      if (datum.y >= range3[0] - epsilon2 && datum.y <= range3[1] + epsilon2) {\n        const { x1, x2, y } = datum;\n        const separatorBox = new BBox(Math.min(x1, x2), y, Math.abs(x1 - x2), 0);\n        separatorBoxes.push(separatorBox);\n        separatorLayout.push({ x1, x2, y });\n      }\n    });\n    const axisLineLayout = [];\n    const axisLineBoxes = [];\n    const lineCount = tickTreeLayout ? tickTreeLayout.depth + 1 : 1;\n    for (let i = 0; i < lineCount; i++) {\n      const visible = labels.length > 0 && (i === 0 || labelGrid && isLabelTree);\n      const x = i > 0 ? -maxLeafLabelWidth - this.label.padding * 2 - (i - 1) * lineHeight : 0;\n      const lineBox = new BBox(x, Math.min(...range3), 0, Math.abs(range3[1] - range3[0]));\n      axisLineBoxes.push(lineBox);\n      axisLineLayout.push({ x, y1: range3[0], y2: range3[1], visible });\n    }\n    const getTransformBox = (bbox2) => {\n      const matrix = new Matrix();\n      const {\n        rotation: axisRotation,\n        translationX,\n        translationY,\n        rotationCenterX,\n        rotationCenterY\n      } = this.getAxisTransform();\n      Matrix.updateTransformMatrix(matrix, 1, 1, axisRotation, translationX, translationY, {\n        scalingCenterX: 0,\n        scalingCenterY: 0,\n        rotationCenterX,\n        rotationCenterY\n      });\n      return matrix.transformBBox(bbox2);\n    };\n    const bbox = BBox.merge([...labelBBoxes.values(), ...separatorBoxes, ...axisLineBoxes]);\n    const transformedBBox = getTransformBox(bbox);\n    return {\n      bbox: transformedBBox,\n      tickLabelLayout,\n      separatorLayout,\n      axisLineLayout\n    };\n  }\n  calculateLayout() {\n    const { axisLineLayout, separatorLayout, tickLabelLayout, bbox } = this.computeLayout();\n    this.computedLayout = {\n      axisLineLayout,\n      separatorLayout,\n      tickLabelLayout\n    };\n    return { bbox, primaryTickCount: void 0 };\n  }\n};\nGroupedCategoryAxis.className = \"GroupedCategoryAxis\";\nGroupedCategoryAxis.type = \"grouped-category\";\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], GroupedCategoryAxis.prototype, \"labelColor\", 2);\n\n// packages/ag-charts-community/src/module/module.ts\nvar BaseModuleInstance = class {\n  constructor() {\n    this.destroyFns = [];\n  }\n  destroy() {\n    for (const destroyFn of this.destroyFns) {\n      destroyFn();\n    }\n  }\n};\nvar ModuleRegistry = class {\n  constructor() {\n    this.modules = [];\n    this.dependencies = /* @__PURE__ */ new Map();\n    this.dependents = /* @__PURE__ */ new Map();\n  }\n  register(...modules) {\n    for (const module of modules) {\n      this.registerDependencies(module);\n      const otherModule = this.modules.find(\n        (other) => module.type === other.type && module.optionsKey === other.optionsKey && module.identifier === other.identifier\n      );\n      if (otherModule) {\n        if (module.packageType === \"enterprise\" && otherModule.packageType === \"community\") {\n          const index = this.modules.indexOf(otherModule);\n          this.modules.splice(index, 1, module);\n        }\n      } else {\n        this.modules.push(module);\n      }\n    }\n  }\n  hasEnterpriseModules() {\n    return this.modules.some((m) => m.packageType === \"enterprise\");\n  }\n  *byType(...types) {\n    const { dependents } = this;\n    const yielded = /* @__PURE__ */ new Set();\n    let count = 0;\n    const maxCount = 3;\n    const modulesByType = this.modules.filter((module) => types.includes(module.type));\n    do {\n      for (const module of modulesByType) {\n        if (yielded.has(module.optionsKey) || dependents.has(module.optionsKey)) {\n          continue;\n        }\n        yield module;\n        yielded.add(module.optionsKey);\n        for (const [key, dependencies] of dependents.entries()) {\n          dependencies.delete(module.optionsKey);\n          if (dependencies.size === 0) {\n            dependents.delete(key);\n          }\n        }\n      }\n      count++;\n    } while (yielded.size < modulesByType.length && count < maxCount);\n    if (dependents.size > 0) {\n      throw new Error(`Could not resolve module dependencies: [${[...dependents.keys()]}]`);\n    }\n  }\n  registerDependencies(module) {\n    if (module.dependencies == null || module.dependencies.length === 0)\n      return;\n    for (const key of module.dependencies) {\n      const dependencies = this.dependencies.get(key) ?? /* @__PURE__ */ new Set();\n      dependencies.add(module.optionsKey);\n      this.dependencies.set(key, dependencies);\n    }\n    this.dependents.set(module.optionsKey, new Set(module.dependencies));\n  }\n};\nvar moduleRegistry = new ModuleRegistry();\n\n// packages/ag-charts-community/src/util/async.ts\nfunction sleep(sleepTimeoutMs) {\n  return new Promise((resolve) => {\n    setTimeout(() => resolve(void 0), sleepTimeoutMs);\n  });\n}\n\n// packages/ag-charts-community/src/util/mutex.ts\nvar Mutex = class {\n  constructor() {\n    this.available = true;\n    this.acquireQueue = [];\n  }\n  acquire(cb) {\n    return new Promise((resolve) => {\n      this.acquireQueue.push([cb, resolve]);\n      if (this.available) {\n        this.dispatchNext().catch((e) => Logger.errorOnce(e));\n      }\n    });\n  }\n  async acquireImmediately(cb) {\n    if (!this.available) {\n      return false;\n    }\n    await this.acquire(cb);\n    return true;\n  }\n  async waitForClearAcquireQueue() {\n    return this.acquire(async () => void 0);\n  }\n  async dispatchNext() {\n    this.available = false;\n    let [next, done] = this.acquireQueue.shift() ?? [];\n    while (next) {\n      try {\n        await next();\n        done?.();\n      } catch (error) {\n        Logger.error(\"mutex callback error\", error);\n        done?.();\n      }\n      [next, done] = this.acquireQueue.shift() ?? [];\n    }\n    this.available = true;\n  }\n};\n\n// packages/ag-charts-community/src/util/observable.ts\nvar Observable = class {\n  constructor() {\n    this.eventListeners = /* @__PURE__ */ new Map();\n  }\n  addEventListener(eventType, listener) {\n    if (typeof listener !== \"function\") {\n      throw new Error(\"AG Charts - listener must be a Function\");\n    }\n    const eventTypeListeners = this.eventListeners.get(eventType);\n    if (eventTypeListeners) {\n      eventTypeListeners.add(listener);\n    } else {\n      this.eventListeners.set(eventType, /* @__PURE__ */ new Set([listener]));\n    }\n  }\n  removeEventListener(type, listener) {\n    this.eventListeners.get(type)?.delete(listener);\n    if (this.eventListeners.size === 0) {\n      this.eventListeners.delete(type);\n    }\n  }\n  hasEventListener(type) {\n    return this.eventListeners.has(type);\n  }\n  clearEventListeners() {\n    this.eventListeners.clear();\n  }\n  fireEvent(event) {\n    this.eventListeners.get(event.type)?.forEach((listener) => listener(event));\n  }\n};\n\n// packages/ag-charts-community/src/util/padding.ts\nvar Padding = class extends BaseProperties {\n  constructor(top = 0, right = top, bottom = top, left = right) {\n    super();\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n    this.left = left;\n  }\n  clear() {\n    this.top = this.right = this.bottom = this.left = 0;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"top\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"right\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"bottom\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"left\", 2);\n\n// packages/ag-charts-community/src/util/render.ts\nfunction debouncedAnimationFrame(cb) {\n  return buildScheduler((innerCb, _delayMs) => requestAnimationFrame(innerCb), cb);\n}\nfunction debouncedCallback(cb) {\n  return buildScheduler((innerCb, delayMs = 0) => setTimeout(innerCb, delayMs), cb);\n}\nfunction buildScheduler(scheduleFn, cb) {\n  let scheduleCount = 0;\n  let promiseRunning = false;\n  let awaitingPromise;\n  let awaitingDone;\n  const busy = () => {\n    return promiseRunning;\n  };\n  const done = () => {\n    promiseRunning = false;\n    awaitingDone?.();\n    awaitingDone = void 0;\n    awaitingPromise = void 0;\n    if (scheduleCount > 0) {\n      scheduleFn(scheduleCb);\n    }\n  };\n  const scheduleCb = () => {\n    const count = scheduleCount;\n    scheduleCount = 0;\n    promiseRunning = true;\n    const maybePromise = cb({ count });\n    if (!maybePromise) {\n      done();\n      return;\n    }\n    maybePromise.then(done, done);\n  };\n  return {\n    schedule(delayMs) {\n      if (scheduleCount === 0 && !busy()) {\n        scheduleFn(scheduleCb, delayMs);\n      }\n      scheduleCount++;\n    },\n    async await() {\n      if (!busy()) {\n        return;\n      }\n      if (awaitingPromise == null) {\n        awaitingPromise = new Promise((resolve) => {\n          awaitingDone = resolve;\n        });\n      }\n      while (busy()) {\n        await awaitingPromise;\n      }\n    }\n  };\n}\n\n// packages/ag-charts-community/src/version.ts\nvar VERSION = \"10.0.2\";\n\n// packages/ag-charts-community/src/api/state/memento.ts\nvar MementoCaretaker = class {\n  constructor(version) {\n    this.version = version.split(\"-\")[0];\n  }\n  save(...originators) {\n    const packet = { version: this.version };\n    for (const originator of Object.values(originators)) {\n      packet[originator.mementoOriginatorKey] = this.encode(originator, originator.createMemento());\n    }\n    return packet;\n  }\n  restore(blob, ...originators) {\n    if (typeof blob !== \"object\") {\n      Logger.warnOnce(`Could not restore data of type [${typeof blob}], expecting an object, ignoring.`);\n      return;\n    }\n    if (blob == null) {\n      Logger.warnOnce(`Could not restore data of type [null], expecting an object, ignoring.`);\n      return;\n    }\n    if (!(\"version\" in blob) || typeof blob.version !== \"string\") {\n      Logger.warnOnce(`Could not restore data, missing [version] string in object, ignoring.`);\n      return;\n    }\n    for (const originator of originators) {\n      if (!(originator.mementoOriginatorKey in blob)) {\n        continue;\n      }\n      const memento = this.decode(originator, blob[originator.mementoOriginatorKey]);\n      if (!originator.guardMemento(memento)) {\n        Logger.warnOnce(\n          `Could not restore [${originator.mementoOriginatorKey}] data, value was invalid, ignoring.`,\n          memento\n        );\n        return;\n      }\n      originator.restoreMemento(this.version, blob.version, memento);\n    }\n  }\n  /**\n   * Encode a memento as a serializable object, encoding any non-serializble types.\n   */\n  encode(originator, memento) {\n    try {\n      return JSON.parse(JSON.stringify(memento, this.encodeTypes));\n    } catch (error) {\n      throw new Error(`Failed to encode [${originator.mementoOriginatorKey}] value [${error}].`, {\n        cause: error\n      });\n    }\n  }\n  /**\n   * Decode an encoded memento, decoding any non-serializable types.\n   */\n  decode(originator, encoded) {\n    try {\n      return JSON.parse(JSON.stringify(encoded), this.decodeTypes);\n    } catch (error) {\n      throw new Error(`Failed to decode [${originator.mementoOriginatorKey}] value [${error}].`, {\n        cause: error\n      });\n    }\n  }\n  encodeTypes(key, value) {\n    if (isDate(this[key])) {\n      return { __type: \"date\", value: String(this[key]) };\n    }\n    return value;\n  }\n  decodeTypes(key, value) {\n    if (isObject(this[key]) && \"__type\" in this[key] && this[key].__type === \"date\") {\n      return new Date(this[key].value);\n    }\n    return value;\n  }\n};\n\n// packages/ag-charts-community/src/api/state/stateManager.ts\nvar StateManager = class {\n  constructor() {\n    this.caretaker = new MementoCaretaker(VERSION);\n    this.state = /* @__PURE__ */ new Map();\n  }\n  setState(originator, value) {\n    if (jsonDiff(this.state.get(originator.mementoOriginatorKey), value) == null) {\n      return;\n    }\n    this.state.set(originator.mementoOriginatorKey, value);\n    this.restoreState(originator);\n  }\n  restoreState(originator) {\n    const { caretaker, state } = this;\n    if (!state.has(originator.mementoOriginatorKey))\n      return;\n    const value = state.get(originator.mementoOriginatorKey);\n    caretaker.restore({ version: caretaker.version, [originator.mementoOriginatorKey]: value }, originator);\n  }\n};\n\n// packages/ag-charts-community/src/util/userAgent.ts\nfunction hasConstrainedCanvasMemory() {\n  if (typeof navigator === \"undefined\") {\n    return false;\n  }\n  const iPhoneOSMatch = navigator.userAgent.match(/\\(iPhone; CPU iPhone OS (\\d+_\\d+_\\d+) like Mac OS X\\)/);\n  if (iPhoneOSMatch == null) {\n    return false;\n  }\n  const [major, minor] = iPhoneOSMatch[1].split(\"_\").map(Number);\n  return major < 16 || major === 16 && minor < 6;\n}\n\n// packages/ag-charts-community/src/scene/canvas/hdpiCanvas.ts\nvar _HdpiCanvas = class _HdpiCanvas {\n  constructor(options) {\n    this.enabled = true;\n    this.width = 600;\n    this.height = 300;\n    const { width, height, pixelRatio, canvasConstructor } = options;\n    this.pixelRatio = hasConstrainedCanvasMemory() ? 1 : pixelRatio ?? getWindow(\"devicePixelRatio\");\n    this.element = canvasConstructor?.() ?? createElement(\"canvas\");\n    this.element.style.display = \"block\";\n    this.element.style.width = (width ?? this.width) + \"px\";\n    this.element.style.height = (height ?? this.height) + \"px\";\n    this.element.width = Math.round((width ?? this.width) * this.pixelRatio);\n    this.element.height = Math.round((height ?? this.height) * this.pixelRatio);\n    this.context = this.element.getContext(\"2d\");\n    this.onEnabledChange();\n    this.resize(width ?? 0, height ?? 0);\n    _HdpiCanvas.debugContext(this.context);\n  }\n  static is(value) {\n    return value instanceof _HdpiCanvas;\n  }\n  drawImage(context, dx = 0, dy = 0) {\n    return context.drawImage(this.context.canvas, dx, dy);\n  }\n  toDataURL(type) {\n    return this.element.toDataURL(type);\n  }\n  resize(width, height) {\n    if (!(width > 0 && height > 0))\n      return;\n    const { element: element2, context, pixelRatio } = this;\n    element2.width = Math.round(width * pixelRatio);\n    element2.height = Math.round(height * pixelRatio);\n    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    element2.style.width = width + \"px\";\n    element2.style.height = height + \"px\";\n    this.width = width;\n    this.height = height;\n  }\n  snapshot() {\n  }\n  clear() {\n    this.context.save();\n    this.context.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n    this.context.clearRect(0, 0, this.width, this.height);\n    this.context.restore();\n  }\n  destroy() {\n    this.element.remove();\n    this.element.width = 0;\n    this.element.height = 0;\n    this.context.clearRect(0, 0, 0, 0);\n    Object.freeze(this);\n  }\n  onEnabledChange() {\n    if (this.element) {\n      this.element.style.display = this.enabled ? \"\" : \"none\";\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  static debugContext(ctx) {\n    if (Debug.check(\"canvas\")) {\n      const save = ctx.save.bind(ctx);\n      const restore = ctx.restore.bind(ctx);\n      let depth = 0;\n      Object.assign(ctx, {\n        save() {\n          save();\n          depth++;\n        },\n        restore() {\n          if (depth === 0) {\n            throw new Error(\"AG Charts - Unable to restore() past depth 0\");\n          }\n          restore();\n          depth--;\n        },\n        verifyDepthZero() {\n          if (depth !== 0) {\n            throw new Error(`AG Charts - Save/restore depth is non-zero: ${depth}`);\n          }\n        }\n      });\n    }\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => target.onEnabledChange())\n], _HdpiCanvas.prototype, \"enabled\", 2);\nvar HdpiCanvas = _HdpiCanvas;\n\n// packages/ag-charts-community/src/scene/layersManager.ts\nvar LayersManager = class _LayersManager {\n  constructor(canvas, markDirty) {\n    this.canvas = canvas;\n    this.markDirty = markDirty;\n    this.debug = Debug.create(true, \"scene\");\n    this.layersMap = /* @__PURE__ */ new Map();\n    this.nextZIndex = 0;\n    this.nextLayerId = 0;\n  }\n  static sortLayers(a, b) {\n    return compoundAscending(\n      [a.zIndex, ...a.zIndexSubOrder ?? [void 0, void 0], a.id],\n      [b.zIndex, ...b.zIndexSubOrder ?? [void 0, void 0], b.id],\n      ascendingStringNumberUndefined\n    );\n  }\n  get size() {\n    return this.layersMap.size;\n  }\n  forEach(callback) {\n    Array.from(this.layersMap.values()).sort(_LayersManager.sortLayers).forEach(callback);\n  }\n  resize(width, height) {\n    this.canvas.resize(width, height);\n    this.layersMap.forEach(({ canvas }) => canvas.resize(width, height));\n  }\n  addLayer(opts) {\n    const { width, height, pixelRatio } = this.canvas;\n    const { zIndex = this.nextZIndex++, name, zIndexSubOrder, getComputedOpacity, getVisibility } = opts;\n    const canvas = new HdpiCanvas({ width, height, pixelRatio });\n    const newLayer = {\n      id: this.nextLayerId++,\n      name,\n      canvas,\n      zIndex,\n      zIndexSubOrder,\n      getComputedOpacity,\n      getVisibility\n    };\n    if (zIndex >= this.nextZIndex) {\n      this.nextZIndex = zIndex + 1;\n    }\n    this.layersMap.set(canvas, newLayer);\n    this.debug(\"Scene.addLayer() - layers\", this.layersMap);\n    return newLayer.canvas;\n  }\n  removeLayer(canvas) {\n    if (this.layersMap.has(canvas)) {\n      this.layersMap.delete(canvas);\n      canvas.destroy();\n      this.markDirty();\n      this.debug(\"Scene.removeLayer() -  layers\", this.layersMap);\n    }\n  }\n  moveLayer(canvas, newZIndex, newZIndexSubOrder) {\n    const layer = this.layersMap.get(canvas);\n    if (layer) {\n      layer.zIndex = newZIndex;\n      layer.zIndexSubOrder = newZIndexSubOrder;\n      this.markDirty();\n      this.debug(\"Scene.moveLayer() -  layers\", this.layersMap);\n    }\n  }\n  clear() {\n    this.layersMap.clear();\n  }\n};\n\n// packages/ag-charts-community/src/scene/sceneDebug.ts\nfunction debugStats(layersManager, debugSplitTimes, ctx, renderCtxStats, extraDebugStats = {}) {\n  if (!Debug.check(\"scene:stats\" /* SCENE_STATS */, \"scene:stats:verbose\" /* SCENE_STATS_VERBOSE */))\n    return;\n  const { layersRendered = 0, layersSkipped = 0, nodesRendered = 0, nodesSkipped = 0 } = renderCtxStats ?? {};\n  const end = performance.now();\n  const { start, ...durations } = debugSplitTimes;\n  const splits = Object.entries(durations).map(([n, t]) => {\n    return time(n, t);\n  }).filter((v) => v != null).join(\" + \");\n  const extras = Object.entries(extraDebugStats).map(([k, v]) => `${k}: ${v}`).join(\" ; \");\n  const detailedStats = Debug.check(\"scene:stats:verbose\" /* SCENE_STATS_VERBOSE */);\n  const stats = [\n    `${time(\"\\u23F1\\uFE0F\", start, end)} (${splits})`,\n    `${extras}`,\n    `Layers: ${detailedStats ? pct(layersRendered, layersSkipped) : layersManager.size}`,\n    detailedStats ? `Nodes: ${pct(nodesRendered, nodesSkipped)}` : null\n  ].filter(isString);\n  const statsSize = new Map(stats.map((t) => [t, Text.getTextSize(t, ctx.font)]));\n  const width = Math.max(...Array.from(statsSize.values(), (s) => s.width));\n  const height = accumulate(statsSize.values(), (s) => s.height);\n  ctx.save();\n  ctx.fillStyle = \"white\";\n  ctx.fillRect(0, 0, width, height);\n  ctx.fillStyle = \"black\";\n  let y = 0;\n  for (const [stat, size] of statsSize.entries()) {\n    y += size.height;\n    ctx.fillText(stat, 2, y);\n  }\n  ctx.restore();\n}\nfunction debugSceneNodeHighlight(ctx, debugNodes) {\n  ctx.save();\n  for (const [name, node] of Object.entries(debugNodes)) {\n    const bbox = node.computeTransformedBBox();\n    if (!bbox) {\n      Logger.log(`Scene.render() - no bbox for debugged node [${name}].`);\n      continue;\n    }\n    ctx.globalAlpha = 0.8;\n    ctx.strokeStyle = \"red\";\n    ctx.lineWidth = 1;\n    ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);\n    ctx.fillStyle = \"red\";\n    ctx.strokeStyle = \"white\";\n    ctx.font = \"16px sans-serif\";\n    ctx.textBaseline = \"top\";\n    ctx.textAlign = \"left\";\n    ctx.lineWidth = 2;\n    ctx.strokeText(name, bbox.x, bbox.y, bbox.width);\n    ctx.fillText(name, bbox.x, bbox.y, bbox.width);\n  }\n  ctx.restore();\n}\nfunction buildTree(node) {\n  if (!Debug.check(true, \"scene\" /* SCENE */))\n    return {};\n  return {\n    node,\n    name: (node instanceof Group ? node.name : null) ?? node.id,\n    dirty: RedrawType[node.dirty],\n    ...node.parent?.isVirtual ? {\n      virtualParentDirty: RedrawType[node.parent.dirty],\n      virtualParent: node.parent\n    } : {},\n    ...node.children.map((c) => buildTree(c)).reduce((result, childTree) => {\n      let { name: treeNodeName } = childTree;\n      const {\n        node: { visible, opacity, zIndex, zIndexSubOrder },\n        node: childNode,\n        virtualParent\n      } = childTree;\n      if (!visible || opacity <= 0) {\n        treeNodeName = `(${treeNodeName})`;\n      }\n      if (childNode instanceof Group && childNode.isLayer()) {\n        treeNodeName = `*${treeNodeName}*`;\n      }\n      const key = [\n        `${treeNodeName ?? \"<unknown>\"}`,\n        `z: ${zIndex}`,\n        zIndexSubOrder && `zo: ${zIndexSubOrder.map((v) => typeof v === \"function\" ? `${v()} (fn)` : v).join(\" / \")}`,\n        virtualParent && `(virtual parent)`\n      ].filter((v) => !!v).join(\" \");\n      let selectedKey = key;\n      let index = 1;\n      while (result[selectedKey] != null && index < 100) {\n        selectedKey = `${key} (${index++})`;\n      }\n      result[selectedKey] = childTree;\n      return result;\n    }, {})\n  };\n}\nfunction buildDirtyTree(node) {\n  if (node.dirty === 0 /* NONE */) {\n    return { dirtyTree: {}, paths: [] };\n  }\n  const childrenDirtyTree = node.children.map((c) => buildDirtyTree(c)).filter((c) => c.paths.length > 0);\n  const name = Group.is(node) ? node.name ?? node.id : node.id;\n  const paths = childrenDirtyTree.length ? childrenDirtyTree.flatMap((c) => c.paths).map((p) => `${name}.${p}`) : [name];\n  return {\n    dirtyTree: {\n      name,\n      node,\n      dirty: RedrawType[node.dirty],\n      ...childrenDirtyTree.map((c) => c.dirtyTree).filter((t) => t.dirty != null).reduce((result, childTree) => {\n        result[childTree.name ?? \"<unknown>\"] = childTree;\n        return result;\n      }, {})\n    },\n    paths\n  };\n}\nfunction pct(rendered, skipped) {\n  const total = rendered + skipped;\n  return `${rendered} / ${total} (${Math.round(100 * rendered / total)}%)`;\n}\nfunction time(name, start, end) {\n  const duration = end != null ? end - start : start;\n  return `${name}: ${Math.round(duration * 100) / 100}ms`;\n}\nfunction accumulate(iterator, mapper) {\n  let sum2 = 0;\n  for (const item of iterator) {\n    sum2 += mapper(item);\n  }\n  return sum2;\n}\n\n// packages/ag-charts-community/src/scene/scene.ts\nvar Scene = class {\n  constructor({ width, height, pixelRatio, domManager }) {\n    this.debug = Debug.create(true, \"scene\" /* SCENE */);\n    this.id = createId(this);\n    this.root = null;\n    this.isDirty = false;\n    this.domManager = domManager;\n    const canvasOpts = {\n      width,\n      height,\n      pixelRatio\n    };\n    if (domManager) {\n      canvasOpts.canvasConstructor = () => domManager.addChild(\"canvas\", \"scene-canvas\");\n    }\n    this.canvas = new HdpiCanvas(canvasOpts);\n    this.layersManager = new LayersManager(this.canvas, () => {\n      this.isDirty = true;\n    });\n  }\n  get width() {\n    return this.pendingSize?.[0] ?? this.canvas.width;\n  }\n  get height() {\n    return this.pendingSize?.[1] ?? this.canvas.height;\n  }\n  setContainer(value) {\n    const isElement = (v) => {\n      return typeof v.tagName !== \"undefined\";\n    };\n    if (isElement(value)) {\n      const { element: element2 } = this.canvas;\n      element2.parentElement?.removeChild(element2);\n      value.appendChild(element2);\n    } else {\n      this.domManager = value;\n      this.domManager.addChild(\"canvas\", \"scene-canvas\", this.canvas.element);\n    }\n    return this;\n  }\n  setRoot(node) {\n    if (this.root === node) {\n      return this;\n    }\n    this.isDirty = true;\n    this.root?._setLayerManager();\n    this.root = node;\n    if (node) {\n      node.visible = true;\n      node._setLayerManager(this.layersManager);\n    }\n    return this;\n  }\n  attachNode(node, rootGroupName) {\n    if (!rootGroupName) {\n      this.root?.appendChild(node);\n      return () => this.removeChild(node);\n    }\n    const parentGroup = this.root?.children.find((g) => g instanceof Group && g.name === rootGroupName);\n    if (!parentGroup)\n      throw new Error(\"AG Charts - Unrecognized root group name: \" + rootGroupName);\n    parentGroup.appendChild(node);\n    return () => parentGroup.removeChild(node);\n  }\n  appendChild(node) {\n    this.root?.appendChild(node);\n    return this;\n  }\n  removeChild(node) {\n    this.root?.removeChild(node);\n    return this;\n  }\n  download(fileName, fileFormat) {\n    downloadUrl(this.canvas.toDataURL(fileFormat), fileName?.trim() ?? \"image\");\n  }\n  /** NOTE: Integrated Charts undocumented image download method. */\n  getDataURL(fileFormat) {\n    return this.canvas.toDataURL(fileFormat);\n  }\n  resize(width, height) {\n    width = Math.round(width);\n    height = Math.round(height);\n    if (width > 0 && height > 0 && (width !== this.width || height !== this.height)) {\n      this.pendingSize = [width, height];\n      this.isDirty = true;\n      return true;\n    }\n    return false;\n  }\n  async render(opts) {\n    const { debugSplitTimes = { start: performance.now() }, extraDebugStats } = opts ?? {};\n    const { canvas, canvas: { context: ctx } = {}, root, pendingSize } = this;\n    if (!ctx) {\n      return;\n    }\n    const renderStartTime = performance.now();\n    if (pendingSize) {\n      this.layersManager.resize(...pendingSize);\n      this.pendingSize = void 0;\n    }\n    if (root && !root.visible) {\n      this.isDirty = false;\n      return;\n    }\n    if (root && !this.isDirty) {\n      if (this.debug.check()) {\n        this.debug(\"Scene.render() - no-op\", {\n          redrawType: RedrawType[root.dirty],\n          tree: buildTree(root)\n        });\n      }\n      debugStats(this.layersManager, debugSplitTimes, ctx, void 0, extraDebugStats);\n      return;\n    }\n    const renderCtx = {\n      ctx,\n      devicePixelRatio: this.canvas.pixelRatio ?? 1,\n      forceRender: true,\n      resized: Boolean(pendingSize),\n      debugNodes: {}\n    };\n    if (Debug.check(\"scene:stats:verbose\" /* SCENE_STATS_VERBOSE */)) {\n      renderCtx.stats = { layersRendered: 0, layersSkipped: 0, nodesRendered: 0, nodesSkipped: 0 };\n    }\n    let canvasCleared = false;\n    if (!root || root.dirty >= 1 /* TRIVIAL */) {\n      canvasCleared = true;\n      canvas.clear();\n    }\n    if (root && Debug.check(\"scene:dirtyTree\" /* SCENE_DIRTY_TREE */)) {\n      const { dirtyTree, paths } = buildDirtyTree(root);\n      Debug.create(\"scene:dirtyTree\" /* SCENE_DIRTY_TREE */)(\"Scene.render() - dirtyTree\", { dirtyTree, paths });\n    }\n    if (root && canvasCleared) {\n      this.debug(\"Scene.render() - before\", {\n        redrawType: RedrawType[root.dirty],\n        canvasCleared,\n        tree: buildTree(root)\n      });\n      if (root.visible) {\n        root.preRender();\n        ctx.save();\n        root.render(renderCtx);\n        ctx.restore();\n      }\n    }\n    debugSplitTimes[\"\\u270D\\uFE0F\"] = performance.now() - renderStartTime;\n    if (this.layersManager.size && canvasCleared) {\n      const layerRenderStart = performance.now();\n      ctx.save();\n      ctx.resetTransform();\n      this.layersManager.forEach((layer) => {\n        if (layer.canvas.enabled && layer.getVisibility()) {\n          ctx.globalAlpha = layer.getComputedOpacity();\n          layer.canvas.drawImage(ctx);\n        }\n      });\n      ctx.restore();\n      debugSplitTimes[\"\\u26D9\"] = performance.now() - layerRenderStart;\n    }\n    ctx.verifyDepthZero?.();\n    this.isDirty = false;\n    debugStats(this.layersManager, debugSplitTimes, ctx, renderCtx.stats, extraDebugStats);\n    debugSceneNodeHighlight(ctx, renderCtx.debugNodes);\n    if (root && this.debug.check()) {\n      this.debug(\"Scene.render() - after\", {\n        redrawType: RedrawType[root.dirty],\n        tree: buildTree(root),\n        canvasCleared\n      });\n    }\n  }\n  /** Alternative to destroy() that preserves re-usable resources. */\n  strip() {\n    const { context, pixelRatio } = this.canvas;\n    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    this.layersManager.clear();\n    this.setRoot(null);\n    this.isDirty = false;\n  }\n  destroy() {\n    this.strip();\n    this.canvas.destroy();\n    Object.assign(this, { canvas: void 0 });\n  }\n};\nScene.className = \"Scene\";\n\n// packages/ag-charts-community/src/util/callbackCache.ts\nvar CallbackCache = class {\n  constructor() {\n    this.cache = /* @__PURE__ */ new WeakMap();\n  }\n  call(fn, ...params) {\n    let serialisedParams;\n    let paramCache = this.cache.get(fn);\n    const invoke = () => {\n      try {\n        const result = fn(...params);\n        if (paramCache && serialisedParams != null) {\n          paramCache.set(serialisedParams, result);\n        }\n        return result;\n      } catch (e) {\n        Logger.warnOnce(`User callback errored, ignoring`, e);\n        return;\n      }\n    };\n    try {\n      serialisedParams = JSON.stringify(params);\n    } catch (e) {\n      return invoke();\n    }\n    if (paramCache == null) {\n      paramCache = /* @__PURE__ */ new Map();\n      this.cache.set(fn, paramCache);\n    }\n    if (!paramCache.has(serialisedParams)) {\n      return invoke();\n    }\n    return paramCache.get(serialisedParams);\n  }\n  invalidateCache() {\n    this.cache = /* @__PURE__ */ new WeakMap();\n  }\n};\n\n// packages/ag-charts-community/src/chart/annotation/annotationManager.ts\nvar AnnotationManager = class extends BaseManager {\n  constructor(annotationRoot) {\n    super();\n    this.annotationRoot = annotationRoot;\n    this.mementoOriginatorKey = \"annotations\";\n    this.annotations = [];\n  }\n  createMemento() {\n    return this.annotations;\n  }\n  guardMemento(blob) {\n    return isArray(blob);\n  }\n  restoreMemento(_version, _mementoVersion, memento) {\n    this.listeners.dispatch(\"restore-annotations\", {\n      type: \"restore-annotations\",\n      annotations: memento\n    });\n  }\n  updateData(annotations2) {\n    this.annotations = annotations2 ?? [];\n  }\n  attachNode(node) {\n    this.annotationRoot.append(node);\n    return () => {\n      this.annotationRoot?.removeChild(node);\n      return this;\n    };\n  }\n  setAnnotationStyles(styles) {\n    this.styles = styles;\n  }\n  getAnnotationTypeStyles(type) {\n    return this.styles?.[type];\n  }\n};\n\n// packages/ag-charts-community/src/chart/axis/axisManager.ts\nvar AxisManager = class {\n  constructor(sceneRoot) {\n    this.sceneRoot = sceneRoot;\n    this.axes = /* @__PURE__ */ new Map();\n    this.axisGridGroup = new Group({ name: \"Axes-Grids\", layer: true, zIndex: 1 /* AXIS_GRID_ZINDEX */ });\n    this.axisGroup = new Group({ name: \"Axes\", layer: true, zIndex: 2 /* AXIS_ZINDEX */ });\n    this.sceneRoot.appendChild(this.axisGroup);\n    this.sceneRoot.appendChild(this.axisGridGroup);\n  }\n  updateAxes(oldAxes, newAxes) {\n    for (const axis of oldAxes) {\n      if (newAxes.includes(axis))\n        continue;\n      axis.detachAxis(this.axisGroup, this.axisGridGroup);\n      axis.destroy();\n    }\n    for (const axis of newAxes) {\n      if (oldAxes?.includes(axis))\n        continue;\n      axis.attachAxis(this.axisGroup, this.axisGridGroup);\n    }\n    this.axes.clear();\n    for (const axis of newAxes) {\n      const ctx = axis.createAxisContext();\n      if (this.axes.has(ctx.direction)) {\n        this.axes.get(ctx.direction)?.push(ctx);\n      } else {\n        this.axes.set(ctx.direction, [ctx]);\n      }\n    }\n  }\n  getAxisContext(direction) {\n    return [...this.axes.get(direction) ?? []];\n  }\n  destroy() {\n    this.axes.clear();\n    this.sceneRoot.removeChild(this.axisGroup);\n    this.sceneRoot.removeChild(this.axisGridGroup);\n  }\n};\n\n// packages/ag-charts-community/src/chart/data/dataService.ts\nvar DataService = class extends Listeners {\n  constructor(animationManager) {\n    super();\n    this.animationManager = animationManager;\n    this.dispatchOnlyLatest = true;\n    this.dispatchThrottle = 0;\n    this.requestThrottle = 300;\n    this.isLoadingInitialData = false;\n    this.isLoadingData = false;\n    this.freshRequests = [];\n    this.requestCounter = 0;\n    this.debug = Debug.create(true, \"data-model\", \"data-source\");\n    this.throttledFetch = this.createThrottledFetch(this.requestThrottle);\n    this.throttledDispatch = this.createThrottledDispatch(this.dispatchThrottle);\n  }\n  updateCallback(dataSourceCallback) {\n    if (typeof dataSourceCallback !== \"function\")\n      return;\n    this.debug(\"DataService - updated data source callback\");\n    this.dataSourceCallback = dataSourceCallback;\n    this.isLoadingInitialData = true;\n    this.animationManager.skip();\n    this.dispatch(\"data-source-change\");\n  }\n  clearCallback() {\n    this.dataSourceCallback = void 0;\n  }\n  load(params) {\n    this.isLoadingData = true;\n    this.throttledFetch(params);\n  }\n  isLazy() {\n    return this.dataSourceCallback != null;\n  }\n  isLoading() {\n    return this.isLazy() && (this.isLoadingInitialData || this.isLoadingData);\n  }\n  createThrottledFetch(requestThrottle) {\n    return throttle((params) => this.fetch(params), requestThrottle, {\n      leading: false,\n      trailing: true\n    });\n  }\n  createThrottledDispatch(dispatchThrottle) {\n    return throttle(\n      (id, data) => {\n        this.debug(`DataService - dispatching 'data-load' | ${id}`);\n        this.dispatch(\"data-load\", { type: \"data-load\", data });\n      },\n      dispatchThrottle,\n      {\n        leading: true,\n        trailing: true\n      }\n    );\n  }\n  async fetch(params) {\n    if (!this.dataSourceCallback) {\n      throw new Error(\"DataService - [dataSource.getData] callback not initialised\");\n    }\n    const start = performance.now();\n    const id = this.requestCounter++;\n    this.debug(`DataService - requesting | ${id}`);\n    this.freshRequests.push(id);\n    let response;\n    try {\n      response = await this.dataSourceCallback(params);\n      this.debug(`DataService - response | ${performance.now() - start}ms | ${id}`);\n    } catch (error) {\n      this.debug(`DataService - request failed | ${id}`);\n      Logger.errorOnce(`DataService - request failed | [${error}]`);\n    }\n    this.isLoadingInitialData = false;\n    const requestIndex = this.freshRequests.findIndex((rid) => rid === id);\n    if (requestIndex === -1 || this.dispatchOnlyLatest && requestIndex !== this.freshRequests.length - 1) {\n      this.debug(`DataService - discarding stale request | ${id}`);\n      return;\n    }\n    this.freshRequests = this.freshRequests.slice(requestIndex + 1);\n    if (this.freshRequests.length === 0) {\n      this.isLoadingData = false;\n    }\n    if (Array.isArray(response)) {\n      this.throttledDispatch(id, response);\n    } else {\n      this.dispatch(\"data-error\");\n    }\n  }\n};\n__decorateClass([\n  ActionOnSet({\n    newValue(dispatchThrottle) {\n      this.throttledDispatch = this.createThrottledDispatch(dispatchThrottle);\n    }\n  })\n], DataService.prototype, \"dispatchThrottle\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(requestThrottle) {\n      this.throttledFetch = this.createThrottledFetch(requestThrottle);\n    }\n  })\n], DataService.prototype, \"requestThrottle\", 2);\n\n// packages/ag-charts-community/src/util/guardedElement.ts\nvar GuardedElement = class {\n  constructor(element2, topTabGuard, bottomTabGuard) {\n    this.element = element2;\n    this.topTabGuard = topTabGuard;\n    this.bottomTabGuard = bottomTabGuard;\n    this.destroyFns = [];\n    this.guardTabIndex = 0;\n    this.element.tabIndex = -1;\n    this.initEventListener(this.element, \"blur\", () => this.onBlur());\n    this.initEventListener(this.element, \"focus\", () => this.onFocus());\n    this.initEventListener(this.topTabGuard, \"focus\", (ev) => this.onTabStart(ev, this.topTabGuard));\n    this.initEventListener(this.bottomTabGuard, \"focus\", (ev) => this.onTabStart(ev, this.bottomTabGuard));\n  }\n  set tabIndex(index) {\n    if (index >= 0) {\n      this.guardTabIndex = index;\n    }\n    if (index > 0) {\n      this.topTabGuard.tabIndex = index;\n      this.bottomTabGuard.style.display = \"none\";\n    } else {\n      this.topTabGuard.tabIndex = index;\n      this.bottomTabGuard.tabIndex = index;\n    }\n  }\n  destroy() {\n    for (const fn of this.destroyFns)\n      fn();\n    this.destroyFns.length = 0;\n  }\n  initEventListener(elem, type, handler) {\n    elem.addEventListener(type, handler);\n    this.destroyFns.push(() => elem.removeEventListener(type, handler));\n  }\n  onBlur() {\n    if (this.element.tabIndex === -1) {\n      this.tabIndex = this.guardTabIndex;\n      this.guardTarget = void 0;\n      this.guessedDelta = void 0;\n    }\n  }\n  onFocus() {\n    if (this.element.tabIndex === -1) {\n      this.tabIndex = -1;\n    }\n  }\n  onTabStart(event, target) {\n    if (target.tabIndex > 0) {\n      this.guessedDelta = 0;\n      if (event.relatedTarget != null && \"tabIndex\" in event.relatedTarget) {\n        const prevTabIndex = Number(event.relatedTarget[\"tabIndex\"]);\n        if (!isNaN(prevTabIndex) && prevTabIndex > 0) {\n          this.guessedDelta = prevTabIndex < target.tabIndex ? 1 : -1;\n        }\n      }\n    }\n    this.guardTarget = target;\n    this.element.focus();\n  }\n  getBrowserFocusDelta() {\n    const { guessedDelta, guardTarget, topTabGuard, bottomTabGuard: botTabGuard } = this;\n    if (guessedDelta !== void 0)\n      return guessedDelta;\n    if (guardTarget === topTabGuard)\n      return 1;\n    if (guardTarget === botTabGuard)\n      return -1;\n    return 0;\n  }\n};\n\n// packages/ag-charts-community/src/util/sizeMonitor.ts\nvar SizeMonitor = class {\n  constructor() {\n    this.elements = /* @__PURE__ */ new Map();\n    this.documentReady = false;\n    this.queuedObserveRequests = [];\n    this.onLoad = () => {\n      this.documentReady = true;\n      this.queuedObserveRequests.forEach(([el, cb]) => this.observe(el, cb));\n      this.queuedObserveRequests = [];\n    };\n    if (typeof ResizeObserver === \"undefined\")\n      return;\n    this.resizeObserver = new ResizeObserver((entries) => {\n      for (const {\n        target,\n        contentRect: { width, height }\n      } of entries) {\n        const entry = this.elements.get(target);\n        this.checkSize(entry, target, width, height);\n      }\n    });\n    this.documentReady = getDocument(\"readyState\") === \"complete\";\n    if (!this.documentReady) {\n      getWindow()?.addEventListener(\"load\", this.onLoad);\n    }\n  }\n  destroy() {\n    getWindow()?.removeEventListener(\"load\", this.onLoad);\n    this.resizeObserver?.disconnect();\n    this.resizeObserver = null;\n  }\n  checkSize(entry, element2, width, height) {\n    if (!entry)\n      return;\n    if (width !== entry.size?.width || height !== entry.size?.height) {\n      entry.size = { width, height };\n      entry.cb(entry.size, element2);\n    }\n  }\n  // Only a single callback is supported.\n  observe(element2, cb) {\n    if (!this.documentReady) {\n      this.queuedObserveRequests.push([element2, cb]);\n      return;\n    }\n    if (this.elements.has(element2)) {\n      this.removeFromQueue(element2);\n    } else {\n      this.resizeObserver?.observe(element2);\n    }\n    const entry = { cb };\n    this.elements.set(element2, entry);\n    this.checkSize(entry, element2, element2.offsetWidth, element2.offsetHeight);\n  }\n  unobserve(element2) {\n    this.resizeObserver?.unobserve(element2);\n    this.elements.delete(element2);\n    this.removeFromQueue(element2);\n    if (!this.elements.size) {\n      this.destroy();\n    }\n  }\n  removeFromQueue(element2) {\n    this.queuedObserveRequests = this.queuedObserveRequests.filter(([el]) => el !== element2);\n  }\n};\n\n// packages/ag-charts-community/src/chart/dom/domLayout.html\nvar domLayout_default = '<div class=\"ag-charts-wrapper ag-charts-styles\" data-ag-charts><div class=\"ag-charts-canvas-center\"><div class=\"ag-charts-canvas-container\"><div class=\"ag-charts-tab-guard\"></div><div class=\"ag-charts-canvas\"></div><div class=\"ag-charts-canvas-proxy\"></div><div class=\"ag-charts-tab-guard\"></div><div class=\"ag-charts-canvas-overlay\"></div></div></div></div>';\n\n// packages/ag-charts-community/src/chart/dom/domStyles.css\nvar domStyles_default = \".ag-charts-wrapper,\\n.ag-charts-wrapper:focus,\\n.ag-charts-wrapper:after,\\n.ag-charts-wrapper:before,\\n.ag-charts-wrapper *,\\n.ag-charts-wrapper *:focus,\\n.ag-charts-wrapper *:after,\\n.ag-charts-wrapper *:before{box-sizing:border-box;outline:none}.ag-charts-wrapper{position:relative}.ag-charts-canvas-center{width:100%;height:100%;position:absolute;touch-action:auto;display:flex;align-items:var(--ag-charts-align);justify-content:var(--ag-charts-justify)}.ag-charts-canvas-container,\\n.ag-charts-canvas{position:relative}.ag-charts-canvas-container > *,\\n.ag-charts-canvas > *{display:block}.ag-charts-canvas-proxy{opacity:0;position:absolute;top:0;left:0;pointer-events:none}.ag-charts-tab-guard{opacity:0;width:0px;height:0px}.ag-charts-canvas-overlay{pointer-events:none;position:absolute;top:0;left:0;right:0;bottom:0}.ag-charts-canvas-overlay > *{position:absolute;pointer-events:auto}.ag-charts-theme-default,\\n.ag-charts-theme-default-dark{--ag-charts-active-color:var(--ag-active-color,#2196f3);--ag-charts-background-color:var(--ag-background-color,#fff);--ag-charts-foreground-color:var(--ag-foreground-color,#181d1f);--ag-charts-border-color:var(--ag-border-color,#dddddd);--ag-charts-font-size:var(--ag-font-size,14px);--ag-charts-size:var(--ag-grid-size,8px);--ag-charts-border:var(--ag-charts-border-color) var(--ag-borders,solid 1px);--ag-charts-border-critical:var(--ag-borders-critical,solid 1px);--ag-charts-layer-context-menu:5;--ag-charts-layer-tooltip:4;--ag-charts-layer-toolbar:3;--ag-charts-layer-crosshair:2;--ag-charts-layer-annotations:1;--ag-charts-align:center;--ag-charts-justify:center;--ag-charts-axis-label-background-color:#474747;--ag-charts-axis-label-color:#ffffff;--ag-charts-toolbar-foreground-color:var(--ag-header-foreground-color,var(--ag-charts-foreground-color));--ag-charts-toolbar-background-color:var(\\n        --ag-header-background-color,color-mix(in srgb,var(--ag-charts-background-color),var(--ag-charts-foreground-color) 2%)\\n    );--ag-charts-toolbar-size:34px;--ag-charts-toolbar-size-small:24px;--ag-charts-toolbar-border:var(--ag-charts-border-critical,solid 1px) var(--ag-charts-border-color);--ag-charts-toolbar-hover-color:color-mix(in srgb,var(--ag-charts-background-color),var(--ag-charts-active-color) 12%);--ag-charts-toolbar-focus-color:var(--ag-charts-active-color);--ag-charts-toolbar-active-background-color:color-mix(in srgb,var(--ag-charts-background-color),var(--ag-charts-active-color) 24%);--ag-charts-toolbar-active-color:var(--ag-active-color,#5090dc);--ag-charts-toolbar-disabled-foreground-color:var(\\n        --ag-disabled-foreground-color,color-mix(in srgb,transparent,var(--ag-charts-toolbar-foreground-color) 50%)\\n    );--ag-charts-toolbar-disabled-background-color:color-mix(in srgb,var(--ag-charts-toolbar-background-color),var(--ag-charts-toolbar-foreground-color) 6%);--ag-charts-toolbar-gap:var(--ag-charts-size);--ag-charts-toolbar-font-size:14px;--ag-charts-toolbar-font-size-small:12px;--ag-charts-toolbar-button-padding:7px;--ag-charts-toolbar-button-padding-small:3px;--ag-charts-button-radius:var(--ag-border-radius,4px);--ag-charts-focus-border-color:var(--ag-input-focus-border-color,var(--ag-charts-active-color));--ag-charts-focus-border:solid 1px var(--ag-charts-focus-border-color);--ag-charts-focus-border-shadow:var(\\n        --ag-input-focus-box-shadow,0 0 0 3px color-mix(in srgb,transparent,var(--ag-input-focus-border-color,var(--ag-charts-active-color)) 47%)\\n    );--ag-charts-icon-font-family:'agChartsDefault';--ag-charts-icon-font-weight:normal;--ag-charts-icon-font-color:color-mix(in srgb,transparent,var(--ag-charts-foreground-color),90%)}.ag-charts-theme-default-dark{--ag-charts-background-color:var(--ag-background-color,color-mix(in srgb,#fff,#182230 97%));--ag-charts-foreground-color:var(--ag-foreground-color,#fff);--ag-charts-border-color:var(--ag-border-color,rgba(255,255,255,0.16));--ag-charts-hover-color:var(\\n        --ag-row-hover-color,color-mix(in srgb,transparent,var(--ag-charts-active-color) 20%)\\n    );--ag-charts-axis-label-background-color:#9caebb;--ag-charts-axis-label-color:#000000;--ag-charts-toolbar-background-color:var(--ag-header-background-color,color-mix(in srgb,#fff,#182230 93%))}[class^='ag-charts-icon']{display:block;speak:none;speak:never;mask-size:contain;mask-repeat:no-repeat;background-color:currentColor}.ag-charts-icon-zoom-in{mask-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik04Ljc1IDQuNWEuNzUuNzUgMCAwIDAtMS41IDB2Mi43NUg0LjVhLjc1Ljc1IDAgMCAwIDAgMS41aDIuNzV2Mi43NWEuNzUuNzUgMCAwIDAgMS41IDBWOC43NWgyLjc1YS43NS43NSAwIDAgMCAwLTEuNUg4Ljc1VjQuNVoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-zoom-out{mask-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0zLjc1IDhhLjc1Ljc1IDAgMCAxIC43NS0uNzVoN2EuNzUuNzUgMCAwIDEgMCAxLjVoLTdBLjc1Ljc1IDAgMCAxIDMuNzUgOFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-zoom-in-alt{mask-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXpvb20taW4iPjxjaXJjbGUgY3g9IjExIiBjeT0iMTEiIHI9IjgiLz48bGluZSB4MT0iMjEiIHgyPSIxNi42NSIgeTE9IjIxIiB5Mj0iMTYuNjUiLz48bGluZSB4MT0iMTEiIHgyPSIxMSIgeTE9IjgiIHkyPSIxNCIvPjxsaW5lIHgxPSI4IiB4Mj0iMTQiIHkxPSIxMSIgeTI9IjExIi8+PC9zdmc+)}.ag-charts-icon-zoom-out-alt{mask-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXpvb20tb3V0Ij48Y2lyY2xlIGN4PSIxMSIgY3k9IjExIiByPSI4Ii8+PGxpbmUgeDE9IjIxIiB4Mj0iMTYuNjUiIHkxPSIyMSIgeTI9IjE2LjY1Ii8+PGxpbmUgeDE9IjgiIHgyPSIxNCIgeTE9IjExIiB5Mj0iMTEiLz48L3N2Zz4=)}.ag-charts-icon-reset{mask-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00LjQxMiA0LjA1OCAyLjc1IDIuMzk2VjYuNzVoLjc0NGEuNzYuNzYgMCAwIDAgLjAxMiAwaDMuNTk4TDUuNDc4IDUuMTI1YTQuMTI1IDQuMTI1IDAgMCAxIDIuNTIzLS44NzUgMy43NSAzLjc1IDAgMSAxLTMuMTE5IDUuODMzLjc1Ljc1IDAgMCAwLTEuMjQ3LjgzNEE1LjI1IDUuMjUgMCAxIDAgOCAyLjc1aC0uMDAzYTUuNjI1IDUuNjI1IDAgMCAwLTMuNTg1IDEuMzA4WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-left{mask-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMC4wMyA0LjQ3YS43NS43NSAwIDAgMSAwIDEuMDZMNy41NiA4bDIuNDcgMi40N2EuNzUuNzUgMCAxIDEtMS4wNiAxLjA2bC0zLTNhLjc1Ljc1IDAgMCAxIDAtMS4wNmwzLTNhLjc1Ljc1IDAgMCAxIDEuMDYgMFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-pan-right{mask-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik01Ljk3IDExLjUzYS43NS43NSAwIDAgMSAwLTEuMDZMOC40NCA4IDUuOTcgNS41M2EuNzUuNzUgMCAwIDEgMS4wNi0xLjA2bDMgM2EuNzUuNzUgMCAwIDEgMCAxLjA2bC0zIDNhLjc1Ljc1IDAgMCAxLTEuMDYgMFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-pan-start{mask-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLWNoZXZyb24tZmlyc3QiPjxwYXRoIGQ9Im0xNyAxOC02LTYgNi02Ii8+PHBhdGggZD0iTTcgNnYxMiIvPjwvc3ZnPg==)}.ag-charts-icon-pan-end{mask-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLWNoZXZyb24tbGFzdCI+PHBhdGggZD0ibTcgMTggNi02LTYtNiIvPjxwYXRoIGQ9Ik0xNyA2djEyIi8+PC9zdmc+)}.ag-charts-icon-trend-line{mask-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMi41IiBjeT0iOCIgcj0iMS43NSIgc3Ryb2tlPSIjMDAwIiBzdHJva2Utd2lkdGg9IjEuNSIvPjxjaXJjbGUgY3g9IjEzLjUiIGN5PSI4IiByPSIxLjc1IiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41Ii8+PHBhdGggc3Ryb2tlPSIjMDAwIiBzdHJva2Utd2lkdGg9IjEuNSIgZD0iTTQgOGg4Ii8+PC9zdmc+)}.ag-charts-icon-horizontal-line{mask-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMC4zODYgOC43NWEyLjUwMSAyLjUwMSAwIDAgMS00Ljc3MiAwSC43NWEuNzUuNzUgMCAwIDEgMC0xLjVoNC44NjRhMi41MDEgMi41MDEgMCAwIDEgNC43NzIgMGg0Ljg2NGEuNzUuNzUgMCAwIDEgMCAxLjVoLTQuODY0Wk05IDhhMSAxIDAgMSAxLTIgMCAxIDEgMCAwIDEgMiAwWiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-vertical-line{mask-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik04Ljc1IDUuNjE0YTIuNTAxIDIuNTAxIDAgMCAxIDAgNC43NzJ2NC44NjRhLjc1Ljc1IDAgMCAxLTEuNSAwdi00Ljg2NGEyLjUwMSAyLjUwMSAwIDAgMSAwLTQuNzcyVi43NWEuNzUuNzUgMCAwIDEgMS41IDB2NC44NjRaTTggN2ExIDEgMCAxIDEgMCAyIDEgMSAwIDAgMSAwLTJaIiBmaWxsPSIjMDAwIi8+PC9zdmc+)}.ag-charts-icon-parallel-channel{mask-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC40MjQgNC45MmEyLjUgMi41IDAgMSAwLTMuMzc3LTIuMTRsLTYuNjMgMi45YTIuNTAxIDIuNTAxIDAgMSAwIC42MDcgMS4zNzJsNi41ODUtMi44OGEyLjUwMSAyLjUwMSAwIDAgMCAyLjgxNS43NDhabS4wNS0yLjY5M2ExIDEgMCAxIDEtMS44Ny43MDggMSAxIDAgMCAxIDEuODctLjcwOFptLTExIDQuNzVhMSAxIDAgMSAxLTEuODcuNzA4IDEgMSAwIDAgMSAxLjg3LS43MDhabTEuNTUgNi4wNzVhMi41MDEgMi41MDEgMCAxIDEtLjYwNy0xLjM3Mmw2LjYzLTIuOWEyLjUwMSAyLjUwMSAwIDEgMSAuNTYyIDEuMzkxbC02LjU4NSAyLjg4Wm0tMS41NS0uMDc1YTEgMSAwIDEgMS0xLjg3LjcwOCAxIDEgMCAwIDEgMS44Ny0uNzA4Wm0xMC40Mi0zLjQ2YTEgMSAwIDEgMC0uNzA5LTEuODcgMSAxIDAgMCAwIC43MDggMS44N1oiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-disjoint-channel{mask-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC40MjQgNC45MmEyLjUgMi41IDAgMSAwLTMuMzgzLTIuNDUzTDQuNjkgNC4wNTVhMi41IDIuNSAwIDEgMCAuMzQ0IDEuNDZsNi4zOTItMS41OThhMi41MDEgMi41MDEgMCAwIDAgMyAxLjAwM1ptLjA1LTIuNjkzYTEgMSAwIDEgMS0xLjg3LjcwOCAxIDEgMCAwIDEgMS44Ny0uNzA4Wm0tMTEgMi43NWExIDEgMCAxIDEtMS44Ny43MDggMSAxIDAgMCAxIDEuODctLjcwOFptMS41NiA1LjQyYTIuNSAyLjUgMCAxIDAtLjM0NSAxLjQ2MWw2LjM1MiAxLjU4OGEyLjUgMi41IDAgMSAwIC4zODQtMS40NWwtNi4zOTItMS41OThabS0xLjU2LjUzOGExIDEgMCAxIDAtMS44Ny0uNzA4IDEgMSAwIDAgMCAxLjg3LjcwOFptMTAuNDIgMS40NjFhMSAxIDAgMSAxLS43MDkgMS44NyAxIDEgMCAwIDEgLjcwOC0xLjg3WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-line-color{mask-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgY2xpcC1wYXRoPSJ1cmwoI2EpIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEyLjc4OC41ODNhMi42MyAyLjYzIDAgMCAwLTEuODYuNzdMOS41NDQgMi43MzhhLjc1Ny43NTcgMCAwIDAtLjE0LjE0TDIuMDMyIDEwLjI1di4wMDFjLS4yNDIuMjQxLS40Mi41MzgtLjUyLjg2NGwtLjAwMi4wMDItLjg4IDIuOTAyLS4wMDEuMDAzYTEuMDgzIDEuMDgzIDAgMCAwIDEuMzUgMS4zNDdoLjAwMWwyLjkwMi0uODhoLjAwMWMuMzI2LS4xLjYyMy0uMjc3Ljg2NS0uNTE4di0uMDAxbDcuMzc1LTcuMzc2YS43NjMuNzYzIDAgMCAwIC4xMzktLjEzOWwxLjM4NC0xLjM4NEEyLjYzIDIuNjMgMCAwIDAgMTIuNzg4LjU4M1ptLS4xMjYgNC4zNTIuOTI0LS45MjRhMS4xMyAxLjEzIDAgMCAwLTEuNTk3LTEuNTk3bC0uOTI0LjkyNCAxLjU5NyAxLjU5N1ptLTIuNjU3LS41MzYtNi45MTMgNi45MTRIMy4wOWEuNTgzLjU4MyAwIDAgMC0uMTQ2LjI0MmwtLjY1MyAyLjE1MyAyLjE1NS0uNjU0YS41ODMuNTgzIDAgMCAwIC4yNDEtLjE0NGw2LjkxNC02LjkxNC0xLjU5Ny0xLjU5N1oiIGZpbGw9IiMwMDAiLz48L2c+PGRlZnM+PGNsaXBQYXRoIGlkPSJhIj48cGF0aCBmaWxsPSIjZmZmIiBkPSJNMCAwaDE2djE2SDB6Ii8+PC9jbGlwUGF0aD48L2RlZnM+PC9zdmc+)}.ag-charts-icon-delete{mask-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjA4MyAyLjY2N2MwLS4wOS4wNTMtLjI0Mi4xOTctLjM4Ny4xNDUtLjE0NC4yOTctLjE5Ny4zODctLjE5N2gyLjY2N2MuMDg5IDAgLjI0MS4wNTMuMzg2LjE5Ny4xNDUuMTQ1LjE5Ny4yOTcuMTk3LjM4N3YuNTgzSDYuMDg0di0uNTgzWk01LjMzIDQuNzVIMTEuOTE3djguNTgzYzAgLjA5LS4wNTIuMjQyLS4xOTcuMzg3LS4xNDUuMTQ0LS4yOTcuMTk3LS4zODYuMTk3SDQuNjY3Yy0uMDkgMC0uMjQyLS4wNTMtLjM4Ny0uMTk3LS4xNDQtLjE0NS0uMTk3LS4yOTctLjE5Ny0uMzg3VjQuNzVINS4zM1ptLS43NDUtMS41di0uNTgzYzAtLjU3OC4yOC0xLjA5Mi42MzYtMS40NDcuMzU1LS4zNTYuODctLjYzNyAxLjQ0Ny0uNjM3aDIuNjY3Yy41NzcgMCAxLjA5MS4yODEgMS40NDcuNjM3LjM1NS4zNTUuNjM2Ljg3LjYzNiAxLjQ0N3YuNTgzSDE0YS43NS43NSAwIDAgMSAwIDEuNWgtLjU4M3Y4LjU4M2MwIC41NzgtLjI4MSAxLjA5Mi0uNjM2IDEuNDQ3LS4zNTYuMzU2LS44Ny42MzctMS40NDcuNjM3SDQuNjY3Yy0uNTc3IDAtMS4wOTItLjI4MS0xLjQ0Ny0uNjM3LS4zNTUtLjM1NS0uNjM3LS44Ny0uNjM3LTEuNDQ3VjQuNzVIMmEuNzUuNzUgMCAwIDEgMC0xLjVoMi41ODNabTIuMDgzIDMuMzMzYS43NS43NSAwIDAgMSAuNzUuNzV2NGEuNzUuNzUgMCAxIDEtMS41IDB2LTRhLjc1Ljc1IDAgMCAxIC43NS0uNzVabTMuNDE3Ljc1YS43NS43NSAwIDAgMC0xLjUgMHY0YS43NS43NSAwIDEgMCAxLjUgMHYtNFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-lock{mask-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjE3MyAyLjg0YTIuNTgzIDIuNTgzIDAgMCAxIDQuNDEgMS44Mjd2MS45MTZINS40MTZWNC42NjdjMC0uNjg1LjI3My0xLjM0My43NTctMS44MjdaTTMuOTE3IDYuNTgzVjQuNjY3YTQuMDgzIDQuMDgzIDAgMCAxIDguMTY2IDB2MS45MTZoLjU4NGMxLjE1IDAgMi4wODMuOTMzIDIuMDgzIDIuMDg0djQuNjY2YzAgMS4xNS0uOTMzIDIuMDg0LTIuMDgzIDIuMDg0SDMuMzMzYTIuMDgzIDIuMDgzIDAgMCAxLTIuMDgzLTIuMDg0VjguNjY3YzAtMS4xNTEuOTMzLTIuMDg0IDIuMDgzLTIuMDg0aC41ODNabTcuNDE2IDEuNWgtOGEuNTgzLjU4MyAwIDAgMC0uNTgzLjU4NHY0LjY2NmMwIC4zMjIuMjYxLjU4NC41ODMuNTg0aDkuMzM0YS41ODMuNTgzIDAgMCAwIC41ODMtLjU4NFY4LjY2N2EuNTgzLjU4MyAwIDAgMC0uNTgzLS41ODRoLTEuMzM0WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-unlock{mask-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjkyMyAyLjg0YTIuNTgzIDIuNTgzIDAgMCAxIDMuNjUzIDAgMyAzIDAgMCAxIC41Ny43OThjLjEzNC4yNzguMTcuNDc0LjE3LjU0NWEuNzUuNzUgMCAwIDAgMS41IDBjMC0uMzgxLS4xMzItLjgwOS0uMzItMS4xOThhNC41MDEgNC41MDEgMCAwIDAtLjg1OS0xLjIwNiA0LjA4MyA0LjA4MyAwIDAgMC02Ljk3IDIuODg4djEuOTE2aC0uNTg0QzIuOTMzIDYuNTgzIDIgNy41MTYgMiA4LjY2N3Y0LjY2NmMwIDEuMTUuOTMzIDIuMDg0IDIuMDgzIDIuMDg0aDkuMzM0YzEuMTUgMCAyLjA4My0uOTMzIDIuMDgzLTIuMDg0VjguNjY3YzAtMS4xNTEtLjkzMy0yLjA4NC0yLjA4My0yLjA4NGgtNy4yNVY0LjY2N2MwLS42ODUuMjcyLTEuMzQzLjc1Ni0xLjgyN1pNNS40MTcgOC4wODNINC4wODJhLjU4My41ODMgMCAwIDAtLjU4My41ODR2NC42NjZjMCAuMzIyLjI2MS41ODQuNTgzLjU4NGg5LjMzNGEuNTgzLjU4MyAwIDAgMCAuNTgzLS41ODRWOC42NjdhLjU4My41ODMgMCAwIDAtLjU4My0uNTg0aC04WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-plus{mask-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXBsdXMiPjxwYXRoIGQ9Ik01IDEyaDE0Ii8+PHBhdGggZD0iTTEyIDV2MTQiLz48L3N2Zz4=)}.ag-charts-icon-crossline-add-line{mask-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNOC43NSA0LjVhLjc1Ljc1IDAgMCAwLTEuNSAwdjIuNzVINC41YS43NS43NSAwIDAgMCAwIDEuNWgyLjc1djIuNzVhLjc1Ljc1IDAgMCAwIDEuNSAwVjguNzVoMi43NWEuNzUuNzUgMCAwIDAgMC0xLjVIOC43NXoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}\";\n\n// packages/ag-charts-community/src/chart/dom/domManager.ts\nvar CANVAS_CENTER_CLASS = \"canvas-center\";\nvar DOM_ELEMENT_CLASSES = [\"styles\", CANVAS_CENTER_CLASS, \"canvas\", \"canvas-proxy\", \"canvas-overlay\"];\nvar domElementConfig = /* @__PURE__ */ new Map([\n  [\"styles\", { childElementType: \"style\" }],\n  [\"canvas\", { childElementType: \"canvas\", eventTypes: [\"focus\", \"blur\"] }],\n  [\"canvas-proxy\", { childElementType: \"div\" }],\n  [\"canvas-overlay\", { childElementType: \"div\" }],\n  [CANVAS_CENTER_CLASS, { childElementType: \"div\" }]\n]);\nfunction setupObserver(element2, cb) {\n  if (typeof IntersectionObserver === \"undefined\")\n    return;\n  const observer = new IntersectionObserver(\n    (entries) => {\n      for (const entry of entries) {\n        if (entry.target === element2) {\n          cb(entry.intersectionRatio);\n        }\n      }\n    },\n    { root: element2 }\n  );\n  observer.observe(element2);\n  return observer;\n}\nvar DOMManager = class extends BaseManager {\n  constructor(container) {\n    super();\n    this.containerSize = void 0;\n    this.sizeMonitor = new SizeMonitor();\n    const templateEl = createElement(\"div\");\n    templateEl.innerHTML = domLayout_default;\n    this.element = templateEl.children.item(0);\n    this.rootElements = DOM_ELEMENT_CLASSES.reduce(\n      (r, c) => {\n        const cssClass = `ag-charts-${c}`;\n        const el = this.element.classList.contains(cssClass) ? this.element : this.element.querySelector(`.${cssClass}`);\n        if (!el)\n          throw new Error(`AG Charts - unable to find DOM element ${cssClass}`);\n        r[c] = { element: el, children: /* @__PURE__ */ new Map(), listeners: [] };\n        return r;\n      },\n      {}\n    );\n    let hidden = false;\n    this.observer = setupObserver(this.element, (intersectionRatio) => {\n      if (intersectionRatio === 0 && !hidden) {\n        this.listeners.dispatch(\"hidden\", { type: \"hidden\" });\n      }\n      hidden = intersectionRatio === 0;\n    });\n    this.setSizeOptions();\n    this.addStyles(\"dom-manager\", domStyles_default);\n    if (container) {\n      this.setContainer(container);\n    }\n  }\n  destroy() {\n    super.destroy();\n    this.observer?.unobserve(this.element);\n    if (this.container) {\n      this.sizeMonitor.unobserve(this.container);\n    }\n    Object.values(this.rootElements).forEach((el) => {\n      el.children.forEach((c) => c.remove());\n      el.element.remove();\n    });\n    this.guardedElement?.destroy();\n    this.element.remove();\n  }\n  setSizeOptions(minWidth = 300, minHeight = 300, optionsWidth, optionsHeight) {\n    const { style } = this.element;\n    style.width = `${optionsWidth ?? minWidth}px`;\n    style.height = `${optionsHeight ?? minHeight}px`;\n  }\n  updateContainerSize() {\n    const { style: centerStyle } = this.rootElements[CANVAS_CENTER_CLASS].element;\n    centerStyle.width = `${this.containerSize?.width ?? 0}px`;\n    centerStyle.height = `${this.containerSize?.height ?? 0}px`;\n  }\n  setContainer(newContainer) {\n    if (newContainer === this.container)\n      return;\n    if (this.container) {\n      this.container.removeChild(this.element);\n      this.sizeMonitor.unobserve(this.container);\n    }\n    newContainer.appendChild(this.element);\n    this.sizeMonitor.observe(newContainer, (size) => {\n      this.containerSize = size;\n      this.updateContainerSize();\n      this.listeners.dispatch(\"resize\", { type: \"resize\" });\n    });\n    this.container = newContainer;\n    this.listeners.dispatch(\"container-changed\", { type: \"container-changed\" });\n  }\n  setThemeClass(themeClassName) {\n    const themeClassNamePrefix = \"ag-charts-theme-\";\n    this.element.classList.forEach((className) => {\n      if (className.startsWith(themeClassNamePrefix) && className !== themeClassName) {\n        this.element.classList.remove(className);\n      }\n    });\n    this.element.classList.add(themeClassName);\n  }\n  createTabGuards() {\n    const canvasElement = this.rootElements[\"canvas\"].element.querySelector(\"canvas\");\n    const tabGuards = this.element.querySelectorAll(\".ag-charts-tab-guard\");\n    if (canvasElement == null || tabGuards[0] == null || tabGuards[1] == null) {\n      throw new Error(\"AG Charts - error initialising canvas tab guards\");\n    }\n    return new GuardedElement(canvasElement, tabGuards[0], tabGuards[1]);\n  }\n  setTabIndex(tabIndex) {\n    this.guardedElement ?? (this.guardedElement = this.createTabGuards());\n    this.guardedElement.tabIndex = tabIndex;\n  }\n  getBrowserFocusDelta() {\n    return this.guardedElement?.getBrowserFocusDelta() ?? 0;\n  }\n  addEventListener(type, listener, options) {\n    this.element.addEventListener(type, listener, options);\n    domElementConfig.forEach((config, elType) => {\n      if (!config.eventTypes?.includes(type))\n        return;\n      const els = this.rootElements[elType];\n      els.listeners.push([type, listener, options]);\n      els.children.forEach((el) => {\n        el.addEventListener(type, listener);\n      });\n    });\n  }\n  removeEventListener(type, listener, options) {\n    this.element.removeEventListener(type, listener, options);\n    domElementConfig.forEach((config, elType) => {\n      if (!config.eventTypes?.includes(type))\n        return;\n      const els = this.rootElements[elType];\n      els.listeners = els.listeners.filter(([t, l]) => t !== type && l !== listener);\n      els.children.forEach((el) => {\n        el.removeEventListener(type, listener, options);\n      });\n    });\n  }\n  getBoundingClientRect() {\n    return this.rootElements[\"canvas\"].element.getBoundingClientRect();\n  }\n  getDocumentRoot() {\n    const docRoot = this.container?.ownerDocument?.body ?? getDocument(\"body\");\n    let parent = this.container;\n    while (parent != null) {\n      if (parent === docRoot) {\n        return void 0;\n      }\n      if (parent.parentNode instanceof DocumentFragment) {\n        return parent;\n      }\n      parent = parent.parentNode;\n    }\n    return void 0;\n  }\n  getChildBoundingClientRect(type) {\n    const { children } = this.rootElements[type];\n    const childRects = [];\n    for (const child of children.values()) {\n      childRects.push(BBox.fromDOMRect(child.getBoundingClientRect()));\n    }\n    return BBox.merge(childRects);\n  }\n  calculateCanvasPosition(el) {\n    let x = 0;\n    let y = 0;\n    const { x: cx = 0, y: cy = 0 } = this.getChildBoundingClientRect(\"canvas\") ?? {};\n    const elRect = el.getBoundingClientRect();\n    x = elRect.x - cx;\n    y = elRect.y - cy;\n    return { x, y };\n  }\n  isManagedDOMElement(el, container = this.element) {\n    while (el && el !== container) {\n      if (el.parentElement == null)\n        return false;\n      el = el.parentElement;\n    }\n    return true;\n  }\n  isManagedChildDOMElement(el, domElementClass, id) {\n    const { children } = this.rootElements[domElementClass];\n    const search = children?.get(id);\n    return search != null && this.isManagedDOMElement(el, search);\n  }\n  isEventOverElement(event) {\n    let element2 = event.target;\n    if (element2 == null)\n      return false;\n    while (element2 !== this.element) {\n      element2 = element2.parentElement;\n      if (element2 == null)\n        return false;\n    }\n    return true;\n  }\n  addStyles(id, styles) {\n    const styleElement = this.addChild(\"styles\", id);\n    styleElement.innerHTML = styles;\n  }\n  removeStyles(id) {\n    this.removeChild(\"styles\", id);\n  }\n  updateCursor(style) {\n    this.element.style.cursor = style;\n  }\n  getCursor() {\n    return this.element.style.cursor;\n  }\n  addChild(domElementClass, id, child) {\n    const { element: element2, children, listeners } = this.rootElements[domElementClass];\n    if (!children) {\n      throw new Error(\"AG Charts - unable to create DOM elements after destroy()\");\n    }\n    if (children.has(id))\n      return children.get(id);\n    const { childElementType = \"div\" } = domElementConfig.get(domElementClass) ?? {};\n    if (child && child.tagName.toLowerCase() !== childElementType.toLowerCase()) {\n      throw new Error(\"AG Charts - mismatching DOM element type\");\n    }\n    const newChild = child ?? createElement(childElementType);\n    for (const [type, fn, opts] of listeners) {\n      newChild.addEventListener(type, fn, opts);\n    }\n    children.set(id, newChild);\n    element2?.appendChild(newChild);\n    return newChild;\n  }\n  removeChild(domElementClass, id) {\n    const { children } = this.rootElements[domElementClass];\n    if (!children)\n      return;\n    if (!children.has(id))\n      return;\n    children.get(id)?.remove();\n    children.delete(id);\n  }\n  incrementDataCounter(name) {\n    const { dataset } = this.element;\n    dataset[name] ?? (dataset[name] = \"0\");\n    dataset[name] = String(Number(dataset[name]) + 1);\n  }\n};\n\n// packages/ag-charts-community/src/scene/polyRoots.ts\nfunction linearRoot(a, b) {\n  const t = -b / a;\n  return a !== 0 && t >= 0 && t <= 1 ? [t] : [];\n}\nfunction quadraticRoots(a, b, c) {\n  if (a === 0) {\n    return linearRoot(b, c);\n  }\n  const D = b * b - 4 * a * c;\n  const roots = [];\n  if (D === 0) {\n    const t = -b / (2 * a);\n    if (t >= 0 && t <= 1) {\n      roots.push(t);\n    }\n  } else if (D > 0) {\n    const rD = Math.sqrt(D);\n    const t1 = (-b - rD) / (2 * a);\n    const t2 = (-b + rD) / (2 * a);\n    if (t1 >= 0 && t1 <= 1) {\n      roots.push(t1);\n    }\n    if (t2 >= 0 && t2 <= 1) {\n      roots.push(t2);\n    }\n  }\n  return roots;\n}\nfunction cubicRoots(a, b, c, d) {\n  if (a === 0) {\n    return quadraticRoots(b, c, d);\n  }\n  const A = b / a;\n  const B = c / a;\n  const C = d / a;\n  const Q = (3 * B - A * A) / 9;\n  const R = (9 * A * B - 27 * C - 2 * A * A * A) / 54;\n  const D = Q * Q * Q + R * R;\n  const third = 1 / 3;\n  const roots = [];\n  if (D >= 0) {\n    const rD = Math.sqrt(D);\n    const S = Math.sign(R + rD) * Math.pow(Math.abs(R + rD), third);\n    const T = Math.sign(R - rD) * Math.pow(Math.abs(R - rD), third);\n    const Im = Math.abs(Math.sqrt(3) * (S - T) / 2);\n    const t = -third * A + (S + T);\n    if (t >= 0 && t <= 1) {\n      roots.push(t);\n    }\n    if (Im === 0) {\n      const t2 = -third * A - (S + T) / 2;\n      if (t2 >= 0 && t2 <= 1) {\n        roots.push(t2);\n      }\n    }\n  } else {\n    const theta = Math.acos(R / Math.sqrt(-Q * Q * Q));\n    const thirdA = third * A;\n    const twoSqrtQ = 2 * Math.sqrt(-Q);\n    const t1 = twoSqrtQ * Math.cos(third * theta) - thirdA;\n    const t2 = twoSqrtQ * Math.cos(third * (theta + 2 * Math.PI)) - thirdA;\n    const t3 = twoSqrtQ * Math.cos(third * (theta + 4 * Math.PI)) - thirdA;\n    if (t1 >= 0 && t1 <= 1) {\n      roots.push(t1);\n    }\n    if (t2 >= 0 && t2 <= 1) {\n      roots.push(t2);\n    }\n    if (t3 >= 0 && t3 <= 1) {\n      roots.push(t3);\n    }\n  }\n  return roots;\n}\n\n// packages/ag-charts-community/src/scene/intersection.ts\nfunction segmentIntersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\n  const d = (ax2 - ax1) * (by2 - by1) - (ay2 - ay1) * (bx2 - bx1);\n  if (d === 0) {\n    return 0;\n  }\n  const ua = ((bx2 - bx1) * (ay1 - by1) - (ax1 - bx1) * (by2 - by1)) / d;\n  const ub = ((ax2 - ax1) * (ay1 - by1) - (ay2 - ay1) * (ax1 - bx1)) / d;\n  if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n    return 1;\n  }\n  return 0;\n}\nfunction cubicSegmentIntersections(px1, py1, px2, py2, px3, py3, px4, py4, x1, y1, x2, y2) {\n  let intersections = 0;\n  const A = y1 - y2;\n  const B = x2 - x1;\n  const C = x1 * (y2 - y1) - y1 * (x2 - x1);\n  const bx = bezierCoefficients(px1, px2, px3, px4);\n  const by = bezierCoefficients(py1, py2, py3, py4);\n  const a = A * bx[0] + B * by[0];\n  const b = A * bx[1] + B * by[1];\n  const c = A * bx[2] + B * by[2];\n  const d = A * bx[3] + B * by[3] + C;\n  const roots = cubicRoots(a, b, c, d);\n  for (const t of roots) {\n    const tt = t * t;\n    const ttt = t * tt;\n    const x = bx[0] * ttt + bx[1] * tt + bx[2] * t + bx[3];\n    const y = by[0] * ttt + by[1] * tt + by[2] * t + by[3];\n    let s;\n    if (x1 === x2) {\n      s = (y - y1) / (y2 - y1);\n    } else {\n      s = (x - x1) / (x2 - x1);\n    }\n    if (s >= 0 && s <= 1) {\n      intersections++;\n    }\n  }\n  return intersections;\n}\nfunction bezierCoefficients(P1, P2, P3, P4) {\n  return [\n    // Bézier expressed as matrix operations:\n    -P1 + 3 * P2 - 3 * P3 + P4,\n    //                 |-1  3 -3  1| |P1|\n    3 * P1 - 6 * P2 + 3 * P3,\n    //   [t^3 t^2 t 1] | 3 -6  3  0| |P2|\n    -3 * P1 + 3 * P2,\n    //                 |-3  3  0  0| |P3|\n    P1\n    //                 | 1  0  0  0| |P4|\n  ];\n}\nfunction arcIntersections(cx, cy, r, startAngle, endAngle, counterClockwise, x1, y1, x2, y2) {\n  if (isNaN(cx) || isNaN(cy)) {\n    return 0;\n  }\n  if (counterClockwise) {\n    [endAngle, startAngle] = [startAngle, endAngle];\n  }\n  const k = (y2 - y1) / (x2 - x1);\n  const y0 = y1 - k * x1;\n  const a = Math.pow(k, 2) + 1;\n  const b = 2 * (k * (y0 - cy) - cx);\n  const c = Math.pow(cx, 2) + Math.pow(y0 - cy, 2) - Math.pow(r, 2);\n  const d = Math.pow(b, 2) - 4 * a * c;\n  if (d < 0) {\n    return 0;\n  }\n  const i1x = (-b + Math.sqrt(d)) / 2 / a;\n  const i2x = (-b - Math.sqrt(d)) / 2 / a;\n  let intersections = 0;\n  [i1x, i2x].forEach((x) => {\n    const isXInsideLine = x >= Math.min(x1, x2) && x <= Math.max(x1, x2);\n    if (!isXInsideLine) {\n      return;\n    }\n    const y = k * x + y0;\n    const adjacent = x - cx;\n    const opposite = y - cy;\n    const angle2 = Math.atan2(opposite, adjacent);\n    if (isBetweenAngles(angle2, startAngle, endAngle)) {\n      intersections++;\n    }\n  });\n  return intersections;\n}\n\n// packages/ag-charts-community/src/scene/extendedPath2D.ts\nvar ExtendedPath2D = class {\n  constructor() {\n    // The methods of this class will likely be called many times per animation frame,\n    // and any allocation can trigger a GC cycle during animation, so we attempt\n    // to minimize the number of allocations.\n    this.path2d = new Path2D();\n    this.previousCommands = [];\n    this.previousParams = [];\n    this.previousClosedPath = false;\n    this.commands = [];\n    this.params = [];\n    this.openedPath = false;\n    this.closedPath = false;\n  }\n  isDirty() {\n    return this.closedPath !== this.previousClosedPath || this.previousCommands.length !== this.commands.length || this.previousParams.length !== this.params.length || this.previousCommands.toString() !== this.commands.toString() || this.previousParams.toString() !== this.params.toString();\n  }\n  getPath2D() {\n    return this.path2d;\n  }\n  moveTo(x, y) {\n    this.openedPath = true;\n    this.path2d.moveTo(x, y);\n    this.commands.push(0 /* Move */);\n    this.params.push(x, y);\n  }\n  lineTo(x, y) {\n    if (this.openedPath) {\n      this.path2d.lineTo(x, y);\n      this.commands.push(1 /* Line */);\n      this.params.push(x, y);\n    } else {\n      this.moveTo(x, y);\n    }\n  }\n  rect(x, y, width, height) {\n    this.moveTo(x, y);\n    this.lineTo(x + width, y);\n    this.lineTo(x + width, y + height);\n    this.lineTo(x, y + height);\n    this.closePath();\n  }\n  roundRect(x, y, width, height, radii) {\n    radii = Math.min(radii, width / 2, height / 2);\n    this.moveTo(x, y + radii);\n    this.arc(x + radii, y + radii, radii, Math.PI, 1.5 * Math.PI);\n    this.lineTo(x + radii, y);\n    this.lineTo(x + width - radii, y);\n    this.arc(x + width - radii, y + radii, radii, 1.5 * Math.PI, 2 * Math.PI);\n    this.lineTo(x + width, y + radii);\n    this.lineTo(x + width, y + height - radii);\n    this.arc(x + width - radii, y + height - radii, radii, 0, Math.PI / 2);\n    this.lineTo(x + width - radii, y + height);\n    this.lineTo(x + radii, y + height);\n    this.arc(x + +radii, y + height - radii, radii, Math.PI / 2, Math.PI);\n    this.lineTo(x, y + height - radii);\n    this.closePath();\n  }\n  arc(x, y, r, sAngle, eAngle, counterClockwise) {\n    this.openedPath = true;\n    this.path2d.arc(x, y, r, sAngle, eAngle, counterClockwise);\n    this.commands.push(2 /* Arc */);\n    this.params.push(x, y, r, sAngle, eAngle, counterClockwise ? 1 : 0);\n  }\n  cubicCurveTo(cx1, cy1, cx2, cy2, x, y) {\n    if (!this.openedPath) {\n      this.moveTo(cx1, cy1);\n    }\n    this.path2d.bezierCurveTo(cx1, cy1, cx2, cy2, x, y);\n    this.commands.push(3 /* Curve */);\n    this.params.push(cx1, cy1, cx2, cy2, x, y);\n  }\n  closePath() {\n    if (this.openedPath) {\n      this.path2d.closePath();\n      this.commands.push(4 /* ClosePath */);\n      this.openedPath = false;\n      this.closedPath = true;\n    }\n  }\n  clear(trackChanges) {\n    if (trackChanges) {\n      this.previousCommands = this.commands;\n      this.previousParams = this.params;\n      this.previousClosedPath = this.closedPath;\n    }\n    this.path2d = new Path2D();\n    this.openedPath = false;\n    this.closedPath = false;\n    this.commands = [];\n    this.params = [];\n  }\n  isPointInPath(x, y) {\n    const commands = this.commands;\n    const params = this.params;\n    const cn = commands.length;\n    const ox = -1e4;\n    const oy = -1e4;\n    let sx = NaN;\n    let sy = NaN;\n    let px = 0;\n    let py = 0;\n    let intersectionCount = 0;\n    for (let ci = 0, pi = 0; ci < cn; ci++) {\n      switch (commands[ci]) {\n        case 0 /* Move */:\n          intersectionCount += segmentIntersection(sx, sy, px, py, ox, oy, x, y);\n          px = params[pi++];\n          sx = px;\n          py = params[pi++];\n          sy = py;\n          break;\n        case 1 /* Line */:\n          intersectionCount += segmentIntersection(px, py, params[pi++], params[pi++], ox, oy, x, y);\n          px = params[pi - 2];\n          py = params[pi - 1];\n          break;\n        case 3 /* Curve */:\n          intersectionCount += cubicSegmentIntersections(\n            px,\n            py,\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            ox,\n            oy,\n            x,\n            y\n          );\n          px = params[pi - 2];\n          py = params[pi - 1];\n          break;\n        case 2 /* Arc */:\n          const cx = params[pi++];\n          const cy = params[pi++];\n          const r = params[pi++];\n          const startAngle = params[pi++];\n          const endAngle = params[pi++];\n          const counterClockwise = Boolean(params[pi++]);\n          intersectionCount += arcIntersections(\n            cx,\n            cy,\n            r,\n            startAngle,\n            endAngle,\n            counterClockwise,\n            ox,\n            oy,\n            x,\n            y\n          );\n          if (!isNaN(sx)) {\n            const startX = cx + Math.cos(startAngle) * r;\n            const startY = cy + Math.sin(startAngle) * r;\n            intersectionCount += segmentIntersection(px, py, startX, startY, ox, oy, x, y);\n          }\n          px = cx + Math.cos(endAngle) * r;\n          py = cy + Math.sin(endAngle) * r;\n          break;\n        case 4 /* ClosePath */:\n          intersectionCount += segmentIntersection(sx, sy, px, py, ox, oy, x, y);\n          break;\n      }\n    }\n    return intersectionCount % 2 === 1;\n  }\n  distanceSquared(x, y) {\n    let best = Infinity;\n    const commands = this.commands;\n    const params = this.params;\n    const cn = commands.length;\n    let sx = NaN;\n    let sy = NaN;\n    let px = 0;\n    let py = 0;\n    for (let ci = 0, pi = 0; ci < cn; ci++) {\n      switch (commands[ci]) {\n        case 0 /* Move */:\n          px = sx = params[pi++];\n          py = sy = params[pi++];\n          break;\n        case 1 /* Line */: {\n          const nx = params[pi++];\n          const ny = params[pi++];\n          best = lineDistanceSquared(x, y, px, py, nx, ny, best);\n          break;\n        }\n        case 3 /* Curve */:\n          Logger.error(\"Command.Curve distanceSquare not implemented\");\n          break;\n        case 2 /* Arc */: {\n          const cx = params[pi++];\n          const cy = params[pi++];\n          const r = params[pi++];\n          const startAngle = params[pi++];\n          const endAngle = params[pi++];\n          const startX = cx + Math.cos(startAngle) * r;\n          const startY = cy + Math.sin(startAngle) * r;\n          const counterClockwise = Boolean(params[pi++]);\n          best = lineDistanceSquared(x, y, px, py, startX, startY, best);\n          best = arcDistanceSquared(x, y, cx, cy, r, startAngle, endAngle, counterClockwise, best);\n          px = cx + Math.cos(endAngle) * r;\n          py = cy + Math.sin(endAngle) * r;\n          break;\n        }\n        case 4 /* ClosePath */:\n          best = lineDistanceSquared(x, y, px, py, sx, sy, best);\n          break;\n      }\n    }\n    return best;\n  }\n  getPoints() {\n    const { commands, params } = this;\n    const coords = [];\n    let pi = 0;\n    for (let ci = 0; ci < commands.length; ci++) {\n      switch (commands[ci]) {\n        case 0 /* Move */:\n        case 1 /* Line */:\n          coords.push({ x: params[pi++], y: params[pi++] });\n          break;\n        case 3 /* Curve */:\n          pi += 4;\n          coords.push({ x: params[pi++], y: params[pi++] });\n          break;\n        case 2 /* Arc */:\n          coords.push({ x: params[pi++], y: params[pi++] });\n          pi += 4;\n          break;\n        case 4 /* ClosePath */:\n          break;\n      }\n    }\n    return coords;\n  }\n  // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d\n  computeSVGDataPath(ox, oy) {\n    const buffer = [];\n    const { commands, params } = this;\n    let pi = 0;\n    for (let ci = 0; ci < commands.length; ci++) {\n      switch (commands[ci]) {\n        case 0 /* Move */:\n          buffer.push(\"M\", ox + params[pi++], oy + params[pi++]);\n          break;\n        case 1 /* Line */:\n          buffer.push(\"L\", ox + params[pi++], oy + params[pi++]);\n          break;\n        case 3 /* Curve */:\n          buffer.push(\n            \"C\",\n            ox + params[pi++],\n            oy + params[pi++],\n            ox + params[pi++],\n            oy + params[pi++],\n            ox + params[pi++],\n            oy + params[pi++]\n          );\n          break;\n        case 2 /* Arc */:\n          const [cx, cy, r, a0, a1, ccw] = [\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++]\n          ];\n          const x0 = ox + cx + Math.cos(a0) * r;\n          const y0 = oy + cy + Math.sin(a0) * r;\n          const x1 = ox + cx + Math.cos(a1) * r;\n          const y1 = oy + cy + Math.sin(a1) * r;\n          const largeArcFlag = angleDiff(a0, a1, !!ccw) > Math.PI ? 1 : 0;\n          const sweepFlag = (ccw + 1) % 2;\n          buffer.push(\"L\", x0, y0, \"A\", r, r, 0, largeArcFlag, sweepFlag, x1, y1);\n          break;\n        case 4 /* ClosePath */:\n          buffer.push(\"Z\");\n          break;\n      }\n    }\n    return buffer.join(\" \");\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/path.ts\nfunction ScenePathChangeDetection(opts) {\n  const { redraw = 3 /* MAJOR */, changeCb, convertor } = opts ?? {};\n  return SceneChangeDetection({ redraw, type: \"path\", convertor, changeCb });\n}\nvar Path = class extends Shape {\n  constructor() {\n    super(...arguments);\n    /**\n     * Declare a path to retain for later rendering and hit testing\n     * using custom Path2D class. Think of it as a TypeScript version\n     * of the native Path2D (with some differences) that works in all browsers.\n     */\n    this.path = new ExtendedPath2D();\n    this._clipX = NaN;\n    this._clipY = NaN;\n    /**\n     * The path only has to be updated when certain attributes change.\n     * For example, if transform attributes (such as `translationX`)\n     * are changed, we don't have to update the path. The `dirtyPath` flag\n     * is how we keep track if the path has to be updated or not.\n     */\n    this._dirtyPath = true;\n  }\n  set clipX(value) {\n    this._clipX = value;\n    this.dirtyPath = true;\n  }\n  set clipY(value) {\n    this._clipY = value;\n    this.dirtyPath = true;\n  }\n  set dirtyPath(value) {\n    if (this._dirtyPath !== value) {\n      this._dirtyPath = value;\n      if (value) {\n        this.markDirty(this, 3 /* MAJOR */);\n      }\n    }\n  }\n  get dirtyPath() {\n    return this._dirtyPath;\n  }\n  checkPathDirty() {\n    if (this._dirtyPath) {\n      return;\n    }\n    this.dirtyPath = this.path.isDirty() || (this.fillShadow?.isDirty() ?? false) || (this._clipPath?.isDirty() ?? false);\n  }\n  isPointInPath(x, y) {\n    const point = this.transformPoint(x, y);\n    return this.path.closedPath && this.path.isPointInPath(point.x, point.y);\n  }\n  distanceSquared(x, y) {\n    const point = this.transformPoint(x, y);\n    return this.distanceSquaredTransformedPoint(point.x, point.y);\n  }\n  computeSVGDataPath() {\n    const { x, y } = this.inverseTransformPoint(0, 0);\n    return this.path.computeSVGDataPath(x, y);\n  }\n  distanceSquaredTransformedPoint(x, y) {\n    if (this.path.closedPath && this.path.isPointInPath(x, y)) {\n      return 0;\n    }\n    return this.path.distanceSquared(x, y);\n  }\n  isDirtyPath() {\n    return false;\n  }\n  updatePath() {\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    this.computeTransformMatrix();\n    this.matrix.toContext(ctx);\n    if (this.dirtyPath || this.isDirtyPath()) {\n      this.updatePath();\n      this.dirtyPath = false;\n    }\n    if (!isNaN(this._clipX) && !isNaN(this._clipY) && this.clipMode != null) {\n      ctx.save();\n      const margin = this.strokeWidth / 2;\n      this._clipPath ?? (this._clipPath = new ExtendedPath2D());\n      this._clipPath.clear();\n      this._clipPath.rect(-margin, -margin, this._clipX + margin, this._clipY + margin + margin);\n      if (this.clipMode === \"normal\") {\n        ctx.clip(this._clipPath?.getPath2D());\n      }\n      if (this._clipX > 0 && this._clipY > 0) {\n        this.drawPath(ctx);\n      }\n      if (this.clipMode === \"punch-out\") {\n        ctx.clip(this._clipPath?.getPath2D());\n        const { x = -1e4, y = -1e4, width = 2e4, height = 2e4 } = this.computeBBox() ?? {};\n        ctx.clearRect(x, y, width, height);\n      }\n      ctx.restore();\n    } else {\n      this.drawPath(ctx);\n    }\n    this.fillShadow?.markClean();\n    super.render(renderCtx);\n  }\n  drawPath(ctx) {\n    this.fillStroke(ctx, this.path.getPath2D());\n  }\n};\nPath.className = \"Path\";\n__decorateClass([\n  ScenePathChangeDetection()\n], Path.prototype, \"clipMode\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Path.prototype, \"clipX\", 1);\n__decorateClass([\n  ScenePathChangeDetection()\n], Path.prototype, \"clipY\", 1);\n\n// packages/ag-charts-community/src/chart/dom/focusStyles.ts\nvar focusStyles_exports = {};\n__export(focusStyles_exports, {\n  block: () => block,\n  css: () => focusStyles_default,\n  elements: () => elements,\n  modifiers: () => modifiers\n});\n\n// packages/ag-charts-community/src/chart/dom/focusStyles.css\nvar focusStyles_default = \".ag-charts-focus.ag-charts-focus__indicator{position:absolute;display:block;pointer-events:none;user-select:none;width:100%;height:100%}.ag-charts-focus.ag-charts-focus__indicator > div{position:absolute;outline:var(--ag-charts-focus-border);outline-width:2px;box-shadow:var(--ag-charts-focus-border-shadow)}.ag-charts-focus.ag-charts-focus__indicator > svg{width:100%;height:100%;fill:none;stroke:var(--ag-charts-focus-border-color);stroke-width:2px}.ag-charts-focus--hidden{visibility:hidden}\";\n\n// packages/ag-charts-community/src/chart/dom/focusStyles.ts\nvar block = \"ag-charts-focus\";\nvar elements = { indicator: \"ag-charts-focus__indicator\", svg: \"ag-charts-focus__svg\" };\nvar modifiers = { hidden: \"ag-charts-focus--hidden\" };\n\n// packages/ag-charts-community/src/chart/dom/focusIndicator.ts\nvar FocusIndicator = class {\n  constructor(domManager) {\n    this.domManager = domManager;\n    const { css, block: block3, elements: elements3, modifiers: modifiers3 } = focusStyles_exports;\n    this.div = getDocument().createElement(\"div\");\n    this.svg = getDocument().createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    this.path = getDocument().createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    this.svg.append(this.path);\n    domManager.addStyles(block3, css);\n    this.element = domManager.addChild(\"canvas-overlay\", block3);\n    this.element.classList.add(block3, elements3.indicator, modifiers3.hidden);\n    this.element.append(this.svg);\n  }\n  destroy() {\n    this.domManager.removeStyles(block);\n    this.domManager.removeChild(\"canvas-overlay\", block);\n  }\n  updateBounds(bounds) {\n    if (bounds === void 0) {\n      this.element.classList.add(modifiers.hidden);\n    } else if (bounds instanceof Path) {\n      this.path.setAttribute(\"d\", bounds.computeSVGDataPath());\n      this.show(this.svg);\n    } else {\n      setElementBBox(this.div, bounds);\n      this.show(this.div);\n    }\n  }\n  show(child) {\n    this.element.classList.remove(modifiers.hidden);\n    this.element.innerHTML = \"\";\n    this.element.append(child);\n  }\n};\n\n// packages/ag-charts-community/src/chart/dom/proxyInteractionService.ts\nfunction checkType(type, meta) {\n  return meta.params?.type === type;\n}\nfunction allocateMeta(params) {\n  const map = { button: \"button\", slider: \"input\", toolbar: \"div\", group: \"div\" };\n  return { params, result: createElement(map[params.type]) };\n}\nvar ProxyInteractionService = class {\n  constructor(updateService, localeManager, domManager, focusIndicator) {\n    this.localeManager = localeManager;\n    this.domManager = domManager;\n    this.focusIndicator = focusIndicator;\n    // This debug option make the proxies button partially transparent instead of fully transparent.\n    // To enabled this option, set window.agChartsDebug = ['showDOMProxies'].\n    this.debugShowDOMProxies = Debug.check(\"showDOMProxies\");\n    this.destroyFns = [];\n    this.destroyFns.push(updateService.addListener(\"update-complete\", () => this.update()));\n  }\n  destroy() {\n    this.destroyFns.forEach((fn) => fn());\n  }\n  update() {\n    if (this.focusable) {\n      this.focusIndicator.updateBounds(this.focusable.computeTransformedBBox());\n    }\n  }\n  addLocalisation(fn) {\n    fn();\n    this.destroyFns.push(this.localeManager.addListener(\"locale-changed\", fn));\n  }\n  createProxyContainer(args) {\n    const meta = allocateMeta(args);\n    const { params, result: div } = meta;\n    this.domManager.addChild(\"canvas-overlay\", params.id, div);\n    div.classList.add(...params.classList);\n    div.style.pointerEvents = \"none\";\n    div.role = params.type;\n    div.ariaOrientation = params.ariaOrientation;\n    this.addLocalisation(() => {\n      div.ariaLabel = this.localeManager.t(params.ariaLabel.id, params.ariaLabel.params);\n    });\n    return div;\n  }\n  createProxyElement(args) {\n    const meta = allocateMeta(args);\n    if (checkType(\"button\", meta)) {\n      const { params, result: button } = meta;\n      this.initElement(params, button);\n      if (typeof params.textContent === \"string\") {\n        button.textContent = params.textContent;\n      } else {\n        const { textContent } = params;\n        this.addLocalisation(() => {\n          button.textContent = this.localeManager.t(textContent.id, textContent.params);\n        });\n      }\n    }\n    if (checkType(\"slider\", meta)) {\n      const { params, result: slider } = meta;\n      this.initElement(params, slider);\n      slider.type = \"range\";\n      slider.role = \"presentation\";\n      slider.style.margin = \"0px\";\n      slider.ariaOrientation = params.ariaOrientation;\n      this.addLocalisation(() => {\n        slider.ariaLabel = this.localeManager.t(params.ariaLabel.id, params.ariaLabel.params);\n      });\n    }\n    return meta.result;\n  }\n  initElement(params, element2) {\n    const { focusable, onclick, onchange, onfocus, onblur, tabIndex, id, parent } = params;\n    element2.id = id;\n    element2.style.pointerEvents = \"none\";\n    element2.style.opacity = this.debugShowDOMProxies ? \"0.25\" : \"0\";\n    element2.style.position = \"absolute\";\n    element2.style.overflow = \"hidden\";\n    if (tabIndex !== void 0) {\n      element2.tabIndex = tabIndex;\n    }\n    parent.appendChild(element2);\n    element2.addEventListener(\"focus\", (_event) => {\n      this.focusable = focusable;\n      element2.style.setProperty(\"pointerEvents\", null);\n      this.focusIndicator.updateBounds(focusable.computeTransformedBBox());\n    });\n    element2.addEventListener(\"blur\", (_event) => {\n      this.focusable = void 0;\n      element2.style.pointerEvents = \"none\";\n      this.focusIndicator.updateBounds(void 0);\n    });\n    if (onclick) {\n      element2.addEventListener(\"click\", onclick);\n    }\n    if (onfocus) {\n      element2.addEventListener(\"focus\", onfocus);\n    }\n    if (onblur) {\n      element2.addEventListener(\"blur\", onblur);\n    }\n    if (onchange) {\n      element2.addEventListener(\"change\", onchange);\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/animationBatch.ts\nvar AnimationBatch = class {\n  constructor(maxAnimationTime) {\n    this.maxAnimationTime = maxAnimationTime;\n    this.debug = Debug.create(true, \"animation\");\n    this.controllers = /* @__PURE__ */ new Map();\n    this.stoppedCbs = /* @__PURE__ */ new Set();\n    this.currentPhase = 0;\n    this.phases = new Map(PHASE_ORDER.map((p) => [p, []]));\n    this.skipAnimations = false;\n    this.animationTimeConsumed = 0;\n    /** Guard against premature animation execution. */\n    this.isReady = false;\n  }\n  get size() {\n    return this.controllers.size;\n  }\n  get consumedTimeMs() {\n    return this.animationTimeConsumed;\n  }\n  isActive() {\n    return this.controllers.size > 0;\n  }\n  getActiveControllers() {\n    return this.phases.get(PHASE_ORDER[this.currentPhase]) ?? [];\n  }\n  checkOverlappingId(id) {\n    if (id != null && this.controllers.has(id)) {\n      this.controllers.get(id).stop();\n      this.debug(`Skipping animation batch due to update of existing animation: ${id}`);\n      this.skip();\n    }\n  }\n  addAnimation(animation) {\n    if (animation.isComplete)\n      return;\n    const animationPhaseIdx = PHASE_ORDER.indexOf(animation.phase);\n    if (animationPhaseIdx < this.currentPhase) {\n      this.debug(`Skipping animation due to being for an earlier phase`, animation.id);\n      animation.stop();\n      return;\n    }\n    this.controllers.set(animation.id, animation);\n    this.phases.get(animation.phase)?.push(animation);\n  }\n  removeAnimation(animation) {\n    this.controllers.delete(animation.id);\n    const phase = this.phases.get(animation.phase);\n    const index = phase?.indexOf(animation);\n    if (index != null && index >= 0) {\n      phase?.splice(index, 1);\n    }\n  }\n  progress(deltaTime) {\n    if (!this.isReady)\n      return;\n    let unusedTime = deltaTime === 0 ? 0.01 : deltaTime;\n    const refresh = () => {\n      const phase2 = PHASE_ORDER[this.currentPhase];\n      return {\n        phaseControllers: [...this.getActiveControllers()],\n        phase: phase2,\n        phaseMeta: PHASE_METADATA[phase2]\n      };\n    };\n    let { phase, phaseControllers, phaseMeta } = refresh();\n    const arePhasesComplete = () => PHASE_ORDER[this.currentPhase] == null;\n    const progressPhase = () => {\n      ({ phase, phaseControllers, phaseMeta } = refresh());\n      while (!arePhasesComplete() && phaseControllers.length === 0) {\n        this.currentPhase++;\n        ({ phase, phaseControllers, phaseMeta } = refresh());\n        this.debug(`AnimationBatch - phase changing to ${phase}`, { unusedTime }, phaseControllers);\n      }\n    };\n    const total = this.controllers.size;\n    this.debug(`AnimationBatch - ${deltaTime}ms; phase ${phase} with ${phaseControllers?.length} of ${total}`);\n    do {\n      const phaseDeltaTime = unusedTime;\n      const skipPhase = phaseMeta.skipIfNoEarlierAnimations && this.animationTimeConsumed === 0;\n      let completeCount = 0;\n      for (const controller of phaseControllers) {\n        if (skipPhase) {\n          controller.stop();\n        } else {\n          unusedTime = Math.min(controller.update(phaseDeltaTime), unusedTime);\n        }\n        if (controller.isComplete) {\n          completeCount++;\n          this.removeAnimation(controller);\n        }\n      }\n      this.animationTimeConsumed += phaseDeltaTime - unusedTime;\n      this.debug(`AnimationBatch - updated ${phaseControllers.length} controllers; ${completeCount} completed`);\n      this.debug(`AnimationBatch - animationTimeConsumed: ${this.animationTimeConsumed}`);\n      progressPhase();\n    } while (unusedTime > 0 && !arePhasesComplete());\n    if (this.animationTimeConsumed > this.maxAnimationTime) {\n      Logger.warnOnce(\n        \"Animation batch exceeded max animation time, skipping.\",\n        new Map(this.controllers.entries())\n      );\n      this.stop();\n    }\n  }\n  ready() {\n    if (this.isReady)\n      return;\n    this.isReady = true;\n    this.debug(`AnimationBatch - ready; skipped: ${this.skipAnimations}`, [...this.controllers]);\n    let skipAll = true;\n    for (const [, controller] of this.controllers) {\n      if (controller.duration > 0 && PHASE_METADATA[controller.phase].skipIfNoEarlierAnimations !== true) {\n        skipAll = false;\n        break;\n      }\n    }\n    if (!skipAll) {\n      for (const [, controller] of this.controllers) {\n        if (controller.autoplay) {\n          controller.play(true);\n        }\n      }\n    }\n  }\n  skip(skip = true) {\n    if (this.skipAnimations === false && skip === true) {\n      for (const controller of this.controllers.values()) {\n        controller.stop();\n      }\n      this.controllers.clear();\n    }\n    this.skipAnimations = skip;\n  }\n  play() {\n    for (const controller of this.controllers.values()) {\n      controller.play();\n    }\n  }\n  pause() {\n    for (const controller of this.controllers.values()) {\n      controller.pause();\n    }\n  }\n  stop() {\n    for (const controller of this.controllers.values()) {\n      try {\n        controller.stop();\n        this.removeAnimation(controller);\n      } catch (error) {\n        Logger.error(\"Error during animation stop\", error);\n      }\n    }\n    this.dispatchStopped();\n  }\n  stopByAnimationId(id) {\n    if (id != null && this.controllers.has(id)) {\n      const controller = this.controllers.get(id);\n      if (controller) {\n        controller.stop();\n        this.removeAnimation(controller);\n      }\n    }\n  }\n  stopByAnimationGroupId(id) {\n    for (const controller of this.controllers.values()) {\n      if (controller.groupId === id) {\n        this.stopByAnimationId(controller.id);\n      }\n    }\n  }\n  dispatchStopped() {\n    this.stoppedCbs.forEach((cb) => cb());\n    this.stoppedCbs.clear();\n  }\n  isSkipped() {\n    return this.skipAnimations;\n  }\n  destroy() {\n    this.stop();\n    this.controllers.clear();\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/animationManager.ts\nfunction validAnimationDuration(testee) {\n  if (testee == null)\n    return true;\n  return !isNaN(testee) && testee >= 0 && testee <= 2;\n}\nvar AnimationManager = class extends BaseManager {\n  constructor(interactionManager, chartUpdateMutex) {\n    super();\n    this.interactionManager = interactionManager;\n    this.chartUpdateMutex = chartUpdateMutex;\n    this.defaultDuration = 1e3;\n    this.batch = new AnimationBatch(this.defaultDuration * 1.5);\n    this.debug = Debug.create(true, \"animation\");\n    this.rafAvailable = typeof requestAnimationFrame !== \"undefined\";\n    this.isPlaying = false;\n    this.requestId = null;\n    this.skipAnimations = false;\n    this.currentAnonymousAnimationId = 0;\n  }\n  /**\n   * Create an animation to tween a value between the `from` and `to` properties. If an animation already exists\n   * with the same `id`, immediately stop it.\n   */\n  animate({ ...opts }) {\n    const batch = this.batch;\n    try {\n      batch.checkOverlappingId(opts.id);\n    } catch (error) {\n      this.failsafeOnError(error);\n      return;\n    }\n    let { id } = opts;\n    if (id == null) {\n      id = `__${this.currentAnonymousAnimationId}`;\n      this.currentAnonymousAnimationId += 1;\n    }\n    const skip = this.isSkipped() || opts.phase === \"none\";\n    if (skip) {\n      this.debug(\"AnimationManager - skipping animation\");\n    }\n    const { delay, duration } = opts;\n    if (!validAnimationDuration(delay)) {\n      throw new Error(`Animation delay of ${delay} is unsupported (${id})`);\n    }\n    if (!validAnimationDuration(duration)) {\n      throw new Error(`Animation duration of ${duration} is unsupported (${id})`);\n    }\n    const animation = new Animation({\n      ...opts,\n      id,\n      skip,\n      autoplay: this.isPlaying ? opts.autoplay : false,\n      phase: opts.phase,\n      defaultDuration: this.defaultDuration\n    });\n    if (this.forceTimeJump(animation, this.defaultDuration)) {\n      return;\n    }\n    this.batch.addAnimation(animation);\n    return animation;\n  }\n  play() {\n    if (this.isPlaying) {\n      return;\n    }\n    this.isPlaying = true;\n    this.debug(\"AnimationManager.play()\");\n    try {\n      this.batch.play();\n    } catch (error) {\n      this.failsafeOnError(error);\n    }\n    this.requestAnimation();\n  }\n  pause() {\n    if (!this.isPlaying) {\n      return;\n    }\n    this.isPlaying = false;\n    this.cancelAnimation();\n    this.debug(\"AnimationManager.pause()\");\n    try {\n      this.batch.pause();\n    } catch (error) {\n      this.failsafeOnError(error);\n    }\n  }\n  stop() {\n    this.isPlaying = false;\n    this.cancelAnimation();\n    this.debug(\"AnimationManager.stop()\");\n    this.batch.stop();\n  }\n  stopByAnimationId(id) {\n    try {\n      this.batch.stopByAnimationId(id);\n    } catch (error) {\n      this.failsafeOnError(error);\n    }\n  }\n  stopByAnimationGroupId(id) {\n    try {\n      this.batch.stopByAnimationGroupId(id);\n    } catch (error) {\n      this.failsafeOnError(error);\n    }\n  }\n  reset() {\n    if (this.isPlaying) {\n      this.stop();\n      this.play();\n    } else {\n      this.stop();\n    }\n  }\n  skip(skip = true) {\n    this.skipAnimations = skip;\n  }\n  isSkipped() {\n    return !this.rafAvailable || this.skipAnimations || this.batch.isSkipped();\n  }\n  isActive() {\n    return this.isPlaying && this.batch.isActive();\n  }\n  skipCurrentBatch() {\n    if (this.debug.check()) {\n      this.debug(`AnimationManager - skipCurrentBatch()`, { stack: new Error().stack });\n    }\n    this.batch.skip();\n  }\n  /** Mocking point for tests to guarantee that animation updates happen. */\n  isSkippingFrames() {\n    return true;\n  }\n  /** Mocking point for tests to capture requestAnimationFrame callbacks. */\n  scheduleAnimationFrame(cb) {\n    this.requestId = requestAnimationFrame(cb);\n  }\n  /** Mocking point for tests to skip animations to a specific point in time. */\n  forceTimeJump(_animation, _defaultDuration) {\n    return false;\n  }\n  requestAnimation() {\n    if (!this.rafAvailable)\n      return;\n    if (!this.batch.isActive() || this.requestId !== null)\n      return;\n    let prevTime;\n    const onAnimationFrame = async (time2) => {\n      const executeAnimationFrame = async () => {\n        const deltaTime = time2 - (prevTime ?? time2);\n        prevTime = time2;\n        this.debug(\"AnimationManager - onAnimationFrame()\", {\n          controllersCount: this.batch.size,\n          deltaTime\n        });\n        this.interactionManager.pushState(1 /* Animation */);\n        try {\n          this.batch.progress(deltaTime);\n        } catch (error) {\n          this.failsafeOnError(error);\n        }\n        this.listeners.dispatch(\"animation-frame\", {\n          type: \"animation-frame\",\n          deltaMs: deltaTime\n        });\n      };\n      if (this.isSkippingFrames()) {\n        await this.chartUpdateMutex.acquireImmediately(executeAnimationFrame);\n      } else {\n        await this.chartUpdateMutex.acquire(executeAnimationFrame);\n      }\n      if (this.batch.isActive()) {\n        this.scheduleAnimationFrame(onAnimationFrame);\n      } else {\n        this.batch.stop();\n        this.listeners.dispatch(\"animation-stop\", {\n          type: \"animation-stop\",\n          deltaMs: this.batch.consumedTimeMs\n        });\n      }\n    };\n    this.listeners.dispatch(\"animation-start\", {\n      type: \"animation-start\",\n      deltaMs: 0\n    });\n    this.scheduleAnimationFrame(onAnimationFrame);\n  }\n  cancelAnimation() {\n    if (this.requestId === null)\n      return;\n    cancelAnimationFrame(this.requestId);\n    this.requestId = null;\n    this.startBatch();\n  }\n  failsafeOnError(error, cancelAnimation = true) {\n    Logger.error(\"Error during animation, skipping animations\", error);\n    if (cancelAnimation) {\n      this.cancelAnimation();\n    }\n  }\n  startBatch(skipAnimations) {\n    this.debug(`AnimationManager - startBatch() with skipAnimations=${skipAnimations}.`);\n    this.reset();\n    this.batch.stop();\n    this.batch.destroy();\n    this.batch = new AnimationBatch(this.defaultDuration * 1.5);\n    if (skipAnimations === true) {\n      this.batch.skip();\n    }\n  }\n  endBatch() {\n    if (this.batch.isActive()) {\n      this.batch.ready();\n      this.requestAnimation();\n    } else {\n      this.interactionManager.popState(1 /* Animation */);\n      if (this.batch.isSkipped()) {\n        this.batch.skip(false);\n      }\n    }\n  }\n  onBatchStop(cb) {\n    this.batch.stoppedCbs.add(cb);\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/ariaAnnouncementServices.ts\nvar AriaAnnouncementService = class _AriaAnnouncementService {\n  constructor(localeManager, domManager, layoutService) {\n    this.localeManager = localeManager;\n    this.domManager = domManager;\n    this.layoutService = layoutService;\n    this.debug = Debug.create(true, \"aria\");\n    this.destroyFns = [];\n    this.liveElem = _AriaAnnouncementService.createAnnouncer();\n    this.domManager.addChild(\"canvas-proxy\", \"ag-charts-canvas-proxy\", this.liveElem);\n    this.destroyFns.push(\n      this.layoutService.addListener(\"layout-complete\", (ev) => this.onResize(ev)),\n      () => this.domManager.removeChild(\"canvas-proxy\", \"ag-charts-canvas-proxy\")\n    );\n  }\n  static createAnnouncer() {\n    const e = getDocument().createElement(\"div\");\n    e.classList.add(\"ag-charts-aria-announcer\");\n    setAttribute(e, \"role\", \"figure\");\n    setAttribute(e, \"aria-live\", \"assertive\");\n    return e;\n  }\n  destroy() {\n    this.destroyFns.forEach((fn) => fn());\n  }\n  onResize(event) {\n    this.liveElem.style.width = `${event.chart.width}px`;\n    this.liveElem.style.height = `${event.chart.height}px`;\n  }\n  announceValue(id, params) {\n    const { localeManager, liveElem } = this;\n    const value = localeManager.t(id, params);\n    this.debug(`AriaAnnouncementService - announceValue: ${value}`);\n    liveElem.textContent = \"\\xA0\";\n    setTimeout(() => liveElem.innerText = value, 16);\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/chartEventManager.ts\nvar ChartEventManager = class extends BaseManager {\n  legendItemClick(series, itemId, enabled, legendItemName) {\n    const event = {\n      type: \"legend-item-click\",\n      series,\n      itemId,\n      enabled,\n      legendItemName\n    };\n    this.listeners.dispatch(\"legend-item-click\", event);\n  }\n  legendItemDoubleClick(series, itemId, enabled, numVisibleItems, legendItemName) {\n    const event = {\n      type: \"legend-item-double-click\",\n      series,\n      itemId,\n      enabled,\n      legendItemName,\n      numVisibleItems\n    };\n    this.listeners.dispatch(\"legend-item-double-click\", event);\n  }\n  axisHover(axisId, direction) {\n    const event = {\n      type: \"axis-hover\",\n      axisId,\n      direction\n    };\n    this.listeners.dispatch(\"axis-hover\", event);\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/contextMenuRegistry.ts\nvar ContextMenuRegistry = class _ContextMenuRegistry {\n  constructor(regionManager) {\n    this.defaultActions = [];\n    this.disabledActions = /* @__PURE__ */ new Set();\n    this.hiddenActions = /* @__PURE__ */ new Set();\n    this.listeners = new Listeners();\n    const { Default: Default2, ContextMenu } = InteractionState;\n    this.destroyFns = [regionManager.listenAll(\"contextmenu\", (e) => this.onContextMenu(e), Default2 | ContextMenu)];\n  }\n  destroy() {\n    this.destroyFns.forEach((d) => d());\n  }\n  onContextMenu(event) {\n    const type = _ContextMenuRegistry.toContextType(event.region);\n    if (type === \"all\") {\n      this.dispatchContext(\"all\", event, {});\n    }\n  }\n  static toContextType(region) {\n    if (region === \"legend\" || region === \"series\") {\n      return region;\n    }\n    return \"all\";\n  }\n  static check(type, event) {\n    return event.type === type;\n  }\n  static checkCallback(desiredType, type, _callback) {\n    return desiredType === type;\n  }\n  dispatchContext(type, pointerEvent, context) {\n    const { offsetX: x, offsetY: y, sourceEvent } = pointerEvent;\n    this.listeners.dispatch(\"\", buildPreventable({ type, x, y, context, sourceEvent }));\n  }\n  addListener(handler) {\n    return this.listeners.addListener(\"\", handler);\n  }\n  filterActions(type) {\n    return this.defaultActions.filter((action) => {\n      return action.id && !this.hiddenActions.has(action.id) && [\"all\", type].includes(action.type);\n    });\n  }\n  registerDefaultAction(action) {\n    if (action.id && this.defaultActions.find(({ id }) => id === action.id)) {\n      return;\n    }\n    this.defaultActions.push(action);\n  }\n  enableAction(actionId) {\n    this.disabledActions.delete(actionId);\n  }\n  disableAction(actionId) {\n    this.disabledActions.add(actionId);\n  }\n  setActionVisiblity(actionId, visible) {\n    if (visible) {\n      this.hiddenActions.delete(actionId);\n    } else {\n      this.hiddenActions.add(actionId);\n    }\n  }\n  isDisabled(actionId) {\n    return this.disabledActions.has(actionId);\n  }\n};\n\n// packages/ag-charts-community/src/util/stateTracker.ts\nvar StateTracker = class extends Map {\n  constructor(defaultValue, defaultState) {\n    super();\n    this.defaultValue = defaultValue;\n    this.defaultState = defaultState;\n  }\n  set(key, value) {\n    this.delete(key);\n    if (typeof value !== \"undefined\") {\n      super.set(key, value);\n    }\n    return this;\n  }\n  stateId() {\n    return Array.from(this.keys()).pop() ?? this.defaultState;\n  }\n  stateValue() {\n    return Array.from(this.values()).pop() ?? this.defaultValue;\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/cursorManager.ts\nvar Cursor = /* @__PURE__ */ ((Cursor2) => {\n  Cursor2[\"Auto\"] = \"auto\";\n  Cursor2[\"Default\"] = \"default\";\n  Cursor2[\"Grab\"] = \"grab\";\n  Cursor2[\"Grabbing\"] = \"grabbing\";\n  Cursor2[\"Move\"] = \"move\";\n  Cursor2[\"NotAllowed\"] = \"not-allowed\";\n  Cursor2[\"Pointer\"] = \"pointer\";\n  Cursor2[\"EWResize\"] = \"ew-resize\";\n  Cursor2[\"NSResize\"] = \"ns-resize\";\n  Cursor2[\"ZoomIn\"] = \"zoom-in\";\n  Cursor2[\"ZoomOut\"] = \"zoom-out\";\n  return Cursor2;\n})(Cursor || {});\nvar CursorManager = class {\n  constructor(domManager) {\n    this.domManager = domManager;\n    this.stateTracker = new StateTracker(\"default\");\n  }\n  updateCursor(callerId, style) {\n    this.stateTracker.set(callerId, style);\n    this.domManager.updateCursor(this.stateTracker.stateValue());\n  }\n  getCursor() {\n    return this.domManager.getCursor();\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/gestureDetector.ts\nfunction distanceSquared(finger1, finger2) {\n  const dx = finger1.screenX - finger2.screenX;\n  const dy = finger1.screenY - finger2.screenY;\n  return dx * dx + dy * dy;\n}\nfunction distance(finger1, finger2) {\n  return Math.sqrt(distanceSquared(finger1, finger2));\n}\nvar MIN_DISTANCE_TO_START_PINCH = 1;\nvar GestureDetector = class extends BaseManager {\n  constructor(domManager) {\n    super();\n    this.domManager = domManager;\n    this.touchstart = (event) => this.onTouchStart(event);\n    this.touchmove = (event) => this.onTouchMove(event);\n    this.touchend = (event) => this.onTouchEnd(event);\n    this.touchcancel = (event) => this.onTouchCancel(event);\n    this.pinch = {\n      finger1: { identifier: NaN, screenX: NaN, screenY: NaN },\n      finger2: { identifier: NaN, screenX: NaN, screenY: NaN },\n      origin: { x: NaN, y: NaN },\n      distance: NaN,\n      status: 0 /* Off */\n    };\n    this.domManager.addEventListener(\"touchstart\", this.touchstart, { passive: true });\n    this.domManager.addEventListener(\"touchmove\", this.touchmove, { passive: false });\n    this.domManager.addEventListener(\"touchend\", this.touchend);\n    this.domManager.addEventListener(\"touchcancel\", this.touchcancel);\n  }\n  destroy() {\n    this.domManager.removeEventListener(\"touchstart\", this.touchstart);\n    this.domManager.removeEventListener(\"touchmove\", this.touchmove);\n    this.domManager.removeEventListener(\"touchend\", this.touchend);\n    this.domManager.removeEventListener(\"touchcancel\", this.touchcancel);\n  }\n  findPinchTouches(moveEvent) {\n    const { touches } = moveEvent;\n    const { finger1, finger2 } = this.pinch;\n    if (this.pinch.status !== 0 /* Off */ && touches.length === 2) {\n      if (touches[0].identifier === finger1.identifier && touches[1].identifier === finger2.identifier) {\n        return [touches[0], touches[1]];\n      }\n      if (touches[0].identifier === finger2.identifier && touches[1].identifier === finger1.identifier) {\n        return [touches[1], touches[0]];\n      }\n    }\n  }\n  copyTouchData(event) {\n    const keys = [\"identifier\", \"screenX\", \"screenY\"];\n    partialAssign(keys, this.pinch.finger1, event.touches[0]);\n    partialAssign(keys, this.pinch.finger2, event.touches[1]);\n    this.pinch.distance = distance(this.pinch.finger1, this.pinch.finger2);\n  }\n  dispatchPinchEvent(type, deltaDistance, sourceEvent) {\n    const { finger1, finger2, origin } = this.pinch;\n    this.listeners.dispatch(type, buildPreventable({ sourceEvent, type, finger1, finger2, deltaDistance, origin }));\n  }\n  onTouchStart(event) {\n    this.stopPinchTracking(event);\n    const { pinch } = this;\n    if (event.touches.length === 2) {\n      pinch.status = 1 /* Initialized */;\n      this.copyTouchData(event);\n      pinch.origin.x = (event.touches[0].clientX + event.touches[1].clientX) / 2;\n      pinch.origin.y = (event.touches[0].clientY + event.touches[1].clientY) / 2;\n    }\n  }\n  onTouchMove(event) {\n    const pinchTouches = this.findPinchTouches(event);\n    if (pinchTouches !== void 0) {\n      const [touch1, touch2] = pinchTouches;\n      const { pinch } = this;\n      const newDistance = distance(touch1, touch2);\n      const deltaDistance = newDistance - pinch.distance;\n      if (pinch.status === 1 /* Initialized */) {\n        if (Math.abs(deltaDistance) > MIN_DISTANCE_TO_START_PINCH) {\n          pinch.status = 2 /* Running */;\n          this.copyTouchData(event);\n          this.dispatchPinchEvent(\"pinch-start\", 0, event);\n        }\n      } else if (pinch.status === 2 /* Running */) {\n        pinch.distance = newDistance;\n        this.copyTouchData(event);\n        this.dispatchPinchEvent(\"pinch-move\", deltaDistance, event);\n      } else {\n        Logger.error(`unexpected pinch.status: ${pinch.status}`);\n      }\n    }\n  }\n  onTouchEnd(event) {\n    this.stopPinchTracking(event);\n  }\n  onTouchCancel(event) {\n    this.stopPinchTracking(event);\n  }\n  stopPinchTracking(event) {\n    const { pinch } = this;\n    if (pinch.status === 2 /* Running */) {\n      this.dispatchPinchEvent(\"pinch-end\", 0, event);\n    }\n    this.pinch.status = 0 /* Off */;\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/highlightManager.ts\nvar HighlightManager = class extends BaseManager {\n  constructor() {\n    super(...arguments);\n    this.highlightStates = new StateTracker();\n  }\n  updateHighlight(callerId, highlightedDatum) {\n    const { activeHighlight: previousHighlight } = this;\n    this.highlightStates.set(callerId, highlightedDatum);\n    this.activeHighlight = this.highlightStates.stateValue();\n    if (!this.isEqual(this.activeHighlight, previousHighlight)) {\n      this.listeners.dispatch(\"highlight-change\", {\n        type: \"highlight-change\",\n        currentHighlight: this.activeHighlight,\n        previousHighlight\n      });\n    }\n  }\n  getActiveHighlight() {\n    return this.activeHighlight;\n  }\n  isEqual(a, b) {\n    return a === b || a?.series === b?.series && a?.itemId === b?.itemId && a?.datum === b?.datum;\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/keyNavManager.ts\nvar KeyNavManager = class extends BaseManager {\n  constructor(interactionManager, domManager) {\n    super();\n    this.domManager = domManager;\n    this.hasBrowserFocus = false;\n    this.isMouseBlurred = false;\n    this.isClicking = false;\n    this.destroyFns.push(\n      interactionManager.addListener(\"drag-start\", (e) => this.onClickStart(e), 31 /* All */),\n      interactionManager.addListener(\"click\", (e) => this.onClickStop(e), 31 /* All */),\n      interactionManager.addListener(\"drag-end\", (e) => this.onClickStop(e), 31 /* All */),\n      interactionManager.addListener(\"wheel\", (e) => this.mouseBlur(e)),\n      interactionManager.addListener(\"hover\", (e) => this.mouseBlur(e)),\n      interactionManager.addListener(\"drag\", (e) => this.mouseBlur(e)),\n      interactionManager.addListener(\"blur\", (e) => this.onBlur(e), 31 /* All */),\n      interactionManager.addListener(\"focus\", (e) => this.onFocus(e), 31 /* All */),\n      interactionManager.addListener(\"keydown\", (e) => this.onKeyDown(e), 31 /* All */)\n    );\n  }\n  destroy() {\n    super.destroy();\n  }\n  onClickStart(event) {\n    this.isClicking = true;\n    this.mouseBlur(event);\n  }\n  onClickStop(event) {\n    this.mouseBlur(event);\n    this.isClicking = false;\n  }\n  mouseBlur(event) {\n    if (!this.hasBrowserFocus)\n      return;\n    if (!this.isMouseBlurred) {\n      this.dispatch(\"blur\", 0, event);\n      this.isMouseBlurred = true;\n    }\n  }\n  onBlur(event) {\n    this.hasBrowserFocus = false;\n    this.isMouseBlurred = false;\n    this.dispatch(\"blur\", 0, event);\n  }\n  onFocus(event) {\n    const delta3 = this.domManager.getBrowserFocusDelta();\n    this.dispatch(\"browserfocus\", delta3, event);\n    this.hasBrowserFocus = true;\n    if (this.isClicking) {\n      this.isMouseBlurred = true;\n      return;\n    }\n    this.dispatch(\"tab\", delta3, event);\n  }\n  onKeyDown(event) {\n    if (!this.hasBrowserFocus)\n      return;\n    this.isMouseBlurred = false;\n    const { code, altKey, shiftKey, metaKey, ctrlKey } = event.sourceEvent;\n    if (code === \"Tab\") {\n      if (shiftKey) {\n        return this.dispatch(\"tab\", -1, event);\n      } else {\n        return this.dispatch(\"tab\", 1, event);\n      }\n    }\n    if (altKey || shiftKey || metaKey || ctrlKey)\n      return;\n    switch (code) {\n      case \"ArrowDown\":\n        return this.dispatch(\"nav-vert\", 1, event);\n      case \"ArrowUp\":\n        return this.dispatch(\"nav-vert\", -1, event);\n      case \"ArrowLeft\":\n        return this.dispatch(\"nav-hori\", -1, event);\n      case \"ArrowRight\":\n        return this.dispatch(\"nav-hori\", 1, event);\n      case \"ZoomIn\":\n      case \"Add\":\n        return this.dispatch(\"nav-zoom\", 1, event);\n      case \"ZoomOut\":\n      case \"Substract\":\n        return this.dispatch(\"nav-zoom\", -1, event);\n      case \"Space\":\n      case \"Enter\":\n        return this.dispatch(\"submit\", 0, event);\n      case \"Escape\":\n        return this.dispatch(\"cancel\", 0, event);\n      case \"Backspace\":\n      case \"Delete\":\n        return this.dispatch(\"delete\", 0, event);\n    }\n    switch (event.sourceEvent.key) {\n      case \"+\":\n        return this.dispatch(\"nav-zoom\", 1, event);\n      case \"-\":\n        return this.dispatch(\"nav-zoom\", -1, event);\n    }\n  }\n  dispatch(type, delta3, sourceEvent) {\n    dispatchTypedEvent(this.listeners, { type, delta: delta3, sourceEvent });\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/regionManager.ts\nvar REGION_TAB_ORDERING = [\"series\"];\nvar RegionListeners = class extends Listeners {\n};\nfunction addHandler(listeners, interactionManager, type, handler, triggeringStates = 16 /* Default */) {\n  return listeners?.addListener(type, (e) => {\n    const currentState = interactionManager.getState();\n    if (currentState & triggeringStates) {\n      handler(e);\n    }\n  }) ?? (() => {\n  });\n}\nvar RegionManager = class {\n  constructor(interactionManager, keyNavManager, focusIndicator) {\n    this.interactionManager = interactionManager;\n    this.keyNavManager = keyNavManager;\n    this.focusIndicator = focusIndicator;\n    this.currentTabIndex = 0;\n    this.isDragging = false;\n    this.leftCanvas = false;\n    this.regions = /* @__PURE__ */ new Map();\n    this.destroyFns = [];\n    this.allRegionsListeners = new RegionListeners();\n    this.destroyFns.push(\n      ...POINTER_INTERACTION_TYPES.map(\n        (eventName) => interactionManager.addListener(eventName, this.processPointerEvent.bind(this), 31 /* All */)\n      ),\n      this.keyNavManager.addListener(\"blur\", this.onNav.bind(this)),\n      this.keyNavManager.addListener(\"browserfocus\", this.onBrowserFocus.bind(this)),\n      this.keyNavManager.addListener(\"tab\", this.onTab.bind(this)),\n      this.keyNavManager.addListener(\"nav-vert\", this.onNav.bind(this)),\n      this.keyNavManager.addListener(\"nav-hori\", this.onNav.bind(this)),\n      this.keyNavManager.addListener(\"nav-zoom\", this.onNav.bind(this)),\n      this.keyNavManager.addListener(\"submit\", this.onNav.bind(this)),\n      this.keyNavManager.addListener(\"cancel\", this.onNav.bind(this)),\n      this.keyNavManager.addListener(\"delete\", this.onNav.bind(this))\n    );\n  }\n  destroy() {\n    this.destroyFns.forEach((fn) => fn());\n    this.currentRegion = void 0;\n    for (const region of this.regions.values()) {\n      region.listeners.destroy();\n    }\n    this.focusIndicator.destroy();\n    this.regions.clear();\n  }\n  addRegion(name, ...bboxproviders) {\n    if (this.regions.has(name)) {\n      throw new Error(`AG Charts - Region: ${name} already exists`);\n    }\n    const region = {\n      properties: { name, bboxproviders: [...bboxproviders] },\n      listeners: new RegionListeners()\n    };\n    this.regions.set(name, region);\n    return this.makeObserver(region);\n  }\n  updateRegion(name, ...bboxprovider) {\n    const region = this.regions.get(name);\n    if (region) {\n      region.properties.bboxproviders = [...bboxprovider];\n    }\n  }\n  getRegion(name) {\n    return this.makeObserver(this.regions.get(name));\n  }\n  listenAll(type, handler, triggeringStates = 16 /* Default */) {\n    return addHandler(this.allRegionsListeners, this.interactionManager, type, handler, triggeringStates);\n  }\n  // This method return a wrapper object that matches the interface of InteractionManager.addListener.\n  // The intent is to allow the InteractionManager and RegionManager to be used almost interchangeably.\n  makeObserver(region) {\n    const { interactionManager } = this;\n    class ObservableRegionImplementation {\n      addListener(type, handler, triggeringStates = 16 /* Default */) {\n        return addHandler(region?.listeners, interactionManager, type, handler, triggeringStates);\n      }\n    }\n    return new ObservableRegionImplementation();\n  }\n  checkPointerHistory(targetRegion, event) {\n    for (const historyEvent of event.pointerHistory) {\n      const historyRegion = this.pickRegion(historyEvent.offsetX, historyEvent.offsetY);\n      if (targetRegion.properties.name !== historyRegion?.properties.name) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // Create and dispatch a copy of the InteractionEvent.\n  dispatch(region, partialEvent) {\n    if (region == null)\n      return;\n    const event = buildPreventable({ ...partialEvent, region: region.properties.name });\n    this.allRegionsListeners.dispatch(event.type, event);\n    region.listeners.dispatch(event.type, event);\n  }\n  // Process events during a drag action. Returns false if this event should follow the standard\n  // RegionManager.processEvent flow, or true if this event already processed by this function.\n  handleDragging(event) {\n    const { currentRegion } = this;\n    switch (event.type) {\n      case \"drag-start\":\n        this.isDragging = true;\n        this.leftCanvas = false;\n        break;\n      case \"leave\":\n        this.leftCanvas = true;\n        return this.isDragging;\n      case \"enter\":\n        this.leftCanvas = false;\n        return this.isDragging;\n      case \"drag\":\n        if (this.isDragging) {\n          this.dispatch(currentRegion, event);\n          return true;\n        }\n        break;\n      case \"drag-end\":\n        if (this.isDragging) {\n          this.isDragging = false;\n          this.dispatch(currentRegion, event);\n          if (this.leftCanvas) {\n            this.dispatch(currentRegion, { ...event, type: \"leave\" });\n          }\n          return true;\n        }\n        break;\n    }\n    return false;\n  }\n  processPointerEvent(event) {\n    if (this.handleDragging(event)) {\n      return;\n    }\n    const { currentRegion } = this;\n    const newRegion = this.pickRegion(event.offsetX, event.offsetY);\n    if (currentRegion !== void 0 && newRegion?.properties.name !== currentRegion.properties.name) {\n      this.dispatch(currentRegion, { ...event, type: \"leave\" });\n    }\n    if (newRegion !== void 0 && newRegion.properties.name !== currentRegion?.properties.name) {\n      this.dispatch(newRegion, { ...event, type: \"enter\" });\n    }\n    if (newRegion !== void 0 && this.checkPointerHistory(newRegion, event)) {\n      this.dispatch(newRegion, event);\n    }\n    this.currentRegion = newRegion;\n  }\n  pickRegion(x, y) {\n    let currentArea = Infinity;\n    let currentRegion;\n    for (const region of this.regions.values()) {\n      for (const provider of region.properties.bboxproviders) {\n        const bbox = provider.computeTransformedRegionBBox?.() ?? provider.computeTransformedBBox();\n        const area2 = bbox.width * bbox.height;\n        if (area2 < currentArea && bbox.containsPoint(x, y)) {\n          currentArea = area2;\n          currentRegion = region;\n        }\n      }\n    }\n    return currentRegion;\n  }\n  getTabRegion(tabIndex) {\n    if (tabIndex !== void 0 && tabIndex >= 0 && tabIndex < REGION_TAB_ORDERING.length) {\n      return this.regions.get(REGION_TAB_ORDERING[tabIndex]);\n    }\n    return void 0;\n  }\n  getNextInteractableTabIndex(currentIndex, delta3) {\n    const direction = delta3 < 0 ? -1 : 1;\n    let i = currentIndex;\n    while (delta3 !== 0) {\n      const region = this.getTabRegion(i + direction);\n      if (region === void 0) {\n        return void 0;\n      } else {\n        delta3 = delta3 - direction;\n      }\n      i = i + direction;\n    }\n    return i;\n  }\n  validateCurrentTabIndex() {\n    const focusedRegion = this.getTabRegion(this.currentTabIndex);\n    if (focusedRegion !== void 0) {\n      this.currentTabIndex = this.getNextInteractableTabIndex(-1, 1) ?? 0;\n    }\n  }\n  onBrowserFocus(event) {\n    if (event.delta > 0) {\n      this.currentTabIndex = -1;\n    } else if (event.delta < 0) {\n      this.currentTabIndex = REGION_TAB_ORDERING.length;\n    }\n  }\n  onTab(event) {\n    this.validateCurrentTabIndex();\n    const newTabIndex = this.getNextInteractableTabIndex(this.currentTabIndex, event.delta);\n    const newRegion = this.getTabRegion(newTabIndex);\n    const focusedRegion = this.getTabRegion(this.currentTabIndex);\n    if (newTabIndex !== void 0) {\n      this.currentTabIndex = newTabIndex;\n    }\n    if (focusedRegion !== void 0 && newRegion?.properties.name !== focusedRegion.properties.name) {\n      const { delta: delta3, sourceEvent } = event;\n      const blurEvent = buildPreventable({ type: \"blur\", delta: delta3, sourceEvent });\n      this.dispatch(focusedRegion, blurEvent);\n    }\n    if (newRegion === void 0) {\n      this.focusIndicator.updateBounds(void 0);\n    } else {\n      this.dispatch(newRegion, event);\n    }\n  }\n  onNav(event) {\n    const focusedRegion = this.getTabRegion(this.currentTabIndex);\n    this.dispatch(focusedRegion, event);\n  }\n};\n\n// packages/ag-charts-community/src/chart/toolbar/toolbarTypes.ts\nvar TOOLBAR_ALIGNMENTS = [\"start\", \"center\", \"end\"];\nvar TOOLBAR_GROUPS = [\"annotations\", \"annotationOptions\", \"ranges\", \"zoom\"];\nvar ToolbarPosition = /* @__PURE__ */ ((ToolbarPosition2) => {\n  ToolbarPosition2[\"Top\"] = \"top\";\n  ToolbarPosition2[\"Right\"] = \"right\";\n  ToolbarPosition2[\"Bottom\"] = \"bottom\";\n  ToolbarPosition2[\"Left\"] = \"left\";\n  ToolbarPosition2[\"Floating\"] = \"floating\";\n  ToolbarPosition2[\"FloatingTop\"] = \"floating-top\";\n  ToolbarPosition2[\"FloatingBottom\"] = \"floating-bottom\";\n  return ToolbarPosition2;\n})(ToolbarPosition || {});\nvar TOOLBAR_POSITIONS = Object.values(ToolbarPosition);\nfunction isAnimatingFloatingPosition(position) {\n  return [\"floating-top\" /* FloatingTop */, \"floating-bottom\" /* FloatingBottom */].includes(position);\n}\n\n// packages/ag-charts-community/src/chart/interaction/toolbarManager.ts\nvar ToolbarManager = class extends BaseManager {\n  static isGroup(group, event) {\n    return event.group === group;\n  }\n  static isChildElement(domManager, element2) {\n    for (const position of TOOLBAR_POSITIONS) {\n      if (domManager.isManagedChildDOMElement(element2, \"canvas-overlay\", `toolbar-${position}`)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  pressButton(group, value) {\n    this.listeners.dispatch(\"button-pressed\", { type: \"button-pressed\", group, value });\n  }\n  cancel(group) {\n    this.listeners.dispatch(\"cancelled\", { type: \"cancelled\", group });\n  }\n  toggleButton(group, value, options) {\n    const { active = false, enabled = true, visible = true } = options;\n    this.listeners.dispatch(\"button-toggled\", { type: \"button-toggled\", group, value, active, enabled, visible });\n  }\n  toggleGroup(caller, group, visible) {\n    this.listeners.dispatch(\"group-toggled\", { type: \"group-toggled\", caller, group, visible });\n  }\n  changeFloatingAnchor(group, anchor) {\n    this.listeners.dispatch(\"floating-anchor-changed\", { type: \"floating-anchor-changed\", group, anchor });\n  }\n  buttonMoved(group, value, rect) {\n    this.listeners.dispatch(\"button-moved\", { type: \"button-moved\", group, value, rect });\n  }\n  proxyGroupOptions(caller, group, options) {\n    this.listeners.dispatch(\"proxy-group-options\", { type: \"proxy-group-options\", caller, group, options });\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/tooltipManager.css\nvar tooltipManager_default = \".ag-chart-tooltip{transition:transform 0.1s ease;max-width:100%;z-index:99999;font:12px Verdana,sans-serif;color:rgb(70,70,70);box-shadow:0 4px 8px rgba(0,0,0,0.08)}.ag-chart-tooltip-wrap-always{overflow-wrap:break-word;word-break:break-word;hyphens:none}.ag-chart-tooltip-wrap-hyphenate{overflow-wrap:break-word;word-break:break-word;hyphens:auto}.ag-chart-tooltip-wrap-on-space{overflow-wrap:normal;word-break:normal}.ag-chart-tooltip-wrap-never{white-space:pre;text-overflow:ellipsis}.ag-chart-tooltip-no-interaction{pointer-events:none;user-select:none}.ag-chart-tooltip-no-animation{transition:none!important}.ag-chart-tooltip-hidden{visibility:hidden}.ag-chart-tooltip-title{overflow:hidden;position:relative;padding:8px 14px;border-top-left-radius:2px;border-top-right-radius:2px;color:white;background-color:#888888;z-index:1;text-overflow:inherit}.ag-chart-tooltip-title:only-child{border-bottom-left-radius:2px;border-bottom-right-radius:2px}.ag-chart-tooltip-content{overflow:hidden;padding:6px 14px;line-height:1.7em;background:white;border-bottom-left-radius:2px;border-bottom-right-radius:2px;border:1px solid rgba(0,0,0,0.15);text-overflow:inherit}.ag-chart-tooltip-arrow::before{content:'';position:absolute;top:100%;left:50%;transform:translateX(-50%);border:5px solid #d9d9d9;border-left-color:transparent;border-right-color:transparent;border-bottom-color:transparent;width:0;height:0;margin:0 auto}.ag-chart-tooltip-arrow::after{content:'';position:absolute;top:calc(100% - 1px);left:50%;transform:translateX(-50%);border:5px solid white;border-left-color:transparent;border-right-color:transparent;border-bottom-color:transparent;width:0;height:0;margin:0 auto}\";\n\n// packages/ag-charts-community/src/chart/interaction/tooltipManager.ts\nvar TooltipManager = class {\n  constructor(domManager, tooltip) {\n    this.domManager = domManager;\n    this.tooltip = tooltip;\n    this.stateTracker = new StateTracker();\n    this.suppressState = new StateTracker(false);\n    this.appliedState = null;\n    tooltip.setup(domManager);\n    domManager.addListener(\"hidden\", () => this.tooltip.toggle(false));\n    domManager.addStyles(\"tooltip\", tooltipManager_default);\n  }\n  updateTooltip(callerId, meta, content) {\n    if (!this.tooltip.enabled)\n      return;\n    content ?? (content = this.stateTracker.get(callerId)?.content);\n    this.stateTracker.set(callerId, { content, meta });\n    this.applyStates();\n  }\n  removeTooltip(callerId) {\n    if (!this.tooltip.enabled)\n      return;\n    this.stateTracker.delete(callerId);\n    this.applyStates();\n  }\n  suppressTooltip(callerId) {\n    this.suppressState.set(callerId, true);\n  }\n  unsuppressTooltip(callerId) {\n    this.suppressState.delete(callerId);\n  }\n  getTooltipMeta(callerId) {\n    return this.stateTracker.get(callerId)?.meta;\n  }\n  destroy() {\n    this.domManager.removeStyles(\"tooltip\");\n  }\n  applyStates() {\n    const id = this.stateTracker.stateId();\n    const state = id ? this.stateTracker.get(id) : null;\n    if (this.suppressState.stateValue() || state?.meta == null || state?.content == null) {\n      this.appliedState = null;\n      this.tooltip.toggle(false);\n      return;\n    }\n    const canvasRect = this.domManager.getBoundingClientRect();\n    if (this.appliedState?.content === state?.content) {\n      const renderInstantly = this.tooltip.isVisible();\n      this.tooltip.show(canvasRect, state?.meta, null, renderInstantly);\n    } else {\n      this.tooltip.show(canvasRect, state?.meta, state?.content);\n    }\n    this.appliedState = state;\n  }\n  static makeTooltipMeta(event, datum) {\n    const { offsetX, offsetY } = event;\n    const { tooltip } = datum.series.properties;\n    const meta = {\n      offsetX,\n      offsetY,\n      enableInteraction: tooltip.interaction?.enabled ?? false,\n      lastPointerEvent: { type: event.type, offsetX, offsetY },\n      showArrow: tooltip.showArrow,\n      position: {\n        type: tooltip.position.type,\n        xOffset: tooltip.position.xOffset,\n        yOffset: tooltip.position.yOffset\n      }\n    };\n    const refPoint = datum.yBar?.upperPoint ?? datum.midPoint ?? datum.series.datumMidPoint?.(datum);\n    if (tooltip.position.type === \"node\" && refPoint) {\n      const { x, y } = refPoint;\n      const point = datum.series.contentGroup.inverseTransformPoint(x, y);\n      return {\n        ...meta,\n        offsetX: Math.round(point.x),\n        offsetY: Math.round(point.y)\n      };\n    }\n    return meta;\n  }\n};\n\n// packages/ag-charts-community/src/chart/layout/layoutService.ts\nvar LayoutService = class extends Listeners {\n  constructor() {\n    super(...arguments);\n    this.layoutComplete = \"layout-complete\";\n    this.debug = Debug.create(true, \"layout\");\n  }\n  addListener(eventType, handler) {\n    if (this.isLayoutStage(eventType) || this.isLayoutComplete(eventType)) {\n      return super.addListener(eventType, handler);\n    }\n    throw new Error(`AG Charts - unsupported listener type: ${eventType}`);\n  }\n  dispatchPerformLayout(stage, ctx) {\n    if (this.isLayoutStage(stage)) {\n      return this.getListenersByType(stage).reduce((result, listener) => {\n        try {\n          const newCtx = listener.handler(result);\n          this.debug(\"[LayoutService] Context updated to: \", { ...newCtx }, listener);\n          return newCtx;\n        } catch (e) {\n          Logger.errorOnce(e);\n          return result;\n        }\n      }, ctx);\n    }\n    return ctx;\n  }\n  dispatchLayoutComplete(event) {\n    this.dispatch(this.layoutComplete, event);\n  }\n  isLayoutStage(eventType) {\n    return eventType !== this.layoutComplete;\n  }\n  isLayoutComplete(eventType) {\n    return eventType === this.layoutComplete;\n  }\n};\n\n// packages/ag-charts-community/src/chart/locale/defaultMessageFormatter.ts\nvar messageRegExp = /\\$\\{(\\w+)\\}(?:\\[(\\w+)\\])?/gi;\nvar formatters = {\n  number: new Intl.NumberFormat(\"en-US\"),\n  percent: new Intl.NumberFormat(\"en-US\", { style: \"percent\" }),\n  date: new Intl.DateTimeFormat(\"en-US\", { dateStyle: \"full\" }),\n  time: new Intl.DateTimeFormat(\"en-US\", { timeStyle: \"full\" }),\n  datetime: new Intl.DateTimeFormat(\"en-US\", { dateStyle: \"full\", timeStyle: \"full\" })\n};\nvar defaultMessageFormatter = ({ defaultValue, variables }) => {\n  return defaultValue?.replaceAll(messageRegExp, (_, match, format) => {\n    const value = variables[match];\n    const formatter = format != null ? formatters[format] : void 0;\n    if (format != null && formatter == null) {\n      Logger.warnOnce(`Format style [${format}] is not supported`);\n    }\n    if (formatter != null) {\n      return formatter.format(value);\n    } else if (typeof value === \"number\") {\n      return formatters.number.format(value);\n    } else if (value instanceof Date) {\n      return formatters.datetime.format(value);\n    }\n    return value;\n  });\n};\n\n// packages/ag-charts-community/src/chart/locale/localeManager.ts\nvar LocaleManager = class extends Listeners {\n  constructor() {\n    super(...arguments);\n    this.localeText = void 0;\n    this.getLocaleText = void 0;\n  }\n  setLocaleText(localeText) {\n    if (this.localeText !== localeText) {\n      this.localeText = localeText;\n      this.dispatch(\"locale-changed\");\n    }\n  }\n  setLocaleTextFormatter(getLocaleText) {\n    this.getLocaleText = getLocaleText;\n    if (this.getLocaleText !== getLocaleText) {\n      this.getLocaleText = getLocaleText;\n      this.dispatch(\"locale-changed\");\n    }\n  }\n  t(key, variables = {}) {\n    const { localeText = AG_CHARTS_LOCALE_EN_US, getLocaleText } = this;\n    const defaultValue = localeText[key];\n    return getLocaleText?.({ key, defaultValue, variables }) ?? defaultMessageFormatter({ key, defaultValue, variables }) ?? key;\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesStateManager.ts\nvar SeriesStateManager = class {\n  constructor() {\n    this.groups = {};\n  }\n  registerSeries({\n    id,\n    seriesGrouping,\n    visible,\n    type\n  }) {\n    var _a;\n    if (!seriesGrouping)\n      return;\n    (_a = this.groups)[type] ?? (_a[type] = {});\n    this.groups[type][id] = { grouping: seriesGrouping, visible };\n  }\n  deregisterSeries({ id, type }) {\n    if (this.groups[type]) {\n      delete this.groups[type][id];\n    }\n    if (this.groups[type] && Object.keys(this.groups[type]).length === 0) {\n      delete this.groups[type];\n    }\n  }\n  getVisiblePeerGroupIndex({\n    type,\n    seriesGrouping,\n    visible\n  }) {\n    if (!seriesGrouping)\n      return { visibleGroupCount: visible ? 1 : 0, visibleSameStackCount: visible ? 1 : 0, index: 0 };\n    const visibleGroupsSet = /* @__PURE__ */ new Set();\n    const visibleSameStackSet = /* @__PURE__ */ new Set();\n    for (const entry of Object.values(this.groups[type] ?? {})) {\n      if (!entry.visible)\n        continue;\n      visibleGroupsSet.add(entry.grouping.groupIndex);\n      if (entry.grouping.groupIndex === seriesGrouping.groupIndex) {\n        visibleSameStackSet.add(entry.grouping.stackIndex);\n      }\n    }\n    const visibleGroups = Array.from(visibleGroupsSet);\n    visibleGroups.sort((a, b) => a - b);\n    return {\n      visibleGroupCount: visibleGroups.length,\n      visibleSameStackCount: visibleSameStackSet.size,\n      index: visibleGroups.indexOf(seriesGrouping.groupIndex)\n    };\n  }\n};\n\n// packages/ag-charts-community/src/chart/chartUpdateType.ts\nvar ChartUpdateType = /* @__PURE__ */ ((ChartUpdateType2) => {\n  ChartUpdateType2[ChartUpdateType2[\"FULL\"] = 0] = \"FULL\";\n  ChartUpdateType2[ChartUpdateType2[\"UPDATE_DATA\"] = 1] = \"UPDATE_DATA\";\n  ChartUpdateType2[ChartUpdateType2[\"PROCESS_DATA\"] = 2] = \"PROCESS_DATA\";\n  ChartUpdateType2[ChartUpdateType2[\"PERFORM_LAYOUT\"] = 3] = \"PERFORM_LAYOUT\";\n  ChartUpdateType2[ChartUpdateType2[\"SERIES_UPDATE\"] = 4] = \"SERIES_UPDATE\";\n  ChartUpdateType2[ChartUpdateType2[\"TOOLTIP_RECALCULATION\"] = 5] = \"TOOLTIP_RECALCULATION\";\n  ChartUpdateType2[ChartUpdateType2[\"SCENE_RENDER\"] = 6] = \"SCENE_RENDER\";\n  ChartUpdateType2[ChartUpdateType2[\"NONE\"] = 7] = \"NONE\";\n  return ChartUpdateType2;\n})(ChartUpdateType || {});\n\n// packages/ag-charts-community/src/chart/updateService.ts\nvar UpdateService = class extends Listeners {\n  constructor(updateCallback) {\n    super();\n    this.updateCallback = updateCallback;\n  }\n  update(type = 0 /* FULL */, options) {\n    this.updateCallback(type, options);\n  }\n  dispatchUpdateComplete(rects) {\n    this.dispatch(\"update-complete\", {\n      type: \"update-complete\",\n      minRect: rects?.minRect,\n      minVisibleRect: rects?.minVisibleRect\n    });\n  }\n};\n\n// packages/ag-charts-community/src/chart/chartContext.ts\nvar ChartContext = class {\n  constructor(chart, vars) {\n    const { scene, root, syncManager, container, updateCallback, updateMutex, overrideDevicePixelRatio } = vars;\n    this.chartService = chart;\n    this.syncManager = syncManager;\n    this.zoomManager = chart.zoomManager;\n    this.domManager = new DOMManager(container);\n    scene?.setContainer(this.domManager);\n    this.scene = scene ?? new Scene({ pixelRatio: overrideDevicePixelRatio, domManager: this.domManager });\n    this.scene.setRoot(root);\n    this.axisManager = new AxisManager(root);\n    this.localeManager = new LocaleManager();\n    this.annotationManager = new AnnotationManager(chart.annotationRoot);\n    this.chartEventManager = new ChartEventManager();\n    this.cursorManager = new CursorManager(this.domManager);\n    this.highlightManager = new HighlightManager();\n    this.interactionManager = new InteractionManager(chart.keyboard, this.domManager);\n    this.keyNavManager = new KeyNavManager(this.interactionManager, this.domManager);\n    this.focusIndicator = new FocusIndicator(this.domManager);\n    this.regionManager = new RegionManager(this.interactionManager, this.keyNavManager, this.focusIndicator);\n    this.contextMenuRegistry = new ContextMenuRegistry(this.regionManager);\n    this.toolbarManager = new ToolbarManager();\n    this.gestureDetector = new GestureDetector(this.domManager);\n    this.layoutService = new LayoutService();\n    this.ariaAnnouncementService = new AriaAnnouncementService(\n      this.localeManager,\n      this.domManager,\n      this.layoutService\n    );\n    this.updateService = new UpdateService(updateCallback);\n    this.proxyInteractionService = new ProxyInteractionService(\n      this.updateService,\n      this.localeManager,\n      this.domManager,\n      this.focusIndicator\n    );\n    this.seriesStateManager = new SeriesStateManager();\n    this.stateManager = new StateManager();\n    this.callbackCache = new CallbackCache();\n    this.animationManager = new AnimationManager(this.interactionManager, updateMutex);\n    this.animationManager.skip();\n    this.animationManager.play();\n    this.dataService = new DataService(this.animationManager);\n    this.tooltipManager = new TooltipManager(this.domManager, chart.tooltip);\n  }\n  destroy() {\n    this.tooltipManager.destroy();\n    this.contextMenuRegistry.destroy();\n    this.regionManager.destroy();\n    this.proxyInteractionService.destroy();\n    this.focusIndicator.destroy();\n    this.keyNavManager.destroy();\n    this.interactionManager.destroy();\n    this.animationManager.stop();\n    this.animationManager.destroy();\n    this.ariaAnnouncementService.destroy();\n    this.chartEventManager.destroy();\n    this.highlightManager.destroy();\n    this.callbackCache.invalidateCache();\n    this.animationManager.reset();\n    this.syncManager.destroy();\n    this.domManager.destroy();\n    this.axisManager.destroy();\n  }\n};\n\n// packages/ag-charts-community/src/chart/chartHighlight.ts\nvar ChartHighlight = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.range = \"tooltip\";\n  }\n};\n__decorateClass([\n  Validate(UNION([\"tooltip\", \"node\"], \"a range\"))\n], ChartHighlight.prototype, \"range\", 2);\n\n// packages/ag-charts-community/src/chart/data/dataDomain.ts\nvar DiscreteDomain = class _DiscreteDomain {\n  constructor() {\n    this.domain = /* @__PURE__ */ new Set();\n  }\n  static is(value) {\n    return value instanceof _DiscreteDomain;\n  }\n  extend(val) {\n    this.domain.add(val);\n  }\n  getDomain() {\n    return Array.from(this.domain);\n  }\n};\nvar ContinuousDomain = class _ContinuousDomain {\n  constructor() {\n    this.domain = [Infinity, -Infinity];\n  }\n  static is(value) {\n    return value instanceof _ContinuousDomain;\n  }\n  static extendDomain(values, domain = [Infinity, -Infinity]) {\n    for (const value of values) {\n      if (typeof value !== \"number\") {\n        continue;\n      }\n      if (domain[0] > value) {\n        domain[0] = value;\n      }\n      if (domain[1] < value) {\n        domain[1] = value;\n      }\n    }\n    return domain;\n  }\n  extend(value) {\n    if (this.domain[0] > value) {\n      this.domain[0] = value;\n    }\n    if (this.domain[1] < value) {\n      this.domain[1] = value;\n    }\n  }\n  getDomain() {\n    return [...this.domain];\n  }\n};\n\n// packages/ag-charts-community/src/chart/data/dataModel.ts\nfunction toKeyString(keys) {\n  return keys.map((key) => isObject(key) ? JSON.stringify(key) : key).join(\"-\");\n}\nfunction round2(val) {\n  const accuracy = 1e4;\n  if (Number.isInteger(val)) {\n    return val;\n  } else if (Math.abs(val) > accuracy) {\n    return Math.trunc(val);\n  }\n  return Math.round(val * accuracy) / accuracy;\n}\nfunction fixNumericExtentInternal(extent2) {\n  if (extent2 == null) {\n    return [];\n  }\n  let [min, max] = extent2.map(Number);\n  if (min === 0 && max === 0) {\n    return [0, 1];\n  }\n  if (min === Infinity && max === -Infinity) {\n    return [];\n  } else if (min === Infinity) {\n    min = 0;\n  } else if (max === -Infinity) {\n    max = 0;\n  }\n  return isFiniteNumber(min) && isFiniteNumber(max) ? [min, max] : [];\n}\nfunction fixNumericExtent(extent2, axis) {\n  const fixedExtent = fixNumericExtentInternal(extent2);\n  if (fixedExtent.length === 0) {\n    return fixedExtent;\n  }\n  let [min, max] = fixedExtent;\n  if (min === max) {\n    const [paddingMin, paddingMax] = axis?.calculatePadding(min, max) ?? [1, 1];\n    min -= paddingMin;\n    max += paddingMax;\n  }\n  return [min, max];\n}\nfunction getMissCount(scopeProvider, missMap) {\n  return missMap?.get(scopeProvider.id) ?? 0;\n}\nvar INVALID_VALUE = Symbol(\"invalid\");\nfunction getPathComponents(path) {\n  const components = [];\n  let matchIndex = 0;\n  let matchGroup;\n  const regExp = /((?:(?:^|\\.)\\s*\\w+|\\[\\s*(?:'(?:[^']|(?<!\\\\)\\\\')*'|\"(?:[^\"]|(?<!\\\\)\\\\\")*\"|-?\\d+)\\s*\\])\\s*)/g;\n  while (matchGroup = regExp.exec(path)) {\n    if (matchGroup.index !== matchIndex) {\n      return;\n    }\n    matchIndex = matchGroup.index + matchGroup[0].length;\n    const match = matchGroup[1].trim();\n    if (match.startsWith(\".\")) {\n      components.push(match.slice(1).trim());\n    } else if (match.startsWith(\"[\")) {\n      const accessor = match.slice(1, -1).trim();\n      if (accessor.startsWith(`'`)) {\n        components.push(accessor.slice(1, -1).replace(/(?<!\\\\)\\\\'/g, `'`));\n      } else if (accessor.startsWith(`\"`)) {\n        components.push(accessor.slice(1, -1).replace(/(?<!\\\\)\\\\\"/g, `\"`));\n      } else {\n        components.push(accessor);\n      }\n    } else {\n      components.push(match);\n    }\n  }\n  if (matchIndex !== path.length)\n    return;\n  return components;\n}\nfunction createPathAccessor(components) {\n  return (datum) => {\n    let current = datum;\n    for (const component of components) {\n      current = current[component];\n    }\n    return current;\n  };\n}\nvar DataModel = class {\n  constructor(opts, mode = \"standalone\") {\n    this.opts = opts;\n    this.mode = mode;\n    this.debug = Debug.create(true, \"data-model\");\n    this.scopeCache = /* @__PURE__ */ new Map();\n    this.keys = [];\n    this.values = [];\n    this.aggregates = [];\n    this.groupProcessors = [];\n    this.propertyProcessors = [];\n    this.reducers = [];\n    this.processors = [];\n    let keys = true;\n    for (const next of opts.props) {\n      if (next.type === \"key\" && !keys) {\n        throw new Error(\"AG Charts - internal config error: keys must come before values.\");\n      }\n      if (next.type === \"value\" && keys) {\n        keys = false;\n      }\n    }\n    const verifyMatchGroupId = ({ matchGroupIds = [] }) => {\n      for (const matchGroupId of matchGroupIds) {\n        if (this.values.every((def) => def.groupId !== matchGroupId)) {\n          throw new Error(\n            `AG Charts - internal config error: matchGroupIds properties must match defined groups (${matchGroupId}).`\n          );\n        }\n      }\n    };\n    for (const def of opts.props) {\n      switch (def.type) {\n        case \"key\":\n          this.keys.push({ ...def, index: this.keys.length, missing: /* @__PURE__ */ new Map() });\n          break;\n        case \"value\":\n          if (def.property == null) {\n            throw new Error(\n              `AG Charts - internal config error: no properties specified for value definitions: ${JSON.stringify(\n                def\n              )}`\n            );\n          }\n          this.values.push({ ...def, index: this.values.length, missing: /* @__PURE__ */ new Map() });\n          break;\n        case \"aggregate\":\n          verifyMatchGroupId(def);\n          this.aggregates.push({ ...def, index: this.aggregates.length });\n          break;\n        case \"group-value-processor\":\n          verifyMatchGroupId(def);\n          this.groupProcessors.push({ ...def, index: this.groupProcessors.length });\n          break;\n        case \"property-value-processor\":\n          this.propertyProcessors.push({ ...def, index: this.propertyProcessors.length });\n          break;\n        case \"reducer\":\n          this.reducers.push({ ...def, index: this.reducers.length });\n          break;\n        case \"processor\":\n          this.processors.push({ ...def, index: this.processors.length });\n          break;\n      }\n    }\n  }\n  resolveProcessedDataDefById(scope, searchId) {\n    const def = this.scopeCache.get(scope.id)?.get(searchId);\n    if (!def) {\n      throw new Error(`AG Charts - didn't find property definition for [${searchId}, ${scope.id}]`);\n    }\n    return { index: def.index, def };\n  }\n  resolveProcessedDataIndexById(scope, searchId) {\n    return this.resolveProcessedDataDefById(scope, searchId).index;\n  }\n  resolveProcessedDataDefsByIds(scope, searchIds) {\n    return searchIds.map((searchId) => [searchId, this.resolveProcessedDataDefById(scope, searchId)]);\n  }\n  resolveProcessedDataDefsValues(defs, { keys, values }) {\n    const result = {};\n    for (const [searchId, { index, def }] of defs) {\n      const processedData = def.type === \"key\" ? keys : values;\n      result[searchId] = processedData[index];\n    }\n    return result;\n  }\n  getDomain(scope, searchId, type = \"value\", processedData) {\n    const domains = this.getDomainsByType(type, processedData);\n    return domains?.[this.resolveProcessedDataIndexById(scope, searchId)] ?? [];\n  }\n  getDomainsByType(type, processedData) {\n    switch (type) {\n      case \"key\":\n        return processedData.domain.keys;\n      case \"value\":\n        return processedData.domain.values;\n      case \"aggregate\":\n        return processedData.domain.aggValues;\n      case \"group-value-processor\":\n        return processedData.domain.groups;\n      default:\n        return null;\n    }\n  }\n  processData(data, sources) {\n    const {\n      opts: { groupByKeys, groupByFn },\n      aggregates,\n      groupProcessors,\n      reducers,\n      processors,\n      propertyProcessors\n    } = this;\n    const start = performance.now();\n    if (groupByKeys && this.keys.length === 0) {\n      return;\n    }\n    let processedData = this.extractData(data, sources);\n    if (groupByKeys) {\n      processedData = this.groupData(processedData);\n    } else if (groupByFn) {\n      processedData = this.groupData(processedData, groupByFn(processedData));\n    }\n    if (groupProcessors.length > 0) {\n      this.postProcessGroups(processedData);\n    }\n    if (aggregates.length > 0) {\n      this.aggregateData(processedData);\n    }\n    if (propertyProcessors.length > 0) {\n      this.postProcessProperties(processedData);\n    }\n    if (reducers.length > 0) {\n      this.reduceData(processedData);\n    }\n    if (processors.length > 0) {\n      this.postProcessData(processedData);\n    }\n    if (data.length > 0) {\n      for (const def of iterate(this.keys, this.values)) {\n        for (const [scope, missCount] of def.missing) {\n          if (missCount >= data.length) {\n            const scopeHint = scope == null ? \"\" : ` for ${scope}`;\n            Logger.warnOnce(`the key '${def.property}' was not found in any data element${scopeHint}.`);\n          }\n        }\n      }\n    }\n    const end = performance.now();\n    processedData.time = end - start;\n    if (this.debug.check()) {\n      logProcessedData(processedData);\n    }\n    this.scopeCache.clear();\n    for (const def of iterate(this.keys, this.values, this.aggregates)) {\n      if (!def.idsMap)\n        continue;\n      for (const [scope, ids] of def.idsMap) {\n        for (const id of ids) {\n          if (!this.scopeCache.has(scope)) {\n            this.scopeCache.set(scope, /* @__PURE__ */ new Map([[id, def]]));\n          } else if (this.scopeCache.get(scope)?.has(id)) {\n            throw new Error(\"duplicate definition ids on the same scope are not allowed.\");\n          } else {\n            this.scopeCache.get(scope).set(id, def);\n          }\n        }\n      }\n    }\n    return processedData;\n  }\n  valueGroupIdxLookup({ matchGroupIds }) {\n    const result = [];\n    for (const [index, def] of this.values.entries()) {\n      if (!matchGroupIds || def.groupId && matchGroupIds.includes(def.groupId)) {\n        result.push(index);\n      }\n    }\n    return result;\n  }\n  valueIdxLookup(scopes, prop) {\n    const noScopesToMatch = scopes == null || scopes.length === 0;\n    const propId = typeof prop === \"string\" ? prop : prop.id;\n    const hasMatchingScopeId = (def) => {\n      if (def.idsMap) {\n        for (const [scope, ids] of def.idsMap) {\n          if (scopes?.includes(scope) && ids.has(propId)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    const result = this.values.findIndex((def) => {\n      const validDefScopes = def.scopes == null || noScopesToMatch && !def.scopes.length || def.scopes.some((s) => scopes?.includes(s));\n      return validDefScopes && (def.property === propId || def.id === propId || hasMatchingScopeId(def));\n    });\n    if (result === -1) {\n      throw new Error(\n        `AG Charts - configuration error, unknown property ${JSON.stringify(prop)} in scope(s) ${JSON.stringify(\n          scopes\n        )}`\n      );\n    }\n    return result;\n  }\n  extractData(data, sources) {\n    const { dataDomain, processValue, scopes, allScopesHaveSameDefs } = this.initDataDomainProcessor();\n    const sourcesById = new Map(sources?.map((s) => [s.id, s]));\n    const { keys: keyDefs, values: valueDefs } = this;\n    const resultData = new Array(data.length);\n    let resultDataIdx = 0;\n    let partialValidDataCount = 0;\n    for (const [datumIdx, datum] of data.entries()) {\n      const sourceDatums = {};\n      const validScopes = scopes.size > 0 ? new Set(scopes) : void 0;\n      const keys = new Array(keyDefs.length);\n      let keyIdx = 0;\n      let key;\n      for (const def of keyDefs) {\n        key = processValue(def, datum, key);\n        if (key === INVALID_VALUE)\n          break;\n        if (keys) {\n          keys[keyIdx++] = key;\n        }\n      }\n      if (key === INVALID_VALUE)\n        continue;\n      const values = valueDefs.length > 0 ? new Array(valueDefs.length) : void 0;\n      let value;\n      for (const [valueDefIdx, def] of valueDefs.entries()) {\n        for (const scope of def.scopes ?? scopes) {\n          const source = sourcesById.get(scope);\n          const valueDatum = source?.data[datumIdx] ?? datum;\n          value = processValue(def, valueDatum, value, scope);\n          if (value === INVALID_VALUE || !values)\n            continue;\n          if (source != null && def.includeProperty !== false) {\n            const property = def.includeProperty && def.id != null ? def.id : def.property;\n            sourceDatums[scope] ?? (sourceDatums[scope] = {});\n            sourceDatums[scope][property] = value;\n          }\n          values[valueDefIdx] = value;\n        }\n        if (value === INVALID_VALUE) {\n          if (allScopesHaveSameDefs)\n            break;\n          for (const scope of def.scopes ?? scopes) {\n            validScopes?.delete(scope);\n          }\n          if (validScopes?.size === 0)\n            break;\n        }\n      }\n      if (value === INVALID_VALUE && allScopesHaveSameDefs)\n        continue;\n      if (validScopes?.size === 0)\n        continue;\n      const result = { datum: { ...datum, ...sourceDatums }, keys, values };\n      if (!allScopesHaveSameDefs && validScopes && validScopes.size < scopes.size) {\n        partialValidDataCount++;\n        result.validScopes = new Set(validScopes);\n      }\n      resultData[resultDataIdx++] = result;\n    }\n    resultData.length = resultDataIdx;\n    const propertyDomain = (def) => {\n      const defDomain = dataDomain.get(def);\n      const result = defDomain.getDomain();\n      if (ContinuousDomain.is(defDomain) && result[0] > result[1]) {\n        return [];\n      }\n      return result;\n    };\n    return {\n      type: \"ungrouped\",\n      input: { count: data.length },\n      data: resultData,\n      domain: {\n        keys: keyDefs.map(propertyDomain),\n        values: valueDefs.map(propertyDomain)\n      },\n      defs: {\n        allScopesHaveSameDefs,\n        keys: keyDefs,\n        values: valueDefs\n      },\n      partialValidDataCount,\n      time: 0\n    };\n  }\n  groupData(data, groupingFn) {\n    const processedData = /* @__PURE__ */ new Map();\n    for (const dataEntry of data.data) {\n      const { keys, values, datum, validScopes } = dataEntry;\n      const group = groupingFn?.(dataEntry) ?? keys;\n      const groupStr = toKeyString(group);\n      if (processedData.has(groupStr)) {\n        const existingData = processedData.get(groupStr);\n        existingData.values.push(values);\n        existingData.datum.push(datum);\n        if (validScopes != null && existingData.validScopes != null) {\n          for (const scope of existingData.validScopes) {\n            if (!validScopes.has(scope)) {\n              existingData.validScopes.delete(scope);\n            }\n          }\n        }\n      } else {\n        processedData.set(groupStr, {\n          keys: group,\n          values: [values],\n          datum: [datum],\n          validScopes\n        });\n      }\n    }\n    const resultData = new Array(processedData.size);\n    const resultGroups = new Array(processedData.size);\n    let dataIndex = 0;\n    for (const { keys, values, datum, validScopes } of processedData.values()) {\n      if (validScopes?.size === 0)\n        continue;\n      resultGroups[dataIndex] = keys;\n      resultData[dataIndex++] = {\n        keys,\n        values,\n        datum,\n        validScopes\n      };\n    }\n    return {\n      ...data,\n      type: \"grouped\",\n      data: resultData,\n      domain: {\n        ...data.domain,\n        groups: resultGroups\n      }\n    };\n  }\n  aggregateData(processedData) {\n    const isUngrouped = processedData.type === \"ungrouped\";\n    processedData.domain.aggValues = [];\n    for (const [index, def] of this.aggregates.entries()) {\n      const indices = this.valueGroupIdxLookup(def);\n      const domain = [Infinity, -Infinity];\n      for (const datum of processedData.data) {\n        datum.aggValues ?? (datum.aggValues = new Array(this.aggregates.length));\n        if (datum.validScopes)\n          continue;\n        const values = isUngrouped ? [datum.values] : datum.values;\n        let groupAggValues = def.groupAggregateFunction?.() ?? [Infinity, -Infinity];\n        for (const distinctValues of values) {\n          const valuesToAgg = indices.map((valueIdx) => distinctValues[valueIdx]);\n          const valuesAgg = def.aggregateFunction(valuesToAgg, datum.keys);\n          if (valuesAgg) {\n            groupAggValues = def.groupAggregateFunction?.(valuesAgg, groupAggValues) ?? ContinuousDomain.extendDomain(valuesAgg, groupAggValues);\n          }\n        }\n        const finalValues = (def.finalFunction?.(groupAggValues) ?? groupAggValues).map((v) => round2(v));\n        datum.aggValues[index] = finalValues;\n        ContinuousDomain.extendDomain(finalValues, domain);\n      }\n      processedData.domain.aggValues.push(domain);\n    }\n  }\n  postProcessGroups(processedData) {\n    const { groupProcessors } = this;\n    const affectedIndices = /* @__PURE__ */ new Set();\n    const updatedDomains = /* @__PURE__ */ new Map();\n    const groupProcessorIndices = /* @__PURE__ */ new Map();\n    const groupProcessorInitFns = /* @__PURE__ */ new Map();\n    for (const processor of groupProcessors) {\n      const indices = this.valueGroupIdxLookup(processor);\n      groupProcessorIndices.set(processor, indices);\n      groupProcessorInitFns.set(processor, processor.adjust());\n      for (const idx of indices) {\n        const valueDef = this.values[idx];\n        const isDiscrete = valueDef.valueType === \"category\";\n        affectedIndices.add(idx);\n        updatedDomains.set(idx, isDiscrete ? new DiscreteDomain() : new ContinuousDomain());\n      }\n    }\n    const updateDomains = (values) => {\n      for (const valueIndex of affectedIndices) {\n        updatedDomains.get(valueIndex)?.extend(values[valueIndex]);\n      }\n    };\n    for (const group of processedData.data) {\n      for (const processor of groupProcessors) {\n        if (group.validScopes)\n          continue;\n        const valueIndexes = groupProcessorIndices.get(processor) ?? [];\n        const adjustFn = groupProcessorInitFns.get(processor)?.();\n        if (!adjustFn)\n          continue;\n        if (processedData.type === \"grouped\") {\n          for (const values of group.values) {\n            if (values) {\n              adjustFn(values, valueIndexes);\n            }\n          }\n        } else if (group.values) {\n          adjustFn(group.values, valueIndexes);\n        }\n      }\n      if (processedData.type === \"grouped\") {\n        for (const values of group.values) {\n          updateDomains(values);\n        }\n      } else {\n        updateDomains(group.values);\n      }\n    }\n    for (const [idx, dataDomain] of updatedDomains) {\n      processedData.domain.values[idx] = dataDomain.getDomain();\n    }\n  }\n  postProcessProperties(processedData) {\n    for (const { adjust, property, scopes } of this.propertyProcessors) {\n      adjust()(processedData, this.valueIdxLookup(scopes, property));\n    }\n  }\n  reduceData(processedData) {\n    processedData.reduced ?? (processedData.reduced = {});\n    for (const def of this.reducers) {\n      const reducer = def.reducer();\n      let accValue = def.initialValue;\n      for (const datum of processedData.data) {\n        if (!datum.validScopes || def.scopes?.some((s) => datum.validScopes?.has(s))) {\n          accValue = reducer(accValue, datum);\n        }\n      }\n      processedData.reduced[def.property] = accValue;\n    }\n  }\n  postProcessData(processedData) {\n    processedData.reduced ?? (processedData.reduced = {});\n    for (const def of this.processors) {\n      processedData.reduced[def.property] = def.calculate(processedData);\n    }\n  }\n  initDataDomainProcessor() {\n    const { keys: keyDefs, values: valueDefs } = this;\n    const scopes = /* @__PURE__ */ new Set();\n    for (const valueDef of valueDefs) {\n      if (!valueDef.scopes)\n        continue;\n      for (const scope of valueDef.scopes) {\n        scopes.add(scope);\n      }\n    }\n    const dataDomain = /* @__PURE__ */ new Map();\n    const processorFns = /* @__PURE__ */ new Map();\n    let allScopesHaveSameDefs = true;\n    const initDataDomain = () => {\n      for (const def of iterate(keyDefs, valueDefs)) {\n        if (def.valueType === \"category\") {\n          dataDomain.set(def, new DiscreteDomain());\n        } else {\n          dataDomain.set(def, new ContinuousDomain());\n          allScopesHaveSameDefs && (allScopesHaveSameDefs = (def.scopes ?? []).length === scopes.size);\n        }\n      }\n    };\n    initDataDomain();\n    const accessors = this.buildAccessors(iterate(keyDefs, valueDefs));\n    const processValue = (def, datum, previousDatum, scope) => {\n      let valueInDatum;\n      let value;\n      if (accessors.has(def.property)) {\n        try {\n          value = accessors.get(def.property)(datum);\n        } catch (error) {\n        }\n        valueInDatum = value != null;\n      } else {\n        valueInDatum = def.property in datum;\n        value = valueInDatum ? datum[def.property] : def.missingValue;\n      }\n      if (def.forceValue != null) {\n        const valueNegative = valueInDatum && isNegative(value);\n        value = valueNegative ? -1 * def.forceValue : def.forceValue;\n        valueInDatum = true;\n      }\n      const missingValueDef = \"missingValue\" in def;\n      if (!valueInDatum && !missingValueDef) {\n        const missCount = def.missing.get(scope) ?? 0;\n        def.missing.set(scope, missCount + 1);\n      }\n      if (!dataDomain.has(def)) {\n        initDataDomain();\n      }\n      if (valueInDatum && !(def.validation?.(value, datum) ?? true)) {\n        if (\"invalidValue\" in def) {\n          value = def.invalidValue;\n        } else {\n          if (this.mode !== \"integrated\") {\n            Logger.warnOnce(\n              `invalid value of type [${typeof value}] for [${def.scopes} / ${def.id}] ignored:`,\n              `[${value}]`\n            );\n          }\n          return INVALID_VALUE;\n        }\n      }\n      if (def.processor) {\n        if (!processorFns.has(def)) {\n          processorFns.set(def, def.processor());\n        }\n        value = processorFns.get(def)?.(value, previousDatum === INVALID_VALUE ? void 0 : previousDatum);\n      }\n      dataDomain.get(def)?.extend(value);\n      return value;\n    };\n    return { dataDomain, processValue, initDataDomain, scopes, allScopesHaveSameDefs };\n  }\n  buildAccessors(defs) {\n    const result = /* @__PURE__ */ new Map();\n    if (this.mode === \"integrated\") {\n      return result;\n    }\n    for (const def of defs) {\n      const isPath = def.property.includes(\".\") || def.property.includes(\"[\");\n      if (!isPath)\n        continue;\n      const components = getPathComponents(def.property);\n      if (components == null) {\n        Logger.warnOnce(\"Invalid property path [%s]\", def.property);\n        continue;\n      }\n      const accessor = createPathAccessor(components);\n      result.set(def.property, accessor);\n    }\n    return result;\n  }\n};\nfunction logProcessedData(processedData) {\n  const logValues = (name, data) => {\n    if (data.length > 0) {\n      Logger.log(`DataModel.processData() - ${name}`);\n      Logger.table(data);\n    }\n  };\n  Logger.log(\"DataModel.processData() - processedData\", processedData);\n  logValues(\"Key Domains\", processedData.domain.keys);\n  logValues(\"Group Domains\", processedData.domain.groups ?? []);\n  logValues(\"Value Domains\", processedData.domain.values);\n  logValues(\"Aggregate Domains\", processedData.domain.aggValues ?? []);\n  if (processedData.type === \"grouped\") {\n    const flattenedValues = processedData.data.reduce((acc, next) => {\n      const keys = next.keys ?? [];\n      const aggValues = next.aggValues ?? [];\n      const skipKeys = next.keys.map(() => void 0);\n      const skipAggValues = aggValues?.map(() => void 0);\n      acc.push(\n        ...next.values.map((v, i) => [\n          ...i === 0 ? keys : skipKeys,\n          ...v ?? [],\n          ...i == 0 ? aggValues : skipAggValues\n        ])\n      );\n      return acc;\n    }, []);\n    logValues(\"Values\", flattenedValues);\n  } else {\n    const flattenedValues = processedData.data.reduce((acc, next) => {\n      const aggValues = next.aggValues ?? [];\n      acc.push([...next.keys, ...next.values, ...aggValues]);\n      return acc;\n    }, []);\n    logValues(\"Values\", flattenedValues);\n  }\n}\n\n// packages/ag-charts-community/src/chart/data/dataController.ts\nvar _DataController = class _DataController {\n  constructor(mode) {\n    this.mode = mode;\n    this.debug = Debug.create(true, \"data-model\");\n    this.requested = [];\n    this.status = \"setup\";\n  }\n  async request(id, data, opts) {\n    if (this.status !== \"setup\") {\n      throw new Error(`AG Charts - data request after data setup phase.`);\n    }\n    return new Promise((resolve, reject) => {\n      this.requested.push({ id, opts, data, resolve, reject });\n    });\n  }\n  execute() {\n    if (this.status !== \"setup\") {\n      throw new Error(`AG Charts - data request after data setup phase.`);\n    }\n    this.status = \"executed\";\n    this.debug(\"DataController.execute() - requested\", this.requested);\n    const valid = this.validateRequests(this.requested);\n    this.debug(\"DataController.execute() - validated\", valid);\n    const merged = this.mergeRequested(valid);\n    this.debug(\"DataController.execute() - merged\", merged);\n    if (this.debug.check()) {\n      getWindow().processedData = [];\n    }\n    const scopes = this.requested.map(({ id }) => id);\n    const needsValueExtraction = this.hasMultipleDataSources(valid);\n    for (const { opts, data, resolves, rejects, ids } of merged) {\n      try {\n        const dataModel = new DataModel(opts, this.mode);\n        const processedData = dataModel.processData(data, valid);\n        if (this.debug.check()) {\n          getWindow(\"processedData\").push(processedData);\n        }\n        if (processedData?.partialValidDataCount === 0) {\n          resolves.forEach(\n            (resolve, requestIdx) => resolve({\n              dataModel,\n              processedData: this.processScopedData(\n                ids[requestIdx],\n                processedData,\n                scopes,\n                needsValueExtraction\n              )\n            })\n          );\n        } else if (processedData) {\n          this.splitResult(dataModel, processedData, ids, resolves);\n        } else {\n          rejects.forEach((cb) => cb(new Error(`AG Charts - no processed data generated`)));\n        }\n      } catch (error) {\n        rejects.forEach((cb) => cb(error));\n      }\n    }\n  }\n  hasMultipleDataSources(validRequests) {\n    if (validRequests.length) {\n      const [{ data }, ...restRequests] = validRequests;\n      return restRequests.some((v) => data !== v.data);\n    }\n    return false;\n  }\n  processScopedData(id, processedData, ids, needsValueExtraction) {\n    const extractDatum = (datum) => {\n      if (Array.isArray(datum)) {\n        return datum.map(extractDatum);\n      }\n      const extracted = needsValueExtraction ? { ...datum, ...datum[id] } : datum;\n      for (const otherId of ids) {\n        delete extracted[otherId];\n      }\n      return extracted;\n    };\n    const extractValues = (values) => {\n      if (Array.isArray(values)) {\n        return values.map(extractValues);\n      }\n      return values?.[id] ?? values;\n    };\n    return {\n      ...processedData,\n      data: processedData.data.map((datum) => ({\n        ...datum,\n        datum: extractDatum(datum.datum),\n        values: needsValueExtraction ? datum.values?.map(extractValues) : datum.values\n      }))\n    };\n  }\n  validateRequests(requested) {\n    const valid = [];\n    for (const [index, request] of requested.entries()) {\n      if (index > 0 && request.data.length !== requested[0].data.length && request.opts.groupByData === false) {\n        request.reject(\n          new Error(\"all series[].data arrays must be of the same length and have matching keys.\")\n        );\n      } else {\n        valid.push(request);\n      }\n    }\n    return valid;\n  }\n  mergeRequested(requested) {\n    const grouped = [];\n    for (const request of requested) {\n      const match = grouped.find(_DataController.groupMatch(request));\n      if (match) {\n        match.push(request);\n      } else {\n        grouped.push([request]);\n      }\n    }\n    return grouped.map(_DataController.mergeRequests);\n  }\n  splitResult(dataModel, processedData, scopes, resolves) {\n    for (let i = 0; i < scopes.length; i++) {\n      const scope = scopes[i];\n      const resolve = resolves[i];\n      resolve({\n        dataModel,\n        processedData: {\n          ...processedData,\n          data: processedData.data.filter(({ validScopes }) => validScopes?.has(scope) ?? true)\n        }\n      });\n    }\n  }\n  static groupMatch({ data, opts }) {\n    function keys(props) {\n      return props.filter((p) => p.type === \"key\").map((p) => p.property).join(\";\");\n    }\n    return ([group]) => (opts.groupByData === false || group.data === data) && group.opts.groupByKeys === opts.groupByKeys && group.opts.groupByFn === opts.groupByFn && keys(group.opts.props) === keys(opts.props);\n  }\n  static mergeRequests(requests) {\n    return requests.reduce(\n      (result, { id, data, resolve, reject, opts: { props, ...opts } }) => {\n        result.ids.push(id);\n        result.rejects.push(reject);\n        result.resolves.push(resolve);\n        result.data ?? (result.data = data);\n        result.opts ?? (result.opts = { ...opts, props: [] });\n        for (const prop of props) {\n          const clone = { ...prop, scopes: [id] };\n          _DataController.createIdsMap(id, clone);\n          const match = result.opts.props.find(\n            (existing) => existing.type === clone.type && _DataController.deepEqual(existing, clone)\n          );\n          if (!match) {\n            result.opts.props.push(clone);\n            continue;\n          }\n          match.scopes ?? (match.scopes = []);\n          match.scopes.push(...clone.scopes ?? []);\n          if ((match.type === \"key\" || match.type === \"value\") && clone.idsMap?.size) {\n            _DataController.mergeIdsMap(clone.idsMap, match.idsMap);\n          }\n        }\n        return result;\n      },\n      { ids: [], rejects: [], resolves: [], data: null, opts: null }\n    );\n  }\n  static mergeIdsMap(fromMap, toMap) {\n    for (const [scope, ids] of fromMap) {\n      if (toMap.has(scope)) {\n        for (const id of ids) {\n          toMap.get(scope).add(id);\n        }\n      } else {\n        toMap.set(scope, new Set(ids));\n      }\n    }\n  }\n  static createIdsMap(scope, prop) {\n    if (prop.id == null)\n      return;\n    prop.idsMap ?? (prop.idsMap = /* @__PURE__ */ new Map());\n    if (prop.idsMap.has(scope)) {\n      prop.idsMap.get(scope).add(prop.id);\n    } else {\n      prop.idsMap.set(scope, /* @__PURE__ */ new Set([prop.id]));\n    }\n  }\n  static deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n    if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n      if (a.constructor !== b.constructor) {\n        return false;\n      }\n      let i, length2;\n      if (Array.isArray(a)) {\n        length2 = a.length;\n        if (length2 !== b.length) {\n          return false;\n        }\n        for (i = length2 - 1; i >= 0; i--) {\n          if (!_DataController.deepEqual(a[i], b[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      const keys = Object.keys(a);\n      length2 = keys.length;\n      if (length2 !== Object.keys(b).length) {\n        return false;\n      }\n      for (i = length2 - 1; i >= 0; i--) {\n        const key = keys[i];\n        if (!_DataController.skipKeys.has(key) && (!Object.hasOwn(b, key) || !_DataController.deepEqual(a[key], b[key]))) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n};\n// optimized version of deep equality for `mergeRequests` which can potentially loop over 1M times\n_DataController.skipKeys = /* @__PURE__ */ new Set([\"id\", \"idsMap\", \"type\", \"scopes\"]);\nvar DataController = _DataController;\n\n// packages/ag-charts-community/src/chart/factory/axisRegistry.ts\nvar AxisRegistry = class {\n  constructor() {\n    this.axesMap = /* @__PURE__ */ new Map();\n    this.hidden = /* @__PURE__ */ new Set();\n    this.themeTemplates = /* @__PURE__ */ new Map();\n  }\n  register(axisType, module) {\n    this.axesMap.set(axisType, module.instanceConstructor);\n    if (module.themeTemplate) {\n      this.setThemeTemplate(axisType, module.themeTemplate);\n    }\n    if (module.hidden) {\n      this.hidden.add(axisType);\n    }\n  }\n  create(axisType, moduleContext) {\n    const AxisConstructor = this.axesMap.get(axisType);\n    if (AxisConstructor) {\n      return new AxisConstructor(moduleContext);\n    }\n    throw new Error(`AG Charts - unknown axis type: ${axisType}`);\n  }\n  has(axisType) {\n    return this.axesMap.has(axisType);\n  }\n  keys() {\n    return this.axesMap.keys();\n  }\n  publicKeys() {\n    return [...this.keys()].filter((k) => !this.hidden.has(k));\n  }\n  setThemeTemplate(axisType, themeTemplate) {\n    this.themeTemplates.set(axisType, themeTemplate);\n    return this;\n  }\n  getThemeTemplate(axisType) {\n    return this.themeTemplates.get(axisType);\n  }\n};\nvar axisRegistry = new AxisRegistry();\n\n// packages/ag-charts-community/src/chart/factory/expectedEnterpriseModules.ts\nvar EXPECTED_ENTERPRISE_MODULES = [\n  {\n    type: \"root\",\n    optionsKey: \"animation\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"]\n  },\n  { type: \"root\", optionsKey: \"annotations\", chartTypes: [\"cartesian\"] },\n  {\n    type: \"root\",\n    optionsKey: \"background\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n    optionsInnerKey: \"image\"\n  },\n  {\n    type: \"root\",\n    optionsKey: \"contextMenu\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"]\n  },\n  { type: \"root\", optionsKey: \"statusBar\", chartTypes: [\"cartesian\"], identifier: \"status-bar\" },\n  {\n    type: \"root\",\n    optionsKey: \"dataSource\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"]\n  },\n  { type: \"root\", optionsKey: \"sync\", chartTypes: [\"cartesian\"] },\n  { type: \"root\", optionsKey: \"zoom\", chartTypes: [\"cartesian\", \"topology\"] },\n  {\n    type: \"legend\",\n    optionsKey: \"gradientLegend\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n    identifier: \"gradient\"\n  },\n  { type: \"root\", optionsKey: \"navigator\", chartTypes: [\"cartesian\"], optionsInnerKey: \"miniChart\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"angle-category\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"angle-number\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"radius-category\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"radius-number\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"cartesian\"], identifier: \"ordinal-time\" },\n  { type: \"axis-option\", optionsKey: \"crosshair\", chartTypes: [\"cartesian\"] },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"box-plot\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"candlestick\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"ohlc\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"bullet\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"heatmap\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"range-area\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"range-bar\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"waterfall\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"nightingale\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radar-area\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radar-line\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radial-bar\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radial-column\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"hierarchy\"], identifier: \"sunburst\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"hierarchy\"], identifier: \"treemap\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-shape\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-line\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-marker\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-shape-background\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-line-background\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"flow-proportion\"], identifier: \"chord\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"flow-proportion\"], identifier: \"sankey\" },\n  { type: \"series-option\", optionsKey: \"errorBar\", chartTypes: [\"cartesian\"], identifier: \"error-bars\" }\n];\nfunction isEnterpriseSeriesType(type) {\n  return EXPECTED_ENTERPRISE_MODULES.some((s) => s.type === \"series\" && s.identifier === type);\n}\nfunction getEnterpriseSeriesChartTypes(type) {\n  return EXPECTED_ENTERPRISE_MODULES.find((s) => s.type === \"series\" && s.identifier === type)?.chartTypes;\n}\nfunction isEnterpriseCartesian(seriesType) {\n  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === \"cartesian\");\n  return type === \"cartesian\";\n}\nfunction isEnterprisePolar(seriesType) {\n  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === \"polar\");\n  return type === \"polar\";\n}\nfunction isEnterpriseHierarchy(seriesType) {\n  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === \"hierarchy\");\n  return type === \"hierarchy\";\n}\nfunction isEnterpriseTopology(seriesType) {\n  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === \"topology\");\n  return type === \"topology\";\n}\nfunction isEnterpriseFlowProportion(seriesType) {\n  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === \"flow-proportion\");\n  return type === \"flow-proportion\";\n}\nfunction isEnterpriseModule(module) {\n  return module.packageType === \"enterprise\";\n}\nfunction verifyIfModuleExpected(module) {\n  if (!isEnterpriseModule(module)) {\n    throw new Error(\"AG Charts - internal configuration error, only enterprise modules need verification.\");\n  }\n  const stub = EXPECTED_ENTERPRISE_MODULES.find((s) => {\n    return s.type === module.type && s.optionsKey === module.optionsKey && s.identifier === module.identifier && module.chartTypes.every((t) => s.chartTypes.includes(t));\n  });\n  if (stub) {\n    stub.useCount ?? (stub.useCount = 0);\n    stub.useCount++;\n  }\n  return stub != null;\n}\nfunction getUnusedExpectedModules() {\n  return EXPECTED_ENTERPRISE_MODULES.filter(({ useCount }) => useCount == null || useCount === 0);\n}\n\n// packages/ag-charts-community/src/chart/factory/legendRegistry.ts\nvar LegendRegistry = class {\n  constructor() {\n    this.legendMap = /* @__PURE__ */ new Map();\n    this.themeTemplates = /* @__PURE__ */ new Map();\n  }\n  register(legendType, { optionsKey, instanceConstructor, themeTemplate }) {\n    this.legendMap.set(legendType, { optionsKey, instanceConstructor });\n    this.themeTemplates.set(optionsKey, themeTemplate);\n  }\n  create(legendType, moduleContext) {\n    const LegendConstructor = this.legendMap.get(legendType)?.instanceConstructor;\n    if (LegendConstructor) {\n      return new LegendConstructor(moduleContext);\n    }\n    throw new Error(`AG Charts - unknown legend type: ${legendType}`);\n  }\n  getThemeTemplates() {\n    return Object.fromEntries(this.themeTemplates);\n  }\n  getKeys() {\n    return Array.from(this.legendMap.entries()).reduce(\n      (result, [legendType, record]) => {\n        result[legendType] = record.optionsKey;\n        return result;\n      },\n      {}\n    );\n  }\n};\nvar legendRegistry = new LegendRegistry();\n\n// packages/ag-charts-community/src/module/enterpriseModule.ts\nvar enterpriseModule = {\n  isEnterprise: false\n};\n\n// packages/ag-charts-community/src/chart/factory/chartTypes.ts\nvar ChartTypes = class extends Map {\n  get(seriesType) {\n    return super.get(seriesType) ?? \"unknown\";\n  }\n  isCartesian(seriesType) {\n    return this.get(seriesType) === \"cartesian\";\n  }\n  isPolar(seriesType) {\n    return this.get(seriesType) === \"polar\";\n  }\n  isHierarchy(seriesType) {\n    return this.get(seriesType) === \"hierarchy\";\n  }\n  isTopology(seriesType) {\n    return this.get(seriesType) === \"topology\";\n  }\n  isFlowProportion(seriesType) {\n    return this.get(seriesType) === \"flow-proportion\";\n  }\n  get seriesTypes() {\n    return Array.from(this.keys());\n  }\n  get cartesianTypes() {\n    return this.seriesTypes.filter((t) => this.isCartesian(t));\n  }\n  get polarTypes() {\n    return this.seriesTypes.filter((t) => this.isPolar(t));\n  }\n  get hierarchyTypes() {\n    return this.seriesTypes.filter((t) => this.isHierarchy(t));\n  }\n  get topologyTypes() {\n    return this.seriesTypes.filter((t) => this.isTopology(t));\n  }\n  get flowProportionTypes() {\n    return this.seriesTypes.filter((t) => this.isFlowProportion(t));\n  }\n};\nvar ChartDefaults = class extends Map {\n  set(chartType2, defaults) {\n    return super.set(chartType2, mergeDefaults(defaults, this.get(chartType2)));\n  }\n};\nvar chartTypes = new ChartTypes();\nvar publicChartTypes = new ChartTypes();\nvar chartDefaults = new ChartDefaults();\n\n// packages/ag-charts-community/src/chart/factory/seriesRegistry.ts\nvar SeriesRegistry = class {\n  constructor() {\n    this.seriesMap = /* @__PURE__ */ new Map();\n    this.themeTemplates = /* @__PURE__ */ new Map();\n  }\n  register(seriesType, {\n    chartTypes: [chartType2],\n    instanceConstructor,\n    tooltipDefaults,\n    defaultAxes,\n    themeTemplate,\n    enterpriseThemeTemplate,\n    paletteFactory,\n    solo,\n    stackable,\n    groupable,\n    stackedByDefault,\n    swapDefaultAxesCondition,\n    hidden\n  }) {\n    this.setThemeTemplate(seriesType, themeTemplate, enterpriseThemeTemplate);\n    this.seriesMap.set(seriesType, {\n      instanceConstructor,\n      tooltipDefaults,\n      defaultAxes,\n      paletteFactory,\n      solo,\n      stackable,\n      groupable,\n      stackedByDefault,\n      swapDefaultAxesCondition\n    });\n    chartTypes.set(seriesType, chartType2);\n    if (!hidden) {\n      publicChartTypes.set(seriesType, chartType2);\n    }\n  }\n  create(seriesType, moduleContext) {\n    const SeriesConstructor = this.seriesMap.get(seriesType)?.instanceConstructor;\n    if (SeriesConstructor) {\n      return new SeriesConstructor(moduleContext);\n    }\n    throw new Error(`AG Charts - unknown series type: ${seriesType}`);\n  }\n  cloneDefaultAxes(seriesType) {\n    const defaultAxes = this.seriesMap.get(seriesType)?.defaultAxes;\n    return defaultAxes ? { axes: deepClone(defaultAxes) } : null;\n  }\n  setThemeTemplate(seriesType, themeTemplate, enterpriseThemeTemplate = {}) {\n    const currentTemplate = this.themeTemplates.get(seriesType);\n    this.themeTemplates.set(seriesType, {\n      community: mergeDefaults(themeTemplate, currentTemplate?.community),\n      enterprise: mergeDefaults(enterpriseThemeTemplate, themeTemplate, currentTemplate?.community)\n    });\n  }\n  getThemeTemplate(seriesType) {\n    const themeTemplate = this.themeTemplates.get(seriesType);\n    return enterpriseModule.isEnterprise ? themeTemplate?.enterprise : themeTemplate?.community;\n  }\n  getPaletteFactory(seriesType) {\n    return this.seriesMap.get(seriesType)?.paletteFactory;\n  }\n  getTooltipDefauls(seriesType) {\n    return this.seriesMap.get(seriesType)?.tooltipDefaults;\n  }\n  isSolo(seriesType) {\n    return this.seriesMap.get(seriesType)?.solo ?? false;\n  }\n  isGroupable(seriesType) {\n    return this.seriesMap.get(seriesType)?.groupable ?? false;\n  }\n  isStackable(seriesType) {\n    return this.seriesMap.get(seriesType)?.stackable ?? false;\n  }\n  isStackedByDefault(seriesType) {\n    return this.seriesMap.get(seriesType)?.stackedByDefault ?? false;\n  }\n  isDefaultAxisSwapNeeded(options) {\n    let result;\n    for (const series of options.series ?? []) {\n      const { type = \"line\" } = series;\n      const isDefaultAxisSwapped = this.seriesMap.get(type)?.swapDefaultAxesCondition?.(series);\n      if (isDefaultAxisSwapped != null) {\n        if (result != null && result != isDefaultAxisSwapped) {\n          throw new Error(\"AG Charts - The provided series have incompatible directions\");\n        }\n        result = isDefaultAxisSwapped;\n      }\n    }\n    return result;\n  }\n};\nvar seriesRegistry = new SeriesRegistry();\n\n// packages/ag-charts-community/src/chart/interaction/syncManager.ts\nvar _SyncManager = class _SyncManager extends BaseManager {\n  constructor(chart) {\n    super();\n    this.chart = chart;\n  }\n  subscribe(groupId = _SyncManager.DEFAULT_GROUP) {\n    let syncGroup = this.get(groupId);\n    if (!syncGroup) {\n      syncGroup = /* @__PURE__ */ new Set();\n      _SyncManager.chartsGroups.set(groupId, syncGroup);\n    }\n    syncGroup.add(this.chart);\n    return this;\n  }\n  unsubscribe(groupId = _SyncManager.DEFAULT_GROUP) {\n    this.get(groupId)?.delete(this.chart);\n    return this;\n  }\n  getChart() {\n    return this.chart;\n  }\n  getGroup(groupId = _SyncManager.DEFAULT_GROUP) {\n    const syncGroup = this.get(groupId);\n    return syncGroup ? Array.from(syncGroup) : [];\n  }\n  getGroupSiblings(groupId = _SyncManager.DEFAULT_GROUP) {\n    return this.getGroup(groupId).filter((chart) => chart !== this.chart);\n  }\n  get(groupId) {\n    return _SyncManager.chartsGroups.get(groupId);\n  }\n};\n_SyncManager.chartsGroups = /* @__PURE__ */ new Map();\n_SyncManager.DEFAULT_GROUP = Symbol(\"sync-group-default\");\nvar SyncManager = _SyncManager;\n\n// packages/ag-charts-community/src/chart/interaction/zoomManager.ts\nvar ZoomManager = class extends BaseManager {\n  constructor() {\n    super(...arguments);\n    this.axisZoomManagers = /* @__PURE__ */ new Map();\n    this.state = new StateTracker(void 0, \"initial\");\n    this.rejectCallbacks = /* @__PURE__ */ new Map();\n  }\n  updateAxes(axes) {\n    const zoomManagers = new Map(axes.map((axis) => [axis.id, this.axisZoomManagers.get(axis.id)]));\n    this.axisZoomManagers.clear();\n    for (const axis of axes) {\n      this.axisZoomManagers.set(axis.id, zoomManagers.get(axis.id) ?? new AxisZoomManager(axis));\n    }\n    if (this.state.size > 0 && axes.length > 0) {\n      this.updateZoom(this.state.stateId(), this.state.stateValue());\n    }\n  }\n  updateZoom(callerId, newZoom, canChangeInitial = true, rejectCallback) {\n    if (rejectCallback) {\n      this.rejectCallbacks.set(callerId, rejectCallback);\n    }\n    if (this.axisZoomManagers.size === 0) {\n      const stateId = this.state.stateId();\n      if (stateId === \"initial\" || stateId === callerId || canChangeInitial) {\n        this.state.set(callerId, newZoom);\n        if (stateId !== callerId) {\n          this.rejectCallbacks.get(stateId)?.(callerId);\n        }\n      } else {\n        rejectCallback?.(stateId);\n      }\n      return;\n    }\n    this.state.set(callerId, newZoom);\n    this.axisZoomManagers.forEach((axis) => {\n      axis.updateZoom(callerId, newZoom?.[axis.getDirection()]);\n    });\n    this.applyChanges(callerId);\n  }\n  updateAxisZoom(callerId, axisId, newZoom) {\n    this.axisZoomManagers.get(axisId)?.updateZoom(callerId, newZoom);\n    this.applyChanges(callerId);\n  }\n  // Fire this event to signal to listeners that the view is changing through a zoom and/or pan change.\n  fireZoomPanStartEvent(callerId) {\n    this.listeners.dispatch(\"zoom-pan-start\", { type: \"zoom-pan-start\", callerId });\n  }\n  getZoom() {\n    let x;\n    let y;\n    this.axisZoomManagers.forEach((axis) => {\n      if (axis.getDirection() === \"x\" /* X */) {\n        x ?? (x = axis.getZoom());\n      } else if (axis.getDirection() === \"y\" /* Y */) {\n        y ?? (y = axis.getZoom());\n      }\n    });\n    if (x || y) {\n      return { x, y };\n    }\n  }\n  getAxisZoom(axisId) {\n    return this.axisZoomManagers.get(axisId)?.getZoom() ?? { min: 0, max: 1 };\n  }\n  getAxisZooms() {\n    const axes = {};\n    for (const [axisId, axis] of this.axisZoomManagers.entries()) {\n      axes[axisId] = {\n        direction: axis.getDirection(),\n        zoom: axis.getZoom()\n      };\n    }\n    return axes;\n  }\n  applyChanges(callerId) {\n    const changed = Array.from(this.axisZoomManagers.values(), (axis) => axis.applyChanges()).some(Boolean);\n    if (!changed) {\n      return;\n    }\n    const axes = {};\n    for (const [axisId, axis] of this.axisZoomManagers.entries()) {\n      axes[axisId] = axis.getZoom();\n    }\n    this.listeners.dispatch(\"zoom-change\", { type: \"zoom-change\", ...this.getZoom(), axes, callerId });\n  }\n};\nvar AxisZoomManager = class {\n  constructor(axis) {\n    this.axis = axis;\n    const [min = 0, max = 1] = axis.visibleRange;\n    this.state = new StateTracker({ min, max });\n    this.currentZoom = this.state.stateValue();\n  }\n  getDirection() {\n    return this.axis.direction;\n  }\n  updateZoom(callerId, newZoom) {\n    this.state.set(callerId, newZoom);\n  }\n  getZoom() {\n    return deepClone(this.state.stateValue());\n  }\n  applyChanges() {\n    const prevZoom = this.currentZoom;\n    this.currentZoom = this.state.stateValue();\n    return prevZoom.min !== this.currentZoom.min || prevZoom.max !== this.currentZoom.max;\n  }\n};\n\n// packages/ag-charts-community/src/chart/keyboard.ts\nvar Keyboard = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], Keyboard.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], Keyboard.prototype, \"tabIndex\", 2);\n\n// packages/ag-charts-community/src/chart/keyboardUtil.ts\nfunction computeCenter(bboxOrPath) {\n  if (bboxOrPath instanceof BBox) {\n    return bboxOrPath.computeCenter();\n  }\n  return bboxOrPath?.computeTransformedBBox()?.computeCenter();\n}\nfunction makeKeyboardPointerEvent(focusIndicator, pick) {\n  const { bounds, showFocusBox } = pick;\n  if (showFocusBox) {\n    focusIndicator?.updateBounds(bounds);\n  }\n  const { x: offsetX, y: offsetY } = computeCenter(bounds) ?? {};\n  if (offsetX !== void 0 && offsetY !== void 0) {\n    return { type: \"keyboard\", offsetX, offsetY };\n  }\n  return void 0;\n}\n\n// packages/ag-charts-community/src/chart/mapping/prepareAxis.ts\nvar CartesianAxisPositions = [\"top\", \"right\", \"bottom\", \"left\"];\nfunction isAxisPosition(position) {\n  return typeof position === \"string\" && CartesianAxisPositions.includes(position);\n}\nfunction guessInvalidPositions(axes) {\n  const invalidAxes = [];\n  const usedPositions = [];\n  const guesses = [...CartesianAxisPositions];\n  for (const axis of axes) {\n    if (axis instanceof CartesianAxis) {\n      if (isAxisPosition(axis.position)) {\n        usedPositions.push(axis.position);\n      } else {\n        invalidAxes.push(axis);\n      }\n    }\n  }\n  for (const axis of invalidAxes) {\n    let nextGuess;\n    do {\n      nextGuess = guesses.pop();\n    } while (nextGuess && usedPositions.includes(nextGuess));\n    if (nextGuess == null)\n      break;\n    axis.position = nextGuess;\n  }\n}\n\n// packages/ag-charts-community/src/chart/mapping/prepareSeries.ts\nvar MATCHING_KEYS = [\n  \"direction\",\n  \"xKey\",\n  \"yKey\",\n  \"sizeKey\",\n  \"angleKey\",\n  \"radiusKey\",\n  \"normalizedTo\",\n  \"stacked\",\n  \"grouped\",\n  \"stackGroup\"\n];\nfunction matchSeriesOptions(series, optSeries, oldOptsSeries) {\n  const generateKey = (type, i) => {\n    const result = [type];\n    for (const key of MATCHING_KEYS) {\n      if (key in i && i[key] != null)\n        result.push(`${key}=${i[key]}`);\n    }\n    return result.join(\";\");\n  };\n  const seriesMap = /* @__PURE__ */ new Map();\n  let idx = 0;\n  for (const s of series) {\n    const key = generateKey(s.type, s.properties);\n    if (!seriesMap.has(key)) {\n      seriesMap.set(key, []);\n    }\n    seriesMap.get(key)?.push([s, idx++]);\n  }\n  const optsMap = /* @__PURE__ */ new Map();\n  for (const o of optSeries) {\n    const key = generateKey(o.type, o);\n    if (!optsMap.has(key)) {\n      optsMap.set(key, []);\n    }\n    optsMap.get(key)?.push(o);\n  }\n  const overlap = [...seriesMap.keys()].some((k) => optsMap.has(k));\n  if (!overlap) {\n    return { status: \"no-overlap\", oldKeys: seriesMap.keys(), newKeys: optsMap.keys() };\n  }\n  const changes = [];\n  let targetIdx = -1;\n  for (const [key, optArray] of optsMap.entries()) {\n    for (const opts of optArray) {\n      targetIdx++;\n      const seriesArray = seriesMap.get(key);\n      if (seriesArray == null || seriesArray.length < 1) {\n        changes.push({ opts, idx: targetIdx, status: \"add\" });\n        seriesMap.delete(key);\n        continue;\n      }\n      const [outputSeries, outputIdx] = seriesArray.shift();\n      const previousOpts = oldOptsSeries?.[outputIdx] ?? {};\n      const diff2 = jsonDiff(previousOpts, opts ?? {});\n      const { groupIndex, stackIndex } = diff2?.seriesGrouping ?? {};\n      if (groupIndex != null || stackIndex != null) {\n        changes.push({ opts, series: outputSeries, diff: diff2, idx: outputIdx, status: \"series-grouping\" });\n      } else if (diff2) {\n        changes.push({ opts, series: outputSeries, diff: diff2, idx: outputIdx, status: \"update\" });\n      } else {\n        changes.push({ opts, series: outputSeries, idx: outputIdx, status: \"no-op\" });\n      }\n      if (seriesArray.length === 0) {\n        seriesMap.delete(key);\n      }\n    }\n  }\n  for (const seriesArray of seriesMap.values()) {\n    for (const [outputSeries, outputIdx] of seriesArray) {\n      changes.push({ series: outputSeries, idx: outputIdx, status: \"remove\" });\n    }\n  }\n  return { status: \"overlap\", changes };\n}\n\n// packages/ag-charts-community/src/chart/mapping/types.ts\nfunction optionsType(input) {\n  return input.series?.[0]?.type ?? \"line\";\n}\nfunction isAgCartesianChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return true;\n  }\n  if (specifiedType === \"cartesian\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isCartesian(specifiedType) || isEnterpriseCartesian(specifiedType);\n}\nfunction isAgPolarChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"polar\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isPolar(specifiedType) || isEnterprisePolar(specifiedType);\n}\nfunction isAgHierarchyChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"hierarchy\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isHierarchy(specifiedType) || isEnterpriseHierarchy(specifiedType);\n}\nfunction isAgTopologyChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"topology\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isTopology(specifiedType) || isEnterpriseTopology(specifiedType);\n}\nfunction isAgFlowProportionChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"flow-proportion\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isFlowProportion(specifiedType) || isEnterpriseFlowProportion(specifiedType);\n}\nfunction isAgPolarChartOptionsWithSeriesBasedLegend(input) {\n  const specifiedType = optionsType(input);\n  return isAgPolarChartOptions(input) && specifiedType !== \"pie\" && specifiedType !== \"donut\";\n}\nfunction isSeriesOptionType(input) {\n  if (input == null) {\n    return false;\n  }\n  return chartTypes.has(input);\n}\nfunction isAxisOptionType(input) {\n  if (input == null) {\n    return false;\n  }\n  return axisRegistry.has(input);\n}\n\n// packages/ag-charts-community/src/chart/modulesManager.ts\nvar ModulesManager = class extends ModuleMap {\n  applyOptions(options) {\n    for (const m of this.moduleMap.values()) {\n      if (m.module.optionsKey in options && isProperties(m.moduleInstance)) {\n        m.moduleInstance.set(options[m.module.optionsKey]);\n      }\n    }\n  }\n  *legends() {\n    for (const { module, moduleInstance } of this.moduleMap.values()) {\n      if (module.type !== \"legend\")\n        continue;\n      yield {\n        legendType: module.identifier,\n        legend: moduleInstance\n      };\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/overlay/overlay.ts\nvar DEFAULT_OVERLAY_CLASS = \"ag-chart-overlay\";\nvar DEFAULT_OVERLAY_DARK_CLASS = \"ag-chart-dark-overlay\";\nvar Overlay = class extends BaseProperties {\n  constructor(className, defaultMessageId) {\n    super();\n    this.className = className;\n    this.defaultMessageId = defaultMessageId;\n  }\n  getText(localeManager) {\n    return localeManager.t(this.text ?? this.defaultMessageId);\n  }\n  getElement(animationManager, localeManager, rect) {\n    this.content?.remove();\n    this.focusBox = rect;\n    if (this.renderer) {\n      const htmlContent = this.renderer();\n      this.content = createElement(\"div\");\n      if (htmlContent instanceof HTMLElement) {\n        this.content.replaceChildren(htmlContent);\n      } else {\n        this.content.innerHTML = htmlContent;\n      }\n    } else {\n      const content = createElement(\"div\", {\n        display: \"flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        boxSizing: \"border-box\",\n        height: \"100%\",\n        margin: \"8px\",\n        font: \"12px Verdana, sans-serif\"\n      });\n      content.innerText = this.getText(localeManager);\n      this.content = content;\n      animationManager?.animate({\n        from: 0,\n        to: 1,\n        id: \"overlay\",\n        phase: \"add\",\n        groupId: \"opacity\",\n        onUpdate(value) {\n          content.style.opacity = String(value);\n        },\n        onStop() {\n          content.style.opacity = \"1\";\n        }\n      });\n    }\n    return this.content;\n  }\n  removeElement(cleanup = () => this.content?.remove(), animationManager) {\n    if (!this.content)\n      return;\n    if (animationManager) {\n      const { content } = this;\n      animationManager.animate({\n        from: 1,\n        to: 0,\n        phase: \"remove\",\n        id: \"overlay\",\n        groupId: \"opacity\",\n        onUpdate(value) {\n          content.style.opacity = String(value);\n        },\n        onStop() {\n          cleanup?.();\n        }\n      });\n    } else {\n      cleanup?.();\n    }\n    this.content = void 0;\n    this.focusBox = void 0;\n  }\n};\n__decorateClass([\n  Validate(STRING, { optional: true })\n], Overlay.prototype, \"text\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], Overlay.prototype, \"renderer\", 2);\n\n// packages/ag-charts-community/src/chart/overlay/chartOverlays.ts\nvar ChartOverlays = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.darkTheme = false;\n    this.loading = new Overlay(\"ag-chart-loading-overlay\", \"overlayLoadingData\");\n    this.noData = new Overlay(\"ag-chart-no-data-overlay\", \"overlayNoData\");\n    this.noVisibleSeries = new Overlay(\"ag-chart-no-visible-series\", \"overlayNoVisibleSeries\");\n  }\n  getFocusInfo(localeManager) {\n    for (const overlay of [this.loading, this.noData, this.noVisibleSeries]) {\n      if (overlay.focusBox !== void 0) {\n        return { text: overlay.getText(localeManager), rect: overlay.focusBox };\n      }\n    }\n    return void 0;\n  }\n  destroy() {\n    this.loading.removeElement();\n    this.noData.removeElement();\n    this.noVisibleSeries.removeElement();\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], ChartOverlays.prototype, \"darkTheme\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartOverlays.prototype, \"loading\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartOverlays.prototype, \"noData\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartOverlays.prototype, \"noVisibleSeries\", 2);\n\n// packages/ag-charts-community/src/chart/overlay/loadingSpinner.ts\nfunction getLoadingSpinner(text, defaultDuration) {\n  const { animationDuration } = PHASE_METADATA[\"add\"];\n  const duration = animationDuration * defaultDuration;\n  const container = createElement(\"div\", `${DEFAULT_OVERLAY_CLASS}--loading`, {\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    flexDirection: \"column\",\n    height: \"100%\",\n    boxSizing: \"border-box\",\n    font: \"13px Verdana, sans-serif\",\n    // FONT_SIZE.MEDIUM\n    userSelect: \"none\",\n    animation: `ag-charts-loading ${duration}ms linear 50ms both`\n  });\n  const matrix = createElement(\"span\", {\n    width: \"45px\",\n    height: \"40px\",\n    backgroundImage: [\n      \"linear-gradient(#0000 calc(1 * 100% / 6), #ccc 0 calc(3 * 100% / 6), #0000 0), \",\n      \"linear-gradient(#0000 calc(2 * 100% / 6), #ccc 0 calc(4 * 100% / 6), #0000 0), \",\n      \"linear-gradient(#0000 calc(3 * 100% / 6), #ccc 0 calc(5 * 100% / 6), #0000 0)\"\n    ].join(\"\"),\n    backgroundSize: \"10px 400%\",\n    backgroundRepeat: \"no-repeat\",\n    animation: \"ag-charts-loading-matrix 1s infinite linear\"\n  });\n  const label = createElement(\"p\", { marginTop: \"1em\" });\n  label.innerText = text;\n  const background = createElement(\"div\", `${DEFAULT_OVERLAY_CLASS}__loading-background`, {\n    position: \"absolute\",\n    inset: \"0\",\n    opacity: \"0.5\",\n    zIndex: \"-1\"\n  });\n  const animationStyles = createElement(\"style\");\n  animationStyles.innerText = [\n    \"@keyframes ag-charts-loading { from { opacity: 0 } to { opacity: 1 } }\",\n    \"@keyframes ag-charts-loading-matrix {\",\n    \"0% { background-position: 0% 0%, 50% 0%, 100% 0%; }\",\n    \"100% { background-position: 0% 100%, 50% 100%, 100% 100%; }\",\n    \"}\"\n  ].join(\" \");\n  container.replaceChildren(animationStyles, matrix, label, background);\n  return container;\n}\n\n// packages/ag-charts-community/src/chart/data/aggregateFunctions.ts\nfunction sumValues(values, accumulator = [0, 0]) {\n  for (const value of values) {\n    if (typeof value !== \"number\") {\n      continue;\n    }\n    if (value < 0) {\n      accumulator[0] += value;\n    }\n    if (value > 0) {\n      accumulator[1] += value;\n    }\n  }\n  return accumulator;\n}\nfunction sum(id, matchGroupId) {\n  const result = {\n    id,\n    matchGroupIds: [matchGroupId],\n    type: \"aggregate\",\n    aggregateFunction: (values) => sumValues(values)\n  };\n  return result;\n}\nfunction groupSum(id, matchGroupId) {\n  return {\n    id,\n    type: \"aggregate\",\n    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,\n    aggregateFunction: (values) => sumValues(values),\n    groupAggregateFunction: (next, acc = [0, 0]) => {\n      acc[0] += next?.[0] ?? 0;\n      acc[1] += next?.[1] ?? 0;\n      return acc;\n    }\n  };\n}\nfunction range2(id, matchGroupId) {\n  const result = {\n    id,\n    matchGroupIds: [matchGroupId],\n    type: \"aggregate\",\n    aggregateFunction: (values) => ContinuousDomain.extendDomain(values)\n  };\n  return result;\n}\nfunction groupCount(id) {\n  return {\n    id,\n    type: \"aggregate\",\n    aggregateFunction: () => [0, 1],\n    groupAggregateFunction: (next, acc = [0, 0]) => {\n      acc[0] += next?.[0] ?? 0;\n      acc[1] += next?.[1] ?? 0;\n      return acc;\n    }\n  };\n}\nfunction groupAverage(id, matchGroupId) {\n  const def = {\n    id,\n    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,\n    type: \"aggregate\",\n    aggregateFunction: (values) => sumValues(values),\n    groupAggregateFunction: (next, acc = [0, 0, -1]) => {\n      acc[0] += next?.[0] ?? 0;\n      acc[1] += next?.[1] ?? 0;\n      acc[2]++;\n      return acc;\n    },\n    finalFunction: (acc = [0, 0, 0]) => {\n      const result = acc[0] + acc[1];\n      if (result >= 0) {\n        return [0, result / acc[2]];\n      }\n      return [result / acc[2], 0];\n    }\n  };\n  return def;\n}\nfunction area(id, aggFn, matchGroupId) {\n  const result = {\n    id,\n    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,\n    type: \"aggregate\",\n    aggregateFunction: (values, keyRange = []) => {\n      const keyWidth = keyRange[1] - keyRange[0];\n      return aggFn.aggregateFunction(values).map((v) => v / keyWidth);\n    }\n  };\n  if (aggFn.groupAggregateFunction) {\n    result.groupAggregateFunction = aggFn.groupAggregateFunction;\n  }\n  return result;\n}\nfunction accumulatedValue(onlyPositive) {\n  return () => {\n    let value = 0;\n    return (datum) => {\n      if (!isFiniteNumber(datum)) {\n        return datum;\n      }\n      value += onlyPositive ? Math.max(0, datum) : datum;\n      return value;\n    };\n  };\n}\nfunction trailingAccumulatedValue() {\n  return () => {\n    let value = 0;\n    return (datum) => {\n      if (!isFiniteNumber(datum)) {\n        return datum;\n      }\n      const trailingValue = value;\n      value += datum;\n      return trailingValue;\n    };\n  };\n}\n\n// packages/ag-charts-community/src/chart/data/processors.ts\nvar SMALLEST_KEY_INTERVAL = {\n  type: \"reducer\",\n  property: \"smallestKeyInterval\",\n  initialValue: Infinity,\n  reducer: () => {\n    let prevX = NaN;\n    return (smallestSoFar = Infinity, next) => {\n      const nextX = next.keys[0];\n      const interval = Math.abs(nextX - prevX);\n      prevX = nextX;\n      if (!isNaN(interval) && interval > 0 && interval < smallestSoFar) {\n        return interval;\n      }\n      return smallestSoFar;\n    };\n  }\n};\nvar LARGEST_KEY_INTERVAL = {\n  type: \"reducer\",\n  property: \"largestKeyInterval\",\n  initialValue: -Infinity,\n  reducer: () => {\n    let prevX = NaN;\n    return (largestSoFar = -Infinity, next) => {\n      const nextX = next.keys[0];\n      const interval = Math.abs(nextX - prevX);\n      prevX = nextX;\n      if (!isNaN(interval) && interval > 0 && interval > largestSoFar) {\n        return interval;\n      }\n      return largestSoFar;\n    };\n  }\n};\nvar SORT_DOMAIN_GROUPS = {\n  type: \"processor\",\n  property: \"sortedGroupDomain\",\n  calculate: ({ domain: { groups } }) => groups?.slice().sort((a, b) => {\n    for (let i = 0; i < a.length; i++) {\n      const result = a[i] - b[i];\n      if (result !== 0) {\n        return result;\n      }\n    }\n    return 0;\n  })\n};\nfunction normaliseFnBuilder({ normaliseTo, mode }) {\n  const normalise = (val, extent2) => {\n    const result = val * normaliseTo / extent2;\n    if (result >= 0) {\n      return Math.min(normaliseTo, result);\n    }\n    return Math.max(-normaliseTo, result);\n  };\n  return () => () => (values, valueIndexes) => {\n    const valuesExtent = [0, 0];\n    for (const valueIdx of valueIndexes) {\n      const value = values[valueIdx];\n      const valIdx = value < 0 ? 0 : 1;\n      if (mode === \"sum\") {\n        valuesExtent[valIdx] += value;\n      } else if (valIdx === 0) {\n        valuesExtent[valIdx] = Math.min(valuesExtent[valIdx], value);\n      } else {\n        valuesExtent[valIdx] = Math.max(valuesExtent[valIdx], value);\n      }\n    }\n    const extent2 = Math.max(Math.abs(valuesExtent[0]), valuesExtent[1]);\n    for (const valueIdx of valueIndexes) {\n      values[valueIdx] = normalise(values[valueIdx], extent2);\n    }\n  };\n}\nfunction normaliseGroupTo(matchGroupIds, normaliseTo, mode = \"sum\") {\n  return {\n    type: \"group-value-processor\",\n    matchGroupIds,\n    adjust: memo({ normaliseTo, mode }, normaliseFnBuilder)\n  };\n}\nfunction normalisePropertyFnBuilder({\n  normaliseTo,\n  zeroDomain,\n  rangeMin,\n  rangeMax\n}) {\n  const normaliseSpan = normaliseTo[1] - normaliseTo[0];\n  const normalise = (val, start, span) => {\n    const result = normaliseTo[0] + (val - start) / span * normaliseSpan;\n    if (span === 0) {\n      return zeroDomain;\n    } else if (result >= normaliseTo[1]) {\n      return normaliseTo[1];\n    } else if (result < normaliseTo[0]) {\n      return normaliseTo[0];\n    }\n    return result;\n  };\n  return () => (pData, pIdx) => {\n    let [start, end] = pData.domain.values[pIdx];\n    if (rangeMin != null)\n      start = rangeMin;\n    if (rangeMax != null)\n      end = rangeMax;\n    const span = end - start;\n    pData.domain.values[pIdx] = [normaliseTo[0], normaliseTo[1]];\n    for (const group of pData.data) {\n      let groupValues = group.values;\n      if (pData.type === \"ungrouped\") {\n        groupValues = [groupValues];\n      }\n      for (const values of groupValues) {\n        values[pIdx] = normalise(values[pIdx], start, span);\n      }\n    }\n  };\n}\nfunction normalisePropertyTo(property, normaliseTo, zeroDomain, rangeMin, rangeMax) {\n  return {\n    type: \"property-value-processor\",\n    property,\n    adjust: memo({ normaliseTo, rangeMin, rangeMax, zeroDomain }, normalisePropertyFnBuilder)\n  };\n}\nfunction animationValidation(valueKeyIds) {\n  return {\n    type: \"processor\",\n    property: \"animationValidation\",\n    calculate(result) {\n      const { keys, values } = result.defs;\n      const { input, data } = result;\n      let uniqueKeys = true;\n      let orderedKeys = true;\n      const valueKeys = [];\n      for (let k = 0; k < values.length; k++) {\n        if (!valueKeyIds?.includes(values[k].id))\n          continue;\n        valueKeys.push([k, values[k]]);\n      }\n      const processKey = (idx, def, type) => {\n        if (def.valueType === \"category\") {\n          const keyValues = result.domain[type][idx];\n          uniqueKeys && (uniqueKeys = keyValues.length === input.count);\n          return;\n        }\n        let lastValue = data[0]?.[type][idx];\n        for (let d = 1; (uniqueKeys || orderedKeys) && d < data.length; d++) {\n          const keyValue = data[d][type][idx];\n          orderedKeys && (orderedKeys = lastValue <= keyValue);\n          uniqueKeys && (uniqueKeys = lastValue !== keyValue);\n          lastValue = keyValue;\n        }\n      };\n      for (let k = 0; (uniqueKeys || orderedKeys) && k < keys.length; k++) {\n        processKey(k, keys[k], \"keys\");\n      }\n      for (let k = 0; (uniqueKeys || orderedKeys) && k < valueKeys.length; k++) {\n        const [idx, key] = valueKeys[k];\n        processKey(idx, key, \"values\");\n      }\n      return { uniqueKeys, orderedKeys };\n    }\n  };\n}\nfunction buildGroupAccFn({ mode, separateNegative }) {\n  return () => () => (values, valueIndexes) => {\n    const acc = [0, 0];\n    for (const valueIdx of valueIndexes) {\n      const currentVal = values[valueIdx];\n      const accIndex = isNegative(currentVal) && separateNegative ? 0 : 1;\n      if (!isFiniteNumber(currentVal))\n        continue;\n      if (mode === \"normal\")\n        acc[accIndex] += currentVal;\n      values[valueIdx] = acc[accIndex];\n      if (mode === \"trailing\")\n        acc[accIndex] += currentVal;\n    }\n  };\n}\nfunction buildGroupWindowAccFn({ mode, sum: sum2 }) {\n  return () => {\n    const lastValues = [];\n    let firstRow = true;\n    return () => {\n      return (values, valueIndexes) => {\n        let acc = 0;\n        for (const valueIdx of valueIndexes) {\n          const currentVal = values[valueIdx];\n          const lastValue = firstRow && sum2 === \"current\" ? 0 : lastValues[valueIdx];\n          lastValues[valueIdx] = currentVal;\n          const sumValue = sum2 === \"current\" ? currentVal : lastValue;\n          if (!isFiniteNumber(currentVal) || !isFiniteNumber(lastValue)) {\n            values[valueIdx] = acc;\n            continue;\n          }\n          if (mode === \"normal\") {\n            acc += sumValue;\n          }\n          values[valueIdx] = acc;\n          if (mode === \"trailing\") {\n            acc += sumValue;\n          }\n        }\n        firstRow = false;\n      };\n    };\n  };\n}\nfunction accumulateGroup(matchGroupId, mode, sum2, separateNegative = false) {\n  let adjust;\n  if (mode.startsWith(\"window\")) {\n    const modeParam = mode.endsWith(\"-trailing\") ? \"trailing\" : \"normal\";\n    adjust = memo({ mode: modeParam, sum: sum2 }, buildGroupWindowAccFn);\n  } else {\n    adjust = memo({ mode, separateNegative }, buildGroupAccFn);\n  }\n  return {\n    type: \"group-value-processor\",\n    matchGroupIds: [matchGroupId],\n    adjust\n  };\n}\nfunction buildGroupContinuityAccFn({ separateNegative }) {\n  return () => () => (values, valueIndexes) => {\n    const acc = [true, true];\n    for (const valueIdx of valueIndexes) {\n      const currentVal = values[valueIdx];\n      const accIndex = isNegative(currentVal) && separateNegative ? 0 : 1;\n      acc[accIndex] && (acc[accIndex] = isFiniteNumber(currentVal));\n      values[valueIdx] = acc[accIndex];\n    }\n  };\n}\nfunction accumulateContinuity(matchGroupId, separateNegative = false) {\n  const adjust = memo({ separateNegative }, buildGroupContinuityAccFn);\n  return {\n    type: \"group-value-processor\",\n    matchGroupIds: [matchGroupId],\n    adjust\n  };\n}\nfunction diff(previousData, updateMovedData = true) {\n  return {\n    type: \"processor\",\n    property: \"diff\",\n    calculate: (processedData) => {\n      const moved = /* @__PURE__ */ new Map();\n      const added = /* @__PURE__ */ new Map();\n      const updated = /* @__PURE__ */ new Map();\n      const removed = /* @__PURE__ */ new Map();\n      const length2 = Math.max(previousData.data.length, processedData.data.length);\n      for (let i = 0; i < length2; i++) {\n        const prev = previousData.data[i];\n        const datum = processedData.data[i];\n        const prevId = prev ? createDatumId(prev.keys) : \"\";\n        const datumId = datum ? createDatumId(datum.keys) : \"\";\n        if (datum && prev && prevId === datumId) {\n          if (!arraysEqual(prev.values, datum.values)) {\n            updated.set(datumId, datum);\n          }\n          continue;\n        }\n        if (removed.has(datumId)) {\n          if (updateMovedData || !arraysEqual(removed.get(datumId).values, datum.values)) {\n            updated.set(datumId, datum);\n            moved.set(datumId, datum);\n          }\n          removed.delete(datumId);\n        } else if (datum) {\n          added.set(datumId, datum);\n        }\n        if (added.has(prevId)) {\n          if (updateMovedData || !arraysEqual(added.get(prevId).values, prev.values)) {\n            updated.set(prevId, prev);\n            moved.set(prevId, prev);\n          }\n          added.delete(prevId);\n        } else if (prev) {\n          updated.delete(prevId);\n          removed.set(prevId, prev);\n        }\n      }\n      const changed = added.size > 0 || updated.size > 0 || removed.size > 0;\n      return { changed, added, updated, removed, moved };\n    }\n  };\n}\nfunction createDatumId(keys, ...extraKeys) {\n  let result;\n  if (isArray(keys)) {\n    result = keys.map((key) => transformIntegratedCategoryValue(key)).join(\"___\");\n  } else {\n    result = transformIntegratedCategoryValue(keys);\n  }\n  const primitiveType = typeof result === \"string\" || typeof result === \"number\" || result instanceof Date;\n  if (primitiveType && extraKeys.length > 0) {\n    result += `___${extraKeys.join(\"___\")}`;\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/chart/series/series.ts\nvar SeriesNodePickMode = /* @__PURE__ */ ((SeriesNodePickMode2) => {\n  SeriesNodePickMode2[SeriesNodePickMode2[\"EXACT_SHAPE_MATCH\"] = 0] = \"EXACT_SHAPE_MATCH\";\n  SeriesNodePickMode2[SeriesNodePickMode2[\"NEAREST_BY_MAIN_AXIS_FIRST\"] = 1] = \"NEAREST_BY_MAIN_AXIS_FIRST\";\n  SeriesNodePickMode2[SeriesNodePickMode2[\"NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST\"] = 2] = \"NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST\";\n  SeriesNodePickMode2[SeriesNodePickMode2[\"NEAREST_NODE\"] = 3] = \"NEAREST_NODE\";\n  return SeriesNodePickMode2;\n})(SeriesNodePickMode || {});\nfunction basicContinuousCheckDatumValidation(value) {\n  return value != null && isContinuous(value);\n}\nfunction basicDiscreteCheckDatumValidation(value) {\n  return value != null;\n}\nfunction getValidationFn(scaleType) {\n  switch (scaleType) {\n    case \"number\":\n    case \"log\":\n    case \"ordinal-time\":\n    case \"time\":\n    case \"color\":\n      return basicContinuousCheckDatumValidation;\n    default:\n      return basicDiscreteCheckDatumValidation;\n  }\n}\nfunction getValueType(scaleType) {\n  switch (scaleType) {\n    case \"number\":\n    case \"log\":\n    case \"time\":\n    case \"color\":\n      return \"range\";\n    default:\n      return \"category\";\n  }\n}\nfunction keyProperty(propName, scaleType, opts = {}) {\n  const result = {\n    property: propName,\n    type: \"key\",\n    valueType: getValueType(scaleType),\n    validation: getValidationFn(scaleType),\n    ...opts\n  };\n  return result;\n}\nfunction valueProperty(propName, scaleType, opts = {}) {\n  const result = {\n    property: propName,\n    type: \"value\",\n    valueType: getValueType(scaleType),\n    validation: getValidationFn(scaleType),\n    ...opts\n  };\n  return result;\n}\nfunction rangedValueProperty(propName, opts = {}) {\n  const { min = -Infinity, max = Infinity, ...defOpts } = opts;\n  return {\n    type: \"value\",\n    property: propName,\n    valueType: \"range\",\n    validation: basicContinuousCheckDatumValidation,\n    processor: () => (datum) => isFiniteNumber(datum) ? clamp(min, datum, max) : datum,\n    ...defOpts\n  };\n}\nfunction accumulativeValueProperty(propName, scaleType, opts = {}) {\n  const { onlyPositive, ...defOpts } = opts;\n  const result = {\n    ...valueProperty(propName, scaleType, defOpts),\n    processor: accumulatedValue(onlyPositive)\n  };\n  return result;\n}\nfunction trailingAccumulatedValueProperty(propName, scaleType, opts = {}) {\n  const result = {\n    ...valueProperty(propName, scaleType, opts),\n    processor: trailingAccumulatedValue()\n  };\n  return result;\n}\nfunction groupAccumulativeValueProperty(propName, mode, sum2 = \"current\", opts, scaleType) {\n  return [\n    valueProperty(propName, scaleType, opts),\n    accumulateGroup(opts.groupId, mode, sum2, opts.separateNegative),\n    ...opts.rangeId != null ? [range2(opts.rangeId, opts.groupId)] : []\n  ];\n}\nfunction groupAccumulativeContinuityProperty(propName, opts, scaleType) {\n  return [valueProperty(propName, scaleType, opts), accumulateContinuity(opts.groupId, opts.separateNegative)];\n}\nvar SeriesNodeEvent = class {\n  constructor(type, event, { datum }, series) {\n    this.type = type;\n    this.event = event;\n    this.datum = datum;\n    this.seriesId = series.id;\n  }\n};\nvar SeriesGroupingChangedEvent = class {\n  constructor(series, seriesGrouping, oldGrouping) {\n    this.series = series;\n    this.seriesGrouping = seriesGrouping;\n    this.oldGrouping = oldGrouping;\n    this.type = \"groupingChanged\";\n  }\n};\nvar Series = class extends Observable {\n  constructor(seriesOpts) {\n    super();\n    this.destroyFns = [];\n    this.seriesGrouping = void 0;\n    this.NodeEvent = SeriesNodeEvent;\n    this.internalId = createId(this);\n    // The group node that contains all the nodes used to render this series.\n    this.rootGroup = new Group({ name: \"seriesRoot\", isVirtual: true });\n    this.axes = {\n      [\"x\" /* X */]: void 0,\n      [\"y\" /* Y */]: void 0\n    };\n    this.directions = [\"x\" /* X */, \"y\" /* Y */];\n    // Flag to determine if we should recalculate node data.\n    this.nodeDataRefresh = true;\n    this.moduleMap = new ModuleMap();\n    this._declarationOrder = -1;\n    this.seriesListeners = new Listeners();\n    const {\n      moduleCtx,\n      pickModes = [1 /* NEAREST_BY_MAIN_AXIS_FIRST */],\n      directionKeys = {},\n      directionNames = {},\n      contentGroupVirtual = true,\n      canHaveAxes = false\n    } = seriesOpts;\n    this.ctx = moduleCtx;\n    this.directionKeys = directionKeys;\n    this.directionNames = directionNames;\n    this.canHaveAxes = canHaveAxes;\n    this.contentGroup = this.rootGroup.appendChild(\n      new Group({\n        name: `${this.internalId}-content`,\n        isVirtual: contentGroupVirtual,\n        zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n        zIndexSubOrder: this.getGroupZIndexSubOrder(\"data\")\n      })\n    );\n    this.highlightGroup = new Group({\n      name: `${this.internalId}-highlight`,\n      isVirtual: contentGroupVirtual,\n      zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n      zIndexSubOrder: this.getGroupZIndexSubOrder(\"highlight\")\n    });\n    this.highlightNode = this.highlightGroup.appendChild(new Group({ name: \"highlightNode\", zIndex: 0 }));\n    this.highlightLabel = this.highlightGroup.appendChild(new Group({ name: \"highlightLabel\", zIndex: 10 }));\n    this.pickModes = pickModes;\n    this.labelGroup = this.rootGroup.appendChild(\n      new Group({\n        name: `${this.internalId}-series-labels`,\n        zIndex: 8 /* SERIES_LABEL_ZINDEX */\n      })\n    );\n    this.annotationGroup = new Group({\n      name: `${this.id}-annotation`,\n      isVirtual: contentGroupVirtual,\n      zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n      zIndexSubOrder: this.getGroupZIndexSubOrder(\"annotation\")\n    });\n  }\n  get id() {\n    return this.properties?.id ?? this.internalId;\n  }\n  get type() {\n    return this.constructor.type ?? \"\";\n  }\n  get data() {\n    return this._data ?? this._chartData;\n  }\n  set visible(value) {\n    this.properties.visible = value;\n    this.visibleMaybeChanged();\n  }\n  get visible() {\n    return this.properties.visible;\n  }\n  get hasData() {\n    return this.data != null && this.data.length > 0;\n  }\n  get tooltipEnabled() {\n    return this.properties.tooltip?.enabled ?? false;\n  }\n  onDataChange() {\n    this.nodeDataRefresh = true;\n  }\n  setOptionsData(input) {\n    this._data = input;\n    this.onDataChange();\n  }\n  setChartData(input) {\n    this._chartData = input;\n    if (this.data === input) {\n      this.onDataChange();\n    }\n  }\n  onSeriesGroupingChange(prev, next) {\n    const { internalId, type, visible } = this;\n    if (prev) {\n      this.ctx.seriesStateManager.deregisterSeries({ id: internalId, type });\n    }\n    if (next) {\n      this.ctx.seriesStateManager.registerSeries({ id: internalId, type, visible, seriesGrouping: next });\n    }\n    this.fireEvent(new SeriesGroupingChangedEvent(this, next, prev));\n  }\n  getBandScalePadding() {\n    return { inner: 1, outer: 0 };\n  }\n  getGroupZIndexSubOrder(type, subIndex = 0) {\n    let mainAdjust = 0;\n    switch (type) {\n      case \"data\":\n      case \"paths\":\n        break;\n      case \"labels\":\n        mainAdjust += 2e4;\n        break;\n      case \"marker\":\n        mainAdjust += 1e4;\n        break;\n      case \"highlight\":\n        subIndex += 15e3;\n        break;\n      case \"annotation\":\n        mainAdjust += 15e3;\n        break;\n    }\n    const main = () => this._declarationOrder + mainAdjust;\n    return [main, subIndex];\n  }\n  addListener(type, listener) {\n    return this.seriesListeners.addListener(type, listener);\n  }\n  dispatch(type, event) {\n    this.seriesListeners.dispatch(type, event);\n  }\n  addChartEventListeners() {\n    return;\n  }\n  destroy() {\n    this.destroyFns.forEach((f) => f());\n    this.destroyFns = [];\n    this.ctx.seriesStateManager.deregisterSeries(this);\n  }\n  getDirectionValues(direction, properties) {\n    const resolvedDirection = this.resolveKeyDirection(direction);\n    const keys = properties?.[resolvedDirection];\n    const values = [];\n    if (!keys) {\n      return values;\n    }\n    const addValues = (...items) => {\n      for (const value of items) {\n        if (Array.isArray(value)) {\n          addValues(...value);\n        } else if (typeof value === \"object\") {\n          addValues(...Object.values(value));\n        } else {\n          values.push(value);\n        }\n      }\n    };\n    addValues(...keys.map((key) => this.properties[key]));\n    return values;\n  }\n  getKeys(direction) {\n    return this.getDirectionValues(direction, this.directionKeys);\n  }\n  getKeyProperties(direction) {\n    return this.directionKeys[this.resolveKeyDirection(direction)] ?? [];\n  }\n  getNames(direction) {\n    return this.getDirectionValues(direction, this.directionNames);\n  }\n  resolveKeyDirection(direction) {\n    return direction;\n  }\n  // The union of the series domain ('community') and series-option domains ('enterprise').\n  getDomain(direction) {\n    const seriesDomain = this.getSeriesDomain(direction);\n    const moduleDomains = this.moduleMap.mapModules((module) => module.getDomain(direction));\n    return seriesDomain.concat(moduleDomains.flat());\n  }\n  // Indicate that something external changed and we should recalculate nodeData.\n  markNodeDataDirty() {\n    this.nodeDataRefresh = true;\n    this.visibleMaybeChanged();\n  }\n  visibleMaybeChanged() {\n    this.ctx.seriesStateManager.registerSeries(this);\n  }\n  getOpacity() {\n    const defaultOpacity = 1;\n    const { dimOpacity = 1, enabled = true } = this.properties.highlightStyle.series;\n    if (!enabled || dimOpacity === defaultOpacity) {\n      return defaultOpacity;\n    }\n    switch (this.isItemIdHighlighted()) {\n      case 0 /* None */:\n      case 1 /* This */:\n        return defaultOpacity;\n      case 2 /* Other */:\n      default:\n        return dimOpacity;\n    }\n  }\n  getStrokeWidth(defaultStrokeWidth) {\n    const { strokeWidth, enabled = true } = this.properties.highlightStyle.series;\n    if (!enabled || strokeWidth === void 0) {\n      return defaultStrokeWidth;\n    }\n    switch (this.isItemIdHighlighted()) {\n      case 1 /* This */:\n        return strokeWidth;\n      case 0 /* None */:\n      case 2 /* Other */:\n        return defaultStrokeWidth;\n    }\n  }\n  isItemIdHighlighted() {\n    const series = this.ctx.highlightManager?.getActiveHighlight()?.series;\n    if (series == null) {\n      return 0 /* None */;\n    }\n    if (series !== this) {\n      return 2 /* Other */;\n    }\n    return 1 /* This */;\n  }\n  getModuleTooltipParams() {\n    return this.moduleMap.mapModules((module) => module.getTooltipParams()).reduce((total, current) => Object.assign(total, current), {});\n  }\n  pickNode(point, limitPickModes) {\n    const { pickModes, visible, rootGroup } = this;\n    if (!visible || !rootGroup.visible) {\n      return;\n    }\n    for (const pickMode of pickModes) {\n      if (limitPickModes && !limitPickModes.includes(pickMode)) {\n        continue;\n      }\n      let match;\n      switch (pickMode) {\n        case 0 /* EXACT_SHAPE_MATCH */:\n          match = this.pickNodeExactShape(point);\n          break;\n        case 1 /* NEAREST_BY_MAIN_AXIS_FIRST */:\n        case 2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */:\n          match = this.pickNodeMainAxisFirst(\n            point,\n            pickMode === 2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */\n          );\n          break;\n        case 3 /* NEAREST_NODE */:\n          match = this.pickNodeClosestDatum(point);\n          break;\n      }\n      if (match) {\n        return { pickMode, match: match.datum, distance: match.distance };\n      }\n    }\n  }\n  pickNodeExactShape(point) {\n    const match = this.contentGroup.pickNode(point.x, point.y);\n    if (match && match.datum.missing !== true) {\n      return { datum: match.datum, distance: 0 };\n    }\n    return void 0;\n  }\n  pickNodeClosestDatum(_point) {\n    throw new Error(\"AG Charts - Series.pickNodeClosestDatum() not implemented\");\n  }\n  pickNodeNearestDistantObject(point, items) {\n    const match = nearestSquared(point.x, point.y, items);\n    if (match.nearest !== void 0 && match.nearest.datum.missing !== true) {\n      return { datum: match.nearest.datum, distance: Math.sqrt(match.distanceSquared) };\n    }\n    return void 0;\n  }\n  pickNodeMainAxisFirst(_point, _requireCategoryAxis) {\n    throw new Error(\"AG Charts - Series.pickNodeMainAxisFirst() not implemented\");\n  }\n  fireNodeClickEvent(event, datum) {\n    this.fireEvent(new this.NodeEvent(\"nodeClick\", event, datum, this));\n  }\n  fireNodeDoubleClickEvent(event, datum) {\n    this.fireEvent(new this.NodeEvent(\"nodeDoubleClick\", event, datum, this));\n  }\n  createNodeContextMenuActionEvent(event, datum) {\n    return new this.NodeEvent(\"nodeContextMenuAction\", event, datum, this);\n  }\n  toggleSeriesItem(itemId, enabled) {\n    this.visible = enabled;\n    this.nodeDataRefresh = true;\n    this.dispatch(\"visibility-changed\", { itemId, enabled });\n  }\n  isEnabled() {\n    return this.visible;\n  }\n  getModuleMap() {\n    return this.moduleMap;\n  }\n  createModuleContext() {\n    return { ...this.ctx, series: this };\n  }\n  getLabelText(label, params, defaultFormatter = String) {\n    if (label.formatter) {\n      return this.ctx.callbackCache.call(label.formatter, { seriesId: this.id, ...params }) ?? defaultFormatter(params.value);\n    }\n    return defaultFormatter(params.value);\n  }\n  getMarkerStyle(marker, params, defaultStyle = marker.getStyle()) {\n    const defaultSize = { size: params.datum.point?.size ?? 0 };\n    const markerStyle = mergeDefaults(defaultSize, defaultStyle);\n    if (marker.itemStyler) {\n      const style = this.ctx.callbackCache.call(marker.itemStyler, {\n        seriesId: this.id,\n        ...markerStyle,\n        ...params,\n        datum: params.datum.datum\n      });\n      return mergeDefaults(style, markerStyle);\n    }\n    return markerStyle;\n  }\n  updateMarkerStyle(markerNode, marker, params, defaultStyle = marker.getStyle(), { applyTranslation = true } = {}) {\n    const { point } = params.datum;\n    const activeStyle = this.getMarkerStyle(marker, params, defaultStyle);\n    const visible = this.visible && activeStyle.size > 0 && point && !isNaN(point.x) && !isNaN(point.y);\n    if (applyTranslation) {\n      markerNode.setProperties({ visible, ...activeStyle, translationX: point?.x, translationY: point?.y });\n    } else {\n      markerNode.setProperties({ visible, ...activeStyle });\n    }\n    if (typeof marker.shape === \"function\" && !markerNode.dirtyPath) {\n      markerNode.path.clear(true);\n      markerNode.updatePath();\n      markerNode.checkPathDirty();\n    }\n  }\n  getMinRects(_width, _height) {\n    return;\n  }\n  get nodeDataDependencies() {\n    return this._nodeDataDependencies ?? { seriesRectWidth: NaN, seriesRectHeight: NaN };\n  }\n  checkResize(newSeriesRect) {\n    const { width: seriesRectWidth, height: seriesRectHeight } = newSeriesRect ?? { width: NaN, height: NaN };\n    const newNodeDataDependencies = newSeriesRect ? { seriesRectWidth, seriesRectHeight } : void 0;\n    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\n    if (resize) {\n      this._nodeDataDependencies = newNodeDataDependencies;\n      this.markNodeDataDirty();\n    }\n    return resize;\n  }\n  pickFocus(_opts) {\n    return void 0;\n  }\n};\nSeries.highlightedZIndex = 1e12;\n__decorateClass([\n  ActionOnSet({\n    changeValue: function(newVal, oldVal) {\n      this.onSeriesGroupingChange(oldVal, newVal);\n    }\n  })\n], Series.prototype, \"seriesGrouping\", 2);\n\n// packages/ag-charts-community/src/chart/series/seriesLayerManager.ts\nvar SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION = 30;\nvar SeriesLayerManager = class {\n  constructor(seriesRoot, highlightRoot, annotationRoot) {\n    this.seriesRoot = seriesRoot;\n    this.highlightRoot = highlightRoot;\n    this.annotationRoot = annotationRoot;\n    this.groups = {};\n    this.series = {};\n    this.expectedSeriesCount = 1;\n    this.mode = \"normal\";\n  }\n  setSeriesCount(count) {\n    this.expectedSeriesCount = count;\n  }\n  requestGroup(seriesConfig) {\n    var _a, _b;\n    const {\n      internalId,\n      type,\n      rootGroup: seriesRootGroup,\n      highlightGroup: seriesHighlightGroup,\n      annotationGroup: seriesAnnotationGroup,\n      seriesGrouping\n    } = seriesConfig;\n    const { groupIndex = internalId } = seriesGrouping ?? {};\n    if (this.series[internalId] != null) {\n      throw new Error(`AG Charts - series already has an allocated layer: ${this.series[internalId]}`);\n    }\n    if (Object.keys(this.series).length === 0) {\n      this.mode = this.expectedSeriesCount >= SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION ? \"aggressive-grouping\" : \"normal\";\n    }\n    (_a = this.groups)[type] ?? (_a[type] = {});\n    const lookupIndex = this.lookupIdx(groupIndex);\n    let groupInfo = this.groups[type][lookupIndex];\n    if (!groupInfo) {\n      groupInfo = (_b = this.groups[type])[lookupIndex] ?? (_b[lookupIndex] = {\n        type,\n        id: lookupIndex,\n        seriesIds: [],\n        group: this.seriesRoot.appendChild(\n          new Group({\n            name: `${type}-content`,\n            layer: true,\n            zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n            zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder(\"data\")\n          })\n        ),\n        highlight: this.highlightRoot.appendChild(\n          new Group({\n            name: `${type}-highlight`,\n            zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n            zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder(\"highlight\")\n          })\n        ),\n        annotation: this.annotationRoot.appendChild(\n          new Group({\n            name: `${type}-annotation`,\n            zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n            zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder(\"annotation\")\n          })\n        )\n      });\n    }\n    this.series[internalId] = { layerState: groupInfo, seriesConfig };\n    groupInfo.seriesIds.push(internalId);\n    groupInfo.group.appendChild(seriesRootGroup);\n    groupInfo.highlight.appendChild(seriesHighlightGroup);\n    groupInfo.annotation.appendChild(seriesAnnotationGroup);\n    return groupInfo.group;\n  }\n  changeGroup(seriesConfig) {\n    const { internalId, seriesGrouping, type, rootGroup, highlightGroup, annotationGroup, oldGrouping } = seriesConfig;\n    const { groupIndex = internalId } = seriesGrouping ?? {};\n    if (this.groups[type]?.[groupIndex]?.seriesIds.includes(internalId)) {\n      return;\n    }\n    if (this.series[internalId] != null) {\n      this.releaseGroup({\n        internalId,\n        seriesGrouping: oldGrouping,\n        type,\n        rootGroup,\n        highlightGroup,\n        annotationGroup\n      });\n    }\n    this.requestGroup(seriesConfig);\n  }\n  releaseGroup(seriesConfig) {\n    const { internalId, rootGroup, highlightGroup, annotationGroup, type } = seriesConfig;\n    if (this.series[internalId] == null) {\n      throw new Error(`AG Charts - series doesn't have an allocated layer: ${internalId}`);\n    }\n    const groupInfo = this.series[internalId]?.layerState;\n    if (groupInfo) {\n      groupInfo.seriesIds = groupInfo.seriesIds.filter((v) => v !== internalId);\n      groupInfo.group.removeChild(rootGroup);\n      groupInfo.highlight.removeChild(highlightGroup);\n      groupInfo.annotation.removeChild(annotationGroup);\n    }\n    if (groupInfo?.seriesIds.length === 0) {\n      this.seriesRoot.removeChild(groupInfo.group);\n      this.highlightRoot.removeChild(groupInfo.highlight);\n      this.annotationRoot.removeChild(groupInfo.annotation);\n      delete this.groups[groupInfo.type][groupInfo.id];\n      delete this.groups[type][internalId];\n    } else if (groupInfo?.seriesIds.length > 0) {\n      const leadSeriesConfig = this.series[groupInfo?.seriesIds?.[0]]?.seriesConfig;\n      groupInfo.group.zIndexSubOrder = leadSeriesConfig?.getGroupZIndexSubOrder(\"data\");\n      groupInfo.highlight.zIndexSubOrder = leadSeriesConfig?.getGroupZIndexSubOrder(\"highlight\");\n      groupInfo.annotation.zIndexSubOrder = leadSeriesConfig?.getGroupZIndexSubOrder(\"annotation\");\n    }\n    delete this.series[internalId];\n  }\n  lookupIdx(groupIndex) {\n    if (this.mode === \"normal\") {\n      return groupIndex;\n    }\n    if (typeof groupIndex === \"string\") {\n      groupIndex = Number(groupIndex.split(\"-\").at(-1));\n      if (!groupIndex) {\n        return 0;\n      }\n    }\n    return Math.floor(\n      clamp(0, groupIndex / this.expectedSeriesCount, 1) * SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION\n    );\n  }\n  destroy() {\n    for (const groups of Object.values(this.groups)) {\n      for (const groupInfo of Object.values(groups)) {\n        this.seriesRoot.removeChild(groupInfo.group);\n        this.highlightRoot.removeChild(groupInfo.highlight);\n        this.annotationRoot.removeChild(groupInfo.annotation);\n      }\n    }\n    this.groups = {};\n    this.series = {};\n  }\n};\n\n// packages/ag-charts-community/src/chart/update/baseLayoutProcessor.ts\nvar BaseLayoutProcessor = class {\n  constructor(chartLike, layoutService) {\n    this.chartLike = chartLike;\n    this.layoutService = layoutService;\n    this.destroyFns = [];\n    this.destroyFns.push(\n      // eslint-disable-next-line sonarjs/no-duplicate-string\n      this.layoutService.addListener(\"start-layout\", (e) => this.positionPadding(e)),\n      this.layoutService.addListener(\"layout-complete\", (e) => this.alignCaptions(e)),\n      this.layoutService.addListener(\"start-layout\", (e) => this.positionCaptions(e))\n    );\n  }\n  destroy() {\n    this.destroyFns.forEach((cb) => cb());\n  }\n  positionPadding(ctx) {\n    const { shrinkRect } = ctx;\n    const { padding } = this.chartLike;\n    shrinkRect.shrink(padding.left, \"left\");\n    shrinkRect.shrink(padding.top, \"top\");\n    shrinkRect.shrink(padding.right, \"right\");\n    shrinkRect.shrink(padding.bottom, \"bottom\");\n    return { ...ctx, shrinkRect };\n  }\n  positionCaptions(ctx) {\n    const { shrinkRect, positions, padding } = ctx;\n    const { title, subtitle, footnote, titlePadding } = this.chartLike;\n    const paddedShrinkRect = shrinkRect.clone().shrink(titlePadding);\n    const newShrinkRect = shrinkRect.clone();\n    const updateCaption = (caption) => {\n      const defaultCaptionHeight = shrinkRect.height / 10;\n      const captionLineHeight = caption.lineHeight ?? caption.fontSize * Text.defaultLineHeightRatio;\n      const maxWidth = shrinkRect.width;\n      const maxHeight = Math.max(captionLineHeight, defaultCaptionHeight);\n      caption.computeTextWrap(maxWidth, maxHeight);\n    };\n    const computeX = (align) => {\n      if (align === \"left\") {\n        return paddedShrinkRect.x;\n      } else if (align === \"right\") {\n        return paddedShrinkRect.x + paddedShrinkRect.width;\n      } else if (align !== \"center\") {\n        Logger.error(`invalid textAlign value: ${align}`);\n      }\n      return paddedShrinkRect.x + paddedShrinkRect.width / 2;\n    };\n    const positionTopAndShrinkBBox = (caption, spacing) => {\n      const baseY = paddedShrinkRect.y;\n      caption.node.x = computeX(caption.textAlign);\n      caption.node.y = baseY;\n      caption.node.textBaseline = \"top\";\n      updateCaption(caption);\n      const bbox = caption.node.computeBBox();\n      const bboxHeight = Math.ceil(bbox.y - baseY + bbox.height + spacing);\n      if (caption.layoutStyle === \"block\") {\n        newShrinkRect.shrink(bboxHeight + 2 * titlePadding, \"top\");\n        paddedShrinkRect.shrink(bboxHeight, \"top\");\n      }\n      return bbox;\n    };\n    const positionBottomAndShrinkBBox = (caption, spacing) => {\n      const baseY = paddedShrinkRect.y + paddedShrinkRect.height;\n      caption.node.x = computeX(caption.textAlign);\n      caption.node.y = baseY;\n      caption.node.textBaseline = \"bottom\";\n      updateCaption(caption);\n      const bbox = caption.node.computeBBox();\n      const bboxHeight = Math.ceil(baseY - bbox.y + spacing);\n      if (caption.layoutStyle === \"block\") {\n        newShrinkRect.shrink(bboxHeight + 2 * titlePadding, \"bottom\");\n        paddedShrinkRect.shrink(bboxHeight, \"bottom\");\n      }\n      return bbox;\n    };\n    title.node.visible = title.enabled;\n    subtitle.node.visible = subtitle.enabled;\n    footnote.node.visible = footnote.enabled;\n    if (title.enabled) {\n      const { spacing = subtitle.enabled ? Caption.SMALL_PADDING : Caption.LARGE_PADDING } = title;\n      positions.title = positionTopAndShrinkBBox(title, spacing);\n    }\n    if (subtitle.enabled) {\n      positions.subtitle = positionTopAndShrinkBBox(subtitle, subtitle.spacing ?? 0);\n    }\n    if (footnote.enabled) {\n      positions.footnote = positionBottomAndShrinkBBox(footnote, footnote.spacing ?? 0);\n    }\n    padding.title = titlePadding;\n    return { ...ctx, shrinkRect: newShrinkRect, positions };\n  }\n  alignCaptions(ctx) {\n    const { title, subtitle, footnote, titlePadding } = this.chartLike;\n    const align = (caption, seriesRect) => {\n      if (caption.layoutStyle !== \"overlay\")\n        return;\n      if (caption.textAlign === \"left\") {\n        caption.node.x = seriesRect.x + titlePadding;\n      } else if (caption.textAlign === \"right\") {\n        const bbox = caption.node.computeBBox();\n        caption.node.x = seriesRect.x + seriesRect.width - bbox.width - titlePadding;\n      }\n    };\n    align(title, ctx.series.rect);\n    align(subtitle, ctx.series.rect);\n    align(footnote, ctx.series.rect);\n  }\n};\n\n// packages/ag-charts-community/src/chart/update/dataWindowProcessor.ts\nvar DataWindowProcessor = class {\n  constructor(chart, dataService, updateService, zoomManager) {\n    this.chart = chart;\n    this.dataService = dataService;\n    this.updateService = updateService;\n    this.zoomManager = zoomManager;\n    this.dirtyZoom = false;\n    this.dirtyDataSource = false;\n    this.lastAxisZooms = /* @__PURE__ */ new Map();\n    this.destroyFns = [];\n    this.destroyFns.push(\n      this.dataService.addListener(\"data-source-change\", () => this.onDataSourceChange()),\n      this.dataService.addListener(\"data-load\", () => this.onDataLoad()),\n      this.dataService.addListener(\"data-error\", () => this.onDataError()),\n      this.updateService.addListener(\"update-complete\", () => this.onUpdateComplete()),\n      this.zoomManager.addListener(\"zoom-change\", () => this.onZoomChange())\n    );\n  }\n  destroy() {\n    this.destroyFns.forEach((cb) => cb());\n  }\n  onDataLoad() {\n    this.updateService.update(1 /* UPDATE_DATA */);\n  }\n  onDataError() {\n    this.updateService.update(3 /* PERFORM_LAYOUT */);\n  }\n  onDataSourceChange() {\n    this.dirtyDataSource = true;\n  }\n  onUpdateComplete() {\n    if (!this.dirtyZoom && !this.dirtyDataSource)\n      return;\n    this.updateWindow().catch((e) => Logger.errorOnce(e));\n  }\n  onZoomChange() {\n    this.dirtyZoom = true;\n  }\n  async updateWindow() {\n    if (!this.dataService.isLazy())\n      return;\n    const axis = this.getValidAxis();\n    let window2;\n    let shouldRefresh = true;\n    if (axis) {\n      const zoom2 = this.zoomManager.getAxisZoom(axis.id);\n      window2 = this.getAxisWindow(axis, zoom2);\n      shouldRefresh = this.shouldRefresh(axis, zoom2);\n    }\n    this.dirtyZoom = false;\n    this.dirtyDataSource = false;\n    if (!shouldRefresh)\n      return;\n    this.dataService.load({ windowStart: window2?.min, windowEnd: window2?.max });\n  }\n  getValidAxis() {\n    return this.chart.axes.find((axis) => axis.type === \"time\");\n  }\n  shouldRefresh(axis, zoom2) {\n    if (this.dirtyDataSource)\n      return true;\n    if (!this.dirtyZoom)\n      return false;\n    const lastZoom = this.lastAxisZooms.get(axis.id);\n    if (lastZoom && zoom2.min === lastZoom.min && zoom2.max === lastZoom.max) {\n      return false;\n    }\n    this.lastAxisZooms.set(axis.id, zoom2);\n    return true;\n  }\n  getAxisWindow(axis, zoom2) {\n    const domain = axis.scale.getDomain?.();\n    if (!zoom2 || !domain || domain.length === 0 || isNaN(Number(domain[0])))\n      return;\n    const diff2 = Number(domain[1]) - Number(domain[0]);\n    const min = new Date(Number(domain[0]) + diff2 * zoom2.min);\n    const max = new Date(Number(domain[0]) + diff2 * zoom2.max);\n    return { min, max };\n  }\n};\n\n// packages/ag-charts-community/src/chart/update/overlaysProcessor.css\nvar overlaysProcessor_default = \".ag-chart-overlay{color:#181d1f;pointer-events:none}.ag-chart-overlay.ag-chart-dark-overlay{color:#ffffff}.ag-chart-overlay--loading{color:rgb(140,140,140)}.ag-chart-overlay__loading-background{background:white;pointer-events:none}.ag-chart-overlay.ag-chart-dark-overlay .ag-chart-overlay__loading-background{background:#192232}\";\n\n// packages/ag-charts-community/src/chart/update/overlaysProcessor.ts\nvar OverlaysProcessor = class {\n  constructor(chartLike, overlays, dataService, layoutService, localeManager, animationManager, domManager) {\n    this.chartLike = chartLike;\n    this.overlays = overlays;\n    this.dataService = dataService;\n    this.layoutService = layoutService;\n    this.localeManager = localeManager;\n    this.animationManager = animationManager;\n    this.domManager = domManager;\n    this.destroyFns = [];\n    this.overlayElem = this.domManager.addChild(\"canvas-overlay\", \"overlay\");\n    this.overlayElem.role = \"status\";\n    this.overlayElem.ariaAtomic = \"false\";\n    this.overlayElem.ariaLive = \"polite\";\n    this.overlayElem.classList.toggle(DEFAULT_OVERLAY_CLASS);\n    this.domManager.addStyles(\"overlays\", overlaysProcessor_default);\n    this.destroyFns.push(this.layoutService.addListener(\"layout-complete\", (e) => this.onLayoutComplete(e)));\n  }\n  destroy() {\n    this.destroyFns.forEach((cb) => cb());\n    this.domManager.removeStyles(\"overlays\");\n    this.domManager.removeChild(\"canvas-overlay\", \"overlay\");\n  }\n  onLayoutComplete({ series: { rect } }) {\n    const isLoading = this.dataService.isLoading();\n    const hasData = this.chartLike.series.some((s) => s.hasData);\n    const anySeriesVisible = this.chartLike.series.some((s) => s.visible);\n    if (this.overlays.darkTheme) {\n      this.overlayElem.classList.add(DEFAULT_OVERLAY_DARK_CLASS);\n    } else {\n      this.overlayElem.classList.remove(DEFAULT_OVERLAY_DARK_CLASS);\n    }\n    this.overlayElem.style.left = `${rect.x}px`;\n    this.overlayElem.style.top = `${rect.y}px`;\n    this.overlayElem.style.width = `${rect.width}px`;\n    this.overlayElem.style.height = `${rect.height}px`;\n    this.toggleOverlay(this.overlays.loading, rect, isLoading);\n    this.toggleOverlay(this.overlays.noData, rect, !isLoading && !hasData);\n    this.toggleOverlay(this.overlays.noVisibleSeries, rect, hasData && !anySeriesVisible);\n  }\n  toggleOverlay(overlay, seriesRect, visible) {\n    if (visible) {\n      const element2 = overlay.getElement(this.animationManager, this.localeManager, seriesRect);\n      this.overlayElem.appendChild(element2);\n    } else {\n      overlay.removeElement(() => {\n        this.overlayElem.innerText = \"\\xA0\";\n      }, this.animationManager);\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/chart.ts\nvar debug = Debug.create(true, \"opts\");\nvar SeriesArea = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.padding = new Padding(0);\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], SeriesArea.prototype, \"clip\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesArea.prototype, \"padding\", 2);\nvar _Chart = class _Chart extends Observable {\n  constructor(options, resources) {\n    var _a;\n    super();\n    this.id = createId(this);\n    this.seriesRoot = new Group({ name: `${this.id}-series-root` });\n    this.highlightRoot = new Group({\n      name: `${this.id}-highlight-root`,\n      layer: true,\n      zIndex: 5 /* SERIES_HIGHLIGHT_ZINDEX */,\n      nonEmptyChildDerivedZIndex: true\n    });\n    this.annotationRoot = new Group({\n      name: `${this.id}-annotation-root`,\n      layer: true,\n      zIndex: 10 /* SERIES_ANNOTATION_ZINDEX */\n    });\n    this.debug = Debug.create();\n    this.extraDebugStats = {};\n    this.data = [];\n    this._firstAutoSize = true;\n    this.padding = new Padding(20);\n    this.titlePadding = 0;\n    this.seriesArea = new SeriesArea();\n    this.title = new Caption();\n    this.subtitle = new Caption();\n    this.footnote = new Caption();\n    this.keyboard = new Keyboard();\n    this.mode = \"standalone\";\n    this.destroyed = false;\n    this._skipSync = false;\n    this._destroyFns = [];\n    this.chartAnimationPhase = \"initial\";\n    this.modulesManager = new ModulesManager();\n    // FIXME: zoomManager should be owned by ctx, but it can't because it is used by CartesianChart.onAxisChange before ctx is initialised\n    this.zoomManager = new ZoomManager();\n    this.processors = [];\n    this.queuedUserOptions = [];\n    this._pendingFactoryUpdatesCount = 0;\n    this._performUpdateNoRenderCount = 0;\n    this._performUpdateSkipAnimations = false;\n    this.performUpdateType = 7 /* NONE */;\n    this.updateShortcutCount = 0;\n    this.seriesToUpdate = /* @__PURE__ */ new Set();\n    this.updateMutex = new Mutex();\n    this.updateRequestors = {};\n    this.performUpdateTrigger = debouncedCallback(async ({ count }) => {\n      if (this.destroyed)\n        return;\n      this.updateMutex.acquire(async () => {\n        try {\n          await this.performUpdate(count);\n        } catch (error) {\n          Logger.error(\"update error\", error);\n        }\n      }).catch((e) => Logger.errorOnce(e));\n    });\n    this._performUpdateSplits = {};\n    this.axes = [];\n    this.series = [];\n    this.focus = {\n      hasFocus: false,\n      series: void 0,\n      seriesIndex: 0,\n      datumIndex: 0,\n      datum: void 0\n    };\n    this.pointerScheduler = debouncedAnimationFrame(() => {\n      if (!this.lastInteractionEvent)\n        return;\n      if (this.performUpdateType <= 4 /* SERIES_UPDATE */) {\n        this.pointerScheduler.schedule();\n        return;\n      }\n      this.handlePointer(this.lastInteractionEvent, false);\n      this.lastInteractionEvent = void 0;\n    });\n    this.onSeriesNodeClick = (event) => {\n      const seriesNodeClickEvent = {\n        ...event,\n        type: \"seriesNodeClick\"\n      };\n      Object.defineProperty(seriesNodeClickEvent, \"series\", {\n        enumerable: false,\n        // Should display the deprecation warning\n        get: () => event.series\n      });\n      this.fireEvent(seriesNodeClickEvent);\n    };\n    this.onSeriesNodeDoubleClick = (event) => {\n      const seriesNodeDoubleClick = {\n        ...event,\n        type: \"seriesNodeDoubleClick\"\n      };\n      this.fireEvent(seriesNodeDoubleClick);\n    };\n    this.seriesGroupingChanged = (event) => {\n      if (!(event instanceof SeriesGroupingChangedEvent))\n        return;\n      const { series, seriesGrouping, oldGrouping } = event;\n      if (series.rootGroup.parent == null)\n        return;\n      this.seriesLayerManager.changeGroup({\n        internalId: series.internalId,\n        type: series.type,\n        rootGroup: series.rootGroup,\n        highlightGroup: series.highlightGroup,\n        annotationGroup: series.annotationGroup,\n        getGroupZIndexSubOrder: (type) => series.getGroupZIndexSubOrder(type),\n        seriesGrouping,\n        oldGrouping\n      });\n    };\n    this.dataProcessListeners = /* @__PURE__ */ new Set();\n    this.chartOptions = options;\n    const scene = resources?.scene;\n    const container = resources?.container;\n    const root = new Group({ name: \"root\" });\n    const titleGroup = new Group({ name: \"titles\", layer: true, zIndex: 8 /* SERIES_LABEL_ZINDEX */ });\n    root.visible = false;\n    root.append(titleGroup);\n    root.append(this.seriesRoot);\n    root.append(this.highlightRoot);\n    root.append(this.annotationRoot);\n    titleGroup.append(this.title.node);\n    titleGroup.append(this.subtitle.node);\n    titleGroup.append(this.footnote.node);\n    const { overrideDevicePixelRatio } = options.specialOverrides;\n    this.tooltip = new Tooltip();\n    this.seriesLayerManager = new SeriesLayerManager(this.seriesRoot, this.highlightRoot, this.annotationRoot);\n    const ctx = this.ctx = new ChartContext(this, {\n      scene,\n      root,\n      syncManager: new SyncManager(this),\n      container,\n      updateCallback: (type = 0 /* FULL */, opts) => this.update(type, opts),\n      updateMutex: this.updateMutex,\n      overrideDevicePixelRatio\n    });\n    this._destroyFns.push(\n      ctx.domManager.addListener(\"resize\", () => this.parentResize(ctx.domManager.containerSize))\n    );\n    this.overlays = new ChartOverlays();\n    (_a = this.overlays.loading).renderer ?? (_a.renderer = () => getLoadingSpinner(this.overlays.loading.getText(ctx.localeManager), ctx.animationManager.defaultDuration));\n    this.processors = [\n      new BaseLayoutProcessor(this, ctx.layoutService),\n      new DataWindowProcessor(this, ctx.dataService, ctx.updateService, ctx.zoomManager),\n      new OverlaysProcessor(\n        this,\n        this.overlays,\n        ctx.dataService,\n        ctx.layoutService,\n        ctx.localeManager,\n        ctx.animationManager,\n        ctx.domManager\n      )\n    ];\n    this.highlight = new ChartHighlight();\n    this.container = container;\n    const { All } = InteractionState;\n    const moduleContext = this.getModuleContext();\n    const seriesRegion = ctx.regionManager.addRegion(\n      \"series\" /* SERIES */,\n      this.seriesRoot,\n      this.ctx.axisManager.axisGridGroup\n    );\n    const horizontalAxesRegion = this.ctx.regionManager.addRegion(\"horizontal-axes\" /* HORIZONTAL_AXES */);\n    const verticalAxesRegion = this.ctx.regionManager.addRegion(\"vertical-axes\" /* VERTICAL_AXES */);\n    ctx.regionManager.addRegion(\"root\", root);\n    this._destroyFns.push(\n      ctx.dataService.addListener(\"data-load\", (event) => {\n        this.data = event.data;\n      }),\n      this.title.registerInteraction(moduleContext),\n      this.subtitle.registerInteraction(moduleContext),\n      this.footnote.registerInteraction(moduleContext),\n      ctx.regionManager.listenAll(\"click\", (event) => this.onClick(event)),\n      ctx.regionManager.listenAll(\"dblclick\", (event) => this.onDoubleClick(event)),\n      seriesRegion.addListener(\n        \"hover\",\n        (event) => this.onMouseMove(event),\n        16 /* Default */ | 4 /* Annotations */\n      ),\n      seriesRegion.addListener(\n        \"drag\",\n        (event) => this.onMouseMove(event),\n        16 /* Default */ | 4 /* Annotations */\n      ),\n      horizontalAxesRegion.addListener(\"hover\", (event) => this.onMouseMove(event)),\n      verticalAxesRegion.addListener(\"hover\", (event) => this.onMouseMove(event)),\n      seriesRegion.addListener(\"leave\", (event) => this.onLeave(event)),\n      horizontalAxesRegion.addListener(\"leave\", (event) => this.onLeave(event)),\n      verticalAxesRegion.addListener(\"leave\", (event) => this.onLeave(event)),\n      seriesRegion.addListener(\"blur\", () => this.onBlur()),\n      seriesRegion.addListener(\"tab\", (event) => this.onTab(event)),\n      seriesRegion.addListener(\"nav-vert\", (event) => this.onNavVert(event)),\n      seriesRegion.addListener(\"nav-hori\", (event) => this.onNavHori(event)),\n      seriesRegion.addListener(\"submit\", (event) => this.onSubmit(event)),\n      seriesRegion.addListener(\"contextmenu\", (event) => this.onContextMenu(event), All),\n      ctx.keyNavManager.addListener(\"browserfocus\", (event) => this.onBrowserFocus(event)),\n      ctx.interactionManager.addListener(\"page-left\", () => this.destroy()),\n      ctx.animationManager.addListener(\"animation-start\", () => this.onAnimationStart()),\n      ctx.animationManager.addListener(\"animation-frame\", () => {\n        this.update(6 /* SCENE_RENDER */);\n      }),\n      ctx.highlightManager.addListener(\"highlight-change\", (event) => this.changeHighlightDatum(event)),\n      ctx.zoomManager.addListener(\"zoom-pan-start\", () => this.resetPointer()),\n      ctx.zoomManager.addListener(\"zoom-change\", () => {\n        this.resetPointer();\n        this.ctx.focusIndicator.updateBounds(void 0);\n        this.series.map((s) => s.animationState?.transition(\"updateData\"));\n        const skipAnimations = this.chartAnimationPhase !== \"initial\";\n        this.update(3 /* PERFORM_LAYOUT */, { forceNodeDataRefresh: true, skipAnimations });\n      })\n    );\n    this.parentResize(ctx.domManager.containerSize);\n  }\n  static getInstance(element2) {\n    return _Chart.chartsInstances.get(element2);\n  }\n  /** NOTE: This is exposed for use by Integrated charts only. */\n  get canvasElement() {\n    return this.ctx.scene.canvas.element;\n  }\n  download(fileName, fileFormat) {\n    this.ctx.scene.download(fileName, fileFormat);\n  }\n  getCanvasDataURL(fileFormat) {\n    return this.ctx.scene.getDataURL(fileFormat);\n  }\n  getOptions() {\n    return this.queuedUserOptions.at(-1) ?? this.chartOptions.userOptions;\n  }\n  getModuleContext() {\n    return this.ctx;\n  }\n  getCaptionText() {\n    return [this.title, this.subtitle, this.footnote].filter((caption) => caption.enabled && caption.text).map((caption) => caption.text).join(\". \");\n  }\n  getAriaLabel() {\n    return this.ctx.localeManager.t(\"ariaAnnounceChart\", {\n      seriesCount: this.series.length,\n      caption: this.getCaptionText()\n    });\n  }\n  getDatumAriaText(datum, html) {\n    const description = html.ariaLabel;\n    return datum.series.getDatumAriaText?.(datum, description) ?? description;\n  }\n  resetAnimations() {\n    this.chartAnimationPhase = \"initial\";\n    for (const series of this.series) {\n      series.resetAnimation(this.chartAnimationPhase);\n    }\n    for (const axis of this.axes) {\n      axis.resetAnimation(this.chartAnimationPhase);\n    }\n    this.animationRect = void 0;\n    this.ctx.animationManager.reset();\n  }\n  skipAnimations() {\n    this.ctx.animationManager.skipCurrentBatch();\n    this._performUpdateSkipAnimations = true;\n  }\n  destroy(opts) {\n    if (this.destroyed) {\n      return;\n    }\n    const keepTransferableResources = opts?.keepTransferableResources;\n    let result;\n    this.performUpdateType = 7 /* NONE */;\n    this._destroyFns.forEach((fn) => fn());\n    this.processors.forEach((p) => p.destroy());\n    this.tooltip.destroy(this.ctx.domManager);\n    this.overlays.destroy();\n    this.modulesManager.destroy();\n    if (keepTransferableResources) {\n      this.ctx.scene.strip();\n      result = {\n        container: this.container,\n        scene: this.ctx.scene\n      };\n    } else {\n      this.ctx.scene.destroy();\n      this.container = void 0;\n    }\n    this.destroySeries(this.series);\n    this.seriesLayerManager.destroy();\n    this.axes.forEach((a) => a.destroy());\n    this.axes = [];\n    this.animationRect = void 0;\n    this.ctx.destroy();\n    this.zoomManager.destroy();\n    this.destroyed = true;\n    Object.freeze(this);\n    return result;\n  }\n  resetPointer(highlightOnly = false) {\n    if (!highlightOnly) {\n      this.ctx.tooltipManager.removeTooltip(this.id);\n    }\n    this.ctx.highlightManager.updateHighlight(this.id);\n    this.lastInteractionEvent = void 0;\n  }\n  requestFactoryUpdate(cb) {\n    if (this.destroyed)\n      return;\n    this._pendingFactoryUpdatesCount++;\n    this.updateMutex.acquire(async () => {\n      if (this.destroyed)\n        return;\n      await cb(this);\n      if (this.destroyed)\n        return;\n      this._pendingFactoryUpdatesCount--;\n    }).catch((e) => Logger.errorOnce(e));\n  }\n  update(type = 0 /* FULL */, opts) {\n    const {\n      forceNodeDataRefresh = false,\n      skipAnimations,\n      seriesToUpdate = this.series,\n      newAnimationBatch\n    } = opts ?? {};\n    if (forceNodeDataRefresh) {\n      this.series.forEach((series) => series.markNodeDataDirty());\n    }\n    for (const series of seriesToUpdate) {\n      this.seriesToUpdate.add(series);\n    }\n    if (skipAnimations) {\n      this.ctx.animationManager.skipCurrentBatch();\n      this._performUpdateSkipAnimations = true;\n    }\n    if (newAnimationBatch && this.ctx.animationManager.isActive()) {\n      this._performUpdateSkipAnimations = true;\n    }\n    this._skipSync = opts?.skipSync ?? false;\n    if (this.debug.check()) {\n      let stack = new Error().stack ?? \"<unknown>\";\n      stack = stack.replace(/\\([^)]*/g, \"\");\n      this.updateRequestors[stack] = type;\n    }\n    if (type < this.performUpdateType) {\n      this.performUpdateType = type;\n      this.performUpdateTrigger.schedule(opts?.backOffMs);\n    }\n  }\n  async performUpdate(count) {\n    const { performUpdateType, extraDebugStats, _performUpdateSplits: splits, ctx } = this;\n    const seriesToUpdate = [...this.seriesToUpdate];\n    this.performUpdateType = 7 /* NONE */;\n    this.seriesToUpdate.clear();\n    if (this.updateShortcutCount === 0 && performUpdateType < 6 /* SCENE_RENDER */) {\n      ctx.animationManager.startBatch(this._performUpdateSkipAnimations);\n      ctx.animationManager.onBatchStop(() => this.chartAnimationPhase = \"ready\");\n    }\n    this.debug(\"Chart.performUpdate() - start\", ChartUpdateType[performUpdateType]);\n    let previousSplit = performance.now();\n    splits.start ?? (splits.start = previousSplit);\n    const updateSplits = (splitName) => {\n      splits[splitName] ?? (splits[splitName] = 0);\n      splits[splitName] += performance.now() - previousSplit;\n      previousSplit = performance.now();\n    };\n    let updateDeferred = false;\n    switch (performUpdateType) {\n      case 0 /* FULL */:\n        this.updateDOM();\n      case 1 /* UPDATE_DATA */:\n        await this.updateData();\n        updateSplits(\"\\u2B07\\uFE0F\");\n      case 2 /* PROCESS_DATA */:\n        await this.processData();\n        this.resetPointer(true);\n        updateSplits(\"\\u{1F3ED}\");\n      case 3 /* PERFORM_LAYOUT */:\n        if (this.checkUpdateShortcut(3 /* PERFORM_LAYOUT */))\n          break;\n        if (!this.checkFirstAutoSize(seriesToUpdate)) {\n          updateDeferred = true;\n          break;\n        }\n        await this.processLayout();\n        updateSplits(\"\\u2316\");\n      case 4 /* SERIES_UPDATE */:\n        if (this.checkUpdateShortcut(4 /* SERIES_UPDATE */))\n          break;\n        const { seriesRect } = this;\n        await Promise.all(seriesToUpdate.map((series) => series.update({ seriesRect })));\n        updateSplits(\"\\u{1F914}\");\n      case 5 /* TOOLTIP_RECALCULATION */:\n        if (this.checkUpdateShortcut(5 /* TOOLTIP_RECALCULATION */))\n          break;\n        const tooltipMeta = ctx.tooltipManager.getTooltipMeta(this.id);\n        if (performUpdateType <= 4 /* SERIES_UPDATE */ && tooltipMeta?.lastPointerEvent != null) {\n          this.handlePointer(tooltipMeta.lastPointerEvent, true);\n        }\n        updateSplits(\"\\u2196\");\n      case 6 /* SCENE_RENDER */:\n        if (this.checkUpdateShortcut(6 /* SCENE_RENDER */))\n          break;\n        ctx.animationManager.endBatch();\n        extraDebugStats[\"updateShortcutCount\"] = this.updateShortcutCount;\n        await ctx.scene.render({ debugSplitTimes: splits, extraDebugStats });\n        this.extraDebugStats = {};\n        for (const key in splits) {\n          delete splits[key];\n        }\n        this.ctx.domManager.incrementDataCounter(\"sceneRenders\");\n      case 7 /* NONE */:\n        this.updateShortcutCount = 0;\n        this.updateRequestors = {};\n        this._performUpdateSkipAnimations = false;\n        ctx.animationManager.endBatch();\n    }\n    if (!updateDeferred) {\n      ctx.updateService.dispatchUpdateComplete(this.getMinRects());\n    }\n    const end = performance.now();\n    this.debug(\"Chart.performUpdate() - end\", {\n      chart: this,\n      durationMs: Math.round((end - splits[\"start\"]) * 100) / 100,\n      count,\n      performUpdateType: ChartUpdateType[performUpdateType]\n    });\n  }\n  updateThemeClassName() {\n    const { theme } = this.chartOptions.processedOptions;\n    const themeClassNamePrefix = \"ag-charts-theme-\";\n    const validThemeClassNames = [`${themeClassNamePrefix}default`, `${themeClassNamePrefix}default-dark`];\n    let themeClassName = validThemeClassNames[0];\n    let isDark = false;\n    if (typeof theme === \"string\") {\n      themeClassName = theme.replace(\"ag-\", themeClassNamePrefix);\n      isDark = theme.includes(\"-dark\");\n    } else if (typeof theme?.baseTheme === \"string\") {\n      themeClassName = theme.baseTheme.replace(\"ag-\", themeClassNamePrefix);\n      isDark = theme.baseTheme.includes(\"-dark\");\n    }\n    if (!validThemeClassNames.includes(themeClassName)) {\n      themeClassName = isDark ? validThemeClassNames[1] : validThemeClassNames[0];\n    }\n    this.ctx.domManager.setThemeClass(themeClassName);\n  }\n  updateDOM() {\n    this.updateThemeClassName();\n    const { enabled, tabIndex } = this.keyboard;\n    this.ctx.domManager.setTabIndex(enabled ? tabIndex ?? 0 : -1);\n    setAttribute(this.ctx.scene.canvas.element, \"role\", \"figure\");\n    setAttribute(this.ctx.scene.canvas.element, \"aria-label\", this.getAriaLabel());\n  }\n  checkUpdateShortcut(checkUpdateType) {\n    const maxShortcuts = 3;\n    if (this.updateShortcutCount > maxShortcuts) {\n      Logger.warn(\n        `exceeded the maximum number of simultaneous updates (${maxShortcuts + 1}), discarding changes and rendering`,\n        this.updateRequestors\n      );\n      return false;\n    }\n    if (this.performUpdateType <= checkUpdateType) {\n      this.updateShortcutCount++;\n      return true;\n    }\n    return false;\n  }\n  checkFirstAutoSize(seriesToUpdate) {\n    if (this.width != null && this.height != null) {\n    } else if (!this._lastAutoSize) {\n      const count = this._performUpdateNoRenderCount++;\n      const backOffMs = (count + 1) ** 2 * 40;\n      if (count < 8) {\n        this.update(3 /* PERFORM_LAYOUT */, { seriesToUpdate, backOffMs });\n        this.debug(\"Chart.checkFirstAutoSize() - backing off until first size update\", backOffMs);\n        return false;\n      }\n      this.debug(\"Chart.checkFirstAutoSize() - timeout for first size update.\");\n    }\n    this._performUpdateNoRenderCount = 0;\n    return true;\n  }\n  onAxisChange(newValue, oldValue) {\n    if (oldValue == null && newValue.length === 0)\n      return;\n    this.ctx.axisManager.updateAxes(oldValue ?? [], newValue);\n  }\n  onSeriesChange(newValue, oldValue) {\n    const seriesToDestroy = oldValue?.filter((series) => !newValue.includes(series)) ?? [];\n    this.destroySeries(seriesToDestroy);\n    this.seriesLayerManager?.setSeriesCount(newValue.length);\n    for (const series of newValue) {\n      if (oldValue?.includes(series))\n        continue;\n      if (series.rootGroup.parent == null) {\n        this.seriesLayerManager.requestGroup(series);\n      }\n      const chart = this;\n      series.chart = {\n        get mode() {\n          return chart.mode;\n        },\n        get isMiniChart() {\n          return false;\n        },\n        get seriesRect() {\n          return chart.seriesRect;\n        },\n        placeLabels() {\n          return chart.placeLabels();\n        }\n      };\n      series.resetAnimation(this.chartAnimationPhase);\n      this.addSeriesListeners(series);\n      series.addChartEventListeners();\n    }\n  }\n  destroySeries(allSeries) {\n    allSeries?.forEach((series) => {\n      series.removeEventListener(\"nodeClick\", this.onSeriesNodeClick);\n      series.removeEventListener(\"nodeDoubleClick\", this.onSeriesNodeDoubleClick);\n      series.removeEventListener(\"groupingChanged\", this.seriesGroupingChanged);\n      series.destroy();\n      this.seriesLayerManager.releaseGroup(series);\n      series.chart = void 0;\n    });\n  }\n  addSeriesListeners(series) {\n    if (this.hasEventListener(\"seriesNodeClick\")) {\n      series.addEventListener(\"nodeClick\", this.onSeriesNodeClick);\n    }\n    if (this.hasEventListener(\"seriesNodeDoubleClick\")) {\n      series.addEventListener(\"nodeDoubleClick\", this.onSeriesNodeDoubleClick);\n    }\n    series.addEventListener(\"groupingChanged\", this.seriesGroupingChanged);\n  }\n  updateAllSeriesListeners() {\n    this.series.forEach((series) => {\n      series.removeEventListener(\"nodeClick\", this.onSeriesNodeClick);\n      series.removeEventListener(\"nodeDoubleClick\", this.onSeriesNodeDoubleClick);\n      this.addSeriesListeners(series);\n    });\n  }\n  assignSeriesToAxes() {\n    this.axes.forEach((axis) => {\n      axis.boundSeries = this.series.filter((s) => {\n        const seriesAxis = s.axes[axis.direction];\n        return seriesAxis === axis;\n      });\n    });\n  }\n  assignAxesToSeries() {\n    const directionToAxesMap = groupBy(this.axes, (axis) => axis.direction);\n    this.series.forEach((series) => {\n      series.directions.forEach((direction) => {\n        const directionAxes = directionToAxesMap[direction];\n        if (!directionAxes) {\n          Logger.warnOnce(\n            `no available axis for direction [${direction}]; check series and axes configuration.`\n          );\n          return;\n        }\n        const seriesKeys = series.getKeys(direction);\n        const newAxis = directionAxes.find(\n          (axis) => !axis.keys.length || seriesKeys.some((key) => axis.keys.includes(key))\n        );\n        if (!newAxis) {\n          Logger.warnOnce(\n            `no matching axis for direction [${direction}] and keys [${seriesKeys}]; check series and axes configuration.`\n          );\n          return;\n        }\n        series.axes[direction] = newAxis;\n      });\n    });\n  }\n  parentResize(size) {\n    if (size == null || this.width != null && this.height != null)\n      return;\n    let { width, height } = size;\n    width = Math.floor(width);\n    height = Math.floor(height);\n    if (width === 0 && height === 0)\n      return;\n    const [autoWidth = 0, authHeight = 0] = this._lastAutoSize ?? [];\n    if (autoWidth === width && authHeight === height)\n      return;\n    this._lastAutoSize = [width, height];\n    this.resize(\"SizeMonitor\", {});\n  }\n  resize(source, opts) {\n    const { scene, animationManager } = this.ctx;\n    const { inWidth, inHeight, inMinWidth, inMinHeight } = opts;\n    this.ctx.domManager.setSizeOptions(\n      inMinWidth ?? this.minWidth,\n      inMinHeight ?? this.minHeight,\n      inWidth ?? this.width,\n      inHeight ?? this.height\n    );\n    const width = inWidth ?? this.width ?? this._lastAutoSize?.[0];\n    const height = inHeight ?? this.height ?? this._lastAutoSize?.[1];\n    this.debug(`Chart.resize() from ${source}`, { width, height, stack: new Error().stack });\n    if (width == null || height == null || !isFiniteNumber(width) || !isFiniteNumber(height))\n      return;\n    if (scene.resize(width, height)) {\n      this.resetPointer();\n      animationManager.reset();\n      let skipAnimations = true;\n      if ((this.width == null || this.height == null) && this._firstAutoSize) {\n        skipAnimations = false;\n        this._firstAutoSize = false;\n      }\n      this.update(3 /* PERFORM_LAYOUT */, { forceNodeDataRefresh: true, skipAnimations });\n    }\n  }\n  async updateData() {\n    this.series.forEach((s) => s.setChartData(this.data));\n    const modulePromises = this.modulesManager.mapModules((m) => m.updateData?.({ data: this.data }));\n    await Promise.all(modulePromises);\n  }\n  async processData() {\n    if (this.series.some((s) => s.canHaveAxes)) {\n      this.assignAxesToSeries();\n      const syncModule = this.modulesManager.getModule(\"sync\");\n      if (syncModule?.enabled) {\n        syncModule.syncAxes(this._skipSync);\n      } else {\n        this.assignSeriesToAxes();\n      }\n    }\n    const dataController = new DataController(this.mode);\n    const seriesPromises = this.series.map((s) => s.processData(dataController));\n    const modulePromises = this.modulesManager.mapModules((m) => m.processData?.({ dataController }));\n    dataController.execute();\n    await Promise.all([...seriesPromises, ...modulePromises]);\n    for (const { legendType, legend } of this.modulesManager.legends()) {\n      legend.data = this.getLegendData(legendType, this.mode !== \"integrated\");\n    }\n    this.dataProcessListeners.forEach((resolve) => resolve());\n    this.dataProcessListeners.clear();\n  }\n  placeLabels() {\n    const visibleSeries = [];\n    const data = [];\n    for (const series of this.series) {\n      if (!series.visible)\n        continue;\n      const labelData = series.getLabelData();\n      if (isPointLabelDatum(labelData?.[0])) {\n        data.push(labelData);\n        visibleSeries.push(series);\n      }\n    }\n    const { seriesRect } = this;\n    const { top, right, bottom, left } = this.seriesArea.padding;\n    const labels = seriesRect && data.length > 0 ? placeLabels(data, {\n      x: -left,\n      y: -top,\n      width: seriesRect.width + left + right,\n      height: seriesRect.height + top + bottom\n    }) : [];\n    return new Map(labels.map((l, i) => [visibleSeries[i], l]));\n  }\n  getLegendData(legendType, warnConflicts) {\n    var _a;\n    const legendData = this.series.filter((s) => s.properties.showInLegend).flatMap((s) => s.getLegendData(legendType));\n    const isCategoryLegendData = (data) => data.every((d) => d.legendType === \"category\");\n    if (warnConflicts && isCategoryLegendData(legendData)) {\n      const seriesMarkerFills = {};\n      const seriesTypeMap = new Map(this.series.map((s) => [s.id, s.type]));\n      for (const {\n        seriesId,\n        symbols: [{ marker }],\n        label\n      } of legendData) {\n        if (marker.fill == null)\n          continue;\n        const seriesType = seriesTypeMap.get(seriesId);\n        const markerFill = seriesMarkerFills[seriesType] ?? (seriesMarkerFills[seriesType] = {});\n        markerFill[_a = label.text] ?? (markerFill[_a] = marker.fill);\n        if (markerFill[label.text] !== marker.fill) {\n          Logger.warnOnce(\n            `legend item '${label.text}' has multiple fill colors, this may cause unexpected behaviour.`\n          );\n        }\n      }\n    }\n    return legendData;\n  }\n  async processLayout() {\n    const oldRect = this.animationRect;\n    await this.performLayout();\n    if (oldRect && !this.animationRect?.equals(oldRect)) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n    this.debug(\"Chart.performUpdate() - seriesRect\", this.seriesRect);\n  }\n  async performLayout() {\n    const { width, height } = this.ctx.scene;\n    let ctx = { shrinkRect: new BBox(0, 0, width, height), positions: {}, padding: {} };\n    ctx = this.ctx.layoutService.dispatchPerformLayout(\"start-layout\", ctx);\n    ctx = this.ctx.layoutService.dispatchPerformLayout(\"before-series\", ctx);\n    for (const m of this.modulesManager.modules()) {\n      if (m.performLayout != null) {\n        ctx = await m.performLayout(ctx);\n      }\n    }\n    return ctx.shrinkRect;\n  }\n  // x/y are local canvas coordinates in CSS pixels, not actual pixels\n  pickNode(point, collection) {\n    const start = performance.now();\n    const reverseSeries = [...collection].reverse();\n    let result;\n    for (const { series, pickModes, maxDistance } of reverseSeries) {\n      if (!series.visible || !series.rootGroup.visible) {\n        continue;\n      }\n      const { match, distance: distance3 } = series.pickNode(point, pickModes) ?? {};\n      if (!match || distance3 == null) {\n        continue;\n      }\n      if ((!result || result.distance > distance3) && distance3 <= (maxDistance ?? Infinity)) {\n        result = { series, distance: distance3, datum: match };\n      }\n      if (distance3 === 0) {\n        break;\n      }\n    }\n    this.extraDebugStats[\"pickSeriesNode\"] = Math.round(\n      (this.extraDebugStats[\"pickSeriesNode\"] ?? 0) + (performance.now() - start)\n    );\n    return result;\n  }\n  pickSeriesNode(point, exactMatchOnly, maxDistance) {\n    const pickModes = exactMatchOnly ? [0 /* EXACT_SHAPE_MATCH */] : void 0;\n    return this.pickNode(\n      point,\n      this.series.map((series) => {\n        return { series, pickModes, maxDistance };\n      })\n    );\n  }\n  pickTooltip(point) {\n    return this.pickNode(\n      point,\n      this.series.map((series) => {\n        const tooltipRange = series.properties.tooltip.range;\n        let pickModes;\n        if (tooltipRange === \"exact\") {\n          pickModes = [0 /* EXACT_SHAPE_MATCH */];\n        } else {\n          pickModes = void 0;\n        }\n        const maxDistance = typeof tooltipRange === \"number\" ? tooltipRange : void 0;\n        return { series, pickModes, maxDistance };\n      })\n    );\n  }\n  onMouseMove(event) {\n    this.lastInteractionEvent = event;\n    this.pointerScheduler.schedule();\n    this.extraDebugStats[\"mouseX\"] = event.offsetX;\n    this.extraDebugStats[\"mouseY\"] = event.offsetY;\n    this.update(6 /* SCENE_RENDER */);\n  }\n  onLeave(event) {\n    const el = event.relatedElement;\n    if (el && this.ctx.domManager.isManagedDOMElement(el))\n      return;\n    this.resetPointer();\n    this.update(6 /* SCENE_RENDER */);\n    this.ctx.cursorManager.updateCursor(\"chart\");\n  }\n  onBrowserFocus(event) {\n    if (event.delta > 0) {\n      this.focus.datum = void 0;\n      this.focus.series = void 0;\n      this.focus.datumIndex = 0;\n      this.focus.seriesIndex = 0;\n    } else if (event.delta < 0) {\n      this.focus.datum = void 0;\n      this.focus.series = void 0;\n      this.focus.datumIndex = Infinity;\n      this.focus.seriesIndex = Infinity;\n    }\n  }\n  onAnimationStart() {\n    if (this.focus.hasFocus) {\n      this.onBlur();\n    }\n  }\n  onBlur() {\n    this.ctx.focusIndicator.updateBounds(void 0);\n    this.resetPointer();\n    this.focus.hasFocus = false;\n  }\n  onTab(event) {\n    this.handleFocus(0, 0);\n    event.preventDefault();\n    this.focus.hasFocus = true;\n  }\n  onNavVert(event) {\n    this.focus.seriesIndex += event.delta;\n    this.handleFocus(event.delta, 0);\n    event.preventDefault();\n  }\n  onNavHori(event) {\n    this.focus.datumIndex += event.delta;\n    this.handleFocus(0, event.delta);\n    event.preventDefault();\n  }\n  onSubmit(event) {\n    const { series, datum } = this.focus;\n    const sourceEvent = event.sourceEvent.sourceEvent;\n    if (series !== void 0 && datum !== void 0) {\n      series.fireNodeClickEvent(sourceEvent, datum);\n    } else {\n      this.fireEvent({\n        type: \"click\",\n        event: sourceEvent\n      });\n    }\n    event.preventDefault();\n  }\n  onContextMenu(event) {\n    this.ctx.tooltipManager.removeTooltip(this.id);\n    const { Default: Default2, ContextMenu } = InteractionState;\n    let pickedNode;\n    if (this.ctx.interactionManager.getState() & (Default2 | ContextMenu)) {\n      this.checkSeriesNodeRange(event, (_series, datum) => {\n        this.ctx.highlightManager.updateHighlight(this.id);\n        pickedNode = datum;\n      });\n    }\n    this.ctx.contextMenuRegistry.dispatchContext(\"series\", event, { pickedNode });\n  }\n  handleFocus(seriesIndexDelta, datumIndexDelta) {\n    this.focus.hasFocus = true;\n    const overlayFocus = this.overlays.getFocusInfo(this.ctx.localeManager);\n    if (overlayFocus == null) {\n      this.handleSeriesFocus(seriesIndexDelta, datumIndexDelta);\n    } else {\n      this.ctx.focusIndicator.updateBounds(overlayFocus.rect);\n      this.ctx.ariaAnnouncementService.announceValue(overlayFocus.text);\n    }\n  }\n  handleSeriesFocus(otherIndexDelta, datumIndexDelta) {\n    const { series, seriesRect, focus } = this;\n    const visibleSeries = series.filter((s) => s.visible);\n    if (visibleSeries.length === 0)\n      return;\n    focus.seriesIndex = clamp(0, focus.seriesIndex, visibleSeries.length - 1);\n    focus.series = visibleSeries[focus.seriesIndex];\n    const { datumIndex, seriesIndex: otherIndex } = focus;\n    const pick = focus.series.pickFocus({ datumIndex, datumIndexDelta, otherIndex, otherIndexDelta, seriesRect });\n    this.updatePickedFocus(pick);\n  }\n  updatePickedFocus(pick) {\n    const { focus } = this;\n    if (pick === void 0 || focus.series === void 0)\n      return;\n    const { datum, datumIndex } = pick;\n    focus.datumIndex = datumIndex;\n    focus.datum = datum;\n    const keyboardEvent = makeKeyboardPointerEvent(this.ctx.focusIndicator, pick);\n    if (keyboardEvent !== void 0) {\n      this.lastInteractionEvent = keyboardEvent;\n      const html = focus.series.getTooltipHtml(datum);\n      const meta = TooltipManager.makeTooltipMeta(this.lastInteractionEvent, datum);\n      const aria = this.getDatumAriaText(datum, html);\n      this.ctx.highlightManager.updateHighlight(this.id, datum);\n      this.ctx.tooltipManager.updateTooltip(this.id, meta, html);\n      this.ctx.ariaAnnouncementService.announceValue(\"ariaAnnounceHoverDatum\", { datum: aria });\n    }\n  }\n  static isHoverEvent(event) {\n    return event !== void 0 && event.type === \"hover\";\n  }\n  static isDragEvent(event) {\n    return event !== void 0 && event.type === \"drag\";\n  }\n  handlePointer(event, redisplay) {\n    const state = this.ctx.interactionManager.getState();\n    if (state !== 16 /* Default */ && state !== 4 /* Annotations */ || !_Chart.isHoverEvent(event) && !_Chart.isDragEvent(event)) {\n      return;\n    }\n    const { lastPick, hoverRect } = this;\n    const { offsetX, offsetY } = event;\n    const disablePointer = (highlightOnly = false) => {\n      if (lastPick) {\n        this.resetPointer(highlightOnly);\n      }\n    };\n    if (redisplay ? this.ctx.animationManager.isActive() : !hoverRect?.containsPoint(offsetX, offsetY)) {\n      disablePointer();\n      return;\n    }\n    this.handlePointerTooltip(event, disablePointer);\n    this.handlePointerNode(event);\n  }\n  handlePointerTooltip(event, disablePointer) {\n    const { lastPick } = this;\n    const { offsetX, offsetY, targetElement } = event;\n    if (targetElement && this.tooltip.interactive && this.ctx.domManager.isManagedChildDOMElement(targetElement, \"canvas-overlay\", DEFAULT_TOOLTIP_CLASS)) {\n      return;\n    }\n    const pick = this.pickTooltip({ x: offsetX, y: offsetY });\n    if (!pick) {\n      this.ctx.tooltipManager.removeTooltip(this.id);\n      if (this.highlight.range === \"tooltip\") {\n        disablePointer(true);\n      }\n      return;\n    }\n    const isNewDatum = this.highlight.range === \"node\" || !lastPick || lastPick !== pick.datum;\n    let html;\n    if (isNewDatum) {\n      html = pick.series.getTooltipHtml(pick.datum);\n      if (this.highlight.range === \"tooltip\") {\n        this.ctx.highlightManager.updateHighlight(this.id, pick.datum);\n      }\n    }\n    const tooltipEnabled = this.tooltip.enabled && pick.series.tooltipEnabled;\n    const shouldUpdateTooltip = tooltipEnabled && (!isNewDatum || html !== void 0);\n    const meta = TooltipManager.makeTooltipMeta(event, pick.datum);\n    if (shouldUpdateTooltip) {\n      this.ctx.tooltipManager.updateTooltip(this.id, meta, html);\n    }\n  }\n  handlePointerNode(event) {\n    const found = this.checkSeriesNodeRange(event, (series, datum) => {\n      if (series.hasEventListener(\"nodeClick\") || series.hasEventListener(\"nodeDoubleClick\")) {\n        this.ctx.cursorManager.updateCursor(\"chart\", \"pointer\");\n      }\n      if (this.highlight.range === \"node\") {\n        this.ctx.highlightManager.updateHighlight(this.id, datum);\n      }\n    });\n    if (!found) {\n      this.ctx.cursorManager.updateCursor(\"chart\");\n      if (this.highlight.range === \"node\") {\n        this.ctx.highlightManager.updateHighlight(this.id);\n      }\n    }\n  }\n  onClick(event) {\n    if (this.checkSeriesNodeClick(event)) {\n      this.update(4 /* SERIES_UPDATE */);\n      event.preventDefault();\n      return;\n    }\n    this.fireEvent({ type: \"click\", event: event.sourceEvent });\n  }\n  onDoubleClick(event) {\n    if (this.checkSeriesNodeDoubleClick(event)) {\n      this.update(4 /* SERIES_UPDATE */);\n      event.preventDefault();\n      return;\n    }\n    this.fireEvent({ type: \"doubleClick\", event: event.sourceEvent });\n  }\n  checkSeriesNodeClick(event) {\n    return this.checkSeriesNodeRange(event, (series, datum) => series.fireNodeClickEvent(event.sourceEvent, datum));\n  }\n  checkSeriesNodeDoubleClick(event) {\n    return this.checkSeriesNodeRange(\n      event,\n      (series, datum) => series.fireNodeDoubleClickEvent(event.sourceEvent, datum)\n    );\n  }\n  checkSeriesNodeRange(event, callback) {\n    const nearestNode = this.pickSeriesNode({ x: event.offsetX, y: event.offsetY }, false);\n    const datum = nearestNode?.datum;\n    const nodeClickRange = datum?.series.properties.nodeClickRange;\n    let pixelRange;\n    if (isFiniteNumber(nodeClickRange)) {\n      pixelRange = nodeClickRange;\n    }\n    let pickedNode = this.pickSeriesNode({ x: event.offsetX, y: event.offsetY }, true);\n    if (pickedNode) {\n      event.preventZoomDblClick = true;\n    }\n    if (datum && nodeClickRange === \"nearest\") {\n      callback(datum.series, datum);\n      return true;\n    }\n    if (nodeClickRange !== \"exact\") {\n      pickedNode = this.pickSeriesNode({ x: event.offsetX, y: event.offsetY }, false, pixelRange);\n    }\n    if (!pickedNode)\n      return false;\n    const isPixelRange = pixelRange != null;\n    const exactlyMatched = nodeClickRange === \"exact\" && pickedNode.distance === 0;\n    if (isPixelRange || exactlyMatched) {\n      const allMatch = event.pointerHistory === void 0 || event.pointerHistory?.every((pastEvent) => {\n        const historyPoint = { x: pastEvent.offsetX, y: pastEvent.offsetY };\n        const historyNode = this.pickSeriesNode(historyPoint, false, pixelRange);\n        return historyNode?.datum === pickedNode?.datum;\n      });\n      if (allMatch) {\n        callback(pickedNode.series, pickedNode.datum);\n        return true;\n      }\n    }\n    return false;\n  }\n  changeHighlightDatum(event) {\n    const seriesToUpdate = /* @__PURE__ */ new Set();\n    const { series: newSeries = void 0, datum: newDatum } = event.currentHighlight ?? {};\n    const { series: lastSeries = void 0, datum: lastDatum } = event.previousHighlight ?? {};\n    if (lastSeries) {\n      seriesToUpdate.add(lastSeries);\n    }\n    if (newSeries) {\n      seriesToUpdate.add(newSeries);\n    }\n    if (lastSeries?.properties.cursor && lastDatum) {\n      this.ctx.cursorManager.updateCursor(lastSeries.id);\n    }\n    if (newSeries?.properties.cursor && newDatum) {\n      this.ctx.cursorManager.updateCursor(newSeries.id, newSeries.properties.cursor);\n    }\n    this.lastPick = event.currentHighlight;\n    const updateAll = newSeries == null || lastSeries == null;\n    if (updateAll) {\n      this.update(4 /* SERIES_UPDATE */);\n    } else {\n      this.update(4 /* SERIES_UPDATE */, { seriesToUpdate });\n    }\n  }\n  async waitForUpdate(timeoutMs = 1e4, failOnTimeout = false) {\n    const start = performance.now();\n    if (this._pendingFactoryUpdatesCount > 0) {\n      await this.updateMutex.waitForClearAcquireQueue();\n    }\n    while (this.performUpdateType !== 7 /* NONE */) {\n      if (performance.now() - start > timeoutMs) {\n        const message = `Chart.waitForUpdate() timeout of ${timeoutMs} reached - first chart update taking too long.`;\n        if (failOnTimeout) {\n          throw new Error(message);\n        } else {\n          Logger.warnOnce(message);\n        }\n      }\n      await sleep(50);\n    }\n    await this.updateMutex.waitForClearAcquireQueue();\n  }\n  waitForDataProcess(timeout) {\n    return new Promise((resolve) => {\n      this.dataProcessListeners.add(resolve);\n      if (isNumber(timeout)) {\n        setTimeout(() => {\n          if (this.dataProcessListeners.has(resolve)) {\n            this.dataProcessListeners.delete(resolve);\n            resolve();\n          }\n        }, timeout);\n      }\n    });\n  }\n  getMinRects() {\n    const { width, height } = this.ctx.scene;\n    const minRects = this.series.map((series) => series.getMinRects(width, height)).filter(isDefined);\n    if (minRects.length === 0)\n      return;\n    let maxWidth = 0;\n    let maxHeight = 0;\n    let maxVisibleWidth = 0;\n    let maxVisibleHeight = 0;\n    for (const { minRect: minRect2, minVisibleRect: minVisibleRect2 } of minRects) {\n      maxWidth = Math.max(maxWidth, minRect2.width);\n      maxHeight = Math.max(maxHeight, minRect2.height);\n      maxVisibleWidth = Math.max(maxVisibleWidth, minVisibleRect2.width);\n      maxVisibleHeight = Math.max(maxVisibleHeight, minVisibleRect2.height);\n    }\n    const minRect = new BBox(0, 0, maxWidth, maxHeight);\n    let minVisibleRect = minRect.clone();\n    if (maxVisibleWidth > 0 && maxVisibleHeight > 0) {\n      minVisibleRect = new BBox(0, 0, maxVisibleWidth, maxVisibleHeight);\n    }\n    return { minRect, minVisibleRect };\n  }\n  filterMiniChartSeries(series) {\n    return series?.filter((s) => s.showInMiniChart !== false);\n  }\n  applyOptions(newChartOptions) {\n    const isDifferentOpts = newChartOptions !== this.chartOptions;\n    const oldOpts = isDifferentOpts ? this.chartOptions.processedOptions : {};\n    const newOpts = newChartOptions.processedOptions;\n    const deltaOptions = newChartOptions.diffOptions(oldOpts);\n    if (deltaOptions == null)\n      return;\n    debug(\"Chart.applyOptions() - applying delta\", deltaOptions);\n    const modulesChanged = this.applyModules(newOpts);\n    const skip = [\n      \"type\",\n      \"data\",\n      \"series\",\n      \"listeners\",\n      \"preset\",\n      \"theme\",\n      \"legend.listeners\",\n      \"navigator.miniChart.series\",\n      \"navigator.miniChart.label\",\n      \"axes\",\n      \"topology\",\n      \"nodes\",\n      \"initialState\"\n    ];\n    if (deltaOptions.listeners) {\n      this.registerListeners(this, deltaOptions.listeners);\n    }\n    jsonApply(this, deltaOptions, { skip });\n    let forceNodeDataRefresh = false;\n    let seriesStatus = \"no-op\";\n    if (deltaOptions.series?.length) {\n      seriesStatus = this.applySeries(this, deltaOptions.series, oldOpts?.series);\n      forceNodeDataRefresh = true;\n    }\n    if (seriesStatus === \"replaced\") {\n      this.resetAnimations();\n    }\n    if (this.applyAxes(this, newOpts, oldOpts, seriesStatus, [], true)) {\n      forceNodeDataRefresh = true;\n    }\n    if (deltaOptions.data) {\n      this.data = deltaOptions.data;\n    }\n    if (deltaOptions.legend?.listeners && this.modulesManager.isEnabled(\"legend\")) {\n      Object.assign(this.legend.listeners, deltaOptions.legend.listeners);\n    }\n    if (deltaOptions.listeners) {\n      this.updateAllSeriesListeners();\n    }\n    this.chartOptions = newChartOptions;\n    const navigatorModule = this.modulesManager.getModule(\"navigator\");\n    const zoomModule = this.modulesManager.getModule(\"zoom\");\n    if (!navigatorModule?.enabled && !zoomModule?.enabled) {\n      this.ctx.zoomManager.updateZoom(\"chart\");\n    }\n    const miniChart = navigatorModule?.miniChart;\n    const miniChartSeries = newOpts.navigator?.miniChart?.series ?? newOpts.series;\n    if (miniChart?.enabled === true && miniChartSeries != null) {\n      this.applyMiniChartOptions(miniChart, miniChartSeries, newOpts, oldOpts);\n    } else if (miniChart?.enabled === false) {\n      miniChart.series = [];\n      miniChart.axes = [];\n    }\n    this.ctx.annotationManager.setAnnotationStyles(newChartOptions.annotationThemes);\n    forceNodeDataRefresh || (forceNodeDataRefresh = this.shouldForceNodeDataRefresh(deltaOptions, seriesStatus));\n    const majorChange = forceNodeDataRefresh || modulesChanged;\n    const updateType = majorChange ? 0 /* FULL */ : 3 /* PERFORM_LAYOUT */;\n    this.maybeResetAnimations(seriesStatus);\n    debug(\"Chart.applyOptions() - update type\", ChartUpdateType[updateType], {\n      seriesStatus,\n      forceNodeDataRefresh\n    });\n    this.update(updateType, { forceNodeDataRefresh, newAnimationBatch: true });\n  }\n  applyInitialState() {\n    const {\n      ctx: { annotationManager, stateManager }\n    } = this;\n    const options = this.getOptions();\n    if (options.initialState?.annotations != null) {\n      const annotations2 = options.initialState.annotations.map((annotation) => {\n        const annotationTheme = annotationManager.getAnnotationTypeStyles(annotation.type);\n        return mergeDefaults(annotation, annotationTheme);\n      });\n      stateManager.setState(annotationManager, annotations2);\n    }\n  }\n  maybeResetAnimations(seriesStatus) {\n    if (this.mode !== \"standalone\")\n      return;\n    switch (seriesStatus) {\n      case \"series-grouping-change\":\n      case \"replaced\":\n        this.resetAnimations();\n        break;\n      default:\n    }\n  }\n  shouldForceNodeDataRefresh(deltaOptions, seriesStatus) {\n    const seriesDataUpdate = !!deltaOptions.data || seriesStatus === \"data-change\" || seriesStatus === \"replaced\";\n    const legendKeys = legendRegistry.getKeys();\n    const optionsHaveLegend = Object.values(legendKeys).some(\n      (legendKey) => deltaOptions[legendKey] != null\n    );\n    const otherRefreshUpdate = deltaOptions.title != null && deltaOptions.subtitle != null;\n    return seriesDataUpdate || optionsHaveLegend || otherRefreshUpdate;\n  }\n  applyMiniChartOptions(miniChart, miniChartSeries, completeOptions, oldOpts) {\n    const oldSeries = oldOpts?.navigator?.miniChart?.series ?? oldOpts?.series;\n    const miniChartSeriesStatus = this.applySeries(\n      miniChart,\n      this.filterMiniChartSeries(miniChartSeries),\n      this.filterMiniChartSeries(oldSeries)\n    );\n    this.applyAxes(miniChart, completeOptions, oldOpts, miniChartSeriesStatus, [\n      \"axes[].tick\",\n      \"axes[].thickness\",\n      \"axes[].title\",\n      \"axes[].crosshair\",\n      \"axes[].gridLine\",\n      \"axes[].label\"\n    ]);\n    const axes = miniChart.axes;\n    const horizontalAxis = axes.find((axis) => axis.direction === \"x\" /* X */);\n    for (const axis of axes) {\n      axis.gridLine.enabled = false;\n      axis.label.enabled = axis === horizontalAxis;\n      axis.tick.enabled = false;\n      axis.interactionEnabled = false;\n    }\n    if (horizontalAxis != null) {\n      const miniChartOpts = completeOptions.navigator?.miniChart;\n      const labelOptions = miniChartOpts?.label;\n      const intervalOptions = miniChartOpts?.label?.interval;\n      horizontalAxis.line.enabled = false;\n      horizontalAxis.label.set(\n        without(labelOptions, [\"interval\", \"rotation\", \"minSpacing\", \"autoRotate\", \"autoRotateAngle\"])\n      );\n      horizontalAxis.tick.set(\n        without(intervalOptions, [\"enabled\", \"width\", \"size\", \"color\", \"interval\", \"step\"])\n      );\n      const step = intervalOptions?.step;\n      if (step != null) {\n        horizontalAxis.interval.step = step;\n      }\n    }\n  }\n  applyModules(options) {\n    const { type: chartType2 } = this.constructor;\n    let modulesChanged = false;\n    for (const module of moduleRegistry.byType(\"root\", \"legend\")) {\n      const isConfigured = options[module.optionsKey] != null;\n      const shouldBeEnabled = isConfigured && module.chartTypes.includes(chartType2);\n      if (shouldBeEnabled === this.modulesManager.isEnabled(module))\n        continue;\n      if (shouldBeEnabled) {\n        this.modulesManager.addModule(module, (m) => new m.instanceConstructor(this.getModuleContext()));\n        if (module.type === \"legend\") {\n          this.modulesManager.getModule(module)?.attachLegend(this.ctx.scene);\n        }\n        this[module.optionsKey] = this.modulesManager.getModule(module);\n      } else {\n        this.modulesManager.removeModule(module);\n        delete this[module.optionsKey];\n      }\n      modulesChanged = true;\n    }\n    return modulesChanged;\n  }\n  applySeries(chart, optSeries, oldOptSeries) {\n    if (!optSeries) {\n      return \"no-change\";\n    }\n    const matchResult = matchSeriesOptions(chart.series, optSeries, oldOptSeries);\n    if (matchResult.status === \"no-overlap\") {\n      debug(`Chart.applySeries() - creating new series instances, status: ${matchResult.status}`, matchResult);\n      chart.series = optSeries.map((opts) => this.createSeries(opts));\n      return \"replaced\";\n    }\n    debug(`Chart.applySeries() - matchResult`, matchResult);\n    const seriesInstances = [];\n    let dataChanged = false;\n    let groupingChanged = false;\n    let isUpdated = false;\n    for (const change of matchResult.changes) {\n      groupingChanged || (groupingChanged = change.status === \"series-grouping\");\n      dataChanged || (dataChanged = change.diff?.data != null);\n      isUpdated || (isUpdated = change.status !== \"no-op\");\n      switch (change.status) {\n        case \"add\":\n          const newSeries = this.createSeries(change.opts);\n          seriesInstances.push(newSeries);\n          debug(`Chart.applySeries() - created new series`, newSeries);\n          break;\n        case \"remove\":\n          debug(`Chart.applySeries() - removing series at previous idx ${change.idx}`, change.series);\n          break;\n        case \"no-op\":\n          seriesInstances.push(change.series);\n          debug(`Chart.applySeries() - no change to series at previous idx ${change.idx}`, change.series);\n          break;\n        case \"series-grouping\":\n        case \"update\":\n        default:\n          const { series, diff: diff2, idx } = change;\n          debug(`Chart.applySeries() - applying series diff previous idx ${idx}`, diff2, series);\n          this.applySeriesValues(series, diff2);\n          series.markNodeDataDirty();\n          seriesInstances.push(series);\n      }\n    }\n    for (let idx = 0; idx < seriesInstances.length; idx++) {\n      seriesInstances[idx]._declarationOrder = idx;\n    }\n    debug(`Chart.applySeries() - final series instances`, seriesInstances);\n    chart.series = seriesInstances;\n    if (groupingChanged) {\n      return \"series-grouping-change\";\n    }\n    if (dataChanged) {\n      return \"data-change\";\n    }\n    return isUpdated ? \"updated\" : \"no-op\";\n  }\n  applyAxes(chart, options, oldOpts, seriesStatus, skip = [], registerRegions = false) {\n    if (!(\"axes\" in options) || !options.axes) {\n      return false;\n    }\n    skip = [\"axes[].type\", ...skip];\n    const { axes } = options;\n    const forceRecreate = seriesStatus === \"replaced\";\n    const matchingTypes = !forceRecreate && chart.axes.length === axes.length && chart.axes.every((a, i) => a.type === axes[i].type);\n    if (matchingTypes && isAgCartesianChartOptions(oldOpts)) {\n      chart.axes.forEach((axis, index) => {\n        const previousOpts = oldOpts.axes?.[index] ?? {};\n        const axisDiff = jsonDiff(previousOpts, axes[index]);\n        debug(`Chart.applyAxes() - applying axis diff idx ${index}`, axisDiff);\n        const path = `axes[${index}]`;\n        jsonApply(axis, axisDiff, { ...JSON_APPLY_PLUGINS, path, skip });\n      });\n      return true;\n    }\n    debug(`Chart.applyAxes() - creating new axes instances; seriesStatus: ${seriesStatus}`);\n    chart.axes = this.createAxis(axes, skip);\n    const axisGroups = {\n      [\"x\" /* X */]: [],\n      [\"y\" /* Y */]: []\n    };\n    chart.axes.forEach((axis) => axisGroups[axis.direction].push(axis.getAxisGroup()));\n    if (registerRegions) {\n      this.ctx.regionManager.updateRegion(\"horizontal-axes\" /* HORIZONTAL_AXES */, ...axisGroups[\"x\" /* X */]);\n      this.ctx.regionManager.updateRegion(\"vertical-axes\" /* VERTICAL_AXES */, ...axisGroups[\"y\" /* Y */]);\n    }\n    return true;\n  }\n  createSeries(seriesOptions) {\n    const seriesInstance = seriesRegistry.create(seriesOptions.type, this.getModuleContext());\n    this.applySeriesOptionModules(seriesInstance, seriesOptions);\n    this.applySeriesValues(seriesInstance, seriesOptions);\n    return seriesInstance;\n  }\n  applySeriesOptionModules(series, options) {\n    const moduleContext = series.createModuleContext();\n    const moduleMap = series.getModuleMap();\n    for (const module of moduleRegistry.byType(\"series-option\")) {\n      if (module.optionsKey in options && module.seriesTypes.includes(series.type)) {\n        moduleMap.addModule(module, (m) => new m.instanceConstructor(moduleContext));\n      }\n    }\n  }\n  applySeriesValues(target, options) {\n    const moduleMap = target.getModuleMap();\n    const { type: _, data, listeners, seriesGrouping, showInMiniChart: __, ...seriesOptions } = options;\n    for (const moduleDef of EXPECTED_ENTERPRISE_MODULES) {\n      if (moduleDef.type !== \"series-option\")\n        continue;\n      if (moduleDef.optionsKey in seriesOptions) {\n        const module = moduleMap.getModule(moduleDef.optionsKey);\n        if (module) {\n          const moduleOptions = seriesOptions[moduleDef.optionsKey];\n          delete seriesOptions[moduleDef.optionsKey];\n          module.properties.set(moduleOptions);\n        }\n      }\n    }\n    target.properties.set(seriesOptions);\n    if (\"data\" in options) {\n      target.setOptionsData(data);\n    }\n    if (listeners) {\n      this.registerListeners(target, listeners);\n    }\n    if (\"seriesGrouping\" in options) {\n      if (seriesGrouping == null) {\n        target.seriesGrouping = void 0;\n      } else {\n        target.seriesGrouping = { ...target.seriesGrouping, ...seriesGrouping };\n      }\n    }\n  }\n  createAxis(options, skip) {\n    const newAxes = [];\n    const moduleContext = this.getModuleContext();\n    for (let index = 0; index < options.length; index++) {\n      const axisOptions = options[index];\n      const axis = axisRegistry.create(axisOptions.type, moduleContext);\n      this.applyAxisModules(axis, axisOptions);\n      jsonApply(axis, axisOptions, { ...JSON_APPLY_PLUGINS, path: `axes[${index}]`, skip });\n      newAxes.push(axis);\n    }\n    guessInvalidPositions(newAxes);\n    return newAxes;\n  }\n  applyAxisModules(axis, options) {\n    const moduleContext = axis.createModuleContext();\n    const moduleMap = axis.getModuleMap();\n    for (const module of moduleRegistry.byType(\"axis-option\")) {\n      const shouldBeEnabled = options[module.optionsKey] != null;\n      if (shouldBeEnabled === moduleMap.isEnabled(module))\n        continue;\n      if (shouldBeEnabled) {\n        moduleMap.addModule(module, (m) => new m.instanceConstructor(moduleContext));\n        axis[module.optionsKey] = moduleMap.getModule(module);\n      } else {\n        moduleMap.removeModule(module);\n        delete axis[module.optionsKey];\n      }\n    }\n  }\n  registerListeners(source, listeners) {\n    source.clearEventListeners();\n    for (const [property, listener] of Object.entries(listeners)) {\n      if (isFunction(listener)) {\n        source.addEventListener(property, listener);\n      }\n    }\n  }\n};\n_Chart.chartsInstances = /* @__PURE__ */ new WeakMap();\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      if (this.destroyed)\n        return;\n      this.ctx.domManager.setContainer(value);\n      _Chart.chartsInstances.set(value, this);\n    },\n    oldValue(value) {\n      _Chart.chartsInstances.delete(value);\n    }\n  })\n], _Chart.prototype, \"container\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"width option\", { inWidth: value });\n    }\n  })\n], _Chart.prototype, \"width\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"height option\", { inHeight: value });\n    }\n  })\n], _Chart.prototype, \"height\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"minWidth option\", { inMinWidth: value });\n    }\n  })\n], _Chart.prototype, \"minWidth\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"minHeight option\", { inMinHeight: value });\n    }\n  })\n], _Chart.prototype, \"minHeight\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], _Chart.prototype, \"titlePadding\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"seriesArea\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"title\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"subtitle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"footnote\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"keyboard\", 2);\n__decorateClass([\n  Validate(UNION([\"standalone\", \"integrated\"], \"a chart mode\"))\n], _Chart.prototype, \"mode\", 2);\n__decorateClass([\n  ActionOnSet({\n    changeValue(newValue, oldValue) {\n      this.onAxisChange(newValue, oldValue);\n    }\n  })\n], _Chart.prototype, \"axes\", 2);\n__decorateClass([\n  ActionOnSet({\n    changeValue(newValue, oldValue) {\n      this.onSeriesChange(newValue, oldValue);\n    }\n  })\n], _Chart.prototype, \"series\", 2);\nvar Chart = _Chart;\n\n// packages/ag-charts-community/src/scene/util/quadtree.ts\nvar QuadtreeNearest = class {\n  constructor(capacity, maxdepth, boundary) {\n    this.root = new QuadtreeNodeNearest(capacity, maxdepth, boundary);\n  }\n  clear(boundary) {\n    this.root.clear(boundary);\n  }\n  addValue(hitTester, value) {\n    const elem = {\n      hitTester,\n      value,\n      distanceSquared: (x, y) => {\n        return hitTester.distanceSquared(x, y);\n      }\n    };\n    this.root.addElem(elem);\n  }\n  find(x, y) {\n    const arg = { best: { nearest: void 0, distanceSquared: Infinity } };\n    this.root.find(x, y, arg);\n    return arg.best;\n  }\n};\nvar QuadtreeSubdivisions = class {\n  constructor(nw, ne, sw, se) {\n    this.nw = nw;\n    this.ne = ne;\n    this.sw = sw;\n    this.se = se;\n  }\n  addElem(elem) {\n    this.nw.addElem(elem);\n    this.ne.addElem(elem);\n    this.sw.addElem(elem);\n    this.se.addElem(elem);\n  }\n  find(x, y, arg) {\n    this.nw.find(x, y, arg);\n    this.ne.find(x, y, arg);\n    this.sw.find(x, y, arg);\n    this.se.find(x, y, arg);\n  }\n};\nvar QuadtreeNode = class {\n  constructor(capacity, maxdepth, boundary) {\n    this.capacity = capacity;\n    this.maxdepth = maxdepth;\n    this.boundary = boundary ?? BBox.NaN;\n    this.elems = [];\n    this.subdivisions = void 0;\n  }\n  clear(boundary) {\n    this.elems.length = 0;\n    this.boundary = boundary;\n    this.subdivisions = void 0;\n  }\n  addElem(e) {\n    if (this.addCondition(e)) {\n      if (this.subdivisions === void 0) {\n        if (this.maxdepth === 0 || this.elems.length < this.capacity) {\n          this.elems.push(e);\n        } else {\n          this.subdivide(e);\n        }\n      } else {\n        this.subdivisions.addElem(e);\n      }\n    }\n  }\n  find(x, y, arg) {\n    if (this.findCondition(x, y, arg)) {\n      if (this.subdivisions === void 0) {\n        this.findAction(x, y, arg);\n      } else {\n        this.subdivisions.find(x, y, arg);\n      }\n    }\n  }\n  subdivide(newElem) {\n    this.subdivisions = this.makeSubdivisions();\n    for (const e of this.elems) {\n      this.subdivisions.addElem(e);\n    }\n    this.subdivisions.addElem(newElem);\n    this.elems.length = 0;\n  }\n  makeSubdivisions() {\n    const { x, y, width, height } = this.boundary;\n    const { capacity } = this;\n    const depth = this.maxdepth - 1;\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n    const nwBoundary = new BBox(x, y, halfWidth, halfHeight);\n    const neBoundary = new BBox(x + halfWidth, y, halfWidth, halfHeight);\n    const swBoundary = new BBox(x, y + halfHeight, halfWidth, halfHeight);\n    const seBoundary = new BBox(x + halfWidth, y + halfHeight, halfWidth, halfHeight);\n    return new QuadtreeSubdivisions(\n      this.child(capacity, depth, nwBoundary),\n      this.child(capacity, depth, neBoundary),\n      this.child(capacity, depth, swBoundary),\n      this.child(capacity, depth, seBoundary)\n    );\n  }\n};\nvar QuadtreeNodeNearest = class _QuadtreeNodeNearest extends QuadtreeNode {\n  addCondition(e) {\n    const { x, y } = e.hitTester.midPoint;\n    return this.boundary.containsPoint(x, y);\n  }\n  findCondition(x, y, arg) {\n    const { best } = arg;\n    return best.distanceSquared !== 0 && this.boundary.distanceSquared(x, y) < best.distanceSquared;\n  }\n  findAction(x, y, arg) {\n    const other = nearestSquared(x, y, this.elems, arg.best.distanceSquared);\n    if (other.nearest !== void 0 && other.distanceSquared < arg.best.distanceSquared) {\n      arg.best = other;\n    }\n  }\n  child(capacity, depth, boundary) {\n    return new _QuadtreeNodeNearest(capacity, depth, boundary);\n  }\n};\n\n// packages/ag-charts-community/src/chart/marker/marker.ts\nvar Marker = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.x = 0;\n    this.y = 0;\n    this.size = 12;\n  }\n  computeBBox() {\n    const { x, y, size } = this;\n    const { center } = this.constructor;\n    return new BBox(x - size * center.x, y - size * center.y, size, size);\n  }\n  computeTransformedBBox() {\n    return super.computeTransformedBBox();\n  }\n  applyPath(s, moves) {\n    const { path } = this;\n    let { x, y } = this;\n    if (this.repeat != null) {\n      x = 0;\n      y = 0;\n    }\n    path.clear();\n    for (const { x: mx, y: my, t } of moves) {\n      x += mx * s;\n      y += my * s;\n      if (t === \"move\") {\n        path.moveTo(x, y);\n      } else {\n        path.lineTo(x, y);\n      }\n    }\n    path.closePath();\n  }\n  executeFill(ctx, path) {\n    if (!path)\n      return;\n    if (this.repeat == null) {\n      return super.executeFill(ctx, path);\n    }\n    ctx.save();\n    let x = this.translationX;\n    let y = this.translationY;\n    for (const translation of this.repeat) {\n      ctx.translate(translation.x - x, translation.y - y);\n      ctx.fill(path);\n      x = translation.x;\n      y = translation.y;\n    }\n    ctx.restore();\n  }\n  executeStroke(ctx, path) {\n    if (!path)\n      return;\n    if (this.repeat == null) {\n      return super.executeStroke(ctx, path);\n    }\n    ctx.save();\n    let x = this.translationX;\n    let y = this.translationY;\n    for (const translation of this.repeat) {\n      ctx.translate(translation.x - x, translation.y - y);\n      ctx.stroke(path);\n      x = translation.x;\n      y = translation.y;\n    }\n    ctx.restore();\n  }\n};\nMarker.center = { x: 0.5, y: 0.5 };\n__decorateClass([\n  ScenePathChangeDetection()\n], Marker.prototype, \"x\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Marker.prototype, \"y\", 2);\n__decorateClass([\n  ScenePathChangeDetection({ convertor: Math.abs })\n], Marker.prototype, \"size\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Marker.prototype, \"repeat\", 2);\n\n// packages/ag-charts-community/src/chart/marker/circle.ts\nvar Circle = class extends Marker {\n  updatePath() {\n    const { x, y, path, size } = this;\n    const r = size / 2;\n    path.clear();\n    path.arc(x, y, r, 0, Math.PI * 2);\n    path.closePath();\n  }\n};\nCircle.className = \"Circle\";\n\n// packages/ag-charts-community/src/chart/marker/cross.ts\nvar _Cross = class _Cross extends Marker {\n  updatePath() {\n    const s = this.size / 4.2;\n    super.applyPath(s, _Cross.moves);\n  }\n};\n_Cross.className = \"Cross\";\n_Cross.moves = [\n  { x: -1, y: 0, t: \"move\" },\n  { x: -1, y: -1 },\n  { x: 1, y: -1 },\n  { x: 1, y: 1 },\n  { x: 1, y: -1 },\n  { x: 1, y: 1 },\n  { x: -1, y: 1 },\n  { x: 1, y: 1 },\n  { x: -1, y: 1 },\n  { x: -1, y: -1 },\n  { x: -1, y: 1 },\n  { x: -1, y: -1 }\n];\nvar Cross = _Cross;\n\n// packages/ag-charts-community/src/chart/marker/diamond.ts\nvar _Diamond = class _Diamond extends Marker {\n  updatePath() {\n    const s = this.size / 2;\n    super.applyPath(s, _Diamond.moves);\n  }\n};\n_Diamond.className = \"Diamond\";\n_Diamond.moves = [\n  { x: 0, y: -1, t: \"move\" },\n  { x: 1, y: 1 },\n  { x: -1, y: 1 },\n  { x: -1, y: -1 },\n  { x: 1, y: -1 }\n];\nvar Diamond = _Diamond;\n\n// packages/ag-charts-community/src/chart/marker/heart.ts\nvar Heart = class extends Marker {\n  rad(degree) {\n    return degree / 180 * Math.PI;\n  }\n  updatePath() {\n    const { x, path, size, rad } = this;\n    const r = size / 4;\n    const y = this.y + r / 2;\n    path.clear();\n    path.arc(x - r, y - r, r, rad(130), rad(330));\n    path.arc(x + r, y - r, r, rad(220), rad(50));\n    path.lineTo(x, y + r);\n    path.closePath();\n  }\n};\nHeart.className = \"Heart\";\n\n// packages/ag-charts-community/src/chart/marker/pin.ts\nvar Pin = class extends Marker {\n  updatePath() {\n    const { path, x, y } = this;\n    const s = this.size;\n    const cx = 0.5;\n    const cy = 1;\n    path.clear();\n    path.moveTo(x + (0.15625 - cx) * s, y + (0.34375 - cy) * s);\n    path.cubicCurveTo(\n      x + (0.15625 - cx) * s,\n      y + (0.151491 - cy) * s,\n      x + (0.307741 - cx) * s,\n      y + (0 - cy) * s,\n      x + (0.5 - cx) * s,\n      y + (0 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.692259 - cx) * s,\n      y + (0 - cy) * s,\n      x + (0.84375 - cx) * s,\n      y + (0.151491 - cy) * s,\n      x + (0.84375 - cx) * s,\n      y + (0.34375 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.84375 - cx) * s,\n      y + (0.493824 - cy) * s,\n      x + (0.784625 - cx) * s,\n      y + (0.600181 - cy) * s,\n      x + (0.716461 - cx) * s,\n      y + (0.695393 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.699009 - cx) * s,\n      y + (0.719769 - cy) * s,\n      x + (0.681271 - cx) * s,\n      y + (0.743104 - cy) * s,\n      x + (0.663785 - cx) * s,\n      y + (0.766105 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.611893 - cx) * s,\n      y + (0.834367 - cy) * s,\n      x + (0.562228 - cx) * s,\n      y + (0.899699 - cy) * s,\n      x + (0.528896 - cx) * s,\n      y + (0.980648 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.524075 - cx) * s,\n      y + (0.992358 - cy) * s,\n      x + (0.512663 - cx) * s,\n      y + (1 - cy) * s,\n      x + (0.5 - cx) * s,\n      y + (1 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.487337 - cx) * s,\n      y + (1 - cy) * s,\n      x + (0.475925 - cx) * s,\n      y + (0.992358 - cy) * s,\n      x + (0.471104 - cx) * s,\n      y + (0.980648 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.487337 - cx) * s,\n      y + (1 - cy) * s,\n      x + (0.475925 - cx) * s,\n      y + (0.992358 - cy) * s,\n      x + (0.471104 - cx) * s,\n      y + (0.980648 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.437772 - cx) * s,\n      y + (0.899699 - cy) * s,\n      x + (0.388107 - cx) * s,\n      y + (0.834367 - cy) * s,\n      x + (0.336215 - cx) * s,\n      y + (0.766105 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.318729 - cx) * s,\n      y + (0.743104 - cy) * s,\n      x + (0.300991 - cx) * s,\n      y + (0.719769 - cy) * s,\n      x + (0.283539 - cx) * s,\n      y + (0.695393 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.215375 - cx) * s,\n      y + (0.600181 - cy) * s,\n      x + (0.15625 - cx) * s,\n      y + (0.493824 - cy) * s,\n      x + (0.15625 - cx) * s,\n      y + (0.34375 - cy) * s\n    );\n    path.closePath();\n  }\n};\nPin.className = \"MapPin\";\nPin.center = { x: 0.5, y: 1 };\n\n// packages/ag-charts-community/src/chart/marker/plus.ts\nvar _Plus = class _Plus extends Marker {\n  updatePath() {\n    const s = this.size / 3;\n    super.applyPath(s, _Plus.moves);\n  }\n};\n_Plus.className = \"Plus\";\n_Plus.moves = [\n  { x: -0.5, y: -0.5, t: \"move\" },\n  { x: 0, y: -1 },\n  { x: 1, y: 0 },\n  { x: 0, y: 1 },\n  { x: 1, y: 0 },\n  { x: 0, y: 1 },\n  { x: -1, y: 0 },\n  { x: 0, y: 1 },\n  { x: -1, y: 0 },\n  { x: 0, y: -1 },\n  { x: -1, y: 0 },\n  { x: 0, y: -1 }\n];\nvar Plus = _Plus;\n\n// packages/ag-charts-community/src/chart/marker/square.ts\nvar Square = class extends Marker {\n  updatePath() {\n    const { path, x, y } = this;\n    const hs = this.size / 2;\n    path.clear();\n    path.moveTo(this.align(x - hs), this.align(y - hs));\n    path.lineTo(this.align(x + hs), this.align(y - hs));\n    path.lineTo(this.align(x + hs), this.align(y + hs));\n    path.lineTo(this.align(x - hs), this.align(y + hs));\n    path.closePath();\n  }\n};\nSquare.className = \"Square\";\n\n// packages/ag-charts-community/src/chart/marker/star.ts\nvar Star = class extends Marker {\n  updatePath() {\n    const { x, y, path, size } = this;\n    const spikes = 5;\n    const innerRadius = size / 2;\n    const rotation = Math.PI / 2;\n    path.clear();\n    for (let i = 0; i < spikes * 2; i++) {\n      const radius = i % 2 === 0 ? size : innerRadius;\n      const angle2 = i * Math.PI / spikes - rotation;\n      const xCoordinate = x + Math.cos(angle2) * radius;\n      const yCoordinate = y + Math.sin(angle2) * radius;\n      path.lineTo(xCoordinate, yCoordinate);\n    }\n    path.closePath();\n  }\n};\nStar.className = \"Star\";\n\n// packages/ag-charts-community/src/chart/marker/triangle.ts\nvar _Triangle = class _Triangle extends Marker {\n  updatePath() {\n    const s = this.size * 1.1;\n    super.applyPath(s, _Triangle.moves);\n  }\n};\n_Triangle.className = \"Triangle\";\n_Triangle.moves = [\n  { x: 0, y: -0.48, t: \"move\" },\n  { x: 0.5, y: 0.87 },\n  { x: -1, y: 0 }\n];\nvar Triangle = _Triangle;\n\n// packages/ag-charts-community/src/chart/marker/util.ts\nvar MARKER_SHAPES = {\n  circle: Circle,\n  cross: Cross,\n  diamond: Diamond,\n  heart: Heart,\n  pin: Pin,\n  plus: Plus,\n  square: Square,\n  star: Star,\n  triangle: Triangle\n};\nvar MARKER_SUPPORTED_SHAPES = Object.keys(MARKER_SHAPES);\nfunction isMarkerShape(shape) {\n  return typeof shape === \"string\" && MARKER_SUPPORTED_SHAPES.includes(shape);\n}\nfunction getMarker(shape = Square) {\n  if (isMarkerShape(shape)) {\n    return MARKER_SHAPES[shape];\n  }\n  if (typeof shape === \"function\") {\n    return shape;\n  }\n  return Square;\n}\n\n// packages/ag-charts-community/src/chart/series/dataModelSeries.ts\nvar DataModelSeries = class extends Series {\n  constructor() {\n    super(...arguments);\n    this.showFocusBox = true;\n  }\n  getScaleInformation({\n    xScale,\n    yScale\n  }) {\n    const isContinuousX = ContinuousScale.is(xScale);\n    const isContinuousY = ContinuousScale.is(yScale);\n    return { isContinuousX, isContinuousY, xScaleType: xScale?.type, yScaleType: yScale?.type };\n  }\n  getModulePropertyDefinitions() {\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    return this.moduleMap.mapModules((mod2) => mod2.getPropertyDefinitions(this.getScaleInformation({ xScale, yScale }))).flat();\n  }\n  // Request data, but with message dispatching to series-options (modules).\n  async requestDataModel(dataController, data, opts) {\n    opts.props.push(...this.getModulePropertyDefinitions());\n    const { dataModel, processedData } = await dataController.request(this.id, data ?? [], opts);\n    this.dataModel = dataModel;\n    this.processedData = processedData;\n    this.dispatch(\"data-processed\", { dataModel, processedData });\n    return { dataModel, processedData };\n  }\n  isProcessedDataAnimatable() {\n    const validationResults = this.processedData?.reduced?.animationValidation;\n    if (!validationResults) {\n      return true;\n    }\n    const { orderedKeys, uniqueKeys } = validationResults;\n    return orderedKeys && uniqueKeys;\n  }\n  checkProcessedDataAnimatable() {\n    if (!this.isProcessedDataAnimatable()) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n  }\n  pickFocus(opts) {\n    const nodeData = this.getNodeData();\n    if (nodeData === void 0 || nodeData.length === 0) {\n      return void 0;\n    }\n    const datumIndex = this.computeFocusDatumIndex(opts, nodeData);\n    if (datumIndex === void 0) {\n      return void 0;\n    }\n    const { showFocusBox } = this;\n    const datum = nodeData[datumIndex];\n    const derivedOpts = { ...opts, datumIndex };\n    const bounds = this.computeFocusBounds(derivedOpts);\n    if (bounds !== void 0) {\n      return { bounds, showFocusBox, datum, datumIndex };\n    }\n  }\n  computeFocusDatumIndex(opts, nodeData) {\n    const isDatumEnabled = (datumIndex2) => {\n      const { missing = false, enabled = true } = nodeData[datumIndex2];\n      return !missing && enabled;\n    };\n    const searchBackward = (datumIndex2) => {\n      while (datumIndex2 >= 0 && !isDatumEnabled(datumIndex2)) {\n        datumIndex2--;\n      }\n      return datumIndex2 === -1 ? void 0 : datumIndex2;\n    };\n    const searchForward = (datumIndex2) => {\n      while (datumIndex2 < nodeData.length && !isDatumEnabled(datumIndex2)) {\n        datumIndex2++;\n      }\n      return datumIndex2 === nodeData.length ? void 0 : datumIndex2;\n    };\n    let datumIndex;\n    const clampedIndex = clamp(0, opts.datumIndex, nodeData.length - 1);\n    if (opts.datumIndexDelta < 0) {\n      datumIndex = searchBackward(clampedIndex);\n    } else if (opts.datumIndexDelta > 0) {\n      datumIndex = searchForward(clampedIndex);\n    } else {\n      datumIndex ?? (datumIndex = searchForward(clampedIndex));\n      datumIndex ?? (datumIndex = searchBackward(clampedIndex));\n    }\n    if (datumIndex === void 0) {\n      if (opts.datumIndexDelta === 0) {\n        return void 0;\n      } else {\n        return opts.datumIndex - opts.datumIndexDelta;\n      }\n    } else {\n      return datumIndex;\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesProperties.ts\nvar SeriesItemHighlightStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.fill = \"rgba(255,255,255, 0.33)\";\n    this.stroke = `rgba(0, 0, 0, 0.4)`;\n    this.strokeWidth = 2;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"lineDashOffset\", 2);\nvar SeriesHighlightStyle = class extends BaseProperties {\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], SeriesHighlightStyle.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], SeriesHighlightStyle.prototype, \"dimOpacity\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], SeriesHighlightStyle.prototype, \"enabled\", 2);\nvar TextHighlightStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.color = \"black\";\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], TextHighlightStyle.prototype, \"color\", 2);\nvar HighlightStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.item = new SeriesItemHighlightStyle();\n    this.series = new SeriesHighlightStyle();\n    this.text = new TextHighlightStyle();\n  }\n};\n__decorateClass([\n  Validate(OBJECT)\n], HighlightStyle.prototype, \"item\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HighlightStyle.prototype, \"series\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HighlightStyle.prototype, \"text\", 2);\nvar SeriesProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.visible = true;\n    this.showInLegend = true;\n    this.cursor = \"default\";\n    this.nodeClickRange = \"exact\";\n    this.highlightStyle = new HighlightStyle();\n  }\n};\n__decorateClass([\n  Validate(STRING, { optional: true })\n], SeriesProperties.prototype, \"id\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesProperties.prototype, \"visible\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesProperties.prototype, \"showInLegend\", 2);\n__decorateClass([\n  Validate(STRING)\n], SeriesProperties.prototype, \"cursor\", 2);\n__decorateClass([\n  Validate(INTERACTION_RANGE)\n], SeriesProperties.prototype, \"nodeClickRange\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesProperties.prototype, \"highlightStyle\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/cartesianSeries.ts\nvar DEFAULT_CARTESIAN_DIRECTION_KEYS = {\n  [\"x\" /* X */]: [\"xKey\"],\n  [\"y\" /* Y */]: [\"yKey\"]\n};\nvar DEFAULT_CARTESIAN_DIRECTION_NAMES = {\n  [\"x\" /* X */]: [\"xName\"],\n  [\"y\" /* Y */]: [\"yName\"]\n};\nvar CartesianSeriesNodeEvent = class extends SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.xKey = series.properties.xKey;\n    this.yKey = series.properties.yKey;\n  }\n};\nvar CartesianSeriesProperties = class extends SeriesProperties {\n};\n__decorateClass([\n  Validate(STRING, { optional: true })\n], CartesianSeriesProperties.prototype, \"legendItemName\", 2);\nvar CartesianSeries = class extends DataModelSeries {\n  constructor({\n    pathsPerSeries = 1,\n    hasMarkers = false,\n    hasHighlightedLabels = false,\n    pathsZIndexSubOrderOffset = [],\n    datumSelectionGarbageCollection = true,\n    markerSelectionGarbageCollection = true,\n    animationAlwaysUpdateSelections = false,\n    animationResetFns,\n    directionKeys,\n    directionNames,\n    ...otherOpts\n  }) {\n    super({\n      directionKeys,\n      directionNames,\n      canHaveAxes: true,\n      ...otherOpts\n    });\n    this.NodeEvent = CartesianSeriesNodeEvent;\n    this.dataNodeGroup = this.contentGroup.appendChild(\n      new Group({\n        name: `${this.id}-series-dataNodes`,\n        zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n        zIndexSubOrder: this.getGroupZIndexSubOrder(\"data\")\n      })\n    );\n    this.markerGroup = this.contentGroup.appendChild(\n      new Group({\n        name: `${this.id}-series-markers`,\n        zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n        zIndexSubOrder: this.getGroupZIndexSubOrder(\"marker\")\n      })\n    );\n    this.labelGroup = this.contentGroup.appendChild(\n      new Group({\n        name: `${this.id}-series-labels`,\n        zIndex: 8 /* SERIES_LABEL_ZINDEX */,\n        zIndexSubOrder: this.getGroupZIndexSubOrder(\"labels\")\n      })\n    );\n    this.labelSelection = Selection.select(this.labelGroup, Text);\n    this.highlightSelection = Selection.select(\n      this.highlightNode,\n      () => this.opts.hasMarkers ? this.markerFactory() : this.nodeFactory()\n    );\n    this.highlightLabelSelection = Selection.select(this.highlightLabel, Text);\n    this.annotationSelections = /* @__PURE__ */ new Set();\n    this.minRectsCache = {\n      dirtyNodeData: true\n    };\n    this.debug = Debug.create();\n    if (!directionKeys || !directionNames)\n      throw new Error(`Unable to initialise series type ${this.type}`);\n    this.opts = {\n      pathsPerSeries,\n      hasMarkers,\n      hasHighlightedLabels,\n      pathsZIndexSubOrderOffset,\n      directionKeys,\n      directionNames,\n      animationResetFns,\n      animationAlwaysUpdateSelections,\n      datumSelectionGarbageCollection,\n      markerSelectionGarbageCollection\n    };\n    this.paths = [];\n    for (let index = 0; index < pathsPerSeries; index++) {\n      this.paths[index] = new Path();\n      this.paths[index].zIndex = 4 /* SERIES_LAYER_ZINDEX */;\n      this.paths[index].zIndexSubOrder = this.getGroupZIndexSubOrder(\"paths\", index);\n      this.contentGroup.appendChild(this.paths[index]);\n    }\n    this.datumSelection = Selection.select(\n      this.dataNodeGroup,\n      () => this.nodeFactory(),\n      datumSelectionGarbageCollection\n    );\n    this.markerSelection = Selection.select(\n      this.markerGroup,\n      () => this.markerFactory(),\n      markerSelectionGarbageCollection\n    );\n    this.animationState = new StateMachine(\n      \"empty\",\n      {\n        empty: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateEmptyUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\",\n          disable: \"disabled\"\n        },\n        ready: {\n          updateData: \"waiting\",\n          clear: \"clearing\",\n          highlight: (data) => this.animateReadyHighlight(data),\n          highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),\n          resize: (data) => this.animateReadyResize(data),\n          reset: \"empty\",\n          skip: \"ready\",\n          disable: \"disabled\"\n        },\n        waiting: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateWaitingUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\",\n          disable: \"disabled\"\n        },\n        disabled: {\n          update: (data) => this.resetAllAnimation(data),\n          reset: \"empty\"\n        },\n        clearing: {\n          update: {\n            target: \"empty\",\n            action: (data) => this.animateClearingUpdateEmpty(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        }\n      },\n      () => this.checkProcessedDataAnimatable()\n    );\n  }\n  get contextNodeData() {\n    return this._contextNodeData;\n  }\n  getNodeData() {\n    return this.contextNodeData?.nodeData;\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    } else if (phase === \"ready\") {\n      this.animationState.transition(\"skip\");\n    } else if (phase === \"disabled\") {\n      this.animationState.transition(\"disable\");\n    }\n  }\n  addChartEventListeners() {\n    this.destroyFns.push(\n      this.ctx.chartEventManager.addListener(\"legend-item-click\", (event) => this.onLegendItemClick(event)),\n      this.ctx.chartEventManager.addListener(\n        \"legend-item-double-click\",\n        (event) => this.onLegendItemDoubleClick(event)\n      )\n    );\n  }\n  destroy() {\n    super.destroy();\n    this._contextNodeData = void 0;\n  }\n  async update({ seriesRect }) {\n    const { visible, _contextNodeData: previousContextData } = this;\n    const series = this.ctx.highlightManager?.getActiveHighlight()?.series;\n    const seriesHighlighted = series === this;\n    const resize = this.checkResize(seriesRect);\n    const highlightItems = await this.updateHighlightSelection(seriesHighlighted);\n    await this.updateSelections(visible);\n    await this.updateNodes(highlightItems, seriesHighlighted, visible);\n    const animationData = this.getAnimationData(seriesRect, previousContextData);\n    if (!animationData)\n      return;\n    if (resize) {\n      this.animationState.transition(\"resize\", animationData);\n    }\n    this.animationState.transition(\"update\", animationData);\n  }\n  async updateSelections(anySeriesItemEnabled) {\n    var _a;\n    const animationSkipUpdate = !this.opts.animationAlwaysUpdateSelections && this.ctx.animationManager.isSkipped();\n    if (!anySeriesItemEnabled && animationSkipUpdate) {\n      return;\n    }\n    if (!this.nodeDataRefresh && !this.isPathOrSelectionDirty()) {\n      return;\n    }\n    if (this.nodeDataRefresh) {\n      this.nodeDataRefresh = false;\n      this.debug(`CartesianSeries.updateSelections() - calling createNodeData() for`, this.id);\n      this.markQuadtreeDirty();\n      this._contextNodeData = await this.createNodeData();\n      const animationValid = this.isProcessedDataAnimatable();\n      if (this._contextNodeData) {\n        (_a = this._contextNodeData).animationValid ?? (_a.animationValid = animationValid);\n      }\n      this.minRectsCache.dirtyNodeData = true;\n      const { dataModel, processedData } = this;\n      if (dataModel !== void 0 && processedData !== void 0) {\n        this.dispatch(\"data-update\", { dataModel, processedData });\n      }\n    }\n    await this.updateSeriesSelections();\n  }\n  async updateSeriesSelections(seriesHighlighted) {\n    const { datumSelection, labelSelection, markerSelection, paths } = this;\n    const contextData = this._contextNodeData;\n    if (!contextData)\n      return;\n    const { nodeData, labelData, itemId } = contextData;\n    await this.updatePaths({ seriesHighlighted, itemId, contextData, paths });\n    this.datumSelection = await this.updateDatumSelection({ nodeData, datumSelection });\n    this.labelSelection = await this.updateLabelSelection({ labelData, labelSelection });\n    if (this.opts.hasMarkers) {\n      this.markerSelection = await this.updateMarkerSelection({ nodeData, markerSelection });\n    }\n  }\n  markerFactory() {\n    const MarkerShape = getMarker();\n    return new MarkerShape();\n  }\n  getGroupZIndexSubOrder(type, subIndex = 0) {\n    const result = super.getGroupZIndexSubOrder(type, subIndex);\n    if (type === \"paths\") {\n      const [superFn] = result;\n      const pathOffset = this.opts.pathsZIndexSubOrderOffset[subIndex] ?? 0;\n      result[0] = isFunction(superFn) ? () => Number(superFn()) + pathOffset : Number(superFn) + pathOffset;\n    }\n    return result;\n  }\n  async updateNodes(highlightedItems, seriesHighlighted, anySeriesItemEnabled) {\n    const {\n      highlightSelection,\n      highlightLabelSelection,\n      opts: { hasMarkers, hasHighlightedLabels }\n    } = this;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const visible = this.visible && this._contextNodeData != null && anySeriesItemEnabled;\n    this.rootGroup.visible = animationEnabled || visible;\n    this.contentGroup.visible = animationEnabled || visible;\n    this.highlightGroup.visible = (animationEnabled || visible) && seriesHighlighted;\n    const opacity = this.getOpacity();\n    if (hasMarkers) {\n      await this.updateMarkerNodes({\n        markerSelection: highlightSelection,\n        isHighlight: true\n      });\n      this.animationState.transition(\"highlightMarkers\", highlightSelection);\n    } else {\n      await this.updateDatumNodes({\n        datumSelection: highlightSelection,\n        isHighlight: true\n      });\n      this.animationState.transition(\"highlight\", highlightSelection);\n    }\n    if (hasHighlightedLabels) {\n      await this.updateLabelNodes({ labelSelection: highlightLabelSelection });\n    }\n    const { dataNodeGroup, markerGroup, datumSelection, labelSelection, markerSelection, paths, labelGroup } = this;\n    const { itemId } = this.contextNodeData ?? {};\n    dataNodeGroup.opacity = opacity;\n    dataNodeGroup.visible = animationEnabled || visible;\n    labelGroup.visible = visible;\n    if (hasMarkers) {\n      markerGroup.opacity = opacity;\n      markerGroup.zIndex = dataNodeGroup.zIndex >= 4 /* SERIES_LAYER_ZINDEX */ ? dataNodeGroup.zIndex : dataNodeGroup.zIndex + 1;\n      markerGroup.visible = visible;\n    }\n    if (labelGroup) {\n      labelGroup.opacity = opacity;\n    }\n    await this.updatePathNodes({\n      seriesHighlighted,\n      itemId,\n      paths,\n      opacity,\n      visible,\n      animationEnabled\n    });\n    if (!dataNodeGroup.visible) {\n      return;\n    }\n    await this.updateDatumNodes({ datumSelection, highlightedItems, isHighlight: false });\n    await this.updateLabelNodes({ labelSelection });\n    if (hasMarkers) {\n      await this.updateMarkerNodes({ markerSelection, isHighlight: false });\n    }\n  }\n  getHighlightLabelData(labelData, highlightedItem) {\n    const labelItems = labelData.filter(\n      (ld) => ld.datum === highlightedItem.datum && ld.itemId === highlightedItem.itemId\n    );\n    return labelItems.length === 0 ? void 0 : labelItems;\n  }\n  getHighlightData(_nodeData, highlightedItem) {\n    return highlightedItem ? [highlightedItem] : void 0;\n  }\n  async updateHighlightSelection(seriesHighlighted) {\n    const { highlightSelection, highlightLabelSelection, _contextNodeData: contextNodeData } = this;\n    if (!contextNodeData)\n      return;\n    const highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();\n    const item = seriesHighlighted && highlightedDatum?.datum ? highlightedDatum : void 0;\n    let labelItems;\n    let highlightItems;\n    if (item != null) {\n      const labelsEnabled = this.isLabelEnabled();\n      const { labelData, nodeData } = contextNodeData;\n      highlightItems = this.getHighlightData(nodeData, item);\n      labelItems = labelsEnabled ? this.getHighlightLabelData(labelData, item) : void 0;\n    }\n    this.highlightSelection = await this.updateHighlightSelectionItem({\n      items: highlightItems,\n      highlightSelection\n    });\n    this.highlightLabelSelection = await this.updateHighlightSelectionLabel({\n      items: labelItems,\n      highlightLabelSelection\n    });\n    return highlightItems;\n  }\n  markQuadtreeDirty() {\n    this.quadtree = void 0;\n  }\n  *datumNodesIter() {\n    for (const { node } of this.datumSelection) {\n      if (node.datum.missing === true)\n        continue;\n      yield node;\n    }\n  }\n  getQuadTree() {\n    if (this.quadtree === void 0) {\n      const { width, height } = this.ctx.scene.canvas;\n      const canvasRect = new BBox(0, 0, width, height);\n      this.quadtree = new QuadtreeNearest(100, 10, canvasRect);\n      this.initQuadTree(this.quadtree);\n    }\n    return this.quadtree;\n  }\n  initQuadTree(_quadtree) {\n  }\n  pickNodeExactShape(point) {\n    const result = super.pickNodeExactShape(point);\n    if (result) {\n      return result;\n    }\n    const { x, y } = point;\n    const {\n      opts: { hasMarkers }\n    } = this;\n    let match;\n    const { dataNodeGroup, markerGroup } = this;\n    match = dataNodeGroup.pickNode(x, y);\n    if (!match && hasMarkers) {\n      match = markerGroup?.pickNode(x, y);\n    }\n    if (match && match.datum.missing !== true) {\n      return { datum: match.datum, distance: 0 };\n    }\n    for (const mod2 of this.moduleMap.modules()) {\n      const { datum } = mod2.pickNodeExact(point) ?? {};\n      if (datum == null)\n        continue;\n      if (datum?.missing === true)\n        continue;\n      return { datum, distance: 0 };\n    }\n  }\n  pickNodeClosestDatum(point) {\n    const { x, y } = point;\n    const { axes, rootGroup, _contextNodeData: contextNodeData } = this;\n    if (!contextNodeData)\n      return;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    const hitPoint = rootGroup.transformPoint(x, y);\n    let minDistance = Infinity;\n    let closestDatum;\n    for (const datum of contextNodeData.nodeData) {\n      const { point: { x: datumX = NaN, y: datumY = NaN } = {} } = datum;\n      if (isNaN(datumX) || isNaN(datumY)) {\n        continue;\n      }\n      const isInRange = xAxis?.inRange(datumX) && yAxis?.inRange(datumY);\n      if (!isInRange) {\n        continue;\n      }\n      const distance3 = Math.max((hitPoint.x - datumX) ** 2 + (hitPoint.y - datumY) ** 2, 0);\n      if (distance3 < minDistance) {\n        minDistance = distance3;\n        closestDatum = datum;\n      }\n    }\n    for (const mod2 of this.moduleMap.modules()) {\n      const modPick = mod2.pickNodeNearest(point);\n      if (modPick !== void 0 && modPick.distanceSquared < minDistance) {\n        minDistance = modPick.distanceSquared;\n        closestDatum = modPick.datum;\n        break;\n      }\n    }\n    if (closestDatum) {\n      const distance3 = Math.max(Math.sqrt(minDistance) - (closestDatum.point?.size ?? 0), 0);\n      return { datum: closestDatum, distance: distance3 };\n    }\n  }\n  pickNodeMainAxisFirst(point, requireCategoryAxis) {\n    const { x, y } = point;\n    const { axes, rootGroup, _contextNodeData: contextNodeData } = this;\n    if (!contextNodeData)\n      return;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    const directions2 = [xAxis, yAxis].filter((a) => a instanceof CategoryAxis).map((a) => a.direction);\n    if (requireCategoryAxis && directions2.length === 0) {\n      return;\n    }\n    const [primaryDirection = \"x\" /* X */] = directions2;\n    const hitPoint = rootGroup.transformPoint(x, y);\n    const hitPointCoords = primaryDirection === \"x\" /* X */ ? [hitPoint.x, hitPoint.y] : [hitPoint.y, hitPoint.x];\n    const minDistance = [Infinity, Infinity];\n    let closestDatum;\n    for (const datum of contextNodeData.nodeData) {\n      const { x: datumX = NaN, y: datumY = NaN } = datum.point ?? datum.midPoint ?? {};\n      if (isNaN(datumX) || isNaN(datumY) || datum.missing === true) {\n        continue;\n      }\n      const isInRange = xAxis?.inRange(datumX) && yAxis?.inRange(datumY);\n      if (!isInRange) {\n        continue;\n      }\n      const datumPoint = primaryDirection === \"x\" /* X */ ? [datumX, datumY] : [datumY, datumX];\n      let newMinDistance = true;\n      for (let i = 0; i < datumPoint.length; i++) {\n        const dist = Math.abs(datumPoint[i] - hitPointCoords[i]);\n        if (dist > minDistance[i]) {\n          newMinDistance = false;\n          break;\n        }\n        if (dist < minDistance[i]) {\n          minDistance[i] = dist;\n          minDistance.fill(Infinity, i + 1, minDistance.length);\n        }\n      }\n      if (newMinDistance) {\n        closestDatum = datum;\n      }\n    }\n    if (closestDatum) {\n      let closestDistanceSquared = Math.max(\n        minDistance[0] ** 2 + minDistance[1] ** 2 - (closestDatum.point?.size ?? 0),\n        0\n      );\n      for (const mod2 of this.moduleMap.modules()) {\n        const modPick = mod2.pickNodeMainAxisFirst(point);\n        if (modPick !== void 0 && modPick.distanceSquared < closestDistanceSquared) {\n          closestDatum = modPick.datum;\n          closestDistanceSquared = modPick.distanceSquared;\n          break;\n        }\n      }\n      return { datum: closestDatum, distance: Math.sqrt(closestDistanceSquared) };\n    }\n  }\n  onLegendItemClick(event) {\n    const { legendItemName } = this.properties;\n    const { enabled, itemId, series } = event;\n    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;\n    if (series.id === this.id || matchedLegendItemName) {\n      this.toggleSeriesItem(itemId, enabled);\n    }\n  }\n  onLegendItemDoubleClick(event) {\n    const { enabled, itemId, series, numVisibleItems } = event;\n    const { legendItemName } = this.properties;\n    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;\n    if (series.id === this.id || matchedLegendItemName) {\n      this.toggleSeriesItem(itemId, true);\n    } else if (enabled && numVisibleItems === 1) {\n      this.toggleSeriesItem(itemId, true);\n    } else {\n      this.toggleSeriesItem(itemId, false);\n    }\n  }\n  isPathOrSelectionDirty() {\n    return false;\n  }\n  getLabelData() {\n    return [];\n  }\n  shouldFlipXY() {\n    return false;\n  }\n  /**\n   * Get the minimum bounding box that contains any adjacent two nodes. The axes are treated independently, so this\n   * may not represent the same two points for both directions. The dimensions represent the greatest distance\n   * between any two adjacent nodes.\n   */\n  getMinRects(width, height) {\n    const { dirtyNodeData, sizeCache, minRect, minVisibleRect } = this.minRectsCache;\n    const newSizeCache = JSON.stringify({ width, height });\n    const dirtySize = newSizeCache !== sizeCache;\n    if (!dirtySize && !dirtyNodeData && minRect && minVisibleRect) {\n      return { minRect, minVisibleRect };\n    }\n    const rects = this.computeMinRects(width, height);\n    this.minRectsCache = {\n      dirtyNodeData: false,\n      sizeCache: newSizeCache,\n      minRect: rects?.minRect,\n      minVisibleRect: rects?.minVisibleRect\n    };\n    return rects;\n  }\n  computeMinRects(width, height) {\n    const context = this._contextNodeData;\n    if (!context?.nodeData.length) {\n      return;\n    }\n    const { nodeData } = context;\n    const minRectXs = Array(nodeData.length);\n    const minRectYs = Array(nodeData.length);\n    for (const [i, { midPoint }] of nodeData.entries()) {\n      minRectXs[i] = midPoint?.x ?? 0;\n      minRectYs[i] = midPoint?.y ?? 0;\n    }\n    minRectXs.sort((a, b) => a - b);\n    minRectYs.sort((a, b) => a - b);\n    let zeroX, widthX, zeroY, heightY;\n    let maxWidth = 0;\n    let maxHeight = 0;\n    for (let i = 1; i < nodeData.length; i++) {\n      if (minRectXs[i] >= 0)\n        zeroX ?? (zeroX = i);\n      if (minRectXs[i] > width)\n        widthX ?? (widthX = i);\n      if (minRectYs[i] >= 0)\n        zeroY ?? (zeroY = i);\n      if (minRectYs[i] > height)\n        heightY ?? (heightY = i);\n      maxWidth = Math.max(maxWidth, minRectXs[i] - minRectXs[i - 1]);\n      maxHeight = Math.max(maxHeight, minRectYs[i] - minRectYs[i - 1]);\n    }\n    widthX ?? (widthX = nodeData.length);\n    heightY ?? (heightY = nodeData.length);\n    const minVisibleRectXs = zeroX != null && widthX != null ? minRectXs.slice(zeroX, widthX) : [];\n    const minVisibleRectYs = zeroY != null && heightY != null ? minRectYs.slice(zeroY, heightY) : [];\n    let maxVisibleWidth = 0;\n    let maxVisibleHeight = 0;\n    for (let i = 1; i < Math.max(minVisibleRectXs.length, minVisibleRectYs.length); i++) {\n      const x1 = minVisibleRectXs[i];\n      const x2 = minVisibleRectXs[i - 1];\n      const y1 = minVisibleRectYs[i];\n      const y2 = minVisibleRectYs[i - 1];\n      if (x1 != null && x2 != null) {\n        maxVisibleWidth = Math.max(maxVisibleWidth, x1 - x2);\n      }\n      if (y1 != null && y2 != null) {\n        maxVisibleHeight = Math.max(maxVisibleHeight, y1 - y2);\n      }\n    }\n    const minRect = new BBox(0, 0, maxWidth, maxHeight);\n    const minVisibleRect = new BBox(0, 0, maxVisibleWidth, maxVisibleHeight);\n    return { minRect, minVisibleRect };\n  }\n  updateHighlightSelectionItem(opts) {\n    const {\n      opts: { hasMarkers }\n    } = this;\n    const { items, highlightSelection } = opts;\n    const nodeData = items ?? [];\n    if (hasMarkers) {\n      const markerSelection = highlightSelection;\n      return this.updateMarkerSelection({ nodeData, markerSelection });\n    } else {\n      return this.updateDatumSelection({\n        nodeData,\n        datumSelection: highlightSelection\n      });\n    }\n  }\n  updateHighlightSelectionLabel(opts) {\n    return this.updateLabelSelection({\n      labelData: opts.items ?? [],\n      labelSelection: opts.highlightLabelSelection\n    });\n  }\n  async updateDatumSelection(opts) {\n    return opts.datumSelection;\n  }\n  async updateDatumNodes(_opts) {\n  }\n  async updateMarkerSelection(opts) {\n    return opts.markerSelection;\n  }\n  async updateMarkerNodes(_opts) {\n  }\n  async updatePaths(opts) {\n    opts.paths.forEach((p) => p.visible = false);\n  }\n  async updatePathNodes(opts) {\n    const { paths, opacity, visible } = opts;\n    for (const path of paths) {\n      path.opacity = opacity;\n      path.visible = visible;\n    }\n  }\n  resetAllAnimation(data) {\n    const { path, datum, label, marker } = this.opts?.animationResetFns ?? {};\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    if (path) {\n      data.paths.forEach((paths) => {\n        resetMotion([paths], path);\n      });\n    }\n    if (datum) {\n      resetMotion([data.datumSelection], datum);\n    }\n    if (label) {\n      resetMotion([data.labelSelection], label);\n    }\n    if (marker && this.opts.hasMarkers) {\n      resetMotion([data.markerSelection], marker);\n    }\n    if (data.contextData?.animationValid === false) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n  }\n  animateEmptyUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateWaitingUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateReadyHighlight(data) {\n    const { datum } = this.opts?.animationResetFns ?? {};\n    if (datum) {\n      resetMotion([data], datum);\n    }\n  }\n  animateReadyHighlightMarkers(data) {\n    const { marker } = this.opts?.animationResetFns ?? {};\n    if (marker) {\n      resetMotion([data], marker);\n    }\n  }\n  animateReadyResize(data) {\n    this.resetAllAnimation(data);\n  }\n  animateClearingUpdateEmpty(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animationTransitionClear() {\n    const animationData = this.getAnimationData();\n    if (!animationData)\n      return;\n    this.animationState.transition(\"clear\", animationData);\n  }\n  getAnimationData(seriesRect, previousContextData) {\n    const { _contextNodeData: contextData } = this;\n    if (!contextData)\n      return;\n    const animationData = {\n      datumSelection: this.datumSelection,\n      markerSelection: this.markerSelection,\n      labelSelection: this.labelSelection,\n      annotationSelections: [...this.annotationSelections],\n      contextData,\n      previousContextData,\n      paths: this.paths,\n      seriesRect\n    };\n    return animationData;\n  }\n  calculateScaling() {\n    const result = {};\n    for (const direction of Object.values(ChartAxisDirection)) {\n      const axis = this.axes[direction];\n      if (!axis)\n        continue;\n      if (axis.scale instanceof LogScale) {\n        const { range: range3, domain } = axis.scale;\n        result[direction] = {\n          type: \"log\",\n          convert: (d) => axis.scale.convert(d),\n          domain: [domain[0], domain[1]],\n          range: [range3[0], range3[1]]\n        };\n      } else if (axis.scale instanceof ContinuousScale) {\n        const { range: range3 } = axis.scale;\n        const domain = axis.scale.getDomain();\n        result[direction] = {\n          type: \"continuous\",\n          domain: [domain[0], domain[1]],\n          range: [range3[0], range3[1]]\n        };\n      } else if (axis.scale) {\n        const { domain } = axis.scale;\n        result[direction] = {\n          type: \"category\",\n          domain,\n          range: domain.map((d) => axis.scale.convert(d))\n        };\n      }\n    }\n    return result;\n  }\n};\n\n// packages/ag-charts-community/src/chart/cartesianChart.ts\nvar directions = [\"top\", \"right\", \"bottom\", \"left\"];\nvar CartesianChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n    /** Integrated Charts feature state - not used in Standalone Charts. */\n    this.paired = true;\n    this.firstSeriesTranslation = true;\n    this._lastCrossLineIds = void 0;\n    this._lastAxisAreaWidths = /* @__PURE__ */ new Map();\n    this._lastClipSeries = false;\n    this._lastVisibility = {\n      crossLines: true,\n      series: true\n    };\n  }\n  onAxisChange(newValue, oldValue) {\n    super.onAxisChange(newValue, oldValue);\n    this.zoomManager.updateAxes(newValue);\n  }\n  destroySeries(series) {\n    super.destroySeries(series);\n    this.firstSeriesTranslation = true;\n  }\n  async performLayout() {\n    const shrinkRect = await super.performLayout();\n    const { firstSeriesTranslation, seriesRoot, annotationRoot, highlightRoot } = this;\n    const { animationRect, seriesRect, visibility, clipSeries } = this.updateAxes(shrinkRect);\n    this.seriesRoot.visible = visibility.series;\n    this.seriesRect = seriesRect;\n    this.animationRect = animationRect;\n    const { x, y } = seriesRect;\n    if (firstSeriesTranslation) {\n      for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n        group.translationX = Math.floor(x);\n        group.translationY = Math.floor(y);\n      }\n      this.firstSeriesTranslation = false;\n    } else {\n      const { translationX, translationY } = seriesRoot;\n      staticFromToMotion(\n        this.id,\n        \"seriesRect\",\n        this.ctx.animationManager,\n        [seriesRoot, highlightRoot, annotationRoot],\n        { translationX, translationY },\n        { translationX: Math.floor(x), translationY: Math.floor(y) },\n        { phase: \"update\" }\n      );\n    }\n    const seriesPaddedRect = seriesRect.clone().grow(this.seriesArea.padding);\n    this.hoverRect = seriesPaddedRect;\n    const clipRect = this.seriesArea.clip || clipSeries ? seriesPaddedRect : void 0;\n    seriesRoot.setClipRectInGroupCoordinateSpace(clipRect);\n    highlightRoot.setClipRectInGroupCoordinateSpace(clipRect);\n    annotationRoot.setClipRectInGroupCoordinateSpace(clipRect);\n    this.ctx.layoutService.dispatchLayoutComplete({\n      type: \"layout-complete\",\n      chart: { width: this.ctx.scene.width, height: this.ctx.scene.height },\n      clipSeries,\n      series: {\n        rect: seriesRect,\n        paddedRect: seriesPaddedRect,\n        visible: visibility.series,\n        shouldFlipXY: this.shouldFlipXY()\n      },\n      axes: this.axes.map((axis) => ({ id: axis.id, ...axis.getLayoutState() }))\n    });\n    const modulePromises = this.modulesManager.mapModules((m) => m.performCartesianLayout?.({ seriesRect }));\n    await Promise.all(modulePromises);\n    return shrinkRect;\n  }\n  updateAxes(inputShrinkRect) {\n    const crossLineIds = this.axes.flatMap((axis) => axis.crossLines ?? []).map((crossLine) => crossLine.id);\n    const axesValid = this._lastCrossLineIds != null && this._lastCrossLineIds.length === crossLineIds.length && this._lastCrossLineIds.every((id, index) => crossLineIds[index] === id);\n    let axisAreaWidths;\n    let clipSeries;\n    let visibility;\n    if (axesValid) {\n      axisAreaWidths = new Map(this._lastAxisAreaWidths.entries());\n      clipSeries = this._lastClipSeries;\n      visibility = { ...this._lastVisibility };\n    } else {\n      axisAreaWidths = /* @__PURE__ */ new Map();\n      clipSeries = false;\n      visibility = { crossLines: true, series: true };\n      this._lastCrossLineIds = crossLineIds;\n    }\n    const liveAxisWidths = new Set(this.axes.map((a) => a.position));\n    for (const position of axisAreaWidths.keys()) {\n      if (!liveAxisWidths.has(position)) {\n        axisAreaWidths.delete(position);\n      }\n    }\n    const stableOutputs = (otherAxisWidths, otherClipSeries, otherVisibility) => {\n      if ([...otherAxisWidths.keys()].some((k) => !axisAreaWidths.has(k))) {\n        return false;\n      }\n      if (visibility.crossLines !== otherVisibility.crossLines || visibility.series !== otherVisibility.series || clipSeries !== otherClipSeries) {\n        return false;\n      }\n      return [...axisAreaWidths.entries()].every(([p, w]) => {\n        const otherW = otherAxisWidths.get(p);\n        if (w != null || otherW != null) {\n          return w === otherW;\n        }\n        return true;\n      });\n    };\n    const ceilValues = (map) => {\n      for (const [key, value] of map.entries()) {\n        if (value && Math.abs(value) === Infinity) {\n          map.set(key, 0);\n          continue;\n        }\n        map.set(key, value != null ? Math.ceil(value) : value);\n      }\n      return map;\n    };\n    let lastPassAxisAreaWidths = /* @__PURE__ */ new Map();\n    let lastPassVisibility = {};\n    let lastPassClipSeries = false;\n    let seriesRect = this.seriesRect?.clone();\n    let count = 0;\n    let primaryTickCounts = {};\n    do {\n      axisAreaWidths = new Map(lastPassAxisAreaWidths.entries());\n      clipSeries = lastPassClipSeries;\n      Object.assign(visibility, lastPassVisibility);\n      const result = this.updateAxesPass(axisAreaWidths, inputShrinkRect.clone(), seriesRect);\n      lastPassAxisAreaWidths = ceilValues(result.axisAreaWidths);\n      lastPassVisibility = result.visibility;\n      lastPassClipSeries = result.clipSeries;\n      ({ seriesRect, primaryTickCounts } = result);\n      if (count++ > 10) {\n        Logger.warn(\"unable to find stable axis layout.\");\n        break;\n      }\n    } while (!stableOutputs(lastPassAxisAreaWidths, lastPassClipSeries, lastPassVisibility));\n    this.axes.forEach((axis) => {\n      axis.update(primaryTickCounts[axis.direction]);\n    });\n    const clipRectPadding = 5;\n    this.axes.forEach((axis) => {\n      axis.setCrossLinesVisible(visibility.crossLines);\n      if (!seriesRect) {\n        return;\n      }\n      axis.clipGrid(\n        seriesRect.x,\n        seriesRect.y,\n        seriesRect.width + clipRectPadding,\n        seriesRect.height + clipRectPadding\n      );\n      switch (axis.position) {\n        case \"left\":\n        case \"right\":\n          axis.clipTickLines(\n            inputShrinkRect.x,\n            seriesRect.y,\n            inputShrinkRect.width + clipRectPadding,\n            seriesRect.height + clipRectPadding\n          );\n          break;\n        case \"top\":\n        case \"bottom\":\n          axis.clipTickLines(\n            seriesRect.x,\n            inputShrinkRect.y,\n            seriesRect.width + clipRectPadding,\n            inputShrinkRect.height + clipRectPadding\n          );\n          break;\n      }\n    });\n    this._lastAxisAreaWidths = axisAreaWidths;\n    this._lastVisibility = visibility;\n    this._lastClipSeries = clipSeries;\n    return { seriesRect, animationRect: inputShrinkRect, visibility, clipSeries };\n  }\n  updateAxesPass(axisAreaWidths, bounds, lastPassSeriesRect) {\n    const axisWidths = /* @__PURE__ */ new Map();\n    const axisGroups = /* @__PURE__ */ new Map();\n    const visibility = {\n      series: true,\n      crossLines: true\n    };\n    let clipSeries = false;\n    const primaryTickCounts = {};\n    const paddedBounds = this.applySeriesPadding(bounds);\n    const crossLinePadding = lastPassSeriesRect ? this.buildCrossLinePadding(axisAreaWidths) : {};\n    const axisAreaBound = this.buildAxisBound(paddedBounds, axisAreaWidths, crossLinePadding, visibility);\n    const seriesRect = this.buildSeriesRect(axisAreaBound, axisAreaWidths);\n    for (const axis of this.axes) {\n      const { position = \"left\" } = axis;\n      const { clipSeries: newClipSeries, axisThickness } = this.calculateAxisDimensions({\n        axis,\n        seriesRect,\n        paddedBounds,\n        primaryTickCounts,\n        clipSeries\n      });\n      axisWidths.set(axis.id, axisThickness);\n      if (!axisGroups.has(position))\n        axisGroups.set(position, []);\n      axisGroups.get(position)?.push(axis);\n      clipSeries = clipSeries || newClipSeries;\n    }\n    const newAxisAreaWidths = /* @__PURE__ */ new Map();\n    const axisOffsets = /* @__PURE__ */ new Map();\n    for (const [position, axes] of axisGroups.entries()) {\n      newAxisAreaWidths.set(position, this.calculateAxisArea(axes, axisWidths, axisOffsets));\n    }\n    for (const [position, axes] of axisGroups.entries()) {\n      this.positionAxes({\n        axes,\n        position,\n        axisWidths,\n        axisOffsets,\n        axisAreaWidths: newAxisAreaWidths,\n        axisBound: axisAreaBound,\n        seriesRect\n      });\n    }\n    return { clipSeries, seriesRect, axisAreaWidths: newAxisAreaWidths, visibility, primaryTickCounts };\n  }\n  buildCrossLinePadding(axisAreaSize) {\n    const crossLinePadding = {};\n    this.axes.forEach((axis) => {\n      axis.crossLines?.forEach((crossLine) => {\n        crossLine.calculatePadding?.(crossLinePadding);\n      });\n    });\n    for (const [side, padding = 0] of Object.entries(crossLinePadding)) {\n      crossLinePadding[side] = Math.max(padding - (axisAreaSize.get(side) ?? 0), 0);\n    }\n    return crossLinePadding;\n  }\n  applySeriesPadding(bounds) {\n    const paddedRect = bounds.clone();\n    const reversedAxes = this.axes.slice().reverse();\n    directions.forEach((dir) => {\n      const padding = this.seriesArea.padding[dir];\n      const axis = reversedAxes.find((a) => a.position === dir);\n      if (axis) {\n        axis.seriesAreaPadding = padding;\n      } else {\n        paddedRect.shrink(padding, dir);\n      }\n    });\n    return paddedRect;\n  }\n  buildAxisBound(bounds, axisAreaWidths, crossLinePadding, visibility) {\n    const result = bounds.clone();\n    const { top = 0, right = 0, bottom = 0, left = 0 } = crossLinePadding;\n    const horizontalPadding = left + right;\n    const verticalPadding = top + bottom;\n    const totalWidth = (axisAreaWidths.get(\"left\") ?? 0) + (axisAreaWidths.get(\"right\") ?? 0) + horizontalPadding;\n    const totalHeight = (axisAreaWidths.get(\"top\") ?? 0) + (axisAreaWidths.get(\"bottom\") ?? 0) + verticalPadding;\n    if (result.width <= totalWidth || result.height <= totalHeight) {\n      visibility.crossLines = false;\n      visibility.series = false;\n      return result;\n    }\n    result.x += left;\n    result.y += top;\n    result.width -= horizontalPadding;\n    result.height -= verticalPadding;\n    return result;\n  }\n  buildSeriesRect(axisBound, axisAreaWidths) {\n    const result = axisBound.clone();\n    result.x += axisAreaWidths.get(\"left\") ?? 0;\n    result.y += axisAreaWidths.get(\"top\") ?? 0;\n    result.width -= (axisAreaWidths.get(\"left\") ?? 0) + (axisAreaWidths.get(\"right\") ?? 0);\n    result.height -= (axisAreaWidths.get(\"top\") ?? 0) + (axisAreaWidths.get(\"bottom\") ?? 0);\n    result.width = Math.max(0, result.width);\n    result.height = Math.max(0, result.height);\n    return result;\n  }\n  clampToOutsideSeriesRect(seriesRect, value, dimension, direction) {\n    const { x, y, width, height } = seriesRect;\n    const clampBounds = [x, y, x + width, y + height];\n    const compareTo = clampBounds[(dimension === \"x\" ? 0 : 1) + (direction === 1 ? 0 : 2)];\n    const clampFn = direction === 1 ? Math.min : Math.max;\n    return clampFn(value, compareTo);\n  }\n  calculateAxisDimensions(opts) {\n    const { axis, seriesRect, paddedBounds, primaryTickCounts } = opts;\n    let { clipSeries } = opts;\n    const { position = \"left\", direction } = axis;\n    this.sizeAxis(axis, seriesRect, position);\n    let primaryTickCount = axis.nice ? primaryTickCounts[direction] : void 0;\n    const isVertical = direction === \"y\" /* Y */;\n    const paddedBoundsCoefficient = 0.3;\n    if (axis.thickness) {\n      axis.maxThickness = axis.thickness;\n    } else {\n      axis.maxThickness = (isVertical ? paddedBounds.width : paddedBounds.height) * paddedBoundsCoefficient;\n    }\n    const layout = axis.calculateLayout(primaryTickCount);\n    primaryTickCount = layout.primaryTickCount;\n    primaryTickCounts[direction] ?? (primaryTickCounts[direction] = primaryTickCount);\n    clipSeries || (clipSeries = axis.dataDomain.clipped || axis.visibleRange[0] > 0 || axis.visibleRange[1] < 1);\n    let axisThickness;\n    if (axis.thickness != null && axis.thickness > 0) {\n      axisThickness = axis.thickness;\n    } else {\n      axisThickness = isVertical ? layout.bbox.width : layout.bbox.height;\n    }\n    axisThickness = Math.ceil(axisThickness);\n    return { clipSeries, axisThickness, primaryTickCount };\n  }\n  sizeAxis(axis, seriesRect, position) {\n    const isCategory = axis instanceof CategoryAxis || axis instanceof GroupedCategoryAxis;\n    const isLeftRight = position === \"left\" || position === \"right\";\n    let { min = 0, max = 1 } = axis.disableZoom ? {} : this.ctx.zoomManager.getAxisZoom(axis.id);\n    const { width, height } = seriesRect;\n    const minStart = 0;\n    const maxEnd = isLeftRight ? height : width;\n    let start = minStart;\n    let end = maxEnd;\n    const { width: axisWidth, unit, align } = axis.layoutConstraints;\n    if (unit === \"px\") {\n      end = start + axisWidth;\n    } else {\n      end = end * axisWidth / 100;\n    }\n    if (align === \"end\") {\n      start = maxEnd - (end - start);\n      end = maxEnd;\n    }\n    if (isCategory && isLeftRight) {\n      [min, max] = [1 - max, 1 - min];\n    } else if (isLeftRight) {\n      [start, end] = [end, start];\n    }\n    axis.range = [start, end];\n    axis.visibleRange = [min, max];\n    axis.gridLength = isLeftRight ? width : height;\n  }\n  calculateAxisArea(axes, axisWidths, axisOffsets) {\n    let totalAxisWidth = 0;\n    let currentOffset = 0;\n    for (const axis of axes) {\n      axisOffsets.set(axis.id, currentOffset);\n      const axisThickness = axisWidths.get(axis.id) ?? 0;\n      totalAxisWidth = Math.max(totalAxisWidth, currentOffset + axisThickness);\n      if (axis.layoutConstraints.stacked) {\n        currentOffset += axisThickness + 15;\n      }\n    }\n    return totalAxisWidth;\n  }\n  positionAxes(opts) {\n    const { axes, axisBound, axisWidths, axisOffsets, axisAreaWidths, seriesRect, position } = opts;\n    const axisAreaWidth = axisAreaWidths.get(position) ?? 0;\n    let mainDimension = \"x\";\n    let minorDimension = \"y\";\n    let direction = 1;\n    let axisBoundMainOffset = 0;\n    if (position === \"top\" || position === \"bottom\") {\n      mainDimension = \"y\";\n      minorDimension = \"x\";\n      axisBoundMainOffset += 1;\n    }\n    axisBoundMainOffset += axisBound[mainDimension];\n    if (position === \"right\" || position === \"bottom\") {\n      direction = -1;\n      axisBoundMainOffset += mainDimension === \"x\" ? axisBound.width : axisBound.height;\n    }\n    for (const axis of axes) {\n      const minorOffset = axisAreaWidths.get(minorDimension === \"x\" ? \"left\" : \"top\") ?? 0;\n      axis.translation[minorDimension] = axisBound[minorDimension] + minorOffset;\n      const axisThickness = axisWidths.get(axis.id) ?? 0;\n      const axisOffset = axisOffsets.get(axis.id) ?? 0;\n      axis.translation[mainDimension] = this.clampToOutsideSeriesRect(\n        seriesRect,\n        axisBoundMainOffset + direction * (axisOffset + axisThickness),\n        mainDimension,\n        direction\n      );\n      axis.gridPadding = axisAreaWidth - axisOffset - axisThickness;\n      axis.updatePosition();\n    }\n  }\n  shouldFlipXY() {\n    return !this.series.some((series) => !(series instanceof CartesianSeries && series.shouldFlipXY()));\n  }\n};\nCartesianChart.className = \"CartesianChart\";\nCartesianChart.type = \"cartesian\";\n\n// packages/ag-charts-community/src/chart/chartProxy.ts\nvar _AgChartInstanceProxy = class _AgChartInstanceProxy {\n  constructor(chart, factoryApi) {\n    this.factoryApi = factoryApi;\n    this.chart = chart;\n  }\n  static isInstance(x) {\n    if (x instanceof _AgChartInstanceProxy) {\n      return true;\n    }\n    if (x.constructor?.name === \"AgChartInstanceProxy\" && x.chart != null) {\n      return true;\n    }\n    return x.chart != null && this.validateImplementation(x);\n  }\n  static validateImplementation(x) {\n    const chartProps = [\"getOptions\", \"destroy\"];\n    const signatureProps = Object.keys(Object.getPrototypeOf(x) ?? {});\n    return chartProps.every((prop) => signatureProps.includes(prop));\n  }\n  async update(options) {\n    this.factoryApi.createOrUpdate(options, this);\n    await this.chart.waitForUpdate();\n  }\n  async updateDelta(deltaOptions) {\n    this.factoryApi.updateUserDelta(this, deltaOptions);\n    await this.chart.waitForUpdate();\n  }\n  getOptions() {\n    const options = deepClone(this.chart.getOptions());\n    for (const key in options) {\n      if (key.startsWith(\"_\")) {\n        delete options[key];\n      }\n    }\n    return options;\n  }\n  waitForUpdate() {\n    return this.chart.waitForUpdate();\n  }\n  async download(opts) {\n    const clone = await this.prepareResizedChart(this, opts);\n    try {\n      clone.chart.download(opts?.fileName, opts?.fileFormat);\n    } finally {\n      clone.destroy();\n    }\n  }\n  async getImageDataURL(opts) {\n    const clone = await this.prepareResizedChart(this, opts);\n    try {\n      return clone.chart.getCanvasDataURL(opts?.fileFormat);\n    } finally {\n      clone.destroy();\n    }\n  }\n  getState() {\n    return this.factoryApi.caretaker.save(this.chart.ctx.annotationManager);\n  }\n  async setState(state) {\n    this.factoryApi.caretaker.restore(state, this.chart.ctx.annotationManager);\n    await this.chart.waitForUpdate();\n  }\n  resetAnimations() {\n    this.chart.resetAnimations();\n  }\n  skipAnimations() {\n    this.chart.skipAnimations();\n  }\n  destroy() {\n    this.chart.destroy();\n  }\n  async prepareResizedChart({ chart }, opts = {}) {\n    const width = opts.width ?? chart.width ?? chart.ctx.scene.canvas.width;\n    const height = opts.height ?? chart.height ?? chart.ctx.scene.canvas.height;\n    const options = mergeDefaults(\n      {\n        container: document.createElement(\"div\"),\n        overrideDevicePixelRatio: 1,\n        width,\n        height\n      },\n      // Disable enterprise features that may interfere with image generation.\n      moduleRegistry.hasEnterpriseModules() && { animation: { enabled: false } },\n      chart.getOptions()\n    );\n    const cloneProxy = await this.factoryApi.createOrUpdate(options);\n    cloneProxy.chart.ctx.zoomManager.updateZoom(\"agChartV2\", chart.ctx.zoomManager.getZoom());\n    chart.series.forEach((series, index) => {\n      if (!series.visible) {\n        cloneProxy.chart.series[index].visible = false;\n      }\n    });\n    chart.update(0 /* FULL */, { forceNodeDataRefresh: true });\n    await cloneProxy.waitForUpdate();\n    return cloneProxy;\n  }\n};\n_AgChartInstanceProxy.chartInstances = /* @__PURE__ */ new WeakMap();\n__decorateClass([\n  ActionOnSet({\n    oldValue(chart) {\n      _AgChartInstanceProxy.chartInstances.delete(chart);\n    },\n    newValue(chart) {\n      _AgChartInstanceProxy.chartInstances.set(chart, this);\n    }\n  })\n], _AgChartInstanceProxy.prototype, \"chart\", 2);\nvar AgChartInstanceProxy = _AgChartInstanceProxy;\n\n// packages/ag-charts-community/src/scale/linearScale.ts\nvar LinearScale = class extends ContinuousScale {\n  constructor() {\n    super([0, 1], [0, 1]);\n    this.type = \"number\";\n  }\n  toDomain(d) {\n    return d;\n  }\n  ticks() {\n    const count = this.tickCount ?? ContinuousScale.defaultTickCount;\n    if (!this.domain || this.domain.length < 2 || count < 1 || !this.domain.every(isFinite)) {\n      return [];\n    }\n    this.refresh();\n    const [d0, d1] = this.getDomain();\n    if (this.interval) {\n      const step = Math.abs(this.interval);\n      if (!isDenseInterval((d1 - d0) / step, this.getPixelRange())) {\n        return range(d0, d1, step);\n      }\n    }\n    return createTicks(d0, d1, count, this.minTickCount, this.maxTickCount);\n  }\n  update() {\n    if (!this.domain || this.domain.length < 2) {\n      return;\n    }\n    if (this.nice) {\n      this.updateNiceDomain();\n    }\n  }\n  getTickStep(start, stop) {\n    return this.interval ?? tickStep(start, stop, this.tickCount, this.minTickCount, this.maxTickCount);\n  }\n  /**\n   * Extends the domain so that it starts and ends on nice round values.\n   */\n  updateNiceDomain() {\n    const count = this.tickCount;\n    if (count < 1) {\n      this.niceDomain = [...this.domain];\n      return;\n    }\n    let [start, stop] = this.domain;\n    if (count === 1) {\n      [start, stop] = niceTicksDomain(start, stop);\n    } else {\n      const roundStart = start > stop ? Math.ceil : Math.floor;\n      const roundStop = stop < start ? Math.floor : Math.ceil;\n      const maxAttempts = 4;\n      for (let i = 0; i < maxAttempts; i++) {\n        const prev0 = start;\n        const prev1 = stop;\n        const step = this.getTickStep(start, stop);\n        const [d0, d1] = this.domain;\n        if (step >= 1) {\n          start = roundStart(d0 / step) * step;\n          stop = roundStop(d1 / step) * step;\n        } else {\n          const s = 1 / step;\n          start = roundStart(d0 * s) / s;\n          stop = roundStop(d1 * s) / s;\n        }\n        if (start === prev0 && stop === prev1) {\n          break;\n        }\n      }\n    }\n    this.niceDomain = [start, stop];\n  }\n  tickFormat({ ticks: specifiedTicks, specifier }) {\n    return tickFormat(specifiedTicks ?? this.ticks(), specifier);\n  }\n};\n\n// packages/ag-charts-community/src/util/secondaryAxisTicks.ts\nfunction calculateNiceSecondaryAxis(domain, primaryTickCount, reverse) {\n  let [start, stop] = findMinMax(domain);\n  start = calculateNiceStart(Math.floor(start), stop, primaryTickCount);\n  const step = getTickStep(start, stop, primaryTickCount);\n  const segments = primaryTickCount - 1;\n  stop = start + segments * step;\n  const d = reverse ? [stop, start] : [start, stop];\n  const ticks = getTicks(start, step, primaryTickCount);\n  return { domain: d, ticks };\n}\nfunction calculateNiceStart(a, b, count) {\n  const rawStep = Math.abs(b - a) / (count - 1);\n  const order = Math.floor(Math.log10(rawStep));\n  const magnitude = Math.pow(10, order);\n  return Math.floor(a / magnitude) * magnitude;\n}\nfunction getTicks(start, step, count) {\n  const stepPower = Math.floor(Math.log10(step));\n  const fractionDigits = step > 0 && step < 1 ? Math.abs(stepPower) : 0;\n  const f = Math.pow(10, fractionDigits);\n  const ticks = [];\n  for (let i = 0; i < count; i++) {\n    const tick = start + step * i;\n    ticks[i] = Math.round(tick * f) / f;\n  }\n  return ticks;\n}\nfunction getTickStep(start, stop, count) {\n  const segments = count - 1;\n  const rawStep = (stop - start) / segments;\n  return calculateNextNiceStep(rawStep);\n}\nfunction calculateNextNiceStep(rawStep) {\n  const order = Math.floor(Math.log10(rawStep));\n  const magnitude = Math.pow(10, order);\n  const step = rawStep / magnitude * 10;\n  if (step > 0 && step <= 1) {\n    return magnitude / 10;\n  }\n  if (step > 1 && step <= 2) {\n    return 2 * magnitude / 10;\n  }\n  if (step > 1 && step <= 5) {\n    return 5 * magnitude / 10;\n  }\n  if (step > 5 && step <= 10) {\n    return 10 * magnitude / 10;\n  }\n  if (step > 10 && step <= 20) {\n    return 20 * magnitude / 10;\n  }\n  if (step > 20 && step <= 40) {\n    return 40 * magnitude / 10;\n  }\n  if (step > 40 && step <= 50) {\n    return 50 * magnitude / 10;\n  }\n  if (step > 50 && step <= 100) {\n    return 100 * magnitude / 10;\n  }\n  return step;\n}\n\n// packages/ag-charts-community/src/chart/axis/numberAxis.ts\nvar NumberAxis = class extends CartesianAxis {\n  constructor(moduleCtx, scale2 = new LinearScale()) {\n    super(moduleCtx, scale2);\n    this.min = NaN;\n    this.max = NaN;\n  }\n  normaliseDataDomain(d) {\n    const { min, max } = this;\n    const { extent: extent2, clipped } = normalisedExtentWithMetadata(d, min, max);\n    return { domain: extent2, clipped };\n  }\n  updateSecondaryAxisTicks(primaryTickCount) {\n    if (this.dataDomain == null) {\n      throw new Error(\"AG Charts - dataDomain not calculated, cannot perform tick calculation.\");\n    }\n    if (this.dataDomain.domain.length === 0) {\n      return [];\n    }\n    const { domain, ticks } = calculateNiceSecondaryAxis(\n      this.dataDomain.domain,\n      primaryTickCount ?? 0,\n      this.reverse\n    );\n    this.scale.nice = false;\n    this.scale.domain = domain;\n    this.scale.update();\n    return ticks;\n  }\n};\nNumberAxis.className = \"NumberAxis\";\nNumberAxis.type = \"number\";\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, LESS_THAN(\"max\"))),\n  Default(NaN)\n], NumberAxis.prototype, \"min\", 2);\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, GREATER_THAN(\"min\"))),\n  Default(NaN)\n], NumberAxis.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/chart/axis/logAxis.ts\nvar NON_ZERO_NUMBER = predicateWithMessage((value) => isNumber(value) && value !== 0, \"a non-zero number\");\nvar LogAxis = class extends NumberAxis {\n  constructor(moduleCtx) {\n    super(moduleCtx, new LogScale());\n    this.min = NaN;\n    this.max = NaN;\n  }\n  normaliseDataDomain(d) {\n    const { min, max } = this;\n    const { extent: extent2, clipped } = normalisedExtentWithMetadata(d, min, max);\n    const isInverted = extent2[0] > extent2[1];\n    const crossesZero = extent2[0] < 0 && extent2[1] > 0;\n    const hasZeroExtent = extent2[0] === 0 && extent2[1] === 0;\n    const invalidDomain = isInverted || crossesZero || hasZeroExtent;\n    if (invalidDomain) {\n      if (crossesZero) {\n        Logger.warn(\n          `the data domain crosses zero, the chart data cannot be rendered. See log axis documentation for more information.`\n        );\n      } else if (hasZeroExtent) {\n        Logger.warn(`the data domain has 0 extent, no data is rendered.`);\n      }\n    }\n    if (extent2[0] === 0) {\n      extent2[0] = 1;\n    }\n    if (extent2[1] === 0) {\n      extent2[1] = -1;\n    }\n    return { domain: extent2, clipped };\n  }\n  set base(value) {\n    this.scale.base = value;\n  }\n  get base() {\n    return this.scale.base;\n  }\n};\nLogAxis.className = \"LogAxis\";\nLogAxis.type = \"log\";\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, NON_ZERO_NUMBER, LESS_THAN(\"max\"))),\n  Default(NaN)\n], LogAxis.prototype, \"min\", 2);\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, NON_ZERO_NUMBER, GREATER_THAN(\"min\"))),\n  Default(NaN)\n], LogAxis.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/chart/axis/timeAxis.ts\nvar TimeAxis = class extends CartesianAxis {\n  constructor(moduleCtx) {\n    super(moduleCtx, new TimeScale());\n    this.min = void 0;\n    this.max = void 0;\n  }\n  normaliseDataDomain(d) {\n    let { min, max } = this;\n    let clipped = false;\n    if (typeof min === \"number\") {\n      min = new Date(min);\n    }\n    if (typeof max === \"number\") {\n      max = new Date(max);\n    }\n    if (d.length > 2) {\n      d = (extent(d) ?? [0, 1e3]).map((x) => new Date(x));\n    }\n    if (min instanceof Date) {\n      clipped || (clipped = min > d[0]);\n      d = [min, d[1]];\n    }\n    if (max instanceof Date) {\n      clipped || (clipped = max < d[1]);\n      d = [d[0], max];\n    }\n    if (d[0] > d[1]) {\n      d = [];\n    }\n    return { domain: d, clipped };\n  }\n  onFormatChange(ticks, fractionDigits, domain, format) {\n    if (format) {\n      super.onFormatChange(ticks, fractionDigits, domain, format);\n    } else {\n      this.labelFormatter = this.scale.tickFormat({ ticks, domain });\n      this.datumFormatter = this.scale.tickFormat({ ticks, domain, formatOffset: 1 });\n    }\n  }\n  calculatePadding() {\n    return [0, 0];\n  }\n};\nTimeAxis.className = \"TimeAxis\";\nTimeAxis.type = \"time\";\n__decorateClass([\n  Validate(AND(DATE_OR_DATETIME_MS, LESS_THAN(\"max\")), { optional: true })\n], TimeAxis.prototype, \"min\", 2);\n__decorateClass([\n  Validate(AND(DATE_OR_DATETIME_MS, GREATER_THAN(\"min\")), { optional: true })\n], TimeAxis.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/scene/shape/rect.ts\nvar epsilon = 1e-6;\nvar cornerEdges = (leadingEdge, trailingEdge, leadingInset, trailingInset, cornerRadius) => {\n  let leadingClipped = false;\n  let trailingClipped = false;\n  let leading0 = trailingInset - Math.sqrt(Math.max(cornerRadius ** 2 - leadingInset ** 2, 0));\n  let leading1 = 0;\n  let trailing0 = 0;\n  let trailing1 = leadingInset - Math.sqrt(Math.max(cornerRadius ** 2 - trailingInset ** 2, 0));\n  if (leading0 > leadingEdge) {\n    leadingClipped = true;\n    leading0 = leadingEdge;\n    leading1 = leadingInset - Math.sqrt(Math.max(cornerRadius ** 2 - (trailingInset - leadingEdge) ** 2));\n  } else if (leading0 < epsilon) {\n    leading0 = 0;\n  }\n  if (trailing1 > trailingEdge) {\n    trailingClipped = true;\n    trailing0 = trailingInset - Math.sqrt(Math.max(cornerRadius ** 2 - (leadingInset - trailingEdge) ** 2));\n    trailing1 = trailingEdge;\n  } else if (trailing1 < epsilon) {\n    trailing1 = 0;\n  }\n  return { leading0, leading1, trailing0, trailing1, leadingClipped, trailingClipped };\n};\nvar drawCorner = (path, { x0, y0, x1, y1, cx, cy }, cornerRadius, move) => {\n  if (move) {\n    path.moveTo(x0, y0);\n  }\n  if (x0 !== x1 || y0 !== y1) {\n    const r0 = Math.atan2(y0 - cy, x0 - cx);\n    const r1 = Math.atan2(y1 - cy, x1 - cx);\n    path.arc(cx, cy, cornerRadius, r0, r1);\n  } else {\n    path.lineTo(x0, y0);\n  }\n};\nvar insetCornerRadiusRect = (path, x, y, width, height, cornerRadii, clipBBox) => {\n  let {\n    topLeft: topLeftCornerRadius,\n    topRight: topRightCornerRadius,\n    bottomRight: bottomRightCornerRadius,\n    bottomLeft: bottomLeftCornerRadius\n  } = cornerRadii;\n  const maxVerticalCornerRadius = Math.max(\n    topLeftCornerRadius + bottomLeftCornerRadius,\n    topRightCornerRadius + bottomRightCornerRadius\n  );\n  const maxHorizontalCornerRadius = Math.max(\n    topLeftCornerRadius + topRightCornerRadius,\n    bottomLeftCornerRadius + bottomRightCornerRadius\n  );\n  if (maxVerticalCornerRadius <= 0 && maxHorizontalCornerRadius <= 0) {\n    if (clipBBox == null) {\n      path.rect(x, y, width, height);\n    } else {\n      path.rect(clipBBox.x, clipBBox.y, clipBBox.width, clipBBox.height);\n    }\n    return;\n  } else if (clipBBox == null && topLeftCornerRadius === topRightCornerRadius && topLeftCornerRadius === bottomRightCornerRadius && topLeftCornerRadius === bottomLeftCornerRadius) {\n    path.roundRect(x, y, width, height, topLeftCornerRadius);\n    return;\n  }\n  if (width < 0) {\n    x += width;\n    width = Math.abs(width);\n  }\n  if (height < 0) {\n    y += height;\n    height = Math.abs(height);\n  }\n  if (width <= 0 || height <= 0)\n    return;\n  if (clipBBox == null) {\n    clipBBox = new BBox(x, y, width, height);\n  } else {\n    const x0 = Math.max(x, clipBBox.x);\n    const x1 = Math.min(x + width, clipBBox.x + clipBBox.width);\n    const y0 = Math.max(y, clipBBox.y);\n    const y1 = Math.min(y + height, clipBBox.y + clipBBox.height);\n    clipBBox = new BBox(x0, y0, x1 - x0, y1 - y0);\n  }\n  const borderScale = Math.max(maxVerticalCornerRadius / height, maxHorizontalCornerRadius / width, 1);\n  if (borderScale > 1) {\n    topLeftCornerRadius /= borderScale;\n    topRightCornerRadius /= borderScale;\n    bottomRightCornerRadius /= borderScale;\n    bottomLeftCornerRadius /= borderScale;\n  }\n  let drawTopLeftCorner = true;\n  let drawTopRightCorner = true;\n  let drawBottomRightCorner = true;\n  let drawBottomLeftCorner = true;\n  let topLeftCorner;\n  let topRightCorner;\n  let bottomRightCorner;\n  let bottomLeftCorner;\n  if (drawTopLeftCorner) {\n    const nodes = cornerEdges(\n      clipBBox.height,\n      clipBBox.width,\n      Math.max(x + topLeftCornerRadius - clipBBox.x, 0),\n      Math.max(y + topLeftCornerRadius - clipBBox.y, 0),\n      topLeftCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawBottomLeftCorner = false;\n    if (nodes.trailingClipped)\n      drawTopRightCorner = false;\n    const x0 = Math.max(clipBBox.x + nodes.leading1, clipBBox.x);\n    const y0 = Math.max(clipBBox.y + nodes.leading0, clipBBox.y);\n    const x1 = Math.max(clipBBox.x + nodes.trailing1, clipBBox.x);\n    const y1 = Math.max(clipBBox.y + nodes.trailing0, clipBBox.y);\n    const cx = x + topLeftCornerRadius;\n    const cy = y + topLeftCornerRadius;\n    topLeftCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  if (drawTopRightCorner) {\n    const nodes = cornerEdges(\n      clipBBox.width,\n      clipBBox.height,\n      Math.max(y + topRightCornerRadius - clipBBox.y, 0),\n      Math.max(clipBBox.x + clipBBox.width - (x + width - topRightCornerRadius), 0),\n      topRightCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawTopLeftCorner = false;\n    if (nodes.trailingClipped)\n      drawBottomRightCorner = false;\n    const x0 = Math.min(clipBBox.x + clipBBox.width - nodes.leading0, clipBBox.x + clipBBox.width);\n    const y0 = Math.max(clipBBox.y + nodes.leading1, clipBBox.y);\n    const x1 = Math.min(clipBBox.x + clipBBox.width - nodes.trailing0, clipBBox.x + clipBBox.width);\n    const y1 = Math.max(clipBBox.y + nodes.trailing1, clipBBox.y);\n    const cx = x + width - topRightCornerRadius;\n    const cy = y + topRightCornerRadius;\n    topRightCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  if (drawBottomRightCorner) {\n    const nodes = cornerEdges(\n      clipBBox.height,\n      clipBBox.width,\n      Math.max(clipBBox.x + clipBBox.width - (x + width - bottomRightCornerRadius), 0),\n      Math.max(clipBBox.y + clipBBox.height - (y + height - bottomRightCornerRadius), 0),\n      bottomRightCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawTopRightCorner = false;\n    if (nodes.trailingClipped)\n      drawBottomLeftCorner = false;\n    const x0 = Math.min(clipBBox.x + clipBBox.width - nodes.leading1, clipBBox.x + clipBBox.width);\n    const y0 = Math.min(clipBBox.y + clipBBox.height - nodes.leading0, clipBBox.y + clipBBox.height);\n    const x1 = Math.min(clipBBox.x + clipBBox.width - nodes.trailing1, clipBBox.x + clipBBox.width);\n    const y1 = Math.min(clipBBox.y + clipBBox.height - nodes.trailing0, clipBBox.y + clipBBox.height);\n    const cx = x + width - bottomRightCornerRadius;\n    const cy = y + height - bottomRightCornerRadius;\n    bottomRightCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  if (drawBottomLeftCorner) {\n    const nodes = cornerEdges(\n      clipBBox.width,\n      clipBBox.height,\n      Math.max(clipBBox.y + clipBBox.height - (y + height - bottomLeftCornerRadius), 0),\n      Math.max(x + bottomLeftCornerRadius - clipBBox.x, 0),\n      bottomLeftCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawBottomRightCorner = false;\n    if (nodes.trailingClipped)\n      drawTopLeftCorner = false;\n    const x0 = Math.max(clipBBox.x + nodes.leading0, clipBBox.x);\n    const y0 = Math.min(clipBBox.y + clipBBox.height - nodes.leading1, clipBBox.y + clipBBox.height);\n    const x1 = Math.max(clipBBox.x + nodes.trailing0, clipBBox.x);\n    const y1 = Math.min(clipBBox.y + clipBBox.height - nodes.trailing1, clipBBox.y + clipBBox.height);\n    const cx = x + bottomLeftCornerRadius;\n    const cy = y + height - bottomLeftCornerRadius;\n    bottomLeftCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  let didMove = false;\n  if (drawTopLeftCorner && topLeftCorner != null) {\n    drawCorner(path, topLeftCorner, topLeftCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  if (drawTopRightCorner && topRightCorner != null) {\n    drawCorner(path, topRightCorner, topRightCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  if (drawBottomRightCorner && bottomRightCorner != null) {\n    drawCorner(path, bottomRightCorner, bottomRightCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  if (drawBottomLeftCorner && bottomLeftCorner != null) {\n    drawCorner(path, bottomLeftCorner, bottomLeftCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  path.closePath();\n};\nvar Rect = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.borderPath = new ExtendedPath2D();\n    this.x = 0;\n    this.y = 0;\n    this.width = 10;\n    this.height = 10;\n    this.topLeftCornerRadius = 0;\n    this.topRightCornerRadius = 0;\n    this.bottomRightCornerRadius = 0;\n    this.bottomLeftCornerRadius = 0;\n    this.clipBBox = void 0;\n    this.crisp = false;\n    this.lastUpdatePathStrokeWidth = Shape.defaultStyles.strokeWidth;\n    this.effectiveStrokeWidth = Shape.defaultStyles.strokeWidth;\n    this.hittester = super.isPointInPath;\n    this.distanceCalculator = super.distanceSquaredTransformedPoint;\n    /**\n     * When the rectangle's width or height is less than a pixel\n     * and crisp mode is on, the rectangle will still fit into the pixel,\n     * but will be less opaque to make an effect of holding less space.\n     */\n    this.microPixelEffectOpacity = 1;\n  }\n  set cornerRadius(cornerRadius) {\n    this.topLeftCornerRadius = cornerRadius;\n    this.topRightCornerRadius = cornerRadius;\n    this.bottomRightCornerRadius = cornerRadius;\n    this.bottomLeftCornerRadius = cornerRadius;\n  }\n  isDirtyPath() {\n    return this.lastUpdatePathStrokeWidth !== this.strokeWidth || Boolean(this.path.isDirty() || this.borderPath.isDirty());\n  }\n  updatePath() {\n    const {\n      path,\n      borderPath,\n      crisp,\n      topLeftCornerRadius: topLeft,\n      topRightCornerRadius: topRight,\n      bottomRightCornerRadius: bottomRight,\n      bottomLeftCornerRadius: bottomLeft\n    } = this;\n    let { x, y, width: w, height: h, strokeWidth, clipBBox } = this;\n    const pixelRatio = this.layerManager?.canvas.pixelRatio ?? 1;\n    const pixelSize = 1 / pixelRatio;\n    let microPixelEffectOpacity = 1;\n    path.clear(true);\n    borderPath.clear(true);\n    if (crisp) {\n      if (w <= pixelSize) {\n        microPixelEffectOpacity *= w / pixelSize;\n      }\n      if (h <= pixelSize) {\n        microPixelEffectOpacity *= h / pixelSize;\n      }\n      w = this.align(x, w);\n      h = this.align(y, h);\n      x = this.align(x);\n      y = this.align(y);\n      clipBBox = clipBBox != null ? new BBox(\n        this.align(clipBBox.x),\n        this.align(clipBBox.y),\n        this.align(clipBBox.x, clipBBox.width),\n        this.align(clipBBox.y, clipBBox.height)\n      ) : void 0;\n    }\n    if (strokeWidth) {\n      if (w < pixelSize) {\n        const lx = x + pixelSize / 2;\n        borderPath.moveTo(lx, y);\n        borderPath.lineTo(lx, y + h);\n        strokeWidth = pixelSize;\n        this.borderClipPath = void 0;\n      } else if (h < pixelSize) {\n        const ly = y + pixelSize / 2;\n        borderPath.moveTo(x, ly);\n        borderPath.lineTo(x + w, ly);\n        strokeWidth = pixelSize;\n        this.borderClipPath = void 0;\n      } else if (strokeWidth < w && strokeWidth < h) {\n        const halfStrokeWidth = strokeWidth / 2;\n        x += halfStrokeWidth;\n        y += halfStrokeWidth;\n        w -= strokeWidth;\n        h -= strokeWidth;\n        const adjustedClipBBox = clipBBox?.clone().shrink(halfStrokeWidth);\n        const cornerRadii = {\n          topLeft: topLeft > 0 ? topLeft - strokeWidth : 0,\n          topRight: topRight > 0 ? topRight - strokeWidth : 0,\n          bottomRight: bottomRight > 0 ? bottomRight - strokeWidth : 0,\n          bottomLeft: bottomLeft > 0 ? bottomLeft - strokeWidth : 0\n        };\n        this.borderClipPath = void 0;\n        if (w > 0 && h > 0 && (adjustedClipBBox == null || adjustedClipBBox?.width > 0 && adjustedClipBBox?.height > 0)) {\n          insetCornerRadiusRect(path, x, y, w, h, cornerRadii, adjustedClipBBox);\n          insetCornerRadiusRect(borderPath, x, y, w, h, cornerRadii, adjustedClipBBox);\n        }\n      } else {\n        this.borderClipPath = this.borderClipPath ?? new ExtendedPath2D();\n        this.borderClipPath.clear(true);\n        this.borderClipPath.rect(x, y, w, h);\n        borderPath.rect(x, y, w, h);\n      }\n    } else {\n      const cornerRadii = { topLeft, topRight, bottomRight, bottomLeft };\n      this.borderClipPath = void 0;\n      insetCornerRadiusRect(path, x, y, w, h, cornerRadii, clipBBox);\n    }\n    if ([topLeft, topRight, bottomRight, bottomLeft].every((r) => r === 0)) {\n      this.hittester = (hitX, hitY) => {\n        const point = this.transformPoint(hitX, hitY);\n        return this.getCachedBBox().containsPoint(point.x, point.y);\n      };\n      this.distanceSquared = (hitX, hitY) => this.getCachedBBox().distanceSquared(hitX, hitY);\n    } else {\n      this.hittester = super.isPointInPath;\n      this.distanceCalculator = super.distanceSquaredTransformedPoint;\n    }\n    this.effectiveStrokeWidth = strokeWidth;\n    this.lastUpdatePathStrokeWidth = strokeWidth;\n    this.microPixelEffectOpacity = microPixelEffectOpacity;\n  }\n  computeBBox() {\n    const { x, y, width, height, clipBBox } = this;\n    return clipBBox?.clone() ?? new BBox(x, y, width, height);\n  }\n  isPointInPath(x, y) {\n    return this.hittester(x, y);\n  }\n  get midPoint() {\n    return { x: this.x + this.width / 2, y: this.y + this.height / 2 };\n  }\n  distanceSquared(x, y) {\n    return this.distanceCalculator(x, y);\n  }\n  applyFillAlpha(ctx) {\n    const { fillOpacity, microPixelEffectOpacity, opacity } = this;\n    ctx.globalAlpha *= opacity * fillOpacity * microPixelEffectOpacity;\n  }\n  renderStroke(ctx) {\n    const { stroke, effectiveStrokeWidth } = this;\n    if (stroke && effectiveStrokeWidth) {\n      const { globalAlpha } = ctx;\n      const {\n        strokeOpacity,\n        lineDash,\n        lineDashOffset,\n        lineCap,\n        lineJoin,\n        borderPath,\n        borderClipPath,\n        opacity,\n        microPixelEffectOpacity\n      } = this;\n      if (borderClipPath) {\n        ctx.clip(borderClipPath.getPath2D());\n      }\n      ctx.strokeStyle = stroke;\n      ctx.globalAlpha *= opacity * strokeOpacity * microPixelEffectOpacity;\n      ctx.lineWidth = effectiveStrokeWidth;\n      if (lineDash) {\n        ctx.setLineDash(lineDash);\n      }\n      if (lineDashOffset) {\n        ctx.lineDashOffset = lineDashOffset;\n      }\n      if (lineCap) {\n        ctx.lineCap = lineCap;\n      }\n      if (lineJoin) {\n        ctx.lineJoin = lineJoin;\n      }\n      ctx.stroke(borderPath.getPath2D());\n      ctx.globalAlpha = globalAlpha;\n    }\n  }\n};\nRect.className = \"Rect\";\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"x\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"y\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"width\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"height\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"topLeftCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"topRightCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"bottomRightCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"bottomLeftCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"clipBBox\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"crisp\", 2);\n\n// packages/ag-charts-community/src/chart/background/background.ts\nvar Background = class extends BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.node = new Group({ name: \"background\", zIndex: 0 /* SERIES_BACKGROUND_ZINDEX */ });\n    this.rectNode = new Rect();\n    this.visible = true;\n    this.fill = \"white\";\n    this.node.appendChild(this.rectNode);\n    this.destroyFns.push(\n      ctx.scene.attachNode(this.node),\n      ctx.layoutService.addListener(\"layout-complete\", (e) => this.onLayoutComplete(e))\n    );\n  }\n  onLayoutComplete(e) {\n    const { width, height } = e.chart;\n    this.rectNode.width = width;\n    this.rectNode.height = height;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN),\n  ProxyPropertyOnWrite(\"node\", \"visible\")\n], Background.prototype, \"visible\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"rectNode\", \"fill\")\n], Background.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(OBJECT, { optional: true })\n], Background.prototype, \"image\", 2);\n\n// packages/ag-charts-community/src/chart/background/backgroundModule.ts\nvar BackgroundModule = {\n  type: \"root\",\n  optionsKey: \"background\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n  instanceConstructor: Background\n};\n\n// packages/ag-charts-community/src/util/keynavUtil.ts\nfunction addRemovableEventListener(destroyFns, button, type, listener) {\n  button.addEventListener(type, listener);\n  destroyFns.push(() => button.removeEventListener(type, listener));\n}\nfunction addEscapeEventListener(destroyFns, elem, onEscape) {\n  addRemovableEventListener(destroyFns, elem, \"keydown\", (event) => {\n    if (event.key === \"Escape\") {\n      onEscape(event);\n    }\n  });\n}\nfunction matchesKey(event, key, ...morekeys) {\n  return !(event.shiftKey || event.altKey || event.ctrlKey || event.metaKey) && (event.key === key || morekeys.some((altkey) => event.key === altkey));\n}\nfunction linkTwoButtons(destroyFns, src, dst, key) {\n  if (!dst)\n    return;\n  addRemovableEventListener(destroyFns, src, \"keydown\", (event) => {\n    if (matchesKey(event, key)) {\n      dst.focus();\n    }\n  });\n}\nfunction linkThreeButtons(destroyFns, curr, next, nextKey, prev, prevKey) {\n  linkTwoButtons(destroyFns, curr, prev, prevKey);\n  linkTwoButtons(destroyFns, curr, next, nextKey);\n  addRemovableEventListener(destroyFns, curr, \"keydown\", (event) => {\n    if (matchesKey(event, nextKey, prevKey)) {\n      event.preventDefault();\n    }\n  });\n}\nvar PREV_NEXT_KEYS = {\n  horizontal: { nextKey: \"ArrowRight\", prevKey: \"ArrowLeft\" },\n  vertical: { nextKey: \"ArrowDown\", prevKey: \"ArrowUp\" }\n};\nfunction initToolbarKeyNav(opts) {\n  const { orientation, toolbar, buttons, onEscape, onFocus, onBlur } = opts;\n  const { nextKey, prevKey } = PREV_NEXT_KEYS[orientation];\n  const ariaHidden = buttons.length === 0;\n  toolbar.role = \"toolbar\";\n  toolbar.ariaOrientation = orientation;\n  toolbar.ariaHidden = ariaHidden.toString();\n  const setTabIndices = (event) => {\n    if (event.target && \"tabIndex\" in event.target) {\n      buttons.forEach((b) => b.tabIndex = -1);\n      event.target.tabIndex = 0;\n    }\n  };\n  const destroyFns = [];\n  for (let i = 0; i < buttons.length; i++) {\n    const prev = buttons[i - 1];\n    const curr = buttons[i];\n    const next = buttons[i + 1];\n    addRemovableEventListener(destroyFns, curr, \"focus\", setTabIndices);\n    if (onFocus)\n      addRemovableEventListener(destroyFns, curr, \"focus\", onFocus);\n    if (onBlur)\n      addRemovableEventListener(destroyFns, curr, \"blur\", onBlur);\n    if (onEscape)\n      addEscapeEventListener(destroyFns, curr, onEscape);\n    linkThreeButtons(destroyFns, curr, prev, prevKey, next, nextKey);\n    curr.tabIndex = i === 0 ? 0 : -1;\n  }\n  return destroyFns;\n}\nfunction initMenuKeyNav(opts) {\n  const { orientation, menu, buttons, onEscape } = opts;\n  const { nextKey, prevKey } = PREV_NEXT_KEYS[orientation];\n  menu.role = \"menu\";\n  menu.ariaOrientation = orientation;\n  const destroyFns = [];\n  for (let i = 0; i < buttons.length; i++) {\n    const prev = buttons[(buttons.length + i - 1) % buttons.length];\n    const curr = buttons[i];\n    const next = buttons[(buttons.length + i + 1) % buttons.length];\n    if (onEscape)\n      addEscapeEventListener(destroyFns, curr, onEscape);\n    linkThreeButtons(destroyFns, curr, prev, prevKey, next, nextKey);\n    curr.tabIndex = -1;\n  }\n  menu.tabIndex = -1;\n  if (onEscape)\n    addEscapeEventListener(destroyFns, menu, onEscape);\n  addRemovableEventListener(destroyFns, menu, \"keydown\", (ev) => {\n    if (ev.target === menu && (ev.key === nextKey || ev.key === prevKey)) {\n      ev.preventDefault();\n      buttons[0]?.focus();\n    }\n  });\n  return destroyFns;\n}\nfunction makeAccessibleClickListener(element2, onclick) {\n  return (event) => {\n    if (element2.ariaDisabled === \"true\") {\n      return event.preventDefault();\n    }\n    onclick(event);\n  };\n}\n\n// packages/ag-charts-community/src/chart/gridLayout.ts\nfunction gridLayout({\n  orientation,\n  bboxes,\n  maxHeight,\n  maxWidth,\n  itemPaddingY = 0,\n  itemPaddingX = 0,\n  forceResult = false\n}) {\n  const horizontal = orientation === \"horizontal\";\n  const primary = {\n    max: horizontal ? maxWidth : maxHeight,\n    fn: horizontal ? (b) => b.width : (b) => b.height,\n    padding: horizontal ? itemPaddingX : itemPaddingY\n  };\n  const secondary = {\n    max: horizontal ? maxHeight : maxWidth,\n    fn: horizontal ? (b) => b.height : (b) => b.width,\n    padding: horizontal ? itemPaddingY : itemPaddingX\n  };\n  let processedBBoxCount = 0;\n  const rawPages = [];\n  while (processedBBoxCount < bboxes.length) {\n    const unprocessedBBoxes = bboxes.slice(processedBBoxCount);\n    const result = processBBoxes(unprocessedBBoxes, processedBBoxCount, primary, secondary, forceResult);\n    if (!result) {\n      return;\n    }\n    processedBBoxCount += result.processedBBoxCount;\n    rawPages.push(result.pageIndices);\n  }\n  return buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX);\n}\nfunction processBBoxes(bboxes, indexOffset, primary, secondary, forceResult) {\n  const minGuess = 1;\n  let startingGuess = estimateStartingGuess(bboxes, primary);\n  if (startingGuess < minGuess) {\n    if (!forceResult) {\n      return;\n    }\n    startingGuess = minGuess;\n  }\n  let guess = startingGuess;\n  while (guess >= minGuess) {\n    const pageIndices = calculatePage(bboxes, indexOffset, guess, primary, secondary, forceResult);\n    if (pageIndices == null && guess <= minGuess) {\n      return;\n    }\n    if (pageIndices == null) {\n      guess--;\n      continue;\n    }\n    if (typeof pageIndices === \"number\") {\n      if (pageIndices <= minGuess) {\n        return;\n      }\n      guess = pageIndices < guess && pageIndices > minGuess ? pageIndices : guess;\n      guess--;\n      continue;\n    }\n    const processedBBoxCount = pageIndices.length * pageIndices[0].length;\n    return { processedBBoxCount, pageIndices };\n  }\n}\nfunction calculatePage(bboxes, indexOffset, primaryCount, primary, secondary, forceResult) {\n  const result = [];\n  let sumSecondary = 0;\n  let currentMaxSecondary = 0;\n  let currentPrimaryIndices = [];\n  const maxPrimaryValues = [];\n  for (let bboxIndex = 0; bboxIndex < bboxes.length; bboxIndex++) {\n    const primaryValueIdx = (bboxIndex + primaryCount) % primaryCount;\n    if (primaryValueIdx === 0) {\n      sumSecondary += currentMaxSecondary;\n      currentMaxSecondary = 0;\n      if (currentPrimaryIndices.length > 0) {\n        result.push(currentPrimaryIndices);\n      }\n      currentPrimaryIndices = [];\n    }\n    const primaryValue = primary.fn(bboxes[bboxIndex]) + primary.padding;\n    maxPrimaryValues[primaryValueIdx] = Math.max(maxPrimaryValues[primaryValueIdx] ?? 0, primaryValue);\n    currentMaxSecondary = Math.max(currentMaxSecondary, secondary.fn(bboxes[bboxIndex]) + secondary.padding);\n    const currentSecondaryDimension = sumSecondary + currentMaxSecondary;\n    const returnResult = !forceResult || result.length > 0;\n    if (currentSecondaryDimension > secondary.max && returnResult) {\n      currentPrimaryIndices = [];\n      break;\n    }\n    const sumPrimary = maxPrimaryValues.reduce((sum2, next) => sum2 + next, 0);\n    if (sumPrimary > primary.max && !forceResult) {\n      if (maxPrimaryValues.length < primaryCount) {\n        return maxPrimaryValues.length;\n      }\n      return;\n    }\n    currentPrimaryIndices.push(bboxIndex + indexOffset);\n  }\n  if (currentPrimaryIndices.length > 0) {\n    result.push(currentPrimaryIndices);\n  }\n  return result.length > 0 ? result : void 0;\n}\nfunction buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX) {\n  let maxPageWidth = 0;\n  let maxPageHeight = 0;\n  const pages = rawPages.map((indices) => {\n    if (orientation === \"horizontal\") {\n      indices = transpose(indices);\n    }\n    let endIndex = 0;\n    const columns = indices.map((colIndices) => {\n      const colBBoxes = colIndices.map((bboxIndex) => {\n        endIndex = Math.max(bboxIndex, endIndex);\n        return bboxes[bboxIndex];\n      });\n      let columnHeight = 0;\n      let columnWidth = 0;\n      colBBoxes.forEach((bbox) => {\n        columnHeight += bbox.height + itemPaddingY;\n        columnWidth = Math.max(columnWidth, bbox.width + itemPaddingX);\n      });\n      return {\n        indices: colIndices,\n        bboxes: colBBoxes,\n        columnHeight: Math.ceil(columnHeight),\n        columnWidth: Math.ceil(columnWidth)\n      };\n    });\n    let pageWidth = 0;\n    let pageHeight = 0;\n    columns.forEach((column) => {\n      pageWidth += column.columnWidth;\n      pageHeight = Math.max(pageHeight, column.columnHeight);\n    });\n    maxPageWidth = Math.max(pageWidth, maxPageWidth);\n    maxPageHeight = Math.max(pageHeight, maxPageHeight);\n    return {\n      columns,\n      startIndex: indices[0][0],\n      endIndex,\n      pageWidth,\n      pageHeight\n    };\n  });\n  return { pages, maxPageWidth, maxPageHeight };\n}\nfunction transpose(data) {\n  const result = [];\n  for (const _ of data[0]) {\n    result.push([]);\n  }\n  data.forEach((innerData, dataIdx) => {\n    innerData.forEach((item, itemIdx) => {\n      result[itemIdx][dataIdx] = item;\n    });\n  });\n  return result;\n}\nfunction estimateStartingGuess(bboxes, primary) {\n  const n = bboxes.length;\n  let primarySum = 0;\n  for (let bboxIndex = 0; bboxIndex < n; bboxIndex++) {\n    primarySum += primary.fn(bboxes[bboxIndex]) + primary.padding;\n    if (primarySum > primary.max) {\n      const ratio = n / bboxIndex;\n      if (ratio < 2) {\n        return Math.ceil(n / 2);\n      }\n      return bboxIndex;\n    }\n  }\n  return n;\n}\n\n// packages/ag-charts-community/src/chart/markerLabel.ts\nvar MarkerLabel = class extends Group {\n  constructor() {\n    super({ name: \"markerLabelGroup\" });\n    this.label = new Text();\n    this.symbolsGroup = new Group({\n      name: \"legend-markerLabel-symbols\"\n    });\n    this.pageIndex = NaN;\n    this._markers = [];\n    this._lines = [];\n    const { markers, label, lines } = this;\n    label.textBaseline = \"middle\";\n    label.fontSize = 12;\n    label.fontFamily = \"Verdana, sans-serif\";\n    label.fill = \"black\";\n    label.y = 1;\n    this.symbolsGroup.append([...lines, ...markers]);\n    this.append([this.symbolsGroup, label]);\n  }\n  destroy() {\n    super.destroy();\n    this.proxyButton?.remove();\n  }\n  set markers(value) {\n    if (!arraysEqual(this._markers, value)) {\n      this._markers.forEach((marker) => {\n        this.removeChild(marker);\n      });\n      this._markers = value;\n      this._markers.forEach((marker) => {\n        this.symbolsGroup.appendChild(marker);\n      });\n    }\n  }\n  get markers() {\n    return this._markers;\n  }\n  set lines(value) {\n    if (!arraysEqual(this._lines, value)) {\n      this._lines.forEach((line) => {\n        this.removeChild(line);\n      });\n      this._lines = value;\n      this._lines.forEach((line) => {\n        this.symbolsGroup.appendChild(line);\n      });\n    }\n  }\n  get lines() {\n    return this._lines;\n  }\n  update(dimensionProps) {\n    const { markers, lines } = this;\n    let shift = 0;\n    for (let i = 0; i < Math.max(markers.length, lines.length); i++) {\n      const { length: length2, spacing } = dimensionProps[i] ?? 0;\n      const marker = markers[i];\n      const line = lines[i];\n      const size = marker?.size ?? 0;\n      if (marker) {\n        const center = marker.constructor.center;\n        marker.x = (center.x - 0.5) * size + length2 / 2 + shift;\n        marker.y = (center.y - 0.5) * size;\n      }\n      if (line) {\n        line.x1 = shift;\n        line.x2 = shift + length2;\n        line.y1 = 0;\n        line.y2 = 0;\n        line.markDirtyTransform();\n      }\n      shift += spacing + Math.max(length2, size);\n    }\n    const lastSymbolProps = dimensionProps.at(-1);\n    const lastLine = this.lines.at(-1);\n    const lastMarker = this.markers.at(-1);\n    const lineEnd = lastLine?.visible ? lastLine.x2 : -Infinity;\n    const markerEnd = (lastMarker?.x ?? 0) + (lastMarker?.size ?? 0) / 2;\n    this.label.x = Math.max(lineEnd, markerEnd) + (lastSymbolProps?.spacing ?? 0);\n    if (dimensionProps.length < 2) {\n      return;\n    }\n    const bbox = this.symbolsGroup.computeBBox();\n    const clippedWidth = Math.max(lastMarker?.size ?? 0, lastSymbolProps?.length ?? 0);\n    const clipRect = new BBox(bbox.x + clippedWidth / 2, bbox.y, clippedWidth, bbox.height);\n    this.symbolsGroup.setClipRectInGroupCoordinateSpace(clipRect);\n  }\n  render(renderCtx) {\n    this.markers.forEach((marker) => {\n      marker.opacity = this.opacity;\n    });\n    this.lines.forEach((line) => {\n      line.opacity = this.opacity;\n    });\n    this.label.opacity = this.opacity;\n    super.render(renderCtx);\n  }\n};\nMarkerLabel.className = \"MarkerLabel\";\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], MarkerLabel.prototype, \"text\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], MarkerLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], MarkerLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], MarkerLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], MarkerLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\", \"fill\")\n], MarkerLabel.prototype, \"color\", 2);\n\n// packages/ag-charts-community/src/chart/pagination/pagination.ts\nvar PaginationLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.color = \"black\";\n    this.fontStyle = void 0;\n    this.fontWeight = void 0;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING)\n], PaginationLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], PaginationLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], PaginationLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], PaginationLabel.prototype, \"fontFamily\", 2);\nvar PaginationMarkerStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.size = 15;\n    this.fill = void 0;\n    this.fillOpacity = void 0;\n    this.stroke = void 0;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarkerStyle.prototype, \"size\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], PaginationMarkerStyle.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], PaginationMarkerStyle.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], PaginationMarkerStyle.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarkerStyle.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PaginationMarkerStyle.prototype, \"strokeOpacity\", 2);\nvar PaginationMarker = class extends BaseProperties {\n  constructor(parent) {\n    super();\n    this.parent = parent;\n    this.shape = Triangle;\n    this.size = 15;\n    this.padding = 8;\n  }\n};\n__decorateClass([\n  ActionOnSet({\n    changeValue() {\n      if (this.parent.marker === this) {\n        this.parent.onMarkerShapeChange();\n      }\n    }\n  })\n], PaginationMarker.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarker.prototype, \"size\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarker.prototype, \"padding\", 2);\nvar Pagination = class extends BaseProperties {\n  constructor(chartUpdateCallback, pageUpdateCallback, regionManager, cursorManager) {\n    super();\n    this.chartUpdateCallback = chartUpdateCallback;\n    this.pageUpdateCallback = pageUpdateCallback;\n    this.regionManager = regionManager;\n    this.cursorManager = cursorManager;\n    this.id = createId(this);\n    this.marker = new PaginationMarker(this);\n    this.activeStyle = new PaginationMarkerStyle();\n    this.inactiveStyle = new PaginationMarkerStyle();\n    this.highlightStyle = new PaginationMarkerStyle();\n    this.label = new PaginationLabel();\n    this.group = new Group({ name: \"pagination\" });\n    this.labelNode = new Text();\n    this.destroyFns = [];\n    this.totalPages = 0;\n    this.currentPage = 0;\n    this.translationX = 0;\n    this.translationY = 0;\n    this.nextButtonDisabled = false;\n    this.previousButtonDisabled = false;\n    this._visible = true;\n    this._enabled = true;\n    this._orientation = \"vertical\";\n    this._nextButton = new Triangle();\n    this._previousButton = new Triangle();\n    this.labelNode.setProperties({\n      textBaseline: \"middle\",\n      fontSize: 12,\n      fontFamily: \"Verdana, sans-serif\",\n      fill: \"black\",\n      y: 1\n    });\n    this.group.append([this.nextButton, this.previousButton, this.labelNode]);\n    const region = this.regionManager.addRegion(\"pagination\", this.group);\n    this.destroyFns.push(\n      region.addListener(\"click\", (event) => this.onPaginationClick(event)),\n      region.addListener(\"hover\", (event) => this.onPaginationMouseMove(event))\n    );\n    this.update();\n    this.updateMarkers();\n  }\n  destroy() {\n    this.destroyFns.forEach((f) => f());\n  }\n  set visible(value) {\n    this._visible = value;\n    this.updateGroupVisibility();\n  }\n  get visible() {\n    return this._visible;\n  }\n  set enabled(value) {\n    this._enabled = value;\n    this.updateGroupVisibility();\n  }\n  get enabled() {\n    return this._enabled;\n  }\n  updateGroupVisibility() {\n    this.group.visible = this.enabled && this.visible;\n  }\n  set orientation(value) {\n    this._orientation = value;\n    switch (value) {\n      case \"horizontal\": {\n        this.previousButton.rotation = -Math.PI / 2;\n        this.nextButton.rotation = Math.PI / 2;\n        break;\n      }\n      case \"vertical\":\n      default: {\n        this.previousButton.rotation = 0;\n        this.nextButton.rotation = Math.PI;\n      }\n    }\n  }\n  get orientation() {\n    return this._orientation;\n  }\n  set nextButton(value) {\n    if (this._nextButton !== value) {\n      this.group.removeChild(this._nextButton);\n      this._nextButton = value;\n      this.group.appendChild(value);\n    }\n  }\n  get nextButton() {\n    return this._nextButton;\n  }\n  set previousButton(value) {\n    if (this._previousButton !== value) {\n      this.group.removeChild(this._previousButton);\n      this._previousButton = value;\n      this.group.appendChild(value);\n    }\n  }\n  get previousButton() {\n    return this._previousButton;\n  }\n  update() {\n    this.updateLabel();\n    this.updatePositions();\n    this.enableOrDisableButtons();\n  }\n  updatePositions() {\n    this.group.translationX = this.translationX;\n    this.group.translationY = this.translationY;\n    this.updateLabelPosition();\n    this.updateNextButtonPosition();\n  }\n  updateLabelPosition() {\n    const { size: markerSize, padding: markerPadding } = this.marker;\n    this.nextButton.size = markerSize;\n    this.previousButton.size = markerSize;\n    this.labelNode.x = markerSize / 2 + markerPadding;\n  }\n  updateNextButtonPosition() {\n    const labelBBox = this.labelNode.computeBBox();\n    this.nextButton.translationX = labelBBox.x + labelBBox.width + this.marker.size / 2 + this.marker.padding;\n  }\n  updateLabel() {\n    const {\n      currentPage,\n      totalPages: pages,\n      labelNode,\n      label: { color, fontStyle, fontWeight, fontSize, fontFamily }\n    } = this;\n    labelNode.text = `${currentPage + 1} / ${pages}`;\n    labelNode.fill = color;\n    labelNode.fontStyle = fontStyle;\n    labelNode.fontWeight = fontWeight;\n    labelNode.fontSize = fontSize;\n    labelNode.fontFamily = fontFamily;\n  }\n  updateMarkers() {\n    const {\n      nextButton,\n      previousButton,\n      nextButtonDisabled,\n      previousButtonDisabled,\n      activeStyle,\n      inactiveStyle,\n      highlightStyle,\n      highlightActive\n    } = this;\n    const buttonStyle = (button, disabled) => {\n      if (disabled) {\n        return inactiveStyle;\n      } else if (button === highlightActive) {\n        return highlightStyle;\n      }\n      return activeStyle;\n    };\n    this.updateMarker(nextButton, buttonStyle(\"next\", nextButtonDisabled));\n    this.updateMarker(previousButton, buttonStyle(\"previous\", previousButtonDisabled));\n  }\n  updateMarker(marker, style) {\n    const { size } = this.marker;\n    marker.size = size;\n    marker.fill = style.fill;\n    marker.fillOpacity = style.fillOpacity ?? 1;\n    marker.stroke = style.stroke;\n    marker.strokeWidth = style.strokeWidth;\n    marker.strokeOpacity = style.strokeOpacity;\n  }\n  enableOrDisableButtons() {\n    const { currentPage, totalPages } = this;\n    const zeroPagesToDisplay = totalPages === 0;\n    const onLastPage = currentPage === totalPages - 1;\n    const onFirstPage = currentPage === 0;\n    this.nextButtonDisabled = onLastPage || zeroPagesToDisplay;\n    this.previousButtonDisabled = onFirstPage || zeroPagesToDisplay;\n  }\n  nextButtonContainsPoint(offsetX, offsetY) {\n    return !this.nextButtonDisabled && this.nextButton.containsPoint(offsetX, offsetY);\n  }\n  previousButtonContainsPoint(offsetX, offsetY) {\n    return !this.previousButtonDisabled && this.previousButton.containsPoint(offsetX, offsetY);\n  }\n  clickNext() {\n    this.incrementPage();\n    this.onPaginationChanged();\n  }\n  clickPrevious() {\n    this.decrementPage();\n    this.onPaginationChanged();\n  }\n  setPage(pageNumber) {\n    pageNumber = clamp(0, pageNumber, this.totalPages - 1);\n    if (this.currentPage !== pageNumber) {\n      this.currentPage = pageNumber;\n      this.onPaginationChanged();\n    }\n  }\n  onPaginationClick(event) {\n    const { offsetX, offsetY } = event;\n    event.preventDefault();\n    if (this.nextButtonContainsPoint(offsetX, offsetY)) {\n      this.clickNext();\n    } else if (this.previousButtonContainsPoint(offsetX, offsetY)) {\n      this.clickPrevious();\n    }\n  }\n  onPaginationMouseMove(event) {\n    const { offsetX, offsetY } = event;\n    if (this.nextButtonContainsPoint(offsetX, offsetY)) {\n      this.cursorManager.updateCursor(this.id, \"pointer\");\n      this.highlightActive = \"next\";\n    } else if (this.previousButtonContainsPoint(offsetX, offsetY)) {\n      this.cursorManager.updateCursor(this.id, \"pointer\");\n      this.highlightActive = \"previous\";\n    } else {\n      this.cursorManager.updateCursor(this.id);\n      this.highlightActive = void 0;\n    }\n    this.updateMarkers();\n    this.chartUpdateCallback(6 /* SCENE_RENDER */);\n  }\n  onPaginationChanged() {\n    this.pageUpdateCallback(this.currentPage);\n  }\n  incrementPage() {\n    this.currentPage = Math.min(this.currentPage + 1, this.totalPages - 1);\n  }\n  decrementPage() {\n    this.currentPage = Math.max(this.currentPage - 1, 0);\n  }\n  onMarkerShapeChange() {\n    const Marker2 = getMarker(this.marker.shape || Triangle);\n    this.previousButton = new Marker2();\n    this.nextButton = new Marker2();\n    this.updatePositions();\n    this.updateMarkers();\n    this.chartUpdateCallback(6 /* SCENE_RENDER */);\n  }\n  attachPagination(node) {\n    node.append(this.group);\n  }\n  computeBBox() {\n    return this.group.computeBBox();\n  }\n  computeCSSBounds() {\n    const group = this.group.computeTransformedBBox();\n    const prev = this._previousButton.computeTransformedBBox();\n    const next = this._nextButton.computeTransformedBBox();\n    prev.x -= group.x;\n    prev.y -= group.y;\n    next.x -= group.x;\n    next.y -= group.y;\n    return { group, prev, next };\n  }\n};\nPagination.className = \"Pagination\";\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"activeStyle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"inactiveStyle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"highlightStyle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"label\", 2);\n\n// packages/ag-charts-community/src/chart/legend.ts\nvar LegendLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.maxLength = void 0;\n    this.color = \"black\";\n    this.fontStyle = void 0;\n    this.fontWeight = void 0;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendLabel.prototype, \"maxLength\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], LegendLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], LegendLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], LegendLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], LegendLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], LegendLabel.prototype, \"formatter\", 2);\nvar LegendMarker = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.size = 15;\n    this.padding = 8;\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => target.parent?.onMarkerShapeChange())\n], LegendMarker.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendMarker.prototype, \"size\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendMarker.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendMarker.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], LegendMarker.prototype, \"enabled\", 2);\nvar LegendLine = class extends BaseProperties {\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendLine.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendLine.prototype, \"length\", 2);\nvar LegendItem = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.paddingX = 16;\n    this.paddingY = 8;\n    this.showSeriesStroke = false;\n    this.marker = new LegendMarker();\n    this.label = new LegendLabel();\n    this.line = new LegendLine();\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendItem.prototype, \"maxWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendItem.prototype, \"paddingX\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendItem.prototype, \"paddingY\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], LegendItem.prototype, \"showSeriesStroke\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LegendItem.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LegendItem.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LegendItem.prototype, \"line\", 2);\nvar LegendListeners = class extends BaseProperties {\n};\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], LegendListeners.prototype, \"legendItemClick\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], LegendListeners.prototype, \"legendItemDoubleClick\", 2);\nvar ID_LEGEND_VISIBILITY = \"legend-visibility\";\nvar ID_LEGEND_OTHER_SERIES = \"legend-other-series\";\nvar Legend = class extends BaseProperties {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.id = createId(this);\n    this.group = new Group({ name: \"legend\", layer: true, zIndex: 11 /* LEGEND_ZINDEX */ });\n    this.itemSelection = Selection.select(\n      this.group,\n      MarkerLabel\n    );\n    this.oldSize = [0, 0];\n    this.pages = [];\n    this.maxPageSize = [0, 0];\n    /** Item index to track on re-pagination, so current page updates appropriately. */\n    this.paginationTrackingIndex = 0;\n    this.truncatedItems = /* @__PURE__ */ new Set();\n    this._data = [];\n    this.toggleSeries = true;\n    this.item = new LegendItem();\n    this.listeners = new LegendListeners();\n    this.enabled = true;\n    this.position = \"bottom\";\n    this.spacing = 20;\n    this.characterWidths = /* @__PURE__ */ new Map();\n    this.destroyFns = [];\n    this.size = [0, 0];\n    this._visible = true;\n    this.item.marker.parent = this;\n    this.pagination = new Pagination(\n      (type) => ctx.updateService.update(type),\n      (page) => this.updatePageNumber(page),\n      ctx.regionManager,\n      ctx.cursorManager\n    );\n    this.pagination.attachPagination(this.group);\n    ctx.contextMenuRegistry.registerDefaultAction({\n      id: ID_LEGEND_VISIBILITY,\n      type: \"legend\",\n      label: \"contextMenuToggleSeriesVisibility\",\n      action: (params) => this.contextToggleVisibility(params)\n    });\n    ctx.contextMenuRegistry.registerDefaultAction({\n      id: ID_LEGEND_OTHER_SERIES,\n      type: \"legend\",\n      label: \"contextMenuToggleOtherSeries\",\n      action: (params) => this.contextToggleOtherSeries(params)\n    });\n    const { Default: Default2, Animation: Animation2, ContextMenu } = InteractionState;\n    const animationState = Default2 | Animation2;\n    const contextMenuState = Default2 | Animation2 | ContextMenu;\n    const region = ctx.regionManager.addRegion(\"legend\", this.group);\n    this.destroyFns.push(\n      region.addListener(\"contextmenu\", (e) => this.checkContextClick(e), contextMenuState),\n      region.addListener(\"click\", (e) => this.checkLegendClick(e), animationState),\n      region.addListener(\"dblclick\", (e) => this.checkLegendDoubleClick(e), animationState),\n      region.addListener(\"hover\", (e) => this.handleLegendMouseMove(e)),\n      region.addListener(\"leave\", (e) => this.handleLegendMouseExit(e), animationState),\n      region.addListener(\"enter\", (e) => this.handleLegendMouseEnter(e), animationState),\n      ctx.layoutService.addListener(\"start-layout\", (e) => this.positionLegend(e)),\n      () => this.detachLegend(),\n      ctx.localeManager.addListener(\"locale-changed\", () => this.onLocaleChanged())\n    );\n    this.proxyLegendToolbar = this.ctx.proxyInteractionService.createProxyContainer({\n      type: \"toolbar\",\n      id: `${this.id}-toolbar`,\n      classList: [\"ag-charts-proxy-legend-toolbar\"],\n      ariaLabel: { id: \"ariaLabelLegend\" },\n      ariaOrientation: \"horizontal\"\n    });\n    this.proxyLegendPagination = this.ctx.proxyInteractionService.createProxyContainer({\n      type: \"group\",\n      id: `${this.id}-pagination`,\n      classList: [\"ag-charts-proxy-legend-pagination\"],\n      ariaLabel: { id: \"ariaLabelLegendPagination\" },\n      ariaOrientation: \"horizontal\"\n    });\n  }\n  set data(value) {\n    this._data = value;\n    this.updateGroupVisibility();\n  }\n  get data() {\n    return this._data;\n  }\n  destroy() {\n    this.ctx.domManager.removeChild(\"canvas-overlay\", `${this.id}-toolbar`);\n    this.ctx.domManager.removeChild(\"canvas-overlay\", `${this.id}-pagination`);\n    this.destroyFns.forEach((f) => f());\n    this.pagination.destroy();\n    this.itemSelection.clear();\n  }\n  initLegendItemToolbar() {\n    this.itemSelection.each((markerLabel, _, i) => {\n      markerLabel.proxyButton ?? (markerLabel.proxyButton = this.ctx.proxyInteractionService.createProxyElement({\n        type: \"button\",\n        id: `ag-charts-legend-item-${i}`,\n        textContent: this.getItemAriaText(i),\n        parent: this.proxyLegendToolbar,\n        focusable: markerLabel,\n        // Retrieve the datum from the node rather than from the method parameter.\n        // The method parameter `datum` gets destroyed when the data is refreshed\n        // using Series.getLegendData(). But the scene node will stay the same.\n        onclick: () => {\n          this.doClick(markerLabel.datum);\n          markerLabel.proxyButton.textContent = this.getItemAriaText(i, !markerLabel.datum.enabled);\n        },\n        onblur: () => this.doMouseExit(),\n        onfocus: () => {\n          const bounds = markerLabel?.computeTransformedBBox();\n          const event = makeKeyboardPointerEvent(this.ctx.focusIndicator, { bounds, showFocusBox: true });\n          this.doHover(event, markerLabel.datum);\n          this.pagination.setPage(markerLabel.pageIndex);\n        }\n      }));\n    });\n    const buttons = this.itemSelection.nodes().map((markerLabel) => markerLabel.proxyButton).filter((button) => !!button);\n    initToolbarKeyNav({\n      orientation: this.getOrientation(),\n      buttons,\n      toolbar: this.proxyLegendToolbar\n    });\n  }\n  onMarkerShapeChange() {\n    this.itemSelection.clear();\n    this.group.markDirty(this.group, 2 /* MINOR */);\n  }\n  getOrientation() {\n    if (this.orientation !== void 0) {\n      return this.orientation;\n    }\n    switch (this.position) {\n      case \"right\":\n      case \"left\":\n        return \"vertical\";\n      case \"bottom\":\n      case \"top\":\n        return \"horizontal\";\n    }\n  }\n  getCharacterWidths(font) {\n    const { characterWidths } = this;\n    if (characterWidths.has(font)) {\n      return characterWidths.get(font);\n    }\n    const cw = {\n      \"...\": Text.getTextSize(\"...\", font).width\n    };\n    characterWidths.set(font, cw);\n    return cw;\n  }\n  set visible(value) {\n    this._visible = value;\n    this.updateGroupVisibility();\n  }\n  get visible() {\n    return this._visible;\n  }\n  updateGroupVisibility() {\n    this.group.visible = this.enabled && this.visible && this.data.length > 0;\n  }\n  attachLegend(scene) {\n    scene.appendChild(this.group);\n  }\n  detachLegend() {\n    this.group.parent?.removeChild(this.group);\n  }\n  getItemLabel(datum) {\n    const {\n      ctx: { callbackCache }\n    } = this;\n    const { formatter } = this.item.label;\n    if (formatter) {\n      return callbackCache.call(formatter, {\n        itemId: datum.itemId,\n        value: datum.label.text,\n        seriesId: datum.seriesId\n      });\n    }\n    return datum.label.text;\n  }\n  /**\n   * The method is given the desired size of the legend, which only serves as a hint.\n   * The vertically oriented legend will take as much horizontal space as needed, but will\n   * respect the height constraints, and the horizontal legend will take as much vertical\n   * space as needed in an attempt not to exceed the given width.\n   * After the layout is done, the {@link size} will contain the actual size of the legend.\n   * If the actual size is not the same as the previous actual size, the legend will fire\n   * the 'layoutChange' event to communicate that another layout is needed, and the above\n   * process should be repeated.\n   * @param width\n   * @param height\n   */\n  calcLayout(width, height) {\n    const {\n      paddingX,\n      paddingY,\n      label,\n      maxWidth,\n      label: { maxLength = Infinity, fontStyle, fontWeight, fontSize, fontFamily }\n    } = this.item;\n    const data = [...this.data];\n    if (this.reverseOrder) {\n      data.reverse();\n    }\n    const proxyToolbarNeedsUpdate = this.itemSelection.nodes().length === 0;\n    this.itemSelection.update(data);\n    if (proxyToolbarNeedsUpdate) {\n      this.initLegendItemToolbar();\n    }\n    const bboxes = [];\n    const font = getFont(label);\n    const itemMaxWidthPercentage = 0.8;\n    const maxItemWidth = maxWidth ?? width * itemMaxWidthPercentage;\n    this.itemSelection.each((markerLabel, datum) => {\n      markerLabel.fontStyle = fontStyle;\n      markerLabel.fontWeight = fontWeight;\n      markerLabel.fontSize = fontSize;\n      markerLabel.fontFamily = fontFamily;\n      const paddedSymbolWidth = this.updateMarkerLabel(markerLabel, datum, this.calcMarkerWidth());\n      const id = datum.itemId ?? datum.id;\n      const labelText = this.getItemLabel(datum);\n      const text = (labelText ?? \"<unknown>\").replace(/\\r?\\n/g, \" \");\n      markerLabel.text = this.truncate(text, maxLength, maxItemWidth, paddedSymbolWidth, font, id);\n      bboxes.push(markerLabel.computeBBox());\n    });\n    width = Math.max(1, width);\n    height = Math.max(1, height);\n    if (!isFinite(width)) {\n      return {};\n    }\n    const size = this.size;\n    const oldSize = this.oldSize;\n    size[0] = width;\n    size[1] = height;\n    if (size[0] !== oldSize[0] || size[1] !== oldSize[1]) {\n      oldSize[0] = size[0];\n      oldSize[1] = size[1];\n    }\n    const { pages, maxPageHeight, maxPageWidth } = this.updatePagination(bboxes, width, height);\n    const oldPages = this.pages;\n    this.pages = pages;\n    this.maxPageSize = [maxPageWidth - paddingX, maxPageHeight - paddingY];\n    const pageNumber = this.pagination.currentPage;\n    const page = this.pages[pageNumber];\n    if (this.pages.length < 1 || !page) {\n      this.visible = false;\n      return { oldPages };\n    }\n    this.visible = true;\n    this.updatePositions(pageNumber);\n    this.update();\n    return { oldPages };\n  }\n  calcSymbolsLengths(symbol) {\n    const { showSeriesStroke, marker, line } = this.item;\n    const markerEnabled = marker.enabled ?? (showSeriesStroke && (symbol.marker.enabled ?? true));\n    const markerLength = markerEnabled ? marker.size : 0;\n    const lineEnabled = !!(symbol.line && showSeriesStroke);\n    const lineLength = lineEnabled ? line.length ?? 25 : 0;\n    return { markerEnabled, markerLength, lineEnabled, lineLength };\n  }\n  calcMarkerWidth() {\n    let result = 0;\n    this.itemSelection.each((_, datum) => {\n      datum.symbols.forEach((symbol) => {\n        const { lineLength, markerLength } = this.calcSymbolsLengths(symbol);\n        result = Math.max(result, lineLength, markerLength);\n      });\n    });\n    return result;\n  }\n  updateMarkerLabel(markerLabel, datum, markerWidth) {\n    const { marker: itemMarker, paddingX } = this.item;\n    const dimensionProps = [];\n    let paddedSymbolWidth = paddingX;\n    if (markerLabel.markers.length !== datum.symbols.length && markerLabel.lines.length !== datum.symbols.length) {\n      const markers = [];\n      const lines = [];\n      datum.symbols.forEach((symbol) => {\n        const { shape: markerShape = symbol.marker.shape } = itemMarker;\n        const MarkerCtr = getMarker(markerShape);\n        lines.push(new Line());\n        markers.push(new MarkerCtr());\n      });\n      markerLabel.markers = markers;\n      markerLabel.lines = lines;\n    }\n    datum.symbols.forEach((symbol, i) => {\n      const spacing = symbol.marker.padding ?? itemMarker.padding;\n      const { markerEnabled, lineEnabled } = this.calcSymbolsLengths(symbol);\n      markerLabel.markers[i].size = markerEnabled || !lineEnabled ? itemMarker.size : 0;\n      dimensionProps.push({ length: markerWidth, spacing });\n      if (markerEnabled || lineEnabled) {\n        paddedSymbolWidth += spacing + markerWidth;\n      }\n    });\n    markerLabel.update(dimensionProps);\n    return paddedSymbolWidth;\n  }\n  truncate(text, maxCharLength, maxItemWidth, paddedMarkerWidth, font, id) {\n    const ellipsis2 = `...`;\n    const textChars = text.split(\"\");\n    let addEllipsis = false;\n    if (text.length > maxCharLength) {\n      text = `${text.substring(0, maxCharLength)}`;\n      addEllipsis = true;\n    }\n    const labelWidth = Math.floor(paddedMarkerWidth + Text.getTextSize(text, font).width);\n    if (labelWidth > maxItemWidth) {\n      let truncatedText = \"\";\n      const characterWidths = this.getCharacterWidths(font);\n      let cumulativeWidth = paddedMarkerWidth + characterWidths[ellipsis2];\n      for (const char of textChars) {\n        if (!characterWidths[char]) {\n          characterWidths[char] = Text.getTextSize(char, font).width;\n        }\n        cumulativeWidth += characterWidths[char];\n        if (cumulativeWidth > maxItemWidth) {\n          break;\n        }\n        truncatedText += char;\n      }\n      text = truncatedText;\n      addEllipsis = true;\n    }\n    if (addEllipsis) {\n      text += ellipsis2;\n      this.truncatedItems.add(id);\n    } else {\n      this.truncatedItems.delete(id);\n    }\n    return text;\n  }\n  updatePagination(bboxes, width, height) {\n    const orientation = this.getOrientation();\n    const trackingIndex = Math.min(this.paginationTrackingIndex, bboxes.length);\n    this.pagination.orientation = orientation;\n    this.pagination.translationX = 0;\n    this.pagination.translationY = 0;\n    const { pages, maxPageHeight, maxPageWidth, paginationBBox, paginationVertical } = this.calculatePagination(\n      bboxes,\n      width,\n      height\n    );\n    const newCurrentPage = pages.findIndex((p) => p.endIndex >= trackingIndex);\n    this.pagination.currentPage = clamp(0, newCurrentPage, pages.length - 1);\n    const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;\n    const paginationComponentPadding = 8;\n    const legendItemsWidth = maxPageWidth - itemPaddingX;\n    const legendItemsHeight = maxPageHeight - itemPaddingY;\n    let paginationX = 0;\n    let paginationY = -paginationBBox.y - this.item.marker.size / 2;\n    if (paginationVertical) {\n      paginationY += legendItemsHeight + paginationComponentPadding;\n    } else {\n      paginationX += -paginationBBox.x + legendItemsWidth + paginationComponentPadding;\n      paginationY += (legendItemsHeight - paginationBBox.height) / 2;\n    }\n    this.pagination.translationX = paginationX;\n    this.pagination.translationY = paginationY;\n    this.pagination.update();\n    this.pagination.updateMarkers();\n    let pageIndex = 0;\n    this.itemSelection.each((markerLabel, _, nodeIndex) => {\n      if (nodeIndex > (pages[pageIndex]?.endIndex ?? Infinity)) {\n        pageIndex++;\n      }\n      markerLabel.pageIndex = pageIndex;\n    });\n    return {\n      maxPageHeight,\n      maxPageWidth,\n      pages\n    };\n  }\n  updatePaginationProxyButtons(oldPages) {\n    this.proxyLegendPagination.style.display = this.pagination.visible ? \"absolute\" : \"none\";\n    const oldNeedsButtons = (oldPages?.length ?? this.pages.length) > 1;\n    const newNeedsButtons = this.pages.length > 1;\n    if (oldNeedsButtons === newNeedsButtons)\n      return;\n    if (newNeedsButtons) {\n      this.proxyPrevButton = this.ctx.proxyInteractionService.createProxyElement({\n        type: \"button\",\n        id: `${this.id}-prev-page`,\n        textContent: { id: \"ariaLabelLegendPagePrevious\" },\n        tabIndex: 0,\n        parent: this.proxyLegendPagination,\n        focusable: this.pagination.previousButton,\n        onclick: () => this.pagination.clickPrevious()\n      });\n      this.proxyNextButton ?? (this.proxyNextButton = this.ctx.proxyInteractionService.createProxyElement({\n        type: \"button\",\n        id: `${this.id}-next-page`,\n        textContent: { id: \"ariaLabelLegendPageNext\" },\n        tabIndex: 0,\n        parent: this.proxyLegendPagination,\n        focusable: this.pagination.nextButton,\n        onclick: () => this.pagination.clickNext()\n      }));\n      const { group, prev, next } = this.pagination.computeCSSBounds();\n      setElementBBox(this.proxyLegendPagination, group);\n      setElementBBox(this.proxyPrevButton, prev);\n      setElementBBox(this.proxyNextButton, next);\n    } else {\n      this.proxyNextButton?.remove();\n      this.proxyPrevButton?.remove();\n      [this.proxyNextButton, this.proxyPrevButton] = [void 0, void 0];\n    }\n  }\n  calculatePagination(bboxes, width, height) {\n    const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;\n    const orientation = this.getOrientation();\n    const paginationVertical = [\"left\", \"right\"].includes(this.position);\n    let paginationBBox = this.pagination.computeBBox();\n    let lastPassPaginationBBox = new BBox(0, 0, 0, 0);\n    let pages = [];\n    let maxPageWidth = 0;\n    let maxPageHeight = 0;\n    let count = 0;\n    const stableOutput = (bbox) => {\n      return bbox.width === paginationBBox.width && bbox.height === paginationBBox.height;\n    };\n    const forceResult = this.maxWidth !== void 0 && this.maxHeight !== void 0;\n    do {\n      if (count++ > 10) {\n        Logger.warn(\"unable to find stable legend layout.\");\n        break;\n      }\n      paginationBBox = lastPassPaginationBBox;\n      const maxWidth = width - (paginationVertical ? 0 : paginationBBox.width);\n      const maxHeight = height - (paginationVertical ? paginationBBox.height : 0);\n      const layout = gridLayout({\n        orientation,\n        bboxes,\n        maxHeight,\n        maxWidth,\n        itemPaddingY,\n        itemPaddingX,\n        forceResult\n      });\n      pages = layout?.pages ?? [];\n      maxPageWidth = layout?.maxPageWidth ?? 0;\n      maxPageHeight = layout?.maxPageHeight ?? 0;\n      const totalPages = pages.length;\n      this.pagination.visible = totalPages > 1;\n      this.pagination.totalPages = totalPages;\n      this.pagination.update();\n      lastPassPaginationBBox = this.pagination.computeBBox();\n      if (!this.pagination.visible) {\n        break;\n      }\n    } while (!stableOutput(lastPassPaginationBBox));\n    return { maxPageWidth, maxPageHeight, pages, paginationBBox, paginationVertical };\n  }\n  updatePositions(pageNumber = 0) {\n    const {\n      item: { paddingY },\n      itemSelection,\n      pages\n    } = this;\n    if (pages.length < 1 || !pages[pageNumber]) {\n      return;\n    }\n    const { columns, startIndex: visibleStart, endIndex: visibleEnd } = pages[pageNumber];\n    let x = 0;\n    let y = 0;\n    const columnCount = columns.length;\n    const rowCount = columns[0].indices.length;\n    const horizontal = this.getOrientation() === \"horizontal\";\n    const itemHeight = columns[0].bboxes[0].height + paddingY;\n    const rowSumColumnWidths = [];\n    itemSelection.each((markerLabel, _, i) => {\n      if (i < visibleStart || i > visibleEnd) {\n        markerLabel.visible = false;\n        return;\n      }\n      const pageIndex = i - visibleStart;\n      let columnIndex = 0;\n      let rowIndex = 0;\n      if (horizontal) {\n        columnIndex = pageIndex % columnCount;\n        rowIndex = Math.floor(pageIndex / columnCount);\n      } else {\n        columnIndex = Math.floor(pageIndex / rowCount);\n        rowIndex = pageIndex % rowCount;\n      }\n      markerLabel.visible = true;\n      const column = columns[columnIndex];\n      if (!column) {\n        return;\n      }\n      y = Math.floor(itemHeight * rowIndex);\n      x = Math.floor(rowSumColumnWidths[rowIndex] ?? 0);\n      rowSumColumnWidths[rowIndex] = (rowSumColumnWidths[rowIndex] ?? 0) + column.columnWidth;\n      markerLabel.translationX = x;\n      markerLabel.translationY = y;\n      const { width, height } = markerLabel.computeBBox();\n      setElementBBox(markerLabel.proxyButton, { x, y, width, height });\n    });\n  }\n  updatePageNumber(pageNumber) {\n    const { pages } = this;\n    const { startIndex, endIndex } = pages[pageNumber];\n    if (startIndex === 0) {\n      this.paginationTrackingIndex = 0;\n    } else if (pageNumber === pages.length - 1) {\n      this.paginationTrackingIndex = endIndex;\n    } else {\n      this.paginationTrackingIndex = Math.floor((startIndex + endIndex) / 2);\n    }\n    this.pagination.update();\n    this.pagination.updateMarkers();\n    this.updatePositions(pageNumber);\n    this.ctx.updateService.update(6 /* SCENE_RENDER */);\n  }\n  update() {\n    const {\n      label: { color }\n    } = this.item;\n    this.itemSelection.each((markerLabel, datum) => {\n      datum.symbols.forEach((symbol, index) => {\n        const marker = markerLabel.markers[index];\n        const line = markerLabel.lines[index];\n        if (marker) {\n          const { strokeWidth, fill, stroke, fillOpacity, strokeOpacity } = this.getMarkerStyles(symbol);\n          marker.fill = fill;\n          marker.stroke = stroke;\n          marker.strokeWidth = strokeWidth;\n          marker.fillOpacity = fillOpacity;\n          marker.strokeOpacity = strokeOpacity;\n        }\n        if (line) {\n          const lineStyles = this.getLineStyles(symbol);\n          line.stroke = lineStyles.stroke;\n          line.strokeOpacity = lineStyles.strokeOpacity;\n          line.strokeWidth = lineStyles.strokeWidth;\n          line.lineDash = lineStyles.lineDash;\n        }\n      });\n      markerLabel.opacity = datum.enabled ? 1 : 0.5;\n      markerLabel.color = color;\n    });\n    this.updateContextMenu();\n  }\n  updateContextMenu() {\n    const { toggleSeries } = this;\n    this.ctx.contextMenuRegistry.setActionVisiblity(ID_LEGEND_VISIBILITY, toggleSeries);\n    this.ctx.contextMenuRegistry.setActionVisiblity(ID_LEGEND_OTHER_SERIES, toggleSeries);\n  }\n  getLineStyles(datum) {\n    const { stroke, strokeOpacity = 1, strokeWidth, lineDash } = datum.line ?? {};\n    const defaultLineStrokeWidth = Math.min(2, strokeWidth ?? 1);\n    return {\n      stroke,\n      strokeOpacity,\n      strokeWidth: this.item.line.strokeWidth ?? defaultLineStrokeWidth,\n      lineDash\n    };\n  }\n  getMarkerStyles(datum) {\n    const { fill, stroke, strokeOpacity = 1, fillOpacity = 1, strokeWidth } = datum.marker;\n    const defaultLineStrokeWidth = Math.min(2, strokeWidth ?? 1);\n    return {\n      fill,\n      stroke,\n      strokeOpacity,\n      fillOpacity,\n      strokeWidth: this.item.marker.strokeWidth ?? defaultLineStrokeWidth\n    };\n  }\n  getDatumForPoint(x, y) {\n    const visibleChildBBoxes = [];\n    const closestLeftTop = { dist: Infinity, datum: void 0 };\n    for (const child of this.group.children) {\n      if (!child.visible)\n        continue;\n      if (!(child instanceof MarkerLabel))\n        continue;\n      const childBBox = child.computeBBox();\n      childBBox.grow(this.item.paddingX / 2, \"horizontal\");\n      childBBox.grow(this.item.paddingY / 2, \"vertical\");\n      if (childBBox.containsPoint(x, y)) {\n        return child.datum;\n      }\n      const distX = x - childBBox.x - this.item.paddingX / 2;\n      const distY = y - childBBox.y - this.item.paddingY / 2;\n      const dist = distX ** 2 + distY ** 2;\n      const toTheLeftTop = distX >= 0 && distY >= 0;\n      if (toTheLeftTop && dist < closestLeftTop.dist) {\n        closestLeftTop.dist = dist;\n        closestLeftTop.datum = child.datum;\n      }\n      visibleChildBBoxes.push(childBBox);\n    }\n    const pageBBox = BBox.merge(visibleChildBBoxes);\n    if (!pageBBox.containsPoint(x, y)) {\n      return;\n    }\n    return closestLeftTop.datum;\n  }\n  computePagedBBox() {\n    const actualBBox = this.group.computeBBox();\n    if (this.pages.length <= 1) {\n      return actualBBox;\n    }\n    const [maxPageWidth, maxPageHeight] = this.maxPageSize;\n    actualBBox.height = Math.max(maxPageHeight, actualBBox.height);\n    actualBBox.width = Math.max(maxPageWidth, actualBBox.width);\n    return actualBBox;\n  }\n  contextToggleVisibility(params) {\n    const datum = this.data.find((v) => v.itemId === params.itemId);\n    this.doClick(datum);\n  }\n  contextToggleOtherSeries(params) {\n    const datum = this.data.find((v) => v.itemId === params.itemId);\n    this.doDoubleClick(datum);\n  }\n  checkContextClick(event) {\n    const legendItem = this.getDatumForPoint(event.offsetX, event.offsetY);\n    if (this.preventHidingAll && this.contextMenuDatum?.enabled && this.getVisibleItemCount() <= 1) {\n      this.ctx.contextMenuRegistry.disableAction(ID_LEGEND_VISIBILITY);\n    } else {\n      this.ctx.contextMenuRegistry.enableAction(ID_LEGEND_VISIBILITY);\n    }\n    this.ctx.contextMenuRegistry.dispatchContext(\"legend\", event, { legendItem });\n  }\n  checkLegendClick(event) {\n    const datum = this.getDatumForPoint(event.offsetX, event.offsetY);\n    if (this.doClick(datum)) {\n      event.preventDefault();\n    }\n  }\n  getVisibleItemCount() {\n    return this.ctx.chartService.series.flatMap((s) => s.getLegendData(\"category\")).filter((d) => d.enabled).length;\n  }\n  doClick(datum) {\n    const {\n      listeners: { legendItemClick },\n      ctx: { chartService, highlightManager },\n      preventHidingAll,\n      toggleSeries\n    } = this;\n    if (!datum) {\n      return false;\n    }\n    const { id, itemId, enabled } = datum;\n    const series = chartService.series.find((s) => s.id === id);\n    if (!series) {\n      return false;\n    }\n    let newEnabled = enabled;\n    if (toggleSeries) {\n      newEnabled = !enabled;\n      if (preventHidingAll && !newEnabled) {\n        const numVisibleItems = this.getVisibleItemCount();\n        if (numVisibleItems < 2) {\n          newEnabled = true;\n        }\n      }\n      const status = newEnabled ? \"ariaAnnounceVisible\" : \"ariaAnnounceHidden\";\n      this.ctx.ariaAnnouncementService.announceValue(status);\n      this.ctx.chartEventManager.legendItemClick(series, itemId, newEnabled, datum.legendItemName);\n    }\n    if (newEnabled) {\n      highlightManager.updateHighlight(this.id, {\n        series,\n        itemId,\n        datum: void 0\n      });\n    } else {\n      highlightManager.updateHighlight(this.id);\n    }\n    this.ctx.updateService.update(2 /* PROCESS_DATA */, { forceNodeDataRefresh: true });\n    legendItemClick?.({ type: \"click\", enabled: newEnabled, itemId, seriesId: series.id });\n    return true;\n  }\n  checkLegendDoubleClick(event) {\n    const datum = this.getDatumForPoint(event.offsetX, event.offsetY);\n    if (this.doDoubleClick(datum)) {\n      event.preventDefault();\n    }\n  }\n  doDoubleClick(datum) {\n    const {\n      listeners: { legendItemDoubleClick },\n      ctx: { chartService },\n      toggleSeries\n    } = this;\n    if (chartService.mode === \"integrated\") {\n      return false;\n    }\n    if (!datum) {\n      return false;\n    }\n    const { id, itemId, seriesId } = datum;\n    const series = chartService.series.find((s) => s.id === id);\n    if (!series) {\n      return false;\n    }\n    if (toggleSeries) {\n      const legendData = chartService.series.flatMap((s) => s.getLegendData(\"category\"));\n      const numVisibleItems = legendData.filter((d) => d.enabled).length;\n      const clickedItem = legendData.find((d) => d.itemId === itemId && d.seriesId === seriesId);\n      this.ctx.chartEventManager.legendItemDoubleClick(\n        series,\n        itemId,\n        clickedItem?.enabled ?? false,\n        numVisibleItems,\n        clickedItem?.legendItemName\n      );\n    }\n    this.ctx.updateService.update(2 /* PROCESS_DATA */, { forceNodeDataRefresh: true });\n    legendItemDoubleClick?.({ type: \"dblclick\", enabled: true, itemId, seriesId: series.id });\n    return true;\n  }\n  handleLegendMouseMove(event) {\n    if (!this.enabled) {\n      return;\n    }\n    const { offsetX, offsetY } = event;\n    event.preventDefault();\n    const datum = this.getDatumForPoint(offsetX, offsetY);\n    this.doHover(event, datum);\n  }\n  doHover(event, datum) {\n    const { toggleSeries, listeners } = this;\n    if (event === void 0 || datum === void 0) {\n      this.ctx.cursorManager.updateCursor(this.id);\n      this.ctx.highlightManager.updateHighlight(this.id);\n      return;\n    }\n    const series = datum ? this.ctx.chartService.series.find((s) => s.id === datum?.id) : void 0;\n    if (datum && this.truncatedItems.has(datum.itemId ?? datum.id)) {\n      const { offsetX, offsetY } = event;\n      this.ctx.tooltipManager.updateTooltip(\n        this.id,\n        { offsetX, offsetY, lastPointerEvent: event, showArrow: false },\n        toTooltipHtml({ content: this.getItemLabel(datum) })\n      );\n    } else {\n      this.ctx.tooltipManager.removeTooltip(this.id);\n    }\n    if (toggleSeries || listeners.legendItemClick != null || listeners.legendItemDoubleClick != null) {\n      this.ctx.cursorManager.updateCursor(this.id, \"pointer\");\n    }\n    if (datum?.enabled && series) {\n      this.ctx.highlightManager.updateHighlight(this.id, {\n        series,\n        itemId: datum?.itemId,\n        datum: void 0\n      });\n    } else {\n      this.ctx.highlightManager.updateHighlight(this.id);\n    }\n  }\n  handleLegendMouseExit(_event) {\n    this.doMouseExit();\n  }\n  doMouseExit() {\n    this.ctx.cursorManager.updateCursor(this.id);\n    this.ctx.tooltipManager.removeTooltip(this.id);\n    if (this.ctx.interactionManager.getState() === 16 /* Default */) {\n      this.ctx.highlightManager.updateHighlight(this.id);\n    }\n  }\n  handleLegendMouseEnter(event) {\n    const {\n      enabled,\n      toggleSeries,\n      listeners: { legendItemClick: clickListener, legendItemDoubleClick: dblclickListener }\n    } = this;\n    const datum = this.getDatumForPoint(event.offsetX, event.offsetY);\n    if (enabled && datum !== void 0 && (toggleSeries || clickListener != null || dblclickListener != null)) {\n      this.ctx.cursorManager.updateCursor(this.id, \"pointer\");\n    }\n  }\n  onLocaleChanged() {\n    this.itemSelection.each(({ proxyButton }, _, i) => {\n      if (proxyButton != null) {\n        proxyButton.textContent = this.getItemAriaText(i);\n      }\n    });\n  }\n  getItemAriaText(nodeIndex, enabled) {\n    const datum = this.data[nodeIndex];\n    const label = datum && this.getItemLabel(datum);\n    enabled ?? (enabled = datum.enabled);\n    const lm = this.ctx.localeManager;\n    if (nodeIndex >= 0 && label) {\n      const index = nodeIndex + 1;\n      const count = this.data.length;\n      const part1 = lm.t(\"ariaLabelLegendItem\", { label, index, count });\n      const part2 = lm.t(enabled ? \"ariaAnnounceVisible\" : \"ariaAnnounceHidden\");\n      return [part1, part2].join(\"\");\n    }\n    return lm.t(\"ariaLabelLegendItemUnknown\");\n  }\n  positionLegend(ctx) {\n    const { shrinkRect } = ctx;\n    const newShrinkRect = shrinkRect.clone();\n    if (!this.enabled || !this.data.length) {\n      return { ...ctx, shrinkRect: newShrinkRect };\n    }\n    const [legendWidth, legendHeight] = this.calculateLegendDimensions(shrinkRect);\n    this.group.translationX = 0;\n    this.group.translationY = 0;\n    const { oldPages } = this.calcLayout(legendWidth, legendHeight);\n    const legendBBox = this.computePagedBBox();\n    const calculateTranslationPerpendicularDimension = () => {\n      switch (this.position) {\n        case \"top\":\n        case \"left\":\n          return 0;\n        case \"bottom\":\n          return shrinkRect.height - legendBBox.height;\n        case \"right\":\n        default:\n          return shrinkRect.width - legendBBox.width;\n      }\n    };\n    if (this.visible) {\n      let translationX;\n      let translationY;\n      switch (this.position) {\n        case \"top\":\n        case \"bottom\":\n          translationX = (shrinkRect.width - legendBBox.width) / 2;\n          translationY = calculateTranslationPerpendicularDimension();\n          newShrinkRect.shrink(legendBBox.height, this.position);\n          break;\n        case \"left\":\n        case \"right\":\n        default:\n          translationX = calculateTranslationPerpendicularDimension();\n          translationY = (shrinkRect.height - legendBBox.height) / 2;\n          newShrinkRect.shrink(legendBBox.width, this.position);\n      }\n      this.group.translationX = Math.floor(-legendBBox.x + shrinkRect.x + translationX);\n      this.group.translationY = Math.floor(-legendBBox.y + shrinkRect.y + translationY);\n      const proxyBBox = this.group.computeTransformedBBox();\n      if (proxyBBox) {\n        setElementBBox(this.proxyLegendToolbar, proxyBBox);\n        this.proxyLegendToolbar.style.removeProperty(\"display\");\n      }\n      this.proxyLegendToolbar.ariaOrientation = this.getOrientation();\n    } else {\n      this.proxyLegendToolbar.style.display = \"none\";\n    }\n    this.updatePaginationProxyButtons(oldPages);\n    if (this.visible && this.enabled && this.data.length) {\n      const legendPadding = this.spacing;\n      newShrinkRect.shrink(legendPadding, this.position);\n      const legendPositionedBBox = legendBBox.clone();\n      legendPositionedBBox.x += this.group.translationX;\n      legendPositionedBBox.y += this.group.translationY;\n    }\n    return { ...ctx, shrinkRect: newShrinkRect };\n  }\n  calculateLegendDimensions(shrinkRect) {\n    const { width, height } = shrinkRect;\n    const aspectRatio = width / height;\n    const maxCoefficient = 0.5;\n    const minHeightCoefficient = 0.2;\n    const minWidthCoefficient = 0.25;\n    let legendWidth, legendHeight;\n    switch (this.position) {\n      case \"top\":\n      case \"bottom\":\n        const heightCoefficient = aspectRatio < 1 ? Math.min(maxCoefficient, minHeightCoefficient * (1 / aspectRatio)) : minHeightCoefficient;\n        legendWidth = this.maxWidth ? Math.min(this.maxWidth, width) : width;\n        legendHeight = this.maxHeight ? Math.min(this.maxHeight, height) : Math.round(height * heightCoefficient);\n        break;\n      case \"left\":\n      case \"right\":\n      default:\n        const widthCoefficient = aspectRatio > 1 ? Math.min(maxCoefficient, minWidthCoefficient * aspectRatio) : minWidthCoefficient;\n        legendWidth = this.maxWidth ? Math.min(this.maxWidth, width) : Math.round(width * widthCoefficient);\n        legendHeight = this.maxHeight ? Math.min(this.maxHeight, height) : height;\n    }\n    return [legendWidth, legendHeight];\n  }\n};\nLegend.className = \"Legend\";\n__decorateClass([\n  Validate(BOOLEAN)\n], Legend.prototype, \"toggleSeries\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Legend.prototype, \"pagination\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Legend.prototype, \"item\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Legend.prototype, \"listeners\", 2);\n__decorateClass([\n  ObserveChanges((target) => target.updateGroupVisibility()),\n  Validate(BOOLEAN)\n], Legend.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITION)\n], Legend.prototype, \"position\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Legend.prototype, \"maxWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Legend.prototype, \"maxHeight\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], Legend.prototype, \"reverseOrder\", 2);\n__decorateClass([\n  Validate(UNION([\"horizontal\", \"vertical\"], \"an orientation\"), { optional: true })\n], Legend.prototype, \"orientation\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], Legend.prototype, \"preventHidingAll\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Legend.prototype, \"spacing\", 2);\n\n// packages/ag-charts-community/src/chart/legendModule.ts\nvar CommunityLegendModule = {\n  type: \"legend\",\n  optionsKey: \"legend\",\n  identifier: \"category\",\n  chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n  instanceConstructor: Legend,\n  packageType: \"community\"\n};\n\n// packages/ag-charts-community/src/chart/locale/locale.ts\nvar Locale = class extends BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.localeText = void 0;\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => {\n    target.ctx.localeManager.setLocaleText(target.localeText);\n  }),\n  Validate(PLAIN_OBJECT, { optional: true })\n], Locale.prototype, \"localeText\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    target.ctx.localeManager.setLocaleTextFormatter(target.getLocaleText);\n  }),\n  Validate(FUNCTION, { optional: true })\n], Locale.prototype, \"getLocaleText\", 2);\n\n// packages/ag-charts-community/src/chart/locale/localeModule.ts\nvar LocaleModule = {\n  type: \"root\",\n  optionsKey: \"locale\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n  instanceConstructor: Locale\n};\n\n// packages/ag-charts-community/src/chart/navigator/shapes/rangeHandle.ts\nvar RangeHandle = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.zIndex = 3;\n    this._fill = \"#f2f2f2\";\n    this._stroke = \"#999999\";\n    this._strokeWidth = 1;\n    this._lineCap = \"square\";\n    this._centerX = 0;\n    this._centerY = 0;\n    this._width = 8;\n    this._gripLineGap = 2;\n    this._gripLineLength = 8;\n    this._height = 16;\n  }\n  set centerX(value) {\n    if (this._centerX !== value) {\n      this._centerX = value;\n      this.dirtyPath = true;\n    }\n  }\n  get centerX() {\n    return this._centerX;\n  }\n  set centerY(value) {\n    if (this._centerY !== value) {\n      this._centerY = value;\n      this.dirtyPath = true;\n    }\n  }\n  get centerY() {\n    return this._centerY;\n  }\n  set width(value) {\n    if (this._width !== value) {\n      this._width = value;\n      this.dirtyPath = true;\n    }\n  }\n  get width() {\n    return this._width;\n  }\n  set gripLineGap(value) {\n    if (this._gripLineGap !== value) {\n      this._gripLineGap = value;\n      this.dirtyPath = true;\n    }\n  }\n  get gripLineGap() {\n    return this._gripLineGap;\n  }\n  set gripLineLength(value) {\n    if (this._gripLineLength !== value) {\n      this._gripLineLength = value;\n      this.dirtyPath = true;\n    }\n  }\n  get gripLineLength() {\n    return this._gripLineLength;\n  }\n  set height(value) {\n    if (this._height !== value) {\n      this._height = value;\n      this.dirtyPath = true;\n    }\n  }\n  get height() {\n    return this._height;\n  }\n  layout(x, y) {\n    this.centerX = x;\n    this.centerY = y;\n  }\n  static align(minHandle, maxHandle, x, y, width, height, min, max) {\n    const handlePixelAlign = minHandle.strokeWidth / 2;\n    const minHandleX = minHandle.align(x + width * min) + handlePixelAlign;\n    const maxHandleX = minHandleX + minHandle.align(x + width * min, width * (max - min)) - 2 * handlePixelAlign;\n    const handleY = minHandle.align(y + height / 2) + handlePixelAlign;\n    minHandle.layout(minHandleX, handleY);\n    maxHandle.layout(maxHandleX, handleY);\n  }\n  computeBBox() {\n    const { centerX, centerY, width, height } = this;\n    const x = centerX - width / 2;\n    const y = centerY - height / 2;\n    return new BBox(x, y, width, height);\n  }\n  computeTransformedBBox() {\n    return super.computeTransformedBBox();\n  }\n  isPointInPath(x, y) {\n    const point = this.transformPoint(x, y);\n    const bbox = this.computeBBox();\n    return bbox.containsPoint(point.x, point.y);\n  }\n  updatePath() {\n    const { centerX, centerY, path, strokeWidth, gripLineGap, gripLineLength } = this;\n    const pixelRatio = this.layerManager?.canvas?.pixelRatio ?? 1;\n    path.clear();\n    const halfWidth = Math.floor(this.width / 2 * pixelRatio) / pixelRatio;\n    const halfHeight = Math.floor(this.height / 2 * pixelRatio) / pixelRatio;\n    path.moveTo(centerX - halfWidth, centerY - halfHeight);\n    path.lineTo(centerX + halfWidth, centerY - halfHeight);\n    path.lineTo(centerX + halfWidth, centerY + halfHeight);\n    path.lineTo(centerX - halfWidth, centerY + halfHeight);\n    path.closePath();\n    const dx = Math.floor((gripLineGap + strokeWidth) / 2 * pixelRatio) / pixelRatio;\n    const dy = Math.floor(gripLineLength / 2 * pixelRatio) / pixelRatio;\n    path.moveTo(centerX - dx, centerY - dy);\n    path.lineTo(centerX - dx, centerY + dy);\n    path.moveTo(centerX + dx, centerY - dy);\n    path.lineTo(centerX + dx, centerY + dy);\n  }\n};\nRangeHandle.className = \"RangeHandle\";\n__decorateClass([\n  Validate(COLOR_STRING)\n], RangeHandle.prototype, \"_fill\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], RangeHandle.prototype, \"_stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], RangeHandle.prototype, \"_strokeWidth\", 2);\n__decorateClass([\n  Validate(LINE_CAP)\n], RangeHandle.prototype, \"_lineCap\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], RangeHandle.prototype, \"_width\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], RangeHandle.prototype, \"_gripLineGap\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], RangeHandle.prototype, \"_gripLineLength\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], RangeHandle.prototype, \"_height\", 2);\n\n// packages/ag-charts-community/src/chart/navigator/shapes/rangeMask.ts\nvar RangeMask = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.zIndex = 2;\n    this.x = 0;\n    this.y = 0;\n    this.width = 200;\n    this.height = 30;\n    this.min = 0;\n    this.max = 1;\n  }\n  layout(x, y, width, height) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.dirtyPath = true;\n  }\n  update(min, max) {\n    this.min = isNaN(min) ? this.min : min;\n    this.max = isNaN(max) ? this.max : max;\n    this.dirtyPath = true;\n  }\n  computeBBox() {\n    const { x, y, width, height } = this;\n    return new BBox(x, y, width, height);\n  }\n  computeVisibleRangeBBox() {\n    const { x, y, width, height, min, max } = this;\n    const minX = x + width * min;\n    const maxX = x + width * max;\n    return new BBox(minX, y, maxX - minX, height);\n  }\n  updatePath() {\n    const { path, x, y, width, height, min, max, strokeWidth } = this;\n    const pixelAlign = strokeWidth / 2;\n    path.clear();\n    const ax = this.align(x) + pixelAlign;\n    const ay = this.align(y) + pixelAlign;\n    const axw = ax + this.align(x, width) - 2 * pixelAlign;\n    const ayh = ay + this.align(y, height) - 2 * pixelAlign;\n    path.moveTo(ax, ay);\n    path.lineTo(axw, ay);\n    path.lineTo(axw, ayh);\n    path.lineTo(ax, ayh);\n    path.closePath();\n    const minX = this.align(x + width * min) + pixelAlign;\n    const maxX = minX + this.align(x + width * min, width * (max - min)) - 2 * pixelAlign;\n    path.moveTo(minX, ay);\n    path.lineTo(minX, ayh);\n    path.lineTo(maxX, ayh);\n    path.lineTo(maxX, ay);\n    path.closePath();\n  }\n};\nRangeMask.className = \"RangeMask\";\n\n// packages/ag-charts-community/src/chart/navigator/shapes/rangeSelector.ts\nvar RangeSelector = class extends Group {\n  constructor(children) {\n    super({ name: \"rangeSelectorGroup\", layer: true, zIndex: 12 /* NAVIGATOR_ZINDEX */ });\n    this.x = 0;\n    this.y = 0;\n    this.width = 200;\n    this.height = 30;\n    this.lOffset = 0;\n    this.rOffset = 0;\n    this.isContainerNode = true;\n    this.background = new Group({ name: \"navigator-background\" });\n    this.background.zIndex = 1;\n    this.appendChild(this.background);\n    this.append(children);\n  }\n  layout(x, y, width, height, lOffset, rOffset) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.lOffset = lOffset;\n    this.rOffset = rOffset;\n    this.background.translationX = x;\n    this.background.translationY = y;\n  }\n  updateBackground(oldGroup, newGroup) {\n    if (oldGroup != null) {\n      this.background.removeChild(oldGroup);\n    }\n    if (newGroup != null) {\n      this.background.appendChild(newGroup);\n    }\n  }\n  computeBBox() {\n    const { x, y, width, height, lOffset, rOffset } = this;\n    return new BBox(x - lOffset, y, width + (lOffset + rOffset), height);\n  }\n};\n\n// packages/ag-charts-community/src/chart/navigator/navigator.ts\nvar Navigator = class extends BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.miniChart = void 0;\n    this.enabled = false;\n    this.mask = new RangeMask();\n    this.minHandle = new RangeHandle();\n    this.maxHandle = new RangeHandle();\n    this.maskVisibleRange = {\n      computeBBox: () => this.mask.computeVisibleRangeBBox(),\n      computeTransformedBBox: () => this.mask.computeVisibleRangeBBox()\n    };\n    this.height = 30;\n    this.spacing = 10;\n    this.x = 0;\n    this.y = 0;\n    this.width = 0;\n    this.rangeSelector = new RangeSelector([this.mask, this.minHandle, this.maxHandle]);\n    this._min = 0;\n    this._max = 1;\n    this.minRange = 1e-3;\n    const region = ctx.regionManager.addRegion(\"navigator\", this.rangeSelector);\n    const dragStates = 16 /* Default */ | 1 /* Animation */ | 8 /* ZoomDrag */;\n    this.destroyFns.push(\n      ctx.scene.attachNode(this.rangeSelector),\n      region.addListener(\"hover\", (event) => this.onHover(event), dragStates),\n      region.addListener(\"drag-start\", (event) => this.onDragStart(event), dragStates),\n      region.addListener(\"drag\", (event) => this.onDrag(event), dragStates),\n      region.addListener(\"drag-end\", () => this.onDragEnd(), dragStates),\n      region.addListener(\"leave\", (event) => this.onLeave(event), dragStates),\n      this.ctx.localeManager.addListener(\"locale-changed\", () => this.updateZoom()),\n      ctx.zoomManager.addListener(\"zoom-change\", (event) => this.onZoomChange(event))\n    );\n    this.proxyNavigatorToolbar = this.ctx.proxyInteractionService.createProxyContainer({\n      type: \"toolbar\",\n      id: `navigator-toolbar`,\n      classList: [\"ag-charts-proxy-navigator-toolbar\"],\n      ariaOrientation: \"vertical\",\n      ariaLabel: { id: \"ariaLabelNavigator\" }\n    });\n    this.updateGroupVisibility();\n    this.proxyNavigatorElements = [\n      this.ctx.proxyInteractionService.createProxyElement({\n        type: \"slider\",\n        id: \"ag-charts-navigator-min\",\n        ariaLabel: { id: \"ariaLabelNavigatorMinimum\" },\n        ariaOrientation: \"horizontal\",\n        parent: this.proxyNavigatorToolbar,\n        focusable: this.minHandle,\n        onchange: (ev) => this.onMinSliderChange(ev)\n      }),\n      this.ctx.proxyInteractionService.createProxyElement({\n        type: \"slider\",\n        id: \"ag-charts-navigator-pan\",\n        ariaLabel: { id: \"ariaLabelNavigatorRange\" },\n        ariaOrientation: \"horizontal\",\n        parent: this.proxyNavigatorToolbar,\n        focusable: this.maskVisibleRange,\n        onchange: (ev) => this.onPanSliderChange(ev)\n      }),\n      this.ctx.proxyInteractionService.createProxyElement({\n        type: \"slider\",\n        id: \"ag-charts-navigator-max\",\n        ariaLabel: { id: \"ariaLabelNavigatorMaximum\" },\n        ariaOrientation: \"horizontal\",\n        parent: this.proxyNavigatorToolbar,\n        focusable: this.maxHandle,\n        onchange: (ev) => this.onMaxSliderChange(ev)\n      })\n    ];\n    initToolbarKeyNav({\n      orientation: \"vertical\",\n      toolbar: this.proxyNavigatorToolbar,\n      buttons: this.proxyNavigatorElements\n    });\n    this.destroyFns.push(() => {\n      this.proxyNavigatorElements.forEach((e) => e.remove());\n      this.proxyNavigatorToolbar.remove();\n    });\n  }\n  updateBackground(oldGroup, newGroup) {\n    this.rangeSelector?.updateBackground(oldGroup, newGroup);\n  }\n  updateGroupVisibility() {\n    const { enabled } = this;\n    if (this.rangeSelector == null || enabled === this.rangeSelector.visible)\n      return;\n    this.rangeSelector.visible = enabled;\n    if (enabled) {\n      this.updateZoom();\n    } else {\n      this.ctx.zoomManager.updateZoom(\"navigator\");\n    }\n  }\n  async performLayout(ctx) {\n    const { shrinkRect } = ctx;\n    if (this.enabled) {\n      const navigatorTotalHeight = this.height + this.spacing;\n      shrinkRect.shrink(navigatorTotalHeight, \"bottom\");\n      this.y = shrinkRect.y + shrinkRect.height + this.spacing;\n    } else {\n      this.y = 0;\n    }\n    return { ...ctx, shrinkRect };\n  }\n  async performCartesianLayout(opts) {\n    const { x, width } = opts.seriesRect;\n    if (this.enabled) {\n      const { y, height } = this;\n      this.layoutNodes(x, y, width, height);\n      setElementBBox(this.proxyNavigatorToolbar, { x, y, width, height });\n      this.proxyNavigatorToolbar.style.removeProperty(\"display\");\n    } else {\n      this.proxyNavigatorToolbar.style.display = \"none\";\n    }\n    this.x = x;\n    this.width = width;\n  }\n  onHover(event) {\n    if (!this.enabled)\n      return;\n    const { mask, minHandle, maxHandle } = this;\n    const { offsetX, offsetY } = event;\n    if (minHandle.containsPoint(offsetX, offsetY) || maxHandle.containsPoint(offsetX, offsetY)) {\n      this.ctx.cursorManager.updateCursor(\"navigator\", \"ew-resize\");\n    } else if (mask.computeVisibleRangeBBox().containsPoint(offsetX, offsetY)) {\n      this.ctx.cursorManager.updateCursor(\"navigator\", \"grab\");\n    } else {\n      this.ctx.cursorManager.updateCursor(\"navigator\");\n    }\n  }\n  onDragStart(event) {\n    if (!this.enabled)\n      return;\n    const { mask, minHandle, maxHandle, x, width, _min: min } = this;\n    const { offsetX, offsetY } = event;\n    if (minHandle.zIndex < maxHandle.zIndex) {\n      if (maxHandle.containsPoint(offsetX, offsetY)) {\n        this.dragging = \"max\";\n      } else if (minHandle.containsPoint(offsetX, offsetY)) {\n        this.dragging = \"min\";\n      }\n    } else if (minHandle.containsPoint(offsetX, offsetY)) {\n      this.dragging = \"min\";\n    } else if (maxHandle.containsPoint(offsetX, offsetY)) {\n      this.dragging = \"max\";\n    }\n    if (this.dragging == null && mask.computeVisibleRangeBBox().containsPoint(offsetX, offsetY)) {\n      this.dragging = \"pan\";\n      this.panStart = (offsetX - x) / width - min;\n    }\n    if (this.dragging != null) {\n      this.ctx.zoomManager.fireZoomPanStartEvent(\"navigator\");\n    }\n  }\n  onDrag(event) {\n    if (!this.enabled || this.dragging == null)\n      return;\n    const { dragging, minRange, panStart, x, width } = this;\n    let { _min: min, _max: max } = this;\n    const { offsetX } = event;\n    const ratio = (offsetX - x) / width;\n    if (dragging === \"min\") {\n      min = clamp(0, ratio, max - minRange);\n    } else if (dragging === \"max\") {\n      max = clamp(min + minRange, ratio, 1);\n    } else if (dragging === \"pan\" && panStart != null) {\n      const span = max - min;\n      min = clamp(0, ratio - panStart, 1 - span);\n      max = min + span;\n    }\n    this._min = min;\n    this._max = max;\n    this.updateZoom();\n  }\n  onDragEnd() {\n    this.dragging = void 0;\n  }\n  onLeave(_event) {\n    this.ctx.cursorManager.updateCursor(\"navigator\");\n  }\n  onZoomChange(event) {\n    const { x } = event;\n    if (!x)\n      return;\n    this._min = x.min;\n    this._max = x.max;\n    this.updateNodes(x.min, x.max);\n  }\n  onPanSliderChange(_event) {\n    const ratio = this.getSliderRatio(this.proxyNavigatorElements[1]);\n    const span = this._max - this._min;\n    this._min = clamp(0, ratio, 1 - span);\n    this._max = this._min + span;\n    this.updateZoom();\n  }\n  onMinSliderChange(_event) {\n    const slider = this.proxyNavigatorElements[0];\n    this._min = this.setSliderRatioClamped(slider, 0, this._max - this.minRange);\n    this.updateZoom();\n  }\n  onMaxSliderChange(_event) {\n    const slider = this.proxyNavigatorElements[2];\n    this._max = this.setSliderRatioClamped(slider, this._min + this.minRange, 1);\n    this.updateZoom();\n  }\n  setPanSliderValue(min, max) {\n    this.proxyNavigatorElements[1].value = `${Math.round(min * 100)}`;\n    this.proxyNavigatorElements[1].ariaValueText = this.ctx.localeManager.t(\"ariaValuePanRange\", { min, max });\n  }\n  setSliderRatioClamped(slider, clampMin, clampMax) {\n    const ratio = this.getSliderRatio(slider);\n    const clampedRatio = clamp(clampMin, ratio, clampMax);\n    if (clampedRatio !== ratio) {\n      this.setSliderRatio(slider, clampedRatio);\n    }\n    return clampedRatio;\n  }\n  setSliderRatio(slider, ratio) {\n    const value = Math.round(ratio * 100);\n    slider.value = `${value}`;\n    slider.ariaValueText = formatPercentage(value);\n  }\n  getSliderRatio(slider) {\n    return parseFloat(slider.value) / 100;\n  }\n  layoutNodes(x, y, width, height) {\n    const { rangeSelector, mask, minHandle, maxHandle, _min: min, _max: max } = this;\n    rangeSelector.layout(x, y, width, height, minHandle.width / 2, maxHandle.width / 2);\n    mask.layout(x, y, width, height);\n    RangeHandle.align(minHandle, maxHandle, x, y, width, height, min, max);\n    if (min + (max - min) / 2 < 0.5) {\n      minHandle.zIndex = 3;\n      maxHandle.zIndex = 4;\n    } else {\n      minHandle.zIndex = 4;\n      maxHandle.zIndex = 3;\n    }\n    [minHandle, this.maskVisibleRange, maxHandle].forEach((node, index) => {\n      const bbox = node.computeBBox();\n      const tbox = { x: bbox.x - x, y: bbox.y - y, height: bbox.height, width: bbox.width };\n      setElementBBox(this.proxyNavigatorElements[index], tbox);\n    });\n  }\n  updateNodes(min, max) {\n    this.mask.update(min, max);\n  }\n  updateZoom() {\n    if (!this.enabled)\n      return;\n    const { _min: min, _max: max } = this;\n    const zoom2 = this.ctx.zoomManager.getZoom();\n    if (min == null || max == null)\n      return;\n    const warnOnConflict = (stateId) => {\n      if (this.min == null && this.max == null)\n        return;\n      Logger.warnOnce(\n        `Could not apply [navigator.min] or [navigator.max] as [${stateId}] has modified the initial zoom state.`\n      );\n    };\n    this.setPanSliderValue(min, max);\n    this.setSliderRatio(this.proxyNavigatorElements[0], min);\n    this.setSliderRatio(this.proxyNavigatorElements[2], max);\n    return this.ctx.zoomManager.updateZoom(\"navigator\", { x: { min, max }, y: zoom2?.y }, false, warnOnConflict);\n  }\n};\n__decorateClass([\n  Validate(OBJECT, { optional: true })\n], Navigator.prototype, \"miniChart\", 2);\n__decorateClass([\n  Validate(BOOLEAN),\n  ObserveChanges((target) => target.updateGroupVisibility())\n], Navigator.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Navigator.prototype, \"height\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Navigator.prototype, \"spacing\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(min) {\n      this._min = min;\n      this.updateZoom();\n    }\n  }),\n  Validate(AND(RATIO, LESS_THAN(\"max\")), { optional: true })\n], Navigator.prototype, \"min\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(max) {\n      this._max = max;\n      this.updateZoom();\n    }\n  }),\n  Validate(AND(RATIO, GREATER_THAN(\"min\")), { optional: true })\n], Navigator.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/chart/navigator/navigatorModule.ts\nvar NavigatorModule = {\n  type: \"root\",\n  optionsKey: \"navigator\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  instanceConstructor: Navigator,\n  themeTemplate: {\n    navigator: {\n      enabled: false,\n      height: 30,\n      mask: {\n        fill: \"#999999\",\n        stroke: \"#999999\",\n        strokeWidth: 1,\n        fillOpacity: 0.2\n      },\n      minHandle: {\n        fill: \"#f2f2f2\",\n        stroke: \"#999999\",\n        strokeWidth: 1,\n        width: 9,\n        height: 16,\n        gripLineGap: 1,\n        gripLineLength: 8\n      },\n      maxHandle: {\n        fill: \"#f2f2f2\",\n        stroke: \"#999999\",\n        strokeWidth: 1,\n        width: 9,\n        height: 16,\n        gripLineGap: 1,\n        gripLineLength: 8\n      }\n    }\n  }\n};\n\n// packages/ag-charts-community/src/module/theme.ts\nfunction singleSeriesPaletteFactory({ takeColors }) {\n  const {\n    fills: [fill],\n    strokes: [stroke]\n  } = takeColors(1);\n  return { fill, stroke };\n}\nfunction markerPaletteFactory(params) {\n  return { marker: singleSeriesPaletteFactory(params) };\n}\n\n// packages/ag-charts-community/src/chart/themes/constants.ts\nvar FONT_SIZE = /* @__PURE__ */ ((FONT_SIZE2) => {\n  FONT_SIZE2[FONT_SIZE2[\"SMALL\"] = 12] = \"SMALL\";\n  FONT_SIZE2[FONT_SIZE2[\"MEDIUM\"] = 13] = \"MEDIUM\";\n  FONT_SIZE2[FONT_SIZE2[\"LARGE\"] = 17] = \"LARGE\";\n  return FONT_SIZE2;\n})(FONT_SIZE || {});\nvar FONT_WEIGHT2 = /* @__PURE__ */ ((FONT_WEIGHT3) => {\n  FONT_WEIGHT3[\"NORMAL\"] = \"normal\";\n  FONT_WEIGHT3[\"BOLD\"] = \"bold\";\n  FONT_WEIGHT3[\"BOLDER\"] = \"bolder\";\n  FONT_WEIGHT3[\"LIGHTER\"] = \"lighter\";\n  return FONT_WEIGHT3;\n})(FONT_WEIGHT2 || {});\nvar POSITION2 = /* @__PURE__ */ ((POSITION3) => {\n  POSITION3[\"TOP\"] = \"top\";\n  POSITION3[\"RIGHT\"] = \"right\";\n  POSITION3[\"BOTTOM\"] = \"bottom\";\n  POSITION3[\"LEFT\"] = \"left\";\n  return POSITION3;\n})(POSITION2 || {});\nvar CARTESIAN_AXIS_TYPE = /* @__PURE__ */ ((CARTESIAN_AXIS_TYPE2) => {\n  CARTESIAN_AXIS_TYPE2[\"CATEGORY\"] = \"category\";\n  CARTESIAN_AXIS_TYPE2[\"ORDINAL_TIME\"] = \"ordinal-time\";\n  CARTESIAN_AXIS_TYPE2[\"NUMBER\"] = \"number\";\n  CARTESIAN_AXIS_TYPE2[\"TIME\"] = \"time\";\n  CARTESIAN_AXIS_TYPE2[\"LOG\"] = \"log\";\n  return CARTESIAN_AXIS_TYPE2;\n})(CARTESIAN_AXIS_TYPE || {});\nvar POLAR_AXIS_TYPE = /* @__PURE__ */ ((POLAR_AXIS_TYPE2) => {\n  POLAR_AXIS_TYPE2[\"ANGLE_CATEGORY\"] = \"angle-category\";\n  POLAR_AXIS_TYPE2[\"ANGLE_NUMBER\"] = \"angle-number\";\n  POLAR_AXIS_TYPE2[\"RADIUS_CATEGORY\"] = \"radius-category\";\n  POLAR_AXIS_TYPE2[\"RADIUS_NUMBER\"] = \"radius-number\";\n  return POLAR_AXIS_TYPE2;\n})(POLAR_AXIS_TYPE || {});\nvar POLAR_AXIS_SHAPE = /* @__PURE__ */ ((POLAR_AXIS_SHAPE2) => {\n  POLAR_AXIS_SHAPE2[\"CIRCLE\"] = \"circle\";\n  POLAR_AXIS_SHAPE2[\"POLYGON\"] = \"polygon\";\n  return POLAR_AXIS_SHAPE2;\n})(POLAR_AXIS_SHAPE || {});\n\n// packages/ag-charts-community/src/chart/themes/symbols.ts\nvar IS_DARK_THEME = Symbol(\"is-dark-theme\");\nvar DEFAULT_FONT_FAMILY = Symbol(\"default-font\");\nvar DEFAULT_LABEL_COLOUR = Symbol(\"default-label-colour\");\nvar DEFAULT_INVERTED_LABEL_COLOUR = Symbol(\"default-inverted-label-colour\");\nvar DEFAULT_INSIDE_SERIES_LABEL_COLOUR = Symbol(\"default-inside-series-label-colour\");\nvar DEFAULT_MUTED_LABEL_COLOUR = Symbol(\"default-muted-label-colour\");\nvar DEFAULT_AXIS_GRID_COLOUR = Symbol(\"default-axis-grid-colour\");\nvar DEFAULT_AXIS_LINE_COLOUR = Symbol(\"default-axis-line-colour\");\nvar DEFAULT_CROSS_LINES_COLOUR = Symbol(\"default-cross-lines-colour\");\nvar DEFAULT_BACKGROUND_COLOUR = Symbol(\"default-background-colour\");\nvar DEFAULT_SHADOW_COLOUR = Symbol(\"default-shadow-colour\");\nvar DEFAULT_COLOURS = Symbol(\"default-colours\");\nvar DEFAULT_PADDING = Symbol(\"default-padding\");\nvar DEFAULT_CAPTION_LAYOUT_STYLE = Symbol(\"default-caption-layout-style\");\nvar DEFAULT_CAPTION_ALIGNMENT = Symbol(\"default-caption-alignment\");\nvar PALETTE_UP_STROKE = Symbol(\"palette-up-stroke\");\nvar PALETTE_DOWN_STROKE = Symbol(\"palette-down-stroke\");\nvar PALETTE_UP_FILL = Symbol(\"palette-up-fill\");\nvar PALETTE_DOWN_FILL = Symbol(\"palette-down-fill\");\nvar PALETTE_NEUTRAL_STROKE = Symbol(\"palette-neutral-stroke\");\nvar PALETTE_NEUTRAL_FILL = Symbol(\"palette-neutral-fill\");\nvar DEFAULT_POLAR_SERIES_STROKE = Symbol(\"default-polar-series-stroke\");\nvar DEFAULT_DIVERGING_SERIES_COLOUR_RANGE = Symbol(\n  \"default-diverging-series-colour-range\"\n);\nvar DEFAULT_HIERARCHY_FILLS = Symbol(\"default-hierarchy-fills\");\nvar DEFAULT_HIERARCHY_STROKES = Symbol(\"default-hierarchy-strokes\");\nvar DEFAULT_ANNOTATION_STROKE = Symbol(\"default-annotation-stroke\");\nvar DEFAULT_ANNOTATION_BACKGROUND_FILL = Symbol(\"default-annotation-background-fill\");\nvar DEFAULT_ANNOTATION_HANDLE_FILL = Symbol(\"default-annotation-handle-fill\");\nvar DEFAULT_TOOLBAR_POSITION = Symbol(\"default-toolbar-position\");\nvar DEFAULT_GRIDLINE_ENABLED = Symbol(\"default-gridline-enabled\");\n\n// packages/ag-charts-community/src/motion/pathMotion.ts\nfunction pathMotion(groupId, subId, animationManager, paths, fns) {\n  const { addPhaseFn, updatePhaseFn, removePhaseFn } = fns;\n  const animate = (phase, path, updateFn) => {\n    animationManager.animate({\n      id: `${groupId}_${subId}_${path.id}_${phase}`,\n      groupId,\n      from: 0,\n      to: 1,\n      ease: easeOut,\n      collapsable: false,\n      onUpdate(ratio, preInit) {\n        if (preInit && phase !== \"removed\")\n          return;\n        path.path.clear(true);\n        updateFn(ratio, path);\n        path.checkPathDirty();\n      },\n      onStop() {\n        if (phase !== \"added\")\n          return;\n        path.path.clear(true);\n        updateFn(1, path);\n        path.checkPathDirty();\n      },\n      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase]\n    });\n  };\n  for (const path of paths) {\n    if (!animationManager.isSkipped()) {\n      animate(\"removed\", path, removePhaseFn);\n      animate(\"updated\", path, updatePhaseFn);\n    }\n    animate(\"added\", path, addPhaseFn);\n  }\n}\n\n// packages/ag-charts-community/src/util/sanitize.ts\nvar element = null;\nfunction sanitizeHtml(text) {\n  if (text == null) {\n    return;\n  } else if (text === \"\") {\n    return \"\";\n  }\n  element ?? (element = createElement(\"div\"));\n  element.textContent = String(text);\n  return element.innerHTML;\n}\n\n// packages/ag-charts-community/src/chart/series/seriesLabelUtil.ts\nfunction seriesLabelFadeInAnimation({ id }, subId, animationManager, ...labelSelections) {\n  staticFromToMotion(\n    id,\n    subId,\n    animationManager,\n    labelSelections,\n    { opacity: 0 },\n    { opacity: 1 },\n    { phase: \"trailing\" }\n  );\n}\nfunction seriesLabelFadeOutAnimation({ id }, subId, animationManager, ...labelSelections) {\n  staticFromToMotion(\n    id,\n    subId,\n    animationManager,\n    labelSelections,\n    { opacity: 1 },\n    { opacity: 0 },\n    { phase: \"remove\" }\n  );\n}\nfunction resetLabelFn(_node) {\n  return { opacity: 1 };\n}\n\n// packages/ag-charts-community/src/scene/util/changeDetectableProperties.ts\nvar ChangeDetectableProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this._dirty = 3 /* MAJOR */;\n  }\n  markDirty(_source, type = 1 /* TRIVIAL */) {\n    if (this._dirty < type) {\n      this._dirty = type;\n    }\n  }\n  markClean(_opts) {\n    this._dirty = 0 /* NONE */;\n  }\n  isDirty() {\n    return this._dirty > 0 /* NONE */;\n  }\n};\n\n// packages/ag-charts-community/src/scene/dropShadow.ts\nvar DropShadow = class extends ChangeDetectableProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.color = \"rgba(0, 0, 0, 0.5)\";\n    this.xOffset = 0;\n    this.yOffset = 0;\n    this.blur = 5;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(COLOR_STRING),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"color\", 2);\n__decorateClass([\n  Validate(NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"xOffset\", 2);\n__decorateClass([\n  Validate(NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"yOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"blur\", 2);\n\n// packages/ag-charts-community/src/chart/series/seriesMarker.ts\nvar MARKER_SHAPE = predicateWithMessage(\n  (value) => isMarkerShape(value) || typeof value === \"function\" && Object.create(value.prototype) instanceof Marker,\n  `a marker shape keyword such as 'circle', 'diamond' or 'square' or an object extending the Marker class`\n);\nvar SeriesMarker = class extends ChangeDetectableProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.shape = Circle;\n    this.size = 6;\n    this.fillOpacity = 1;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n  }\n  getStyle() {\n    const { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity } = this;\n    return { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity };\n  }\n  getDiameter() {\n    return this.size + this.strokeWidth;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(MARKER_SHAPE),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"size\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true }),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"itemStyler\", 2);\n\n// packages/ag-charts-community/src/chart/series/seriesTooltip.ts\nvar SeriesTooltipInteraction = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesTooltipInteraction.prototype, \"enabled\", 2);\nvar SeriesTooltip = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.interaction = new SeriesTooltipInteraction();\n    this.position = new TooltipPosition();\n    this.range = void 0;\n  }\n  toTooltipHtml(defaults, params) {\n    if (this.renderer) {\n      return toTooltipHtml(this.renderer(params), defaults);\n    }\n    return toTooltipHtml(defaults);\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesTooltip.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], SeriesTooltip.prototype, \"showArrow\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], SeriesTooltip.prototype, \"renderer\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesTooltip.prototype, \"interaction\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesTooltip.prototype, \"position\", 2);\n__decorateClass([\n  Validate(INTERACTION_RANGE, { optional: true })\n], SeriesTooltip.prototype, \"range\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/interpolationProperties.ts\nvar INTERPOLATION_TYPE = UNION([\"linear\", \"smooth\", \"step\"], \"a line style\");\nvar INTERPOLATION_STEP_POSITION = UNION([\"start\", \"middle\", \"end\"]);\nvar InterpolationProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.type = \"linear\";\n    this.tension = 1;\n    this.position = \"end\";\n  }\n};\n__decorateClass([\n  Validate(INTERPOLATION_TYPE)\n], InterpolationProperties.prototype, \"type\", 2);\n__decorateClass([\n  Validate(RATIO)\n], InterpolationProperties.prototype, \"tension\", 2);\n__decorateClass([\n  Validate(INTERPOLATION_STEP_POSITION)\n], InterpolationProperties.prototype, \"position\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesProperties.ts\nvar AreaSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.xName = void 0;\n    this.fill = \"#c16068\";\n    this.fillOpacity = 1;\n    this.stroke = \"#874349\";\n    this.strokeWidth = 2;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.interpolation = new InterpolationProperties();\n    this.shadow = new DropShadow();\n    this.marker = new SeriesMarker();\n    this.label = new Label();\n    this.tooltip = new SeriesTooltip();\n    this.connectMissingData = false;\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], AreaSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AreaSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING)\n], AreaSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AreaSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], AreaSeriesProperties.prototype, \"normalizedTo\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], AreaSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], AreaSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], AreaSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AreaSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], AreaSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], AreaSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AreaSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"interpolation\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"tooltip\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AreaSeriesProperties.prototype, \"connectMissingData\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/markerUtil.ts\nfunction markerFadeInAnimation({ id }, animationManager, status, ...markerSelections) {\n  const params = { phase: status ? NODE_UPDATE_STATE_TO_PHASE_MAPPING[status] : \"trailing\" };\n  staticFromToMotion(id, \"markers\", animationManager, markerSelections, { opacity: 0 }, { opacity: 1 }, params);\n  markerSelections.forEach((s) => s.cleanup());\n}\nfunction markerScaleInAnimation({ id }, animationManager, ...markerSelections) {\n  staticFromToMotion(\n    id,\n    \"markers\",\n    animationManager,\n    markerSelections,\n    { scalingX: 0, scalingY: 0 },\n    { scalingX: 1, scalingY: 1 },\n    { phase: \"initial\" }\n  );\n  markerSelections.forEach((s) => s.cleanup());\n}\nfunction markerSwipeScaleInAnimation({ id, nodeDataDependencies }, animationManager, ...markerSelections) {\n  const seriesWidth = nodeDataDependencies.seriesRectWidth;\n  const fromFn = (_, datum) => {\n    const x = datum.midPoint?.x ?? seriesWidth;\n    let delay = clamp(0, inverseEaseOut(x / seriesWidth), 1);\n    if (isNaN(delay)) {\n      delay = 0;\n    }\n    return { scalingX: 0, scalingY: 0, delay, duration: QUICK_TRANSITION, phase: \"initial\" };\n  };\n  const toFn = () => {\n    return { scalingX: 1, scalingY: 1 };\n  };\n  fromToMotion(id, \"markers\", animationManager, markerSelections, { fromFn, toFn });\n}\nfunction resetMarkerFn(_node) {\n  return { opacity: 1, scalingX: 1, scalingY: 1 };\n}\nfunction resetMarkerPositionFn(_node, datum) {\n  return {\n    translationX: datum.point?.x ?? NaN,\n    translationY: datum.point?.y ?? NaN\n  };\n}\nfunction prepareMarkerAnimation(pairMap, parentStatus) {\n  const readFirstPair = (xValue, type) => {\n    const val = pairMap[type][xValue];\n    return Array.isArray(val) ? val[0] : val;\n  };\n  const markerStatus = (datum) => {\n    const { xValue } = datum;\n    if (pairMap.moved[xValue]) {\n      return { point: readFirstPair(xValue, \"moved\"), status: \"updated\" };\n    } else if (pairMap.removed[xValue]) {\n      return { point: readFirstPair(xValue, \"removed\"), status: \"removed\" };\n    } else if (pairMap.added[xValue]) {\n      return { point: readFirstPair(xValue, \"added\"), status: \"added\" };\n    }\n    return { status: \"unknown\" };\n  };\n  const fromFn = (marker, datum) => {\n    const { status, point } = markerStatus(datum);\n    if (status === \"unknown\")\n      return { opacity: 0 };\n    const defaults = {\n      translationX: point?.from?.x ?? marker.translationX,\n      translationY: point?.from?.y ?? marker.translationY,\n      opacity: marker.opacity,\n      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]\n    };\n    if (parentStatus === \"added\") {\n      return {\n        ...defaults,\n        opacity: 0,\n        translationX: point?.to?.x,\n        translationY: point?.to?.y,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[\"added\"]\n      };\n    }\n    if (status === \"added\") {\n      defaults.opacity = 0;\n    }\n    return defaults;\n  };\n  const toFn = (_marker, datum) => {\n    const { status, point } = markerStatus(datum);\n    if (status === \"unknown\")\n      return { opacity: 0 };\n    const defaults = {\n      translationX: datum.point.x,\n      translationY: datum.point.y,\n      opacity: 1,\n      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]\n    };\n    if (status === \"removed\" || parentStatus === \"removed\") {\n      return {\n        ...defaults,\n        translationX: point?.to?.x,\n        translationY: point?.to?.y,\n        opacity: 0,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[\"removed\"]\n      };\n    }\n    return defaults;\n  };\n  return { fromFn, toFn };\n}\nfunction computeMarkerFocusBounds(series, { datumIndex }) {\n  const nodeData = series.getNodeData();\n  if (nodeData === void 0)\n    return void 0;\n  const datum = nodeData[datumIndex];\n  if (datum === void 0 || datum.point === void 0)\n    return void 0;\n  const size = series.getFormattedMarkerStyle(datum).size;\n  const radius = size / 2;\n  const { x, y } = series.contentGroup.inverseTransformPoint(datum.point.x - radius, datum.point.y - radius);\n  return new BBox(x, y, size, size);\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/linePlotter.ts\nfunction plotLinearPoints(path, points, continuePath) {\n  let didMove = continuePath;\n  for (const { x, y } of points) {\n    if (didMove) {\n      path.lineTo(x, y);\n    } else {\n      path.moveTo(x, y);\n      didMove = true;\n    }\n  }\n}\nvar flatnessRatio = 0.05;\nfunction plotSmoothPoints(path, iPoints, tension, continuePath) {\n  const points = Array.isArray(iPoints) ? iPoints : Array.from(iPoints);\n  if (points.length === 0)\n    return;\n  if (continuePath) {\n    path.lineTo(points[0].x, points[0].y);\n  } else {\n    path.moveTo(points[0].x, points[0].y);\n  }\n  if (points.length <= 1)\n    return;\n  const gradients = points.map((c, i) => {\n    const p = i === 0 ? c : points[i - 1];\n    const n = i === points.length - 1 ? c : points[i + 1];\n    const isTerminalPoint = i === 0 || i === points.length - 1;\n    if (Math.sign(p.y - c.y) === Math.sign(n.y - c.y)) {\n      return 0;\n    }\n    if (!isTerminalPoint) {\n      const range3 = Math.abs(p.y - n.y);\n      const prevRatio = Math.abs(c.y - p.y) / range3;\n      const nextRatio = Math.abs(c.y - n.y) / range3;\n      if (prevRatio <= flatnessRatio || 1 - prevRatio <= flatnessRatio || nextRatio <= flatnessRatio || 1 - nextRatio <= flatnessRatio) {\n        return 0;\n      }\n    }\n    return (n.y - p.y) / (n.x - p.x);\n  });\n  if (gradients[1] === 0) {\n    gradients[0] *= 2;\n  }\n  if (gradients[gradients.length - 2] === 0) {\n    gradients[gradients.length - 1] *= 2;\n  }\n  for (let i = 1; i < points.length; i += 1) {\n    const prev = points[i - 1];\n    const prevM = gradients[i - 1];\n    const cur = points[i];\n    const curM = gradients[i];\n    const dx = cur.x - prev.x;\n    const dy = cur.y - prev.y;\n    let dcp1x = dx * tension / 3;\n    let dcp1y = dx * prevM * tension / 3;\n    let dcp2x = dx * tension / 3;\n    let dcp2y = dx * curM * tension / 3;\n    if (curM === 0 && Math.abs(dcp1y) > Math.abs(dy)) {\n      dcp1x *= Math.abs(dy / dcp1y);\n      dcp1y = Math.sign(dcp1y) * Math.abs(dy);\n    }\n    if (prevM === 0 && Math.abs(dcp2y) > Math.abs(dy)) {\n      dcp2x *= Math.abs(dy / dcp2y);\n      dcp2y = Math.sign(dcp2y) * Math.abs(dy);\n    }\n    path.cubicCurveTo(prev.x + dcp1x, prev.y + dcp1y, cur.x - dcp2x, cur.y - dcp2y, cur.x, cur.y);\n  }\n}\nfunction plotStepPoints(path, points, align, continuePath) {\n  let lastPoint;\n  for (const point of points) {\n    if (lastPoint != null) {\n      const directionalAlign = lastPoint.x < point.x ? align : 1 - align;\n      const x = (point.x - lastPoint.x) * directionalAlign + lastPoint.x;\n      path.lineTo(x, lastPoint?.y ?? point.y);\n      path.lineTo(x, point.y);\n      path.lineTo(point.x, point.y);\n    } else if (continuePath) {\n      path.lineTo(point.x, point.y);\n    } else {\n      path.moveTo(point.x, point.y);\n    }\n    lastPoint = point;\n  }\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/pathUtil.ts\nfunction minMax(nodeData) {\n  return nodeData.reduce(\n    ({ min, max }, node) => {\n      if (min == null || min.point.x > node.point.x) {\n        min = node;\n      }\n      if (max == null || max.point.x < node.point.x) {\n        max = node;\n      }\n      return { min, max };\n    },\n    {}\n  );\n}\nfunction intersectionOnLine(a, b, targetX) {\n  const m = (b.y - a.y) / (b.x - a.x);\n  const y = (targetX - a.x) * m + a.y;\n  return { x: targetX, y };\n}\nfunction backfillPathPoint(results, process, skip, processFn) {\n  let prevMarkerIdx = -1, nextMarkerIdx = 0;\n  const toProcess = [];\n  while (nextMarkerIdx < results.length) {\n    if (results[nextMarkerIdx].change === process) {\n      toProcess.push(results[nextMarkerIdx]);\n      nextMarkerIdx++;\n      continue;\n    }\n    if (results[nextMarkerIdx].change === skip) {\n      nextMarkerIdx++;\n      continue;\n    }\n    if (toProcess.length > 0) {\n      processFn(toProcess, prevMarkerIdx, nextMarkerIdx);\n      toProcess.length = 0;\n    }\n    prevMarkerIdx = nextMarkerIdx;\n    nextMarkerIdx++;\n  }\n  if (toProcess.length > 0) {\n    processFn(toProcess, prevMarkerIdx, nextMarkerIdx);\n  }\n}\nfunction backfillPathPointData(result, splitMode) {\n  backfillPathPoint(result, \"out\", \"in\", (toProcess, sIdx, eIdx) => {\n    if (sIdx === -1 && result[eIdx]) {\n      toProcess.forEach((d) => d.to = result[eIdx].from);\n    } else if (eIdx === result.length && result[sIdx]) {\n      toProcess.forEach((d) => d.to = result[sIdx].from);\n    } else if (splitMode === \"intersect\" && result[sIdx]?.from && result[eIdx]?.from) {\n      toProcess.forEach((d) => d.to = intersectionOnLine(result[sIdx].from, result[eIdx].from, d.from.x));\n    } else {\n      toProcess.forEach((d) => d.to = d.from);\n    }\n  });\n  backfillPathPoint(result, \"in\", \"out\", (toProcess, sIdx, eIdx) => {\n    if (sIdx === -1 && result[eIdx]) {\n      toProcess.forEach((d) => d.from = result[eIdx].to);\n    } else if (eIdx === result.length && result[sIdx]) {\n      toProcess.forEach((d) => d.from = result[sIdx].to);\n    } else if (splitMode === \"intersect\" && result[sIdx]?.to && result[eIdx]?.to) {\n      toProcess.forEach((d) => d.from = intersectionOnLine(result[sIdx].to, result[eIdx].to, d.to.x));\n    } else {\n      toProcess.forEach((d) => d.from = d.to);\n    }\n  });\n}\nfunction calculatePoint(from2, to, ratio) {\n  const x1 = isNaN(from2.x) ? to.x : from2.x;\n  const y1 = isNaN(from2.y) ? to.y : from2.y;\n  const xd = to.x - from2.x;\n  const yd = to.y - from2.y;\n  const xr = isNaN(xd) ? 0 : xd * ratio;\n  const yr = isNaN(yd) ? 0 : yd * ratio;\n  return {\n    x: x1 + xr,\n    y: y1 + yr\n  };\n}\nvar lineSteps = {\n  start: 0,\n  middle: 0.5,\n  end: 1\n};\nfunction plotPath(points, path, interpolation, continuePath = false) {\n  const { path: linePath } = path;\n  if (interpolation?.type === \"smooth\") {\n    plotSmoothPoints(linePath, points, interpolation.tension ?? 1, continuePath);\n  } else if (interpolation?.type === \"step\") {\n    plotStepPoints(linePath, points, lineSteps[interpolation.position ?? \"end\"], continuePath);\n  } else {\n    plotLinearPoints(linePath, points, continuePath);\n  }\n}\nfunction splitPairData(pairData, ratios) {\n  let previousTo;\n  let points = void 0;\n  const out = [];\n  const flushCurrent = () => {\n    if (points != null) {\n      out.push(points);\n      points = void 0;\n    }\n  };\n  for (const data of pairData) {\n    const { from: from2, to } = data;\n    const ratio = ratios[data.change];\n    if (ratio == null || from2 == null || to == null)\n      continue;\n    const point = calculatePoint(from2, to, ratio);\n    if (data.moveTo === false) {\n      points ?? (points = []);\n      points.push(point);\n    } else if (data.moveTo === true || !previousTo) {\n      flushCurrent();\n      points = [point];\n    } else if (previousTo) {\n      const moveToRatio = data.moveTo === \"in\" ? ratio : 1 - ratio;\n      const { x: midPointX, y: midPointY } = calculatePoint(previousTo, point, moveToRatio);\n      points ?? (points = []);\n      points.push({ x: midPointX, y: midPointY });\n      flushCurrent();\n      points = [point];\n    }\n    previousTo = point;\n  }\n  flushCurrent();\n  return out;\n}\nfunction renderPartialPath(pairData, ratios, path, interpolation) {\n  splitPairData(pairData, ratios).forEach((points) => {\n    plotPath(points, path, interpolation);\n  });\n}\nfunction pathSwipeInAnimation({ id, visible, nodeDataDependencies }, animationManager, ...paths) {\n  const { seriesRectWidth: width, seriesRectHeight: height } = nodeDataDependencies;\n  staticFromToMotion(\n    id,\n    \"path_properties\",\n    animationManager,\n    paths,\n    { clipX: 0 },\n    { clipX: width },\n    {\n      phase: \"initial\",\n      start: { clipMode: \"normal\", clipY: height, visible },\n      finish: { clipMode: void 0, visible }\n    }\n  );\n}\nfunction pathFadeInAnimation({ id }, subId, animationManager, phase = \"add\", ...selection) {\n  staticFromToMotion(id, subId, animationManager, selection, { opacity: 0 }, { opacity: 1 }, { phase });\n}\nfunction pathFadeOutAnimation({ id }, subId, animationManager, ...selection) {\n  staticFromToMotion(id, subId, animationManager, selection, { opacity: 1 }, { opacity: 0 }, { phase: \"remove\" });\n}\nfunction buildResetPathFn(opts) {\n  return (_node) => {\n    return { opacity: opts.getOpacity(), clipScalingX: 1, clipMode: void 0 };\n  };\n}\nfunction updateClipPath({ nodeDataDependencies }, path) {\n  const toFinite = (value) => isFinite(value) ? value : 0;\n  path.clipX = toFinite(nodeDataDependencies.seriesRectWidth);\n  path.clipY = toFinite(nodeDataDependencies.seriesRectHeight);\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/scaling.ts\nfunction isContinuousScaling(scaling) {\n  return scaling.type === \"continuous\" || scaling.type === \"log\";\n}\nfunction isCategoryScaling(scaling) {\n  return scaling.type === \"category\";\n}\nfunction areEqual(a, b) {\n  return a.domain.length === b.domain.length && a.range.length === b.range.length && a.domain.every((val, index) => val === b.domain[index]) && a.range.every((val, index) => val === b.range[index]);\n}\nfunction areScalingEqual(a, b) {\n  if (a === void 0 || b === void 0) {\n    return a !== void 0 || b !== void 0;\n  }\n  if (isContinuousScaling(a) && isContinuousScaling(b)) {\n    return a.type === b.type && areEqual(a, b);\n  }\n  if (isCategoryScaling(a) && isCategoryScaling(b)) {\n    return areEqual(a, b);\n  }\n  return false;\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineUtil.ts\nfunction* pathRanges(points) {\n  let start = -1;\n  let end = 0;\n  for (const { point } of points) {\n    if (point.moveTo) {\n      const range3 = start >= 0 ? { start, end } : void 0;\n      start = end;\n      end = start;\n      if (range3 !== void 0) {\n        yield range3;\n      }\n    }\n    end += 1;\n  }\n  if (start !== -1) {\n    yield { start, end };\n  }\n}\nfunction* pathRangePoints(points, { start, end }) {\n  for (let i = start; i < end; i += 1) {\n    yield points[i].point;\n  }\n}\nfunction* pathRangePointsReverse(points, { start, end }) {\n  for (let i = end - 1; i >= start; i -= 1) {\n    yield points[i].point;\n  }\n}\nfunction scale(val, scaling) {\n  if (!scaling)\n    return NaN;\n  if (val instanceof Date) {\n    val = val.getTime();\n  }\n  if (scaling.type === \"continuous\" && typeof val === \"number\") {\n    const domainRatio = (val - scaling.domain[0]) / (scaling.domain[1] - scaling.domain[0]);\n    return domainRatio * (scaling.range[1] - scaling.range[0]) + scaling.range[0];\n  }\n  if (scaling.type === \"log\" && typeof val === \"number\") {\n    return scaling.convert(val);\n  }\n  const matchingIndex = scaling.domain.findIndex((d) => d === val);\n  if (matchingIndex >= 0) {\n    return scaling.range[matchingIndex];\n  }\n  return NaN;\n}\nfunction scalesChanged(newData, oldData) {\n  return !areScalingEqual(newData.scales.x, oldData.scales.x) || !areScalingEqual(newData.scales.y, oldData.scales.y);\n}\nfunction closeMatch(a, b) {\n  const an = Number(a);\n  const bn = Number(b);\n  if (!isNaN(an) && !isNaN(bn)) {\n    return Math.abs(bn - an) < 0.25;\n  }\n  return a === b;\n}\nfunction calculateMoveTo(from2 = false, to = false) {\n  if (from2 === to) {\n    return Boolean(from2);\n  }\n  return from2 ? \"in\" : \"out\";\n}\nfunction pairContinuousData(newData, oldData, opts = {}) {\n  const { backfillSplitMode = \"intersect\" } = opts;\n  const toNewScale = (oldDatum) => {\n    return {\n      x: scale(oldDatum.xValue ?? NaN, newData.scales.x),\n      y: scale(oldDatum.yValue ?? NaN, newData.scales.y)\n    };\n  };\n  const toOldScale = (newDatum) => {\n    return {\n      x: scale(newDatum.xValue ?? NaN, oldData.scales.x),\n      y: scale(newDatum.yValue ?? NaN, oldData.scales.y)\n    };\n  };\n  const result = [];\n  const resultMap = {\n    added: {},\n    moved: {},\n    removed: {}\n  };\n  const pairUp = (from2, to, xValue, change = \"move\") => {\n    if (from2 && (isNaN(from2.point.x) || isNaN(from2.point.y))) {\n      from2 = to;\n    }\n    const resultPoint = {\n      from: from2?.point,\n      to: to?.point,\n      moveTo: calculateMoveTo(from2?.point.moveTo, to?.point.moveTo),\n      change\n    };\n    if (change === \"move\") {\n      resultMap.moved[xValue] = resultPoint;\n      oldIdx++;\n      newIdx++;\n    } else if (change === \"in\") {\n      resultMap.added[xValue] = resultPoint;\n      newIdx++;\n    } else if (change === \"out\") {\n      resultMap.removed[xValue] = resultPoint;\n      oldIdx++;\n    }\n    result.push(resultPoint);\n  };\n  const { min: minFromNode, max: maxFromNode } = minMax(oldData.nodeData);\n  const { min: minToNode, max: maxToNode } = minMax(newData.nodeData);\n  let oldIdx = 0;\n  let newIdx = 0;\n  while (oldIdx < oldData.nodeData.length || newIdx < newData.nodeData.length) {\n    const from2 = oldData.nodeData[oldIdx];\n    const to = newData.nodeData[newIdx];\n    const fromShifted = from2 ? toNewScale(from2) : void 0;\n    const toUnshifted = to ? toOldScale(to) : void 0;\n    const NA = void 0;\n    if (fromShifted && closeMatch(fromShifted.x, to?.point.x)) {\n      pairUp(from2, to, to.xValue, \"move\");\n    } else if (fromShifted && fromShifted.x < (minToNode?.point.x ?? -Infinity)) {\n      pairUp(from2, NA, from2.xValue, \"out\");\n    } else if (fromShifted && fromShifted.x > (maxToNode?.point.x ?? Infinity)) {\n      pairUp(from2, NA, from2.xValue, \"out\");\n    } else if (toUnshifted && toUnshifted.x < (minFromNode?.point.x ?? -Infinity)) {\n      pairUp(NA, to, to.xValue, \"in\");\n    } else if (toUnshifted && toUnshifted.x > (maxFromNode?.point.x ?? Infinity)) {\n      pairUp(NA, to, to.xValue, \"in\");\n    } else if (fromShifted && fromShifted.x < to?.point.x) {\n      pairUp(from2, NA, from2.xValue, \"out\");\n    } else if (toUnshifted && toUnshifted.x < from2?.point.x) {\n      pairUp(NA, to, to.xValue, \"in\");\n    } else if (from2) {\n      pairUp(from2, NA, from2.xValue, \"out\");\n    } else if (to) {\n      pairUp(NA, to, to.xValue, \"in\");\n    } else {\n      throw new Error(\"Unable to process points\");\n    }\n  }\n  backfillPathPointData(result, backfillSplitMode);\n  return { result, resultMap };\n}\nfunction pairCategoryData(newData, oldData, diff2, opts = {}) {\n  const { backfillSplitMode = \"intersect\", multiDatum = false } = opts;\n  const result = [];\n  const resultMapSingle = {\n    added: {},\n    moved: {},\n    removed: {}\n  };\n  const resultMapMulti = {\n    added: {},\n    moved: {},\n    removed: {}\n  };\n  const pointResultMapping = {\n    in: \"added\",\n    move: \"moved\",\n    out: \"removed\"\n  };\n  let previousResultPoint = void 0;\n  let previousXValue = void 0;\n  const addToResultMap = (xValue, newPoint) => {\n    var _a;\n    const type = pointResultMapping[newPoint.change];\n    if (multiDatum) {\n      (_a = resultMapMulti[type])[xValue] ?? (_a[xValue] = []);\n      resultMapMulti[type][xValue].push(newPoint);\n    } else {\n      resultMapSingle[type][xValue] = newPoint;\n    }\n    previousResultPoint = newPoint;\n    previousXValue = transformIntegratedCategoryValue(xValue);\n  };\n  let oldIndex = 0;\n  let newIndex = 0;\n  let isXUnordered = false;\n  while (oldIndex < oldData.nodeData.length || newIndex < newData.nodeData.length) {\n    const before = oldData.nodeData[oldIndex];\n    const after = newData.nodeData[newIndex];\n    const bXValue = transformIntegratedCategoryValue(before?.xValue);\n    const aXValue = transformIntegratedCategoryValue(after?.xValue);\n    let resultPoint;\n    if (bXValue === aXValue) {\n      resultPoint = {\n        change: \"move\",\n        moveTo: calculateMoveTo(before.point.moveTo ?? false, after.point.moveTo),\n        from: before.point,\n        to: after.point\n      };\n      addToResultMap(before?.xValue, resultPoint);\n      oldIndex++;\n      newIndex++;\n    } else if (diff2?.removed.has(String(bXValue))) {\n      resultPoint = {\n        change: \"out\",\n        moveTo: before.point.moveTo ?? false,\n        from: before.point\n      };\n      addToResultMap(before?.xValue, resultPoint);\n      oldIndex++;\n    } else if (diff2?.added.has(String(aXValue))) {\n      resultPoint = {\n        change: \"in\",\n        moveTo: after.point.moveTo ?? false,\n        to: after.point\n      };\n      addToResultMap(after?.xValue, resultPoint);\n      newIndex++;\n    } else if (multiDatum && previousResultPoint && previousXValue === bXValue) {\n      resultPoint = {\n        ...previousResultPoint\n      };\n      addToResultMap(before?.xValue, resultPoint);\n      oldIndex++;\n    } else if (multiDatum && previousResultPoint && previousXValue === aXValue) {\n      resultPoint = {\n        ...previousResultPoint\n      };\n      addToResultMap(after?.xValue, resultPoint);\n      newIndex++;\n    } else {\n      isXUnordered = true;\n      break;\n    }\n    result.push(resultPoint);\n  }\n  let previousX = -Infinity;\n  isXUnordered || (isXUnordered = result.some((pathPoint) => {\n    const { change: marker, to: { x = -Infinity } = {} } = pathPoint;\n    if (marker === \"out\")\n      return;\n    const unordered = x < previousX;\n    previousX = x;\n    return unordered;\n  }));\n  if (isXUnordered) {\n    return { result: void 0, resultMap: void 0 };\n  }\n  backfillPathPointData(result, backfillSplitMode);\n  return { result, resultMap: multiDatum ? resultMapMulti : resultMapSingle };\n}\nfunction determinePathStatus(newData, oldData, pairData) {\n  let status = \"updated\";\n  const visible = (data) => {\n    return data.visible;\n  };\n  if (!visible(oldData) && visible(newData)) {\n    status = \"added\";\n  } else if (visible(oldData) && !visible(newData)) {\n    status = \"removed\";\n  } else {\n    for (let i = 0; i < pairData.length; i++) {\n      if (pairData[i].change !== \"move\")\n        break;\n      if (pairData[i].from?.x !== pairData[i].to?.x)\n        break;\n      if (pairData[i].from?.y !== pairData[i].to?.y)\n        break;\n      if (i === pairData.length - 1)\n        return \"no-op\";\n    }\n  }\n  return status;\n}\nfunction prepareLinePathPropertyAnimation(status, visibleToggleMode) {\n  const phase = visibleToggleMode === \"none\" ? \"updated\" : status;\n  const result = {\n    fromFn: (_path) => {\n      let mixin;\n      if (status === \"removed\") {\n        mixin = { finish: { visible: false } };\n      } else if (status === \"added\") {\n        mixin = { start: { visible: true } };\n      } else {\n        mixin = {};\n      }\n      return { phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase], ...mixin };\n    },\n    toFn: (_path) => {\n      return { phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase] };\n    }\n  };\n  if (visibleToggleMode === \"fade\") {\n    return {\n      fromFn: (path) => {\n        const opacity = status === \"added\" ? 0 : path.opacity;\n        return { opacity, ...result.fromFn(path) };\n      },\n      toFn: (path) => {\n        const opacity = status === \"removed\" ? 0 : 1;\n        return { opacity, ...result.toFn(path) };\n      }\n    };\n  }\n  return result;\n}\nfunction prepareLinePathAnimationFns(newData, oldData, pairData, visibleToggleMode, interpolation, render) {\n  const status = determinePathStatus(newData, oldData, pairData);\n  const removePhaseFn = (ratio, path) => {\n    render(pairData, { move: 0, out: ratio }, path, interpolation);\n  };\n  const updatePhaseFn = (ratio, path) => {\n    render(pairData, { move: ratio }, path, interpolation);\n  };\n  const addPhaseFn = (ratio, path) => {\n    render(pairData, { move: 1, in: ratio }, path, interpolation);\n  };\n  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);\n  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };\n}\nfunction prepareLinePathAnimation(newData, oldData, diff2, interpolation) {\n  const isCategoryBased = newData.scales.x?.type === \"category\";\n  const wasCategoryBased = oldData.scales.x?.type === \"category\";\n  if (isCategoryBased !== wasCategoryBased) {\n    return;\n  }\n  const { result: pairData, resultMap: pairMap } = isCategoryBased ? pairCategoryData(newData, oldData, diff2) : pairContinuousData(newData, oldData);\n  let status = \"updated\";\n  if (oldData.visible && !newData.visible) {\n    status = \"removed\";\n  } else if (!oldData.visible && newData.visible) {\n    status = \"added\";\n  }\n  if (pairData === void 0 || pairMap === void 0) {\n    return;\n  }\n  const hasMotion = (diff2?.changed ?? true) || scalesChanged(newData, oldData) || status !== \"updated\";\n  const pathFns = prepareLinePathAnimationFns(newData, oldData, pairData, \"fade\", interpolation, renderPartialPath);\n  const marker = prepareMarkerAnimation(pairMap, status);\n  return { ...pathFns, marker, hasMotion };\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaUtil.ts\nvar AreaSeriesTag = /* @__PURE__ */ ((AreaSeriesTag2) => {\n  AreaSeriesTag2[AreaSeriesTag2[\"Fill\"] = 0] = \"Fill\";\n  AreaSeriesTag2[AreaSeriesTag2[\"Stroke\"] = 1] = \"Stroke\";\n  AreaSeriesTag2[AreaSeriesTag2[\"Marker\"] = 2] = \"Marker\";\n  AreaSeriesTag2[AreaSeriesTag2[\"Label\"] = 3] = \"Label\";\n  return AreaSeriesTag2;\n})(AreaSeriesTag || {});\nfunction splitFillPoints(context) {\n  const { points, phantomPoints } = context.fillData;\n  return { top: points, bottom: phantomPoints };\n}\nfunction prepPoints(key, ctx, points) {\n  return {\n    scales: ctx.scales,\n    nodeData: points[key],\n    visible: ctx.visible\n  };\n}\nfunction pairFillCategoryData(newData, oldData, diff2) {\n  const oldPoints = splitFillPoints(oldData);\n  const newPoints = splitFillPoints(newData);\n  const pairOpts = { multiDatum: true };\n  return {\n    top: pairCategoryData(\n      prepPoints(\"top\", newData, newPoints),\n      prepPoints(\"top\", oldData, oldPoints),\n      diff2,\n      pairOpts\n    ),\n    bottom: pairCategoryData(\n      prepPoints(\"bottom\", newData, newPoints),\n      prepPoints(\"bottom\", oldData, oldPoints),\n      diff2,\n      pairOpts\n    )\n  };\n}\nfunction pairFillContinuousData(newData, oldData) {\n  const oldPoints = splitFillPoints(oldData);\n  const newPoints = splitFillPoints(newData);\n  return {\n    top: pairContinuousData(prepPoints(\"top\", newData, newPoints), prepPoints(\"top\", oldData, oldPoints)),\n    bottom: pairContinuousData(prepPoints(\"bottom\", newData, newPoints), prepPoints(\"bottom\", oldData, oldPoints))\n  };\n}\nfunction areaPathRenderer(topPairData, bottomPairData, ratios, path, interpolation) {\n  const topPaths = splitPairData(topPairData, ratios);\n  const bottomPaths = splitPairData(bottomPairData, ratios);\n  if (topPaths.length !== bottomPaths.length)\n    return;\n  for (let i = 0; i < topPaths.length; i += 1) {\n    const topPoints = topPaths[i];\n    const bottomPoints = bottomPaths[i].reverse();\n    plotPath(topPoints, path, interpolation, false);\n    plotPath(bottomPoints, path, interpolation, true);\n    path.path.closePath();\n  }\n}\nfunction prepareAreaPathAnimationFns(newData, oldData, topPairData, bottomPairData, visibleToggleMode, interpolation) {\n  const status = determinePathStatus(newData, oldData, topPairData);\n  const removePhaseFn = (ratio, path) => {\n    areaPathRenderer(topPairData, bottomPairData, { move: 0, out: ratio }, path, interpolation);\n  };\n  const updatePhaseFn = (ratio, path) => {\n    areaPathRenderer(topPairData, bottomPairData, { move: ratio }, path, interpolation);\n  };\n  const addPhaseFn = (ratio, path) => {\n    areaPathRenderer(topPairData, bottomPairData, { move: 1, in: ratio }, path, interpolation);\n  };\n  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);\n  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };\n}\nfunction prepareAreaPathAnimation(newData, oldData, diff2, interpolation) {\n  const isCategoryBased = newData.scales.x?.type === \"category\";\n  const wasCategoryBased = oldData.scales.x?.type === \"category\";\n  if (isCategoryBased !== wasCategoryBased) {\n    return;\n  }\n  let status = \"updated\";\n  if (oldData.visible && !newData.visible) {\n    status = \"removed\";\n  } else if (!oldData.visible && newData.visible) {\n    status = \"added\";\n  }\n  const prepareMarkerPairs = () => {\n    if (isCategoryBased) {\n      return pairCategoryData(newData, oldData, diff2, { backfillSplitMode: \"static\", multiDatum: true });\n    }\n    return pairContinuousData(newData, oldData, { backfillSplitMode: \"static\" });\n  };\n  const prepareFillPairs = () => {\n    if (isCategoryBased) {\n      return pairFillCategoryData(newData, oldData, diff2);\n    }\n    return pairFillContinuousData(newData, oldData);\n  };\n  const { resultMap: markerPairMap } = prepareMarkerPairs();\n  const { top, bottom } = prepareFillPairs();\n  if (markerPairMap === void 0 || top.result === void 0 || bottom.result === void 0) {\n    return;\n  }\n  const topData = top.result;\n  const bottomData = bottom.result;\n  const stackVisible = oldData.stackVisible ? newData.stackVisible : false;\n  const fadeMode = stackVisible ? \"none\" : \"fade\";\n  const fill = prepareAreaPathAnimationFns(newData, oldData, topData, bottomData, fadeMode, interpolation);\n  const marker = prepareMarkerAnimation(markerPairMap, status);\n  return { status: fill.status, fill, marker };\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaSeries.ts\nvar AreaSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pathsPerSeries: 2,\n      pathsZIndexSubOrderOffset: [0, 1e3],\n      hasMarkers: true,\n      markerSelectionGarbageCollection: false,\n      pickModes: [1 /* NEAREST_BY_MAIN_AXIS_FIRST */, 0 /* EXACT_SHAPE_MATCH */],\n      animationResetFns: {\n        path: buildResetPathFn({ getOpacity: () => this.getOpacity() }),\n        label: resetLabelFn,\n        marker: (node, datum) => ({ ...resetMarkerFn(node), ...resetMarkerPositionFn(node, datum) })\n      }\n    });\n    this.properties = new AreaSeriesProperties();\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    const { data, visible, seriesGrouping: { groupIndex = this.id, stackCount = 1 } = {} } = this;\n    const { xKey, yKey, connectMissingData, normalizedTo } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const currentIds = {\n      value: `area-stack-${groupIndex}-yValue`,\n      values: `area-stack-${groupIndex}-yValues`,\n      valuesTrailing: `area-stack-${groupIndex}-yValues-trailing`,\n      marker: `area-stack-${groupIndex}-yValues-marker`\n    };\n    const prevIds = {\n      values: `area-stack-${groupIndex}-yValues-prev`,\n      valuesTrailing: `area-stack-${groupIndex}-yValues-trailing-prev`\n    };\n    const extraProps = [];\n    if (isDefined(normalizedTo)) {\n      extraProps.push(normaliseGroupTo(Object.values(currentIds), normalizedTo, \"range\"));\n      extraProps.push(normaliseGroupTo(Object.values(prevIds), normalizedTo, \"range\"));\n    }\n    if (!isContinuousX && animationEnabled && this.processedData) {\n      extraProps.push(diff(this.processedData));\n    }\n    if (animationEnabled) {\n      extraProps.push(animationValidation());\n    }\n    const common = { invalidValue: null };\n    if (connectMissingData && stackCount > 1) {\n      common.invalidValue = 0;\n    }\n    if (!visible) {\n      common.forceValue = 0;\n    }\n    await this.requestDataModel(dataController, data, {\n      props: [\n        keyProperty(xKey, xScaleType, { id: \"xValue\" }),\n        valueProperty(yKey, yScaleType, { id: `yValueRaw`, ...common }),\n        ...groupAccumulativeContinuityProperty(yKey, {\n          id: \"yValueContinuity\",\n          ...common,\n          groupId: `area-stack-${groupIndex}-yValues-continuity`\n        }),\n        valueProperty(yKey, yScaleType, {\n          id: `yValue`,\n          ...common,\n          groupId: currentIds.value\n        }),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"window-trailing\",\n          \"current\",\n          {\n            id: `yValueStart`,\n            ...common,\n            groupId: currentIds.valuesTrailing\n          },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"window\",\n          \"current\",\n          {\n            id: `yValueEnd`,\n            ...common,\n            groupId: currentIds.values\n          },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"normal\",\n          \"current\",\n          {\n            id: `yValueCumulative`,\n            ...common,\n            groupId: currentIds.marker\n          },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"window\",\n          \"last\",\n          {\n            id: `yValuePreviousEnd`,\n            ...common,\n            groupId: prevIds.values\n          },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"window-trailing\",\n          \"last\",\n          {\n            id: `yValuePreviousStart`,\n            ...common,\n            groupId: prevIds.valuesTrailing\n          },\n          yScaleType\n        ),\n        ...extraProps\n      ],\n      groupByKeys: true,\n      groupByData: false\n    });\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel, axes } = this;\n    if (!processedData || !dataModel || processedData.data.length === 0)\n      return [];\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n    const keys = dataModel.getDomain(this, `xValue`, \"key\", processedData);\n    const yExtent = dataModel.getDomain(this, `yValueEnd`, \"value\", processedData);\n    if (direction === \"x\" /* X */) {\n      if (keyDef?.def.type === \"key\" && keyDef.def.valueType === \"category\") {\n        return keys;\n      }\n      return fixNumericExtent(extent(keys), xAxis);\n    } else if (yAxis instanceof LogAxis || yAxis instanceof TimeAxis) {\n      return fixNumericExtent(yExtent, yAxis);\n    } else {\n      const fixedYExtent = [yExtent[0] > 0 ? 0 : yExtent[0], yExtent[1] < 0 ? 0 : yExtent[1]];\n      return fixNumericExtent(fixedYExtent, yAxis);\n    }\n  }\n  async createNodeData() {\n    const { axes, data, processedData: { data: groupedData } = {}, dataModel } = this;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!xAxis || !yAxis || !data || !dataModel || !this.properties.isValid()) {\n      return;\n    }\n    const {\n      yKey,\n      xKey,\n      marker,\n      label,\n      fill: seriesFill,\n      stroke: seriesStroke,\n      connectMissingData\n    } = this.properties;\n    const { scale: xScale } = xAxis;\n    const { scale: yScale } = yAxis;\n    const { isContinuousY } = this.getScaleInformation({ xScale, yScale });\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const defs = dataModel.resolveProcessedDataDefsByIds(this, [\n      `yValueStart`,\n      `yValueEnd`,\n      `yValueRaw`,\n      `yValuePreviousStart`,\n      `yValuePreviousEnd`,\n      `yValueCumulative`,\n      `yValueContinuity`,\n      `yValue`\n    ]);\n    const createMarkerCoordinate = (xDatum, yEnd, rawYDatum) => {\n      let currY;\n      if (isDefined(this.properties.normalizedTo) ? isContinuousY && isContinuous(rawYDatum) : !isNaN(rawYDatum)) {\n        currY = yEnd;\n      }\n      return {\n        x: xScale.convert(xDatum) + xOffset,\n        y: yScale.convert(currY),\n        size: marker.size\n      };\n    };\n    const itemId = yKey;\n    const labelData = [];\n    const markerData = [];\n    const { visibleSameStackCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);\n    const context = {\n      itemId,\n      fillData: { itemId, points: [], phantomPoints: [] },\n      strokeData: { itemId, points: [] },\n      labelData,\n      nodeData: markerData,\n      scales: this.calculateScaling(),\n      visible: this.visible,\n      stackVisible: visibleSameStackCount > 0\n    };\n    const fillPoints = context.fillData.points;\n    const fillPhantomPoints = context.fillData.phantomPoints;\n    const strokePoints = context.strokeData.points;\n    let datumIdx = -1;\n    let lastXDatum;\n    let lastYValueContinuity;\n    let moveTo = true;\n    groupedData?.forEach((datumGroup) => {\n      const {\n        keys,\n        keys: [xDatum],\n        datum: datumArray,\n        values: valuesArray\n      } = datumGroup;\n      valuesArray.forEach((values, valueIdx) => {\n        datumIdx++;\n        const seriesDatum = datumArray[valueIdx];\n        const dataValues = dataModel.resolveProcessedDataDefsValues(defs, { keys, values });\n        const { yValueRaw: yDatum, yValueCumulative, yValueContinuity } = dataValues;\n        const { yValueStart, yValueEnd, yValuePreviousStart, yValuePreviousEnd, yValue } = dataValues;\n        const validPoint = yDatum != null;\n        const point = createMarkerCoordinate(xDatum, +yValueCumulative, yDatum);\n        if (validPoint && marker) {\n          markerData.push({\n            index: datumIdx,\n            series: this,\n            itemId,\n            datum: seriesDatum,\n            midPoint: { x: point.x, y: point.y },\n            cumulativeValue: yValueEnd,\n            yValue: yDatum,\n            xValue: xDatum,\n            yKey,\n            xKey,\n            point,\n            fill: marker.fill ?? seriesFill,\n            stroke: marker.stroke ?? seriesStroke,\n            strokeWidth: marker.strokeWidth ?? this.getStrokeWidth(this.properties.strokeWidth)\n          });\n        }\n        if (validPoint && label) {\n          const labelText = this.getLabelText(\n            label,\n            {\n              value: yDatum,\n              datum: seriesDatum,\n              xKey,\n              yKey,\n              xName: this.properties.xName,\n              yName: this.properties.yName\n            },\n            (value) => isFiniteNumber(value) ? value.toFixed(2) : String(value)\n          );\n          labelData.push({\n            index: datumIdx,\n            series: this,\n            itemId: yKey,\n            datum: seriesDatum,\n            x: point.x,\n            y: point.y,\n            label: labelText ? {\n              text: labelText,\n              fontStyle: label.fontStyle,\n              fontWeight: label.fontWeight,\n              fontSize: label.fontSize,\n              fontFamily: label.fontFamily,\n              textAlign: \"center\",\n              textBaseline: \"bottom\",\n              fill: label.color\n            } : void 0\n          });\n        }\n        if (validPoint || !connectMissingData) {\n          if (!validPoint) {\n            moveTo = true;\n          }\n          const willDrawLine = !moveTo && !connectMissingData;\n          if (willDrawLine && lastYValueContinuity === false && yValueContinuity === true) {\n            fillPoints.push({\n              point: {\n                x: point.x,\n                y: yScale.convert(yValueEnd),\n                moveTo: false\n              },\n              yValue: yDatum,\n              xValue: xDatum\n            });\n            fillPhantomPoints.push({\n              point: {\n                x: point.x,\n                y: yScale.convert(yValueStart),\n                moveTo: false\n              },\n              yValue: yDatum,\n              xValue: xDatum\n            });\n            strokePoints.push({\n              point: {\n                x: point.x,\n                y: yScale.convert(yValueEnd),\n                moveTo: false\n              },\n              yValue: yDatum,\n              xValue: xDatum\n            });\n            moveTo = true;\n          } else if (willDrawLine && lastYValueContinuity === true && yValueContinuity === false) {\n            fillPoints.push({\n              point: {\n                x: xScale.convert(lastXDatum) + xOffset,\n                y: yScale.convert(yValuePreviousEnd),\n                moveTo: true\n              },\n              yValue: yDatum,\n              xValue: xDatum\n            });\n            fillPhantomPoints.push({\n              point: {\n                x: xScale.convert(lastXDatum) + xOffset,\n                y: yScale.convert(yValuePreviousStart),\n                moveTo: true\n              },\n              yValue: yDatum,\n              xValue: xDatum\n            });\n            strokePoints.push({\n              point: {\n                x: xScale.convert(lastXDatum) + xOffset,\n                y: yScale.convert(yValuePreviousEnd),\n                moveTo: true\n              },\n              yValue: yDatum,\n              xValue: xDatum\n            });\n            moveTo = false;\n          }\n          fillPoints.push({\n            point: {\n              x: point.x,\n              y: yScale.convert(yValueCumulative),\n              moveTo\n            },\n            yValue: yDatum,\n            xValue: xDatum\n          });\n          fillPhantomPoints.push({\n            point: {\n              x: point.x,\n              y: yScale.convert(yValueCumulative - yValue),\n              moveTo\n            },\n            yValue: yDatum,\n            xValue: xDatum\n          });\n          strokePoints.push({\n            point: {\n              x: point.x,\n              y: yScale.convert(yValueCumulative),\n              moveTo\n            },\n            yValue: yDatum,\n            xValue: xDatum\n          });\n          moveTo = !validPoint;\n        }\n        lastXDatum = xDatum;\n        lastYValueContinuity = yValueContinuity;\n      });\n    });\n    return context;\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  markerFactory() {\n    const { shape } = this.properties.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  async updatePathNodes(opts) {\n    const { opacity, visible, animationEnabled } = opts;\n    const [fill, stroke] = opts.paths;\n    const strokeWidth = this.getStrokeWidth(this.properties.strokeWidth);\n    stroke.setProperties({\n      tag: 1 /* Stroke */,\n      fill: void 0,\n      lineJoin: stroke.lineCap = \"round\",\n      pointerEvents: 1 /* None */,\n      stroke: this.properties.stroke,\n      strokeWidth,\n      strokeOpacity: this.properties.strokeOpacity,\n      lineDash: this.properties.lineDash,\n      lineDashOffset: this.properties.lineDashOffset,\n      opacity,\n      visible\n    });\n    fill.setProperties({\n      tag: 0 /* Fill */,\n      stroke: void 0,\n      lineJoin: \"round\",\n      pointerEvents: 1 /* None */,\n      fill: this.properties.fill,\n      fillOpacity: this.properties.fillOpacity,\n      lineDash: this.properties.lineDash,\n      lineDashOffset: this.properties.lineDashOffset,\n      strokeOpacity: this.properties.strokeOpacity,\n      fillShadow: this.properties.shadow,\n      opacity,\n      visible: visible || animationEnabled,\n      strokeWidth\n    });\n    updateClipPath(this, stroke);\n    updateClipPath(this, fill);\n  }\n  async updatePaths(opts) {\n    this.updateAreaPaths(opts.paths, opts.contextData);\n  }\n  updateAreaPaths(paths, contextData) {\n    this.updateFillPath(paths, contextData);\n    this.updateStrokePath(paths, contextData);\n  }\n  updateFillPath(paths, contextData) {\n    const { points, phantomPoints } = contextData.fillData;\n    const [fill] = paths;\n    const { interpolation } = this.properties;\n    fill.path.clear(true);\n    for (const range3 of pathRanges(points)) {\n      plotPath(pathRangePoints(points, range3), fill, interpolation, false);\n      plotPath(pathRangePointsReverse(phantomPoints, range3), fill, interpolation, true);\n      fill.path.closePath();\n    }\n    fill.checkPathDirty();\n  }\n  updateStrokePath(paths, contextData) {\n    const { points } = contextData.strokeData;\n    const [, stroke] = paths;\n    const { path: strokePath } = stroke;\n    const { interpolation } = this.properties;\n    strokePath.clear(true);\n    for (const range3 of pathRanges(points)) {\n      plotPath(pathRangePoints(points, range3), stroke, interpolation);\n    }\n    stroke.checkPathDirty();\n  }\n  async updateMarkerSelection(opts) {\n    const { nodeData, markerSelection } = opts;\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    return markerSelection.update(this.properties.marker.enabled ? nodeData : []);\n  }\n  async updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, marker, fill, stroke, strokeWidth, fillOpacity, strokeOpacity, highlightStyle } = this.properties;\n    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle(), {\n      fill,\n      stroke,\n      strokeWidth,\n      fillOpacity,\n      strokeOpacity\n    });\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey }, baseStyle);\n    });\n    if (!highlighted) {\n      this.properties.marker.markClean();\n    }\n  }\n  async updateLabelSelection(opts) {\n    const { labelData, labelSelection } = opts;\n    return labelSelection.update(labelData, (text) => {\n      text.tag = 3 /* Label */;\n    });\n  }\n  async updateLabelNodes(opts) {\n    const { labelSelection } = opts;\n    const { enabled: labelEnabled, fontStyle, fontWeight, fontSize, fontFamily, color } = this.properties.label;\n    labelSelection.each((text, datum) => {\n      const { x, y, label } = datum;\n      if (label && labelEnabled && this.visible) {\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.textAlign = label.textAlign;\n        text.textBaseline = label.textBaseline;\n        text.text = label.text;\n        text.x = x;\n        text.y = y - 10;\n        text.fill = color;\n        text.visible = true;\n      } else {\n        text.visible = false;\n      }\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const { id: seriesId, axes, dataModel } = this;\n    const { xKey, xName, yName, tooltip, marker } = this.properties;\n    const { yKey, xValue, yValue, datum, itemId } = nodeDatum;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !(xAxis && yAxis && isFiniteNumber(yValue)) || !dataModel) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const xString = xAxis.formatDatum(xValue);\n    const yString = yAxis.formatDatum(yValue);\n    const title = sanitizeHtml(yName);\n    const content = sanitizeHtml(xString + \": \" + yString);\n    const baseStyle = mergeDefaults({ fill: this.properties.fill }, marker.getStyle(), {\n      stroke: this.properties.stroke,\n      strokeWidth: this.properties.strokeWidth\n    });\n    const { fill: color } = this.getMarkerStyle(\n      marker,\n      { datum: nodeDatum, xKey, yKey, highlighted: false },\n      baseStyle\n    );\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        datum,\n        itemId,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        color,\n        title,\n        seriesId\n      }\n    );\n  }\n  getLegendData(legendType) {\n    if (!this.data?.length || !this.properties.isValid() || !this.properties.showInLegend || legendType !== \"category\") {\n      return [];\n    }\n    const {\n      yKey,\n      yName,\n      fill,\n      stroke,\n      fillOpacity,\n      strokeOpacity,\n      strokeWidth,\n      lineDash,\n      marker,\n      visible,\n      legendItemName\n    } = this.properties;\n    const useAreaFill = !marker.enabled || marker.fill === void 0;\n    return [\n      {\n        legendType,\n        id: this.id,\n        itemId: yKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: legendItemName ?? yName ?? yKey\n        },\n        symbols: [\n          {\n            marker: {\n              shape: marker.shape,\n              fill: useAreaFill ? fill : marker.fill,\n              fillOpacity: useAreaFill ? fillOpacity : marker.fillOpacity,\n              stroke: marker.stroke ?? stroke,\n              strokeOpacity: marker.strokeOpacity ?? strokeOpacity,\n              strokeWidth: marker.strokeWidth ?? 0,\n              enabled: marker.enabled || strokeWidth <= 0\n            },\n            line: {\n              stroke,\n              strokeOpacity,\n              strokeWidth,\n              lineDash\n            }\n          }\n        ],\n        legendItemName\n      }\n    ];\n  }\n  animateEmptyUpdateReady(animationData) {\n    const { markerSelection, labelSelection, contextData, paths } = animationData;\n    const { animationManager } = this.ctx;\n    this.updateAreaPaths(paths, contextData);\n    pathSwipeInAnimation(this, animationManager, ...paths);\n    resetMotion([markerSelection], resetMarkerPositionFn);\n    markerSwipeScaleInAnimation(this, animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n  }\n  animateReadyResize(animationData) {\n    const { contextData, paths } = animationData;\n    this.updateAreaPaths(paths, contextData);\n    super.animateReadyResize(animationData);\n  }\n  animateWaitingUpdateReady(animationData) {\n    const { animationManager } = this.ctx;\n    const { markerSelection, labelSelection, contextData, paths, previousContextData } = animationData;\n    const [fill, stroke] = paths;\n    if (fill == null && stroke == null)\n      return;\n    super.resetAllAnimation(animationData);\n    const update = () => {\n      this.updateAreaPaths(paths, contextData);\n      this.updateStrokePath(paths, contextData);\n    };\n    const skip = () => {\n      animationManager.skipCurrentBatch();\n      update();\n    };\n    if (contextData == null || previousContextData == null) {\n      update();\n      markerFadeInAnimation(this, animationManager, \"added\", markerSelection);\n      pathFadeInAnimation(this, \"fill_path_properties\", animationManager, \"add\", fill);\n      pathFadeInAnimation(this, \"stroke\", animationManager, \"trailing\", stroke);\n      seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n      return;\n    }\n    const fns = prepareAreaPathAnimation(\n      contextData,\n      previousContextData,\n      this.processedData?.reduced?.diff,\n      this.properties.interpolation\n    );\n    if (fns === void 0) {\n      skip();\n      return;\n    } else if (fns.status === \"no-op\") {\n      return;\n    }\n    markerFadeInAnimation(this, animationManager, void 0, markerSelection);\n    fromToMotion(this.id, \"fill_path_properties\", animationManager, [fill], fns.fill.pathProperties);\n    pathMotion(this.id, \"fill_path_update\", animationManager, [fill], fns.fill.path);\n    this.updateStrokePath(paths, contextData);\n    pathFadeInAnimation(this, \"stroke\", animationManager, \"trailing\", stroke);\n    seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey } = datum;\n    return this.getMarkerStyle(this.properties.marker, { datum, xKey, yKey, highlighted: true });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nAreaSeries.className = \"AreaSeries\";\nAreaSeries.type = \"area\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesModule.ts\nvar AreaSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"area\",\n  instanceConstructor: AreaSeries,\n  stackable: true,\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    },\n    {\n      type: \"category\" /* CATEGORY */,\n      position: \"bottom\" /* BOTTOM */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      nodeClickRange: \"nearest\",\n      tooltip: { position: { type: \"node\" } },\n      fillOpacity: 0.8,\n      strokeOpacity: 1,\n      strokeWidth: 0,\n      lineDash: [0],\n      lineDashOffset: 0,\n      shadow: {\n        enabled: false,\n        color: DEFAULT_SHADOW_COLOUR,\n        xOffset: 3,\n        yOffset: 3,\n        blur: 5\n      },\n      interpolation: {\n        type: \"linear\",\n        // @ts-expect-error - users shouldn't specify all options, but we have to for theming to work\n        tension: 1,\n        position: \"end\"\n      },\n      marker: {\n        enabled: false,\n        shape: \"circle\",\n        size: 7,\n        strokeWidth: 0\n      },\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      }\n    }\n  },\n  paletteFactory: (params) => {\n    const { marker } = markerPaletteFactory(params);\n    return { fill: marker.fill, stroke: marker.stroke, marker };\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/quadtreeUtil.ts\nfunction* childrenIter(parent) {\n  for (const node of parent.children) {\n    yield node;\n  }\n}\nfunction addHitTestersToQuadtree(quadtree, hitTesters) {\n  for (const node of hitTesters) {\n    const datum = node.datum;\n    if (datum === void 0) {\n      Logger.error(\"undefined datum\");\n    } else {\n      quadtree.addValue(node, datum);\n    }\n  }\n}\nfunction findQuadtreeMatch(series, point) {\n  const { x, y } = series.contentGroup.transformPoint(point.x, point.y);\n  const { nearest, distanceSquared: distanceSquared3 } = series.getQuadTree().find(x, y);\n  if (nearest !== void 0) {\n    return { datum: nearest.value, distance: Math.sqrt(distanceSquared3) };\n  }\n  return void 0;\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/abstractBarSeries.ts\nvar AbstractBarSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.direction = \"vertical\";\n  }\n};\n__decorateClass([\n  Validate(DIRECTION)\n], AbstractBarSeriesProperties.prototype, \"direction\", 2);\nvar AbstractBarSeries = class extends CartesianSeries {\n  constructor() {\n    super(...arguments);\n    /**\n     * Used to get the position of bars within each group.\n     */\n    this.groupScale = new BandScale();\n    this.smallestDataInterval = void 0;\n    this.largestDataInterval = void 0;\n  }\n  getBandScalePadding() {\n    return { inner: 0.3, outer: 0.15 };\n  }\n  shouldFlipXY() {\n    return !this.isVertical();\n  }\n  isVertical() {\n    return this.properties.direction === \"vertical\";\n  }\n  getBarDirection() {\n    return this.shouldFlipXY() ? \"x\" /* X */ : \"y\" /* Y */;\n  }\n  getCategoryDirection() {\n    return this.shouldFlipXY() ? \"y\" /* Y */ : \"x\" /* X */;\n  }\n  getValueAxis() {\n    const direction = this.getBarDirection();\n    return this.axes[direction];\n  }\n  getCategoryAxis() {\n    const direction = this.getCategoryDirection();\n    return this.axes[direction];\n  }\n  updateGroupScale(xAxis) {\n    const {\n      groupScale,\n      smallestDataInterval,\n      ctx: { seriesStateManager }\n    } = this;\n    const xScale = xAxis.scale;\n    const xBandWidth = ContinuousScale.is(xScale) ? xScale.calcBandwidth(smallestDataInterval) : xScale.bandwidth;\n    const domain = [];\n    const { index: groupIndex, visibleGroupCount } = seriesStateManager.getVisiblePeerGroupIndex(this);\n    for (let groupIdx = 0; groupIdx < visibleGroupCount; groupIdx++) {\n      domain.push(String(groupIdx));\n    }\n    groupScale.domain = domain;\n    groupScale.range = [0, xBandWidth ?? 0];\n    if (xAxis instanceof CategoryAxis) {\n      groupScale.paddingInner = xAxis.groupPaddingInner;\n    } else if (xAxis instanceof GroupedCategoryAxis) {\n      groupScale.padding = 0.1;\n    } else {\n      groupScale.padding = 0;\n    }\n    groupScale.round = groupScale.padding !== 0;\n    const barWidth = groupScale.bandwidth >= 1 ? (\n      // Pixel-rounded value for low-volume bar charts.\n      groupScale.bandwidth\n    ) : (\n      // Handle high-volume bar charts gracefully.\n      groupScale.rawBandwidth\n    );\n    return { barWidth, groupIndex };\n  }\n  resolveKeyDirection(direction) {\n    if (this.getBarDirection() === \"x\" /* X */) {\n      if (direction === \"x\" /* X */) {\n        return \"y\" /* Y */;\n      }\n      return \"x\" /* X */;\n    }\n    return direction;\n  }\n  initQuadTree(quadtree) {\n    addHitTestersToQuadtree(quadtree, this.datumNodesIter());\n  }\n  pickNodeClosestDatum(point) {\n    return findQuadtreeMatch(this, point);\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/barSeriesProperties.ts\nvar BarSeriesLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.placement = \"inside\";\n  }\n};\n__decorateClass([\n  Validate(PLACEMENT)\n], BarSeriesLabel.prototype, \"placement\", 2);\nvar BarSeriesProperties = class extends AbstractBarSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fill = \"#c16068\";\n    this.fillOpacity = 1;\n    this.stroke = \"#874349\";\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.crisp = void 0;\n    this.shadow = new DropShadow();\n    this.label = new BarSeriesLabel();\n    this.tooltip = new SeriesTooltip();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], BarSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING)\n], BarSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"stackGroup\", 2);\n__decorateClass([\n  Validate(NUMBER, { optional: true })\n], BarSeriesProperties.prototype, \"normalizedTo\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], BarSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], BarSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], BarSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], BarSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], BarSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], BarSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], BarSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], BarSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], BarSeriesProperties.prototype, \"crisp\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], BarSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(OBJECT, { optional: true })\n], BarSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BarSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BarSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/barUtil.ts\nfunction updateRect({ rect, config }) {\n  const {\n    crisp = true,\n    fill,\n    stroke,\n    strokeWidth,\n    fillOpacity,\n    strokeOpacity,\n    lineDash,\n    lineDashOffset,\n    fillShadow,\n    cornerRadius = 0,\n    topLeftCornerRadius = true,\n    topRightCornerRadius = true,\n    bottomRightCornerRadius = true,\n    bottomLeftCornerRadius = true,\n    visible = true\n  } = config;\n  rect.crisp = crisp;\n  rect.fill = fill;\n  rect.stroke = stroke;\n  rect.strokeWidth = strokeWidth;\n  rect.fillOpacity = fillOpacity;\n  rect.strokeOpacity = strokeOpacity;\n  rect.lineDash = lineDash;\n  rect.lineDashOffset = lineDashOffset;\n  rect.fillShadow = fillShadow;\n  rect.topLeftCornerRadius = topLeftCornerRadius ? cornerRadius : 0;\n  rect.topRightCornerRadius = topRightCornerRadius ? cornerRadius : 0;\n  rect.bottomRightCornerRadius = bottomRightCornerRadius ? cornerRadius : 0;\n  rect.bottomLeftCornerRadius = bottomLeftCornerRadius ? cornerRadius : 0;\n  rect.visible = visible;\n}\nfunction getRectConfig({\n  datum,\n  isHighlighted,\n  style,\n  highlightStyle,\n  itemStyler,\n  seriesId,\n  ctx: { callbackCache },\n  ...opts\n}) {\n  const {\n    fill,\n    fillOpacity,\n    stroke,\n    strokeWidth,\n    strokeOpacity,\n    lineDash,\n    lineDashOffset,\n    cornerRadius = 0\n  } = mergeDefaults(isHighlighted && highlightStyle, style);\n  const {\n    fillShadow,\n    topLeftCornerRadius = true,\n    topRightCornerRadius = true,\n    bottomRightCornerRadius = true,\n    bottomLeftCornerRadius = true\n  } = style;\n  let format;\n  if (itemStyler) {\n    format = callbackCache.call(itemStyler, {\n      datum: datum.datum,\n      xKey: datum.xKey,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      cornerRadius,\n      highlighted: isHighlighted,\n      seriesId,\n      ...opts\n    });\n  }\n  return {\n    fill: format?.fill ?? fill,\n    fillOpacity: format?.fillOpacity ?? fillOpacity,\n    stroke: format?.stroke ?? stroke,\n    strokeWidth: format?.strokeWidth ?? strokeWidth,\n    strokeOpacity: format?.strokeOpacity ?? strokeOpacity,\n    lineDash: format?.lineDash ?? lineDash,\n    lineDashOffset: format?.lineDashOffset ?? lineDashOffset,\n    cornerRadius: format?.cornerRadius ?? cornerRadius,\n    topLeftCornerRadius,\n    topRightCornerRadius,\n    bottomRightCornerRadius,\n    bottomLeftCornerRadius,\n    fillShadow\n  };\n}\nfunction checkCrisp(scale2, visibleRange, smallestDataInterval, largestDataInterval) {\n  if (visibleRange != null) {\n    const [visibleMin, visibleMax] = visibleRange;\n    const isZoomed = visibleMin !== 0 || visibleMax !== 1;\n    if (isZoomed)\n      return false;\n  }\n  if (ContinuousScale.is(scale2)) {\n    const spacing = scale2.calcBandwidth(largestDataInterval) - scale2.calcBandwidth(smallestDataInterval);\n    if (spacing > 0 && spacing < 1)\n      return false;\n  }\n  return true;\n}\nvar isDatumNegative = (datum) => {\n  return isNegative(datum.yValue ?? 0);\n};\nfunction collapsedStartingBarPosition(isVertical, axes, mode) {\n  const { startingX, startingY } = getStartingValues(isVertical, axes);\n  const calculate = (datum, prevDatum) => {\n    let x = isVertical ? datum.x : startingX;\n    let y = isVertical ? startingY : datum.y;\n    let width = isVertical ? datum.width : 0;\n    let height = isVertical ? 0 : datum.height;\n    const { opacity } = datum;\n    if (prevDatum && (isNaN(x) || isNaN(y))) {\n      ({ x, y } = prevDatum);\n      width = isVertical ? prevDatum.width : 0;\n      height = isVertical ? 0 : prevDatum.height;\n      if (isVertical && !isDatumNegative(prevDatum)) {\n        y += prevDatum.height;\n      } else if (!isVertical && isDatumNegative(prevDatum)) {\n        x += prevDatum.width;\n      }\n    }\n    let clipBBox;\n    if (datum.clipBBox == null) {\n      clipBBox = void 0;\n    } else if (isDatumNegative(datum)) {\n      clipBBox = isVertical ? new BBox(x, y - height, width, height) : new BBox(x - width, y, width, height);\n    } else {\n      clipBBox = new BBox(x, y, width, height);\n    }\n    return { x, y, width, height, clipBBox, opacity };\n  };\n  return { isVertical, calculate, mode };\n}\nfunction midpointStartingBarPosition(isVertical, mode) {\n  return {\n    isVertical,\n    calculate: (datum) => {\n      return {\n        x: isVertical ? datum.x : datum.x + datum.width / 2,\n        y: isVertical ? datum.y + datum.height / 2 : datum.y,\n        width: isVertical ? datum.width : 0,\n        height: isVertical ? 0 : datum.height,\n        clipBBox: datum.clipBBox,\n        opacity: datum.opacity\n      };\n    },\n    mode\n  };\n}\nfunction prepareBarAnimationFunctions(initPos) {\n  const isRemoved = (datum) => datum == null || isNaN(datum.x) || isNaN(datum.y);\n  const fromFn = (rect, datum, status) => {\n    if (status === \"updated\" && isRemoved(datum)) {\n      status = \"removed\";\n    } else if (status === \"updated\" && isRemoved(rect.previousDatum)) {\n      status = \"added\";\n    }\n    let source;\n    if (status === \"added\" && rect.previousDatum == null && initPos.mode === \"fade\") {\n      source = { ...resetBarSelectionsFn(rect, datum), opacity: 0 };\n    } else if (status === \"unknown\" || status === \"added\") {\n      source = initPos.calculate(datum, rect.previousDatum);\n    } else {\n      source = {\n        x: rect.x,\n        y: rect.y,\n        width: rect.width,\n        height: rect.height,\n        clipBBox: rect.clipBBox,\n        opacity: rect.opacity\n      };\n    }\n    const phase = NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];\n    return { ...source, phase };\n  };\n  const toFn = (rect, datum, status) => {\n    let source;\n    if (status === \"removed\" && rect.datum == null && initPos.mode === \"fade\") {\n      source = { ...resetBarSelectionsFn(rect, datum), opacity: 0 };\n    } else if (status === \"removed\" || isRemoved(datum)) {\n      source = initPos.calculate(datum, rect.previousDatum);\n    } else {\n      source = {\n        x: datum.x,\n        y: datum.y,\n        width: datum.width,\n        height: datum.height,\n        clipBBox: datum.clipBBox,\n        opacity: datum.opacity\n      };\n    }\n    return source;\n  };\n  return { toFn, fromFn };\n}\nfunction getStartingValues(isVertical, axes) {\n  const axis = axes[isVertical ? \"y\" /* Y */ : \"x\" /* X */];\n  let startingX = Infinity;\n  let startingY = 0;\n  if (!axis) {\n    return { startingX, startingY };\n  }\n  if (isVertical) {\n    startingY = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.max(...axis.range));\n  } else {\n    startingX = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.min(...axis.range));\n  }\n  return { startingX, startingY };\n}\nfunction resetBarSelectionsFn(_node, { x, y, width, height, clipBBox, opacity }) {\n  return { x, y, width, height, clipBBox, opacity };\n}\nfunction computeBarFocusBounds(datum, barGroup, seriesRect) {\n  if (datum === void 0)\n    return void 0;\n  const { x, y, width, height } = datum;\n  return barGroup.inverseTransformBBox(new BBox(x, y, width, height)).clip(seriesRect);\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/labelUtil.ts\nfunction updateLabelNode(textNode, label, labelDatum) {\n  if (label.enabled && labelDatum) {\n    const { x, y, text, textAlign, textBaseline } = labelDatum;\n    const { color: fill, fontStyle, fontWeight, fontSize, fontFamily } = label;\n    textNode.setProperties({\n      visible: true,\n      x,\n      y,\n      text,\n      fill,\n      fontStyle,\n      fontWeight,\n      fontSize,\n      fontFamily,\n      textAlign,\n      textBaseline\n    });\n  } else {\n    textNode.visible = false;\n  }\n}\nfunction adjustLabelPlacement({\n  isPositive,\n  isVertical,\n  placement,\n  padding = 0,\n  rect\n}) {\n  let x = rect.x + rect.width / 2;\n  let y = rect.y + rect.height / 2;\n  let textAlign = \"center\";\n  let textBaseline = \"middle\";\n  switch (placement) {\n    case \"start\": {\n      if (isVertical) {\n        y = isPositive ? rect.y + rect.height + padding : rect.y - padding;\n        textBaseline = isPositive ? \"top\" : \"bottom\";\n      } else {\n        x = isPositive ? rect.x - padding : rect.x + rect.width + padding;\n        textAlign = isPositive ? \"start\" : \"end\";\n      }\n      break;\n    }\n    case \"outside\":\n    case \"end\": {\n      if (isVertical) {\n        y = isPositive ? rect.y - padding : rect.y + rect.height + padding;\n        textBaseline = isPositive ? \"bottom\" : \"top\";\n      } else {\n        x = isPositive ? rect.x + rect.width + padding : rect.x - padding;\n        textAlign = isPositive ? \"start\" : \"end\";\n      }\n      break;\n    }\n  }\n  return { x, y, textAlign, textBaseline };\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/barSeries.ts\nvar BarSeries = class extends AbstractBarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [3 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      pathsPerSeries: 0,\n      hasHighlightedLabels: true,\n      datumSelectionGarbageCollection: false,\n      animationAlwaysUpdateSelections: true,\n      animationResetFns: {\n        datum: resetBarSelectionsFn,\n        label: resetLabelFn\n      }\n    });\n    this.properties = new BarSeriesProperties();\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid() || !this.data) {\n      return;\n    }\n    const { seriesGrouping: { groupIndex = this.id } = {}, data = [] } = this;\n    const { xKey, yKey, normalizedTo } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const xScale = this.getCategoryAxis()?.scale;\n    const yScale = this.getValueAxis()?.scale;\n    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const stackGroupName = `bar-stack-${groupIndex}-yValues`;\n    const stackGroupTrailingName = `${stackGroupName}-trailing`;\n    const extraProps = [];\n    if (isFiniteNumber(normalizedTo)) {\n      extraProps.push(\n        normaliseGroupTo([stackGroupName, stackGroupTrailingName], Math.abs(normalizedTo), \"range\")\n      );\n    }\n    if (animationEnabled && this.processedData) {\n      extraProps.push(diff(this.processedData));\n    }\n    if (animationEnabled) {\n      extraProps.push(animationValidation());\n    }\n    const visibleProps = this.visible ? {} : { forceValue: 0 };\n    const { processedData } = await this.requestDataModel(dataController, data, {\n      props: [\n        keyProperty(xKey, xScaleType, { id: \"xValue\" }),\n        valueProperty(yKey, yScaleType, { id: `yValue-raw`, invalidValue: null, ...visibleProps }),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"normal\",\n          \"current\",\n          {\n            id: `yValue-end`,\n            rangeId: `yValue-range`,\n            invalidValue: null,\n            missingValue: 0,\n            groupId: stackGroupName,\n            separateNegative: true,\n            ...visibleProps\n          },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"trailing\",\n          \"current\",\n          {\n            id: `yValue-start`,\n            invalidValue: null,\n            missingValue: 0,\n            groupId: stackGroupTrailingName,\n            separateNegative: true,\n            ...visibleProps\n          },\n          yScaleType\n        ),\n        ...isContinuousX ? [SMALLEST_KEY_INTERVAL, LARGEST_KEY_INTERVAL] : [],\n        ...extraProps\n      ],\n      groupByKeys: true,\n      groupByData: false\n    });\n    this.smallestDataInterval = processedData.reduced?.smallestKeyInterval;\n    this.largestDataInterval = processedData.reduced?.largestKeyInterval;\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel, smallestDataInterval } = this;\n    if (!processedData || !dataModel || processedData.data.length === 0)\n      return [];\n    const categoryAxis = this.getCategoryAxis();\n    const valueAxis = this.getValueAxis();\n    const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n    const keys = dataModel.getDomain(this, `xValue`, \"key\", processedData);\n    const yExtent = dataModel.getDomain(this, `yValue-end`, \"value\", processedData);\n    if (direction === this.getCategoryDirection()) {\n      if (keyDef?.def.type === \"key\" && keyDef.def.valueType === \"category\") {\n        return keys;\n      }\n      const scalePadding = isFiniteNumber(smallestDataInterval) ? smallestDataInterval * 0.5 : 0;\n      const keysExtent = extent(keys) ?? [NaN, NaN];\n      const d0 = keysExtent[0] + -scalePadding;\n      const d1 = keysExtent[1] + scalePadding;\n      return fixNumericExtent([d0, d1], categoryAxis);\n    } else if (this.getValueAxis() instanceof LogAxis) {\n      return fixNumericExtent(yExtent, valueAxis);\n    } else {\n      const fixedYExtent = [Math.min(0, yExtent[0]), Math.max(0, yExtent[1])];\n      return fixNumericExtent(fixedYExtent, valueAxis);\n    }\n  }\n  async createNodeData() {\n    const { dataModel } = this;\n    const xAxis = this.getCategoryAxis();\n    const yAxis = this.getValueAxis();\n    if (!dataModel || !xAxis || !yAxis || !this.properties.isValid())\n      return;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const { xKey, yKey, xName, yName, fill, stroke, strokeWidth, cornerRadius, legendItemName, label } = this.properties;\n    const yReversed = yAxis.isReversed();\n    const { barWidth, groupIndex } = this.updateGroupScale(xAxis);\n    const barOffset = ContinuousScale.is(xScale) ? barWidth * -0.5 : 0;\n    const xIndex = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const yRawIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-raw`);\n    const yStartIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-start`);\n    const yEndIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-end`);\n    const yRangeIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-range`);\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const context = {\n      itemId: yKey,\n      nodeData: [],\n      labelData: [],\n      scales: this.calculateScaling(),\n      visible: this.visible || animationEnabled\n    };\n    const { groupScale, processedData } = this;\n    processedData?.data.forEach(({ keys, datum: seriesDatum, values, aggValues }) => {\n      values.forEach((value, valueIndex) => {\n        const xValue = keys[xIndex];\n        const x = xScale.convert(xValue);\n        const currY = +value[yEndIndex];\n        const prevY = +value[yStartIndex];\n        const yRawValue = value[yRawIndex];\n        const isPositive = yRawValue >= 0 && !Object.is(yRawValue, -0);\n        const isUpward = isPositive !== yReversed;\n        const yRange = aggValues?.[yRangeIndex][isPositive ? 1 : 0] ?? 0;\n        const barX = x + groupScale.convert(String(groupIndex)) + barOffset;\n        if (isNaN(currY))\n          return;\n        const y = yScale.convert(currY);\n        const bottomY = yScale.convert(prevY);\n        const barAlongX = this.getBarDirection() === \"x\" /* X */;\n        const bboxHeight = yScale.convert(yRange);\n        const bboxBottom = yScale.convert(0);\n        const rect = {\n          x: barAlongX ? Math.min(y, bottomY) : barX,\n          y: barAlongX ? barX : Math.min(y, bottomY),\n          width: barAlongX ? Math.abs(bottomY - y) : barWidth,\n          height: barAlongX ? barWidth : Math.abs(bottomY - y)\n        };\n        const clipBBox = new BBox(rect.x, rect.y, rect.width, rect.height);\n        const barRect = {\n          x: barAlongX ? Math.min(bboxBottom, bboxHeight) : barX,\n          y: barAlongX ? barX : Math.min(bboxBottom, bboxHeight),\n          width: barAlongX ? Math.abs(bboxBottom - bboxHeight) : barWidth,\n          height: barAlongX ? barWidth : Math.abs(bboxBottom - bboxHeight),\n          clipBBox\n        };\n        const {\n          fontStyle: labelFontStyle,\n          fontWeight: labelFontWeight,\n          fontSize: labelFontSize,\n          fontFamily: labelFontFamily,\n          color: labelColor,\n          placement\n        } = label;\n        const labelText = this.getLabelText(\n          this.properties.label,\n          {\n            datum: seriesDatum[valueIndex],\n            value: yRawValue,\n            xKey,\n            yKey,\n            xName,\n            yName,\n            legendItemName\n          },\n          (v) => isFiniteNumber(v) ? v.toFixed(2) : String(v)\n        );\n        const labelDatum = labelText ? {\n          text: labelText,\n          fill: labelColor,\n          fontStyle: labelFontStyle,\n          fontWeight: labelFontWeight,\n          fontSize: labelFontSize,\n          fontFamily: labelFontFamily,\n          ...adjustLabelPlacement({\n            isPositive,\n            isVertical: !barAlongX,\n            placement,\n            rect\n          })\n        } : void 0;\n        const lengthRatioMultiplier = this.shouldFlipXY() ? rect.height : rect.width;\n        const nodeData = {\n          series: this,\n          itemId: yKey,\n          datum: seriesDatum[valueIndex],\n          valueIndex,\n          cumulativeValue: currY,\n          xValue,\n          yValue: yRawValue,\n          yKey,\n          xKey,\n          capDefaults: {\n            lengthRatioMultiplier,\n            lengthMax: lengthRatioMultiplier\n          },\n          x: barRect.x,\n          y: barRect.y,\n          width: barRect.width,\n          height: barRect.height,\n          midPoint: { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 },\n          fill,\n          stroke,\n          opacity: 1,\n          strokeWidth,\n          cornerRadius,\n          topLeftCornerRadius: barAlongX !== isUpward,\n          topRightCornerRadius: isUpward,\n          bottomRightCornerRadius: barAlongX === isUpward,\n          bottomLeftCornerRadius: !isUpward,\n          clipBBox,\n          label: labelDatum,\n          missing: yRawValue == null\n        };\n        context.nodeData.push(nodeData);\n        context.labelData.push(nodeData);\n      });\n    });\n    return context;\n  }\n  nodeFactory() {\n    return new Rect();\n  }\n  async updateDatumSelection(opts) {\n    return opts.datumSelection.update(\n      opts.nodeData,\n      (rect) => {\n        rect.tag = 0 /* Bar */;\n      },\n      (datum) => createDatumId(datum.xValue, datum.valueIndex)\n    );\n  }\n  async updateDatumNodes(opts) {\n    if (!this.properties.isValid()) {\n      return;\n    }\n    const {\n      yKey,\n      stackGroup,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      itemStyler,\n      shadow,\n      highlightStyle: { item: itemHighlightStyle }\n    } = this.properties;\n    const xAxis = this.axes[\"x\" /* X */];\n    const crisp = this.properties.crisp ?? checkCrisp(xAxis?.scale, xAxis?.visibleRange, this.smallestDataInterval, this.largestDataInterval);\n    const categoryAlongX = this.getCategoryDirection() === \"x\" /* X */;\n    opts.datumSelection.each((rect, datum) => {\n      const style = {\n        fill,\n        stroke,\n        fillOpacity,\n        strokeOpacity,\n        lineDash,\n        lineDashOffset,\n        fillShadow: shadow,\n        strokeWidth: this.getStrokeWidth(strokeWidth),\n        cornerRadius: datum.cornerRadius,\n        topLeftCornerRadius: datum.topLeftCornerRadius,\n        topRightCornerRadius: datum.topRightCornerRadius,\n        bottomRightCornerRadius: datum.bottomRightCornerRadius,\n        bottomLeftCornerRadius: datum.bottomLeftCornerRadius\n      };\n      const visible = categoryAlongX ? (datum.clipBBox?.width ?? datum.width) > 0 : (datum.clipBBox?.height ?? datum.height) > 0;\n      const config = getRectConfig({\n        datum,\n        ctx: this.ctx,\n        seriesId: this.id,\n        isHighlighted: opts.isHighlight,\n        highlightStyle: itemHighlightStyle,\n        yKey,\n        style,\n        itemStyler,\n        stackGroup\n      });\n      config.crisp = crisp;\n      config.visible = visible;\n      updateRect({ rect, config });\n    });\n  }\n  async updateLabelSelection(opts) {\n    const data = this.isLabelEnabled() ? opts.labelData : [];\n    return opts.labelSelection.update(data, (text) => {\n      text.tag = 1 /* Label */;\n      text.pointerEvents = 1 /* None */;\n    });\n  }\n  async updateLabelNodes(opts) {\n    opts.labelSelection.each((textNode, datum) => {\n      updateLabelNode(textNode, this.properties.label, datum.label);\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const {\n      id: seriesId,\n      processedData,\n      ctx: { callbackCache }\n    } = this;\n    const xAxis = this.getCategoryAxis();\n    const yAxis = this.getValueAxis();\n    if (!processedData || !this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, xName, yName, fill, stroke, strokeWidth, tooltip, itemStyler, stackGroup, legendItemName } = this.properties;\n    const { xValue, yValue, datum, itemId } = nodeDatum;\n    const xString = xAxis.formatDatum(xValue);\n    const yString = yAxis.formatDatum(yValue);\n    const title = sanitizeHtml(yName);\n    const content = sanitizeHtml(xString + \": \" + yString);\n    let format;\n    if (itemStyler) {\n      format = callbackCache.call(itemStyler, {\n        seriesId,\n        datum,\n        xKey,\n        yKey,\n        stackGroup,\n        fill,\n        stroke,\n        strokeWidth: this.getStrokeWidth(strokeWidth),\n        highlighted: false,\n        cornerRadius: this.properties.cornerRadius,\n        fillOpacity: this.properties.fillOpacity,\n        strokeOpacity: this.properties.strokeOpacity,\n        lineDash: this.properties.lineDash ?? [],\n        lineDashOffset: this.properties.lineDashOffset\n      });\n    }\n    const color = format?.fill ?? fill;\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        seriesId,\n        itemId,\n        datum,\n        xKey,\n        yKey,\n        xName,\n        yName,\n        stackGroup,\n        title,\n        color,\n        legendItemName,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  getLegendData(legendType) {\n    const { showInLegend } = this.properties;\n    if (legendType !== \"category\" || !this.data?.length || !this.properties.isValid() || !showInLegend) {\n      return [];\n    }\n    const { yKey, yName, fill, stroke, strokeWidth, fillOpacity, strokeOpacity, legendItemName, visible } = this.properties;\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: yKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: { text: legendItemName ?? yName ?? yKey },\n        symbols: [{ marker: { fill, fillOpacity, stroke, strokeWidth, strokeOpacity } }],\n        legendItemName\n      }\n    ];\n  }\n  animateEmptyUpdateReady({ datumSelection, labelSelection, annotationSelections }) {\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, \"normal\"));\n    fromToMotion(this.id, \"nodes\", this.ctx.animationManager, [datumSelection], fns);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n    seriesLabelFadeInAnimation(this, \"annotations\", this.ctx.animationManager, ...annotationSelections);\n  }\n  animateWaitingUpdateReady(data) {\n    const { datumSelection, labelSelection, annotationSelections, previousContextData } = data;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    const dataDiff = this.processedData?.reduced?.diff;\n    const mode = previousContextData == null ? \"fade\" : \"normal\";\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, mode));\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      this.ctx.animationManager,\n      [datumSelection],\n      fns,\n      (_, datum) => createDatumId(datum.xValue, datum.valueIndex),\n      dataDiff\n    );\n    const hasMotion = dataDiff?.changed ?? true;\n    if (hasMotion) {\n      seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n      seriesLabelFadeInAnimation(this, \"annotations\", this.ctx.animationManager, ...annotationSelections);\n    }\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  computeFocusBounds({ datumIndex, seriesRect }) {\n    const datumBox = this.contextNodeData?.nodeData[datumIndex].clipBBox;\n    return computeBarFocusBounds(datumBox, this.contentGroup, seriesRect);\n  }\n};\nBarSeries.className = \"BarSeries\";\nBarSeries.type = \"bar\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/barSeriesModule.ts\nvar BarSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"bar\",\n  instanceConstructor: BarSeries,\n  stackable: true,\n  groupable: true,\n  tooltipDefaults: { range: \"exact\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    },\n    {\n      type: \"category\" /* CATEGORY */,\n      position: \"bottom\" /* BOTTOM */\n    }\n  ],\n  swapDefaultAxesCondition: (series) => series?.direction === \"horizontal\",\n  themeTemplate: {\n    series: {\n      direction: \"vertical\",\n      fillOpacity: 1,\n      strokeWidth: 0,\n      lineDash: [0],\n      lineDashOffset: 0,\n      label: {\n        enabled: false,\n        fontWeight: \"normal\" /* NORMAL */,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n        placement: \"inside\"\n      },\n      shadow: {\n        enabled: false,\n        color: DEFAULT_SHADOW_COLOUR,\n        xOffset: 3,\n        yOffset: 3,\n        blur: 5\n      }\n    }\n  },\n  enterpriseThemeTemplate: {\n    series: {\n      errorBar: {\n        cap: {\n          lengthRatio: 0.3\n        }\n      }\n    }\n  },\n  paletteFactory: singleSeriesPaletteFactory\n};\n\n// packages/ag-charts-community/src/scale/colorScale.ts\nvar convertColorStringToOklcha = (v) => {\n  const color = Color.fromString(v);\n  const [l, c, h] = Color.RGBtoOKLCH(color.r, color.g, color.b);\n  return { l, c, h, a: color.a };\n};\nvar delta = 1e-6;\nvar isAchromatic = (x) => x.c < delta || x.l < delta || x.l > 1 - delta;\nvar interpolateOklch = (x, y, d) => {\n  d = clamp(0, d, 1);\n  let h;\n  if (isAchromatic(x)) {\n    h = y.h;\n  } else if (isAchromatic(y)) {\n    h = x.h;\n  } else {\n    const xH = x.h;\n    let yH = y.h;\n    const deltaH = y.h - x.h;\n    if (deltaH > 180) {\n      yH -= 360;\n    } else if (deltaH < -180) {\n      yH += 360;\n    }\n    h = xH * (1 - d) + yH * d;\n  }\n  const c = x.c * (1 - d) + y.c * d;\n  const l = x.l * (1 - d) + y.l * d;\n  const a = x.a * (1 - d) + y.a * d;\n  return Color.fromOKLCH(l, c, h, a);\n};\nvar ColorScale = class {\n  constructor() {\n    this.type = \"color\";\n    this.invalid = true;\n    this.domain = [0, 1];\n    this.range = [\"red\", \"blue\"];\n    this.parsedRange = this.range.map(convertColorStringToOklcha);\n  }\n  update() {\n    const { domain, range: range3 } = this;\n    if (domain.length < 2) {\n      Logger.warnOnce(\"`colorDomain` should have at least 2 values.\");\n      if (domain.length === 0) {\n        domain.push(0, 1);\n      } else if (domain.length === 1) {\n        domain.push(domain[0] + 1);\n      }\n    }\n    for (let i = 1; i < domain.length; i++) {\n      const a = domain[i - 1];\n      const b = domain[i];\n      if (a >= b) {\n        Logger.warnOnce(\"`colorDomain` values should be supplied in ascending order.\");\n        domain.sort((a2, b2) => a2 - b2);\n        break;\n      }\n    }\n    if (range3.length < domain.length) {\n      for (let i = range3.length; i < domain.length; i++) {\n        range3.push(range3.length > 0 ? range3[0] : \"black\");\n      }\n    }\n    this.parsedRange = this.range.map(convertColorStringToOklcha);\n  }\n  convert(x) {\n    this.refresh();\n    const { domain, range: range3, parsedRange } = this;\n    const d0 = domain[0];\n    const d1 = domain.at(-1);\n    const r0 = range3[0];\n    const r1 = range3[range3.length - 1];\n    if (x <= d0) {\n      return r0;\n    }\n    if (x >= d1) {\n      return r1;\n    }\n    let index;\n    let q;\n    if (domain.length === 2) {\n      const t = (x - d0) / (d1 - d0);\n      const step = 1 / (range3.length - 1);\n      index = range3.length <= 2 ? 0 : Math.min(Math.floor(t * (range3.length - 1)), range3.length - 2);\n      q = (t - index * step) / step;\n    } else {\n      for (index = 0; index < domain.length - 2; index++) {\n        if (x < domain[index + 1]) {\n          break;\n        }\n      }\n      const a = domain[index];\n      const b = domain[index + 1];\n      q = (x - a) / (b - a);\n    }\n    const c0 = parsedRange[index];\n    const c1 = parsedRange[index + 1];\n    return interpolateOklch(c0, c1, q).toRgbaString();\n  }\n  refresh() {\n    if (!this.invalid)\n      return;\n    this.invalid = false;\n    this.update();\n    if (this.invalid) {\n      Logger.warnOnce(\"Expected update to not invalidate scale\");\n    }\n  }\n};\n__decorateClass([\n  Invalidating\n], ColorScale.prototype, \"domain\", 2);\n__decorateClass([\n  Invalidating\n], ColorScale.prototype, \"range\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesProperties.ts\nvar BubbleSeriesMarker = class extends SeriesMarker {\n  constructor() {\n    super(...arguments);\n    this.maxSize = 30;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], BubbleSeriesMarker.prototype, \"maxSize\", 2);\n__decorateClass([\n  Validate(NUMBER_ARRAY, { optional: true }),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], BubbleSeriesMarker.prototype, \"domain\", 2);\nvar BubbleSeriesLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.placement = \"top\";\n  }\n};\n__decorateClass([\n  Validate(LABEL_PLACEMENT)\n], BubbleSeriesLabel.prototype, \"placement\", 2);\nvar BubbleSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.colorRange = [\"#ffff00\", \"#00ff00\", \"#0000ff\"];\n    this.label = new BubbleSeriesLabel();\n    this.tooltip = new SeriesTooltip();\n    // No validation. Not a part of the options contract.\n    this.marker = new BubbleSeriesMarker();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], BubbleSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], BubbleSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], BubbleSeriesProperties.prototype, \"sizeKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"labelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"colorKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"sizeName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"labelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"colorName\", 2);\n__decorateClass([\n  Validate(NUMBER_ARRAY, { optional: true })\n], BubbleSeriesProperties.prototype, \"colorDomain\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], BubbleSeriesProperties.prototype, \"colorRange\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.shape\")\n], BubbleSeriesProperties.prototype, \"shape\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.size\")\n], BubbleSeriesProperties.prototype, \"size\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.maxSize\")\n], BubbleSeriesProperties.prototype, \"maxSize\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.domain\", { optional: true })\n], BubbleSeriesProperties.prototype, \"domain\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fill\", { optional: true })\n], BubbleSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fillOpacity\")\n], BubbleSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.stroke\", { optional: true })\n], BubbleSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeWidth\")\n], BubbleSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeOpacity\")\n], BubbleSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.itemStyler\", { optional: true })\n], BubbleSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BubbleSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BubbleSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeries.ts\nvar BubbleSeriesNodeEvent = class extends CartesianSeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.sizeKey = series.properties.sizeKey;\n  }\n};\nvar BubbleSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [\n        2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */,\n        3 /* NEAREST_NODE */,\n        0 /* EXACT_SHAPE_MATCH */\n      ],\n      pathsPerSeries: 0,\n      hasMarkers: true,\n      markerSelectionGarbageCollection: false,\n      animationResetFns: {\n        label: resetLabelFn,\n        marker: resetMarkerFn\n      }\n    });\n    this.NodeEvent = BubbleSeriesNodeEvent;\n    this.properties = new BubbleSeriesProperties();\n    this.sizeScale = new LinearScale();\n    this.colorScale = new ColorScale();\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid() || this.data == null || !this.visible)\n      return;\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const colorScaleType = this.colorScale.type;\n    const sizeScaleType = this.sizeScale.type;\n    const { xKey, yKey, sizeKey, labelKey, colorDomain, colorRange, colorKey, marker } = this.properties;\n    const { dataModel, processedData } = await this.requestDataModel(dataController, this.data, {\n      props: [\n        keyProperty(xKey, xScaleType, { id: \"xKey-raw\" }),\n        keyProperty(yKey, yScaleType, { id: \"yKey-raw\" }),\n        ...labelKey ? [keyProperty(labelKey, \"band\", { id: `labelKey-raw` })] : [],\n        valueProperty(xKey, xScaleType, { id: `xValue` }),\n        valueProperty(yKey, yScaleType, { id: `yValue` }),\n        valueProperty(sizeKey, sizeScaleType, { id: `sizeValue` }),\n        ...colorKey ? [valueProperty(colorKey, colorScaleType, { id: `colorValue` })] : [],\n        ...labelKey ? [valueProperty(labelKey, \"band\", { id: `labelValue` })] : []\n      ]\n    });\n    const sizeKeyIdx = dataModel.resolveProcessedDataIndexById(this, `sizeValue`);\n    const processedSize = processedData.domain.values[sizeKeyIdx] ?? [];\n    this.sizeScale.domain = marker.domain ? marker.domain : processedSize;\n    if (colorKey) {\n      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, `colorValue`);\n      this.colorScale.domain = colorDomain ?? processedData.domain.values[colorKeyIdx] ?? [];\n      this.colorScale.range = colorRange;\n      this.colorScale.update();\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { dataModel, processedData } = this;\n    if (!processedData || !dataModel)\n      return [];\n    const id = direction === \"x\" /* X */ ? `xValue` : `yValue`;\n    const dataDef = dataModel.resolveProcessedDataDefById(this, id);\n    const domain = dataModel.getDomain(this, id, \"value\", processedData);\n    if (dataDef?.def.type === \"value\" && dataDef?.def.valueType === \"category\") {\n      return domain;\n    }\n    const axis = this.axes[direction];\n    return fixNumericExtent(extent(domain), axis);\n  }\n  async createNodeData() {\n    const { axes, dataModel, processedData, colorScale, sizeScale } = this;\n    const { xKey, yKey, sizeKey, labelKey, xName, yName, sizeName, labelName, label, colorKey, marker, visible } = this.properties;\n    const markerShape = getMarker(marker.shape);\n    const { placement } = label;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!(dataModel && processedData && visible && xAxis && yAxis)) {\n      return;\n    }\n    const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`);\n    const sizeDataIdx = sizeKey ? dataModel.resolveProcessedDataIndexById(this, `sizeValue`) : -1;\n    const colorDataIdx = colorKey ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : -1;\n    const labelDataIdx = labelKey ? dataModel.resolveProcessedDataIndexById(this, `labelValue`) : -1;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const yOffset = (yScale.bandwidth ?? 0) / 2;\n    const nodeData = [];\n    sizeScale.range = [marker.size, marker.maxSize];\n    const font = label.getFont();\n    for (const { values, datum } of processedData.data ?? []) {\n      const xDatum = values[xDataIdx];\n      const yDatum = values[yDataIdx];\n      const x = xScale.convert(xDatum) + xOffset;\n      const y = yScale.convert(yDatum) + yOffset;\n      const labelText = this.getLabelText(label, {\n        value: labelKey ? values[labelDataIdx] : yDatum,\n        datum,\n        xKey,\n        yKey,\n        sizeKey,\n        labelKey,\n        xName,\n        yName,\n        sizeName,\n        labelName\n      });\n      const size = Text.getTextSize(String(labelText), font);\n      const markerSize = sizeKey ? sizeScale.convert(values[sizeDataIdx]) : marker.size;\n      const fill = colorKey ? colorScale.convert(values[colorDataIdx]) : void 0;\n      nodeData.push({\n        series: this,\n        itemId: yKey,\n        yKey,\n        xKey,\n        datum,\n        xValue: xDatum,\n        yValue: yDatum,\n        sizeValue: values[sizeDataIdx],\n        point: { x, y, size: markerSize },\n        midPoint: { x, y },\n        fill,\n        label: { text: labelText, ...size },\n        marker: markerShape,\n        placement\n      });\n    }\n    return {\n      itemId: yKey,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      visible: this.visible\n    };\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  getLabelData() {\n    return this.contextNodeData?.labelData ?? [];\n  }\n  markerFactory() {\n    const { shape } = this.properties.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  async updateMarkerSelection(opts) {\n    const { nodeData, markerSelection } = opts;\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    const data = this.properties.marker.enabled ? nodeData : [];\n    return markerSelection.update(\n      data,\n      void 0,\n      (datum) => createDatumId([datum.xValue, datum.yValue, datum.label.text])\n    );\n  }\n  async updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, sizeKey, labelKey, marker } = this.properties;\n    const { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity } = mergeDefaults(\n      highlighted && this.properties.highlightStyle.item,\n      marker.getStyle()\n    );\n    const baseStyle = { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity };\n    this.sizeScale.range = [marker.size, marker.maxSize];\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey, sizeKey, labelKey }, baseStyle);\n    });\n    if (!highlighted) {\n      this.properties.marker.markClean();\n    }\n  }\n  async updateLabelSelection(opts) {\n    const placedLabels = this.properties.label.enabled ? this.chart?.placeLabels().get(this) ?? [] : [];\n    return opts.labelSelection.update(\n      placedLabels.map((v) => ({\n        ...v.datum,\n        point: {\n          x: v.x,\n          y: v.y,\n          size: v.datum.point.size\n        }\n      }))\n    );\n  }\n  async updateLabelNodes(opts) {\n    const { label } = this.properties;\n    opts.labelSelection.each((text, datum) => {\n      text.text = datum.label.text;\n      text.fill = label.color;\n      text.x = datum.point?.x ?? 0;\n      text.y = datum.point?.y ?? 0;\n      text.fontStyle = label.fontStyle;\n      text.fontWeight = label.fontWeight;\n      text.fontSize = label.fontSize;\n      text.fontFamily = label.fontFamily;\n      text.textAlign = \"left\";\n      text.textBaseline = \"top\";\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const xAxis = this.axes[\"x\" /* X */];\n    const yAxis = this.axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, sizeKey, labelKey, xName, yName, sizeName, labelName, marker, tooltip } = this.properties;\n    const title = this.properties.title ?? yName;\n    const baseStyle = mergeDefaults(\n      { fill: nodeDatum.fill, strokeWidth: this.getStrokeWidth(marker.strokeWidth) },\n      marker.getStyle()\n    );\n    const { fill: color = \"gray\" } = this.getMarkerStyle(\n      marker,\n      { datum: nodeDatum, highlighted: false, xKey, yKey, sizeKey, labelKey },\n      baseStyle\n    );\n    const {\n      datum,\n      xValue,\n      yValue,\n      sizeValue,\n      label: { text: labelText },\n      itemId\n    } = nodeDatum;\n    const xString = sanitizeHtml(xAxis.formatDatum(xValue));\n    const yString = sanitizeHtml(yAxis.formatDatum(yValue));\n    let content = `<b>${sanitizeHtml(xName ?? xKey)}</b>: ${xString}<br><b>${sanitizeHtml(yName ?? yKey)}</b>: ${yString}`;\n    if (sizeKey) {\n      content += `<br><b>${sanitizeHtml(sizeName ?? sizeKey)}</b>: ${sanitizeHtml(String(sizeValue))}`;\n    }\n    if (labelKey) {\n      content = `<b>${sanitizeHtml(labelName ?? labelKey)}</b>: ${sanitizeHtml(labelText)}<br>` + content;\n    }\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        datum,\n        itemId,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        sizeKey,\n        sizeName,\n        labelKey,\n        labelName,\n        title,\n        color,\n        seriesId: this.id\n      }\n    );\n  }\n  getLegendData() {\n    if (!this.data?.length || !this.properties.isValid()) {\n      return [];\n    }\n    const { yKey, yName, title, marker, visible } = this.properties;\n    const { shape, fill, stroke, fillOpacity, strokeOpacity, strokeWidth } = marker;\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: yKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: title ?? yName ?? yKey\n        },\n        symbols: [\n          {\n            marker: {\n              shape,\n              fill: fill ?? \"rgba(0, 0, 0, 0)\",\n              stroke: stroke ?? \"rgba(0, 0, 0, 0)\",\n              fillOpacity: fillOpacity ?? 1,\n              strokeOpacity: strokeOpacity ?? 1,\n              strokeWidth: strokeWidth ?? 0\n            }\n          }\n        ]\n      }\n    ];\n  }\n  animateEmptyUpdateReady({ markerSelection, labelSelection }) {\n    markerScaleInAnimation(this, this.ctx.animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey, sizeKey, labelKey } = this.properties;\n    return this.getMarkerStyle(this.properties.marker, {\n      datum,\n      xKey,\n      yKey,\n      sizeKey,\n      labelKey,\n      highlighted: false\n    });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nBubbleSeries.className = \"BubbleSeries\";\nBubbleSeries.type = \"bubble\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesModule.ts\nvar BubbleSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"bubble\",\n  instanceConstructor: BubbleSeries,\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"bottom\" /* BOTTOM */\n    },\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      shape: \"circle\",\n      size: 7,\n      maxSize: 30,\n      fillOpacity: 0.8,\n      tooltip: { position: { type: \"node\" } },\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      }\n    }\n  },\n  paletteFactory: singleSeriesPaletteFactory\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesProperties.ts\nvar HistogramSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fillOpacity = 1;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.areaPlot = false;\n    this.aggregation = \"sum\";\n    this.shadow = new DropShadow();\n    this.label = new Label();\n    this.tooltip = new SeriesTooltip();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], HistogramSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], HistogramSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], HistogramSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], HistogramSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], HistogramSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], HistogramSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], HistogramSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], HistogramSeriesProperties.prototype, \"areaPlot\", 2);\n__decorateClass([\n  Validate(ARRAY, { optional: true })\n], HistogramSeriesProperties.prototype, \"bins\", 2);\n__decorateClass([\n  Validate(UNION([\"count\", \"sum\", \"mean\"], \"a histogram aggregation\"))\n], HistogramSeriesProperties.prototype, \"aggregation\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], HistogramSeriesProperties.prototype, \"binCount\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HistogramSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HistogramSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HistogramSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/histogramSeries.ts\nvar defaultBinCount = 10;\nvar HistogramSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [3 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      datumSelectionGarbageCollection: false,\n      animationResetFns: {\n        datum: resetBarSelectionsFn,\n        label: resetLabelFn\n      }\n    });\n    this.properties = new HistogramSeriesProperties();\n    this.calculatedBins = [];\n  }\n  // During processData phase, used to unify different ways of the user specifying\n  // the bins. Returns bins in format[[min1, max1], [min2, max2], ... ].\n  deriveBins(xDomain) {\n    const binStarts = createTicks(xDomain[0], xDomain[1], defaultBinCount);\n    const binSize = tickStep(xDomain[0], xDomain[1], defaultBinCount);\n    const [firstBinEnd] = binStarts;\n    const expandStartToBin = (n) => [n, n + binSize];\n    return [[firstBinEnd - binSize, firstBinEnd], ...binStarts.map(expandStartToBin)];\n  }\n  calculateNiceBins(domain, binCount) {\n    const startGuess = Math.floor(domain[0]);\n    const stop = domain[1];\n    const segments = binCount || 1;\n    const { start, binSize } = this.calculateNiceStart(startGuess, stop, segments);\n    return this.getBins(start, stop, binSize, segments);\n  }\n  getBins(start, stop, step, count) {\n    const bins = [];\n    const precision = this.calculatePrecision(step);\n    for (let i = 0; i < count; i++) {\n      const a = Math.round((start + i * step) * precision) / precision;\n      let b = Math.round((start + (i + 1) * step) * precision) / precision;\n      if (i === count - 1) {\n        b = Math.max(b, stop);\n      }\n      bins[i] = [a, b];\n    }\n    return bins;\n  }\n  calculatePrecision(step) {\n    let precision = 10;\n    if (isFinite(step) && step > 0) {\n      while (step < 1) {\n        precision *= 10;\n        step *= 10;\n      }\n    }\n    return precision;\n  }\n  calculateNiceStart(a, b, segments) {\n    const binSize = Math.abs(b - a) / segments;\n    const order = Math.floor(Math.log10(binSize));\n    const magnitude = Math.pow(10, order);\n    const start = Math.floor(a / magnitude) * magnitude;\n    return {\n      start,\n      binSize\n    };\n  }\n  async processData(dataController) {\n    if (!this.visible) {\n      this.processedData = void 0;\n      this.animationState.transition(\"updateData\");\n    }\n    const { xKey, yKey, areaPlot, aggregation } = this.properties;\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ yScale, xScale });\n    const props = [keyProperty(xKey, xScaleType), SORT_DOMAIN_GROUPS];\n    if (yKey) {\n      let aggProp = groupCount(\"groupAgg\");\n      if (aggregation === \"count\") {\n      } else if (aggregation === \"sum\") {\n        aggProp = groupSum(\"groupAgg\");\n      } else if (aggregation === \"mean\") {\n        aggProp = groupAverage(\"groupAgg\");\n      }\n      if (areaPlot) {\n        aggProp = area(\"groupAgg\", aggProp);\n      }\n      props.push(valueProperty(yKey, yScaleType, { invalidValue: void 0 }), aggProp);\n    } else {\n      let aggProp = groupCount(\"groupAgg\");\n      if (areaPlot) {\n        aggProp = area(\"groupAgg\", aggProp);\n      }\n      props.push(aggProp);\n    }\n    const groupByFn = (dataSet) => {\n      const xExtent = fixNumericExtent(dataSet.domain.keys[0]);\n      if (xExtent.length === 0) {\n        dataSet.domain.groups = [];\n        return () => [];\n      }\n      const bins = isNumber(this.properties.binCount) ? this.calculateNiceBins(xExtent, this.properties.binCount) : this.properties.bins ?? this.deriveBins(xExtent);\n      const binCount = bins.length;\n      this.calculatedBins = [...bins];\n      return (item) => {\n        const xValue = item.keys[0];\n        for (let i = 0; i < binCount; i++) {\n          const nextBin = bins[i];\n          if (xValue >= nextBin[0] && xValue < nextBin[1]) {\n            return nextBin;\n          }\n          if (i === binCount - 1 && xValue <= nextBin[1]) {\n            return nextBin;\n          }\n        }\n        return [];\n      };\n    };\n    if (!this.ctx.animationManager.isSkipped() && this.processedData) {\n      props.push(diff(this.processedData, false));\n    }\n    await this.requestDataModel(dataController, this.data, { props, groupByFn });\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel } = this;\n    if (!processedData || !dataModel || !this.calculatedBins.length)\n      return [];\n    const yDomain = dataModel.getDomain(this, `groupAgg`, \"aggregate\", processedData);\n    const xDomainMin = this.calculatedBins?.[0][0];\n    const xDomainMax = this.calculatedBins?.[(this.calculatedBins?.length ?? 0) - 1][1];\n    if (direction === \"x\" /* X */) {\n      return fixNumericExtent([xDomainMin, xDomainMax]);\n    }\n    return fixNumericExtent(yDomain);\n  }\n  async createNodeData() {\n    const {\n      id: seriesId,\n      axes,\n      processedData,\n      ctx: { callbackCache }\n    } = this;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!xAxis || !yAxis) {\n      return;\n    }\n    const { scale: xScale } = xAxis;\n    const { scale: yScale } = yAxis;\n    const { xKey, yKey, xName, yName, fill, stroke, strokeWidth, cornerRadius } = this.properties;\n    const {\n      formatter: labelFormatter = (params) => String(params.value),\n      fontStyle: labelFontStyle,\n      fontWeight: labelFontWeight,\n      fontSize: labelFontSize,\n      fontFamily: labelFontFamily,\n      color: labelColor\n    } = this.properties.label;\n    const nodeData = [];\n    const context = {\n      itemId: this.properties.yKey ?? this.id,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      animationValid: true,\n      visible: this.visible\n    };\n    if (!this.visible || !processedData || processedData.type !== \"grouped\")\n      return context;\n    processedData.data.forEach((group) => {\n      const {\n        aggValues: [[negativeAgg, positiveAgg]] = [[0, 0]],\n        datum,\n        datum: { length: frequency },\n        keys: domain,\n        keys: [xDomainMin, xDomainMax]\n      } = group;\n      const xMinPx = xScale.convert(xDomainMin);\n      const xMaxPx = xScale.convert(xDomainMax);\n      const total = negativeAgg + positiveAgg;\n      const yZeroPx = yScale.convert(0);\n      const yMaxPx = yScale.convert(total);\n      const w = Math.abs(xMaxPx - xMinPx);\n      const h = Math.abs(yMaxPx - yZeroPx);\n      const x = Math.min(xMinPx, xMaxPx);\n      const y = Math.min(yZeroPx, yMaxPx);\n      let selectionDatumLabel = void 0;\n      if (total !== 0) {\n        selectionDatumLabel = {\n          text: callbackCache.call(labelFormatter, {\n            value: total,\n            datum,\n            seriesId,\n            xKey,\n            yKey,\n            xName,\n            yName\n          }) ?? String(total),\n          fontStyle: labelFontStyle,\n          fontWeight: labelFontWeight,\n          fontSize: labelFontSize,\n          fontFamily: labelFontFamily,\n          fill: labelColor,\n          x: x + w / 2,\n          y: y + h / 2\n        };\n      }\n      const nodeMidPoint = {\n        x: x + w / 2,\n        y: y + h / 2\n      };\n      const yAxisReversed = yAxis.isReversed();\n      nodeData.push({\n        series: this,\n        datum,\n        // required by SeriesNodeDatum, but might not make sense here\n        // since each selection is an aggregation of multiple data.\n        aggregatedValue: total,\n        frequency,\n        domain,\n        yKey,\n        xKey,\n        x,\n        y,\n        xValue: xMinPx,\n        yValue: yMaxPx,\n        width: w,\n        height: h,\n        midPoint: nodeMidPoint,\n        fill,\n        stroke,\n        cornerRadius,\n        topLeftCornerRadius: !yAxisReversed,\n        topRightCornerRadius: !yAxisReversed,\n        bottomRightCornerRadius: yAxisReversed,\n        bottomLeftCornerRadius: yAxisReversed,\n        opacity: 1,\n        strokeWidth,\n        label: selectionDatumLabel\n      });\n    });\n    nodeData.sort((a, b) => a.x - b.x);\n    return context;\n  }\n  nodeFactory() {\n    return new Rect();\n  }\n  async updateDatumSelection(opts) {\n    const { nodeData, datumSelection } = opts;\n    return datumSelection.update(\n      nodeData,\n      (rect) => {\n        rect.tag = 0 /* Bin */;\n        rect.crisp = true;\n      },\n      (datum) => datum.domain.join(\"_\")\n    );\n  }\n  async updateDatumNodes(opts) {\n    const { isHighlight: isDatumHighlighted } = opts;\n    const {\n      fillOpacity: seriesFillOpacity,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      shadow,\n      highlightStyle: {\n        item: {\n          fill: highlightedFill,\n          fillOpacity: highlightFillOpacity = seriesFillOpacity,\n          stroke: highlightedStroke,\n          strokeWidth: highlightedDatumStrokeWidth\n        }\n      }\n    } = this.properties;\n    opts.datumSelection.each((rect, datum, index) => {\n      const {\n        cornerRadius,\n        topLeftCornerRadius,\n        topRightCornerRadius,\n        bottomRightCornerRadius,\n        bottomLeftCornerRadius\n      } = datum;\n      const strokeWidth = isDatumHighlighted && highlightedDatumStrokeWidth !== void 0 ? highlightedDatumStrokeWidth : datum.strokeWidth;\n      const fillOpacity = isDatumHighlighted ? highlightFillOpacity : seriesFillOpacity;\n      rect.fill = (isDatumHighlighted ? highlightedFill : void 0) ?? datum.fill;\n      rect.stroke = (isDatumHighlighted ? highlightedStroke : void 0) ?? datum.stroke;\n      rect.fillOpacity = fillOpacity;\n      rect.strokeOpacity = strokeOpacity;\n      rect.strokeWidth = strokeWidth;\n      rect.lineDash = lineDash;\n      rect.lineDashOffset = lineDashOffset;\n      rect.topLeftCornerRadius = topLeftCornerRadius ? cornerRadius : 0;\n      rect.topRightCornerRadius = topRightCornerRadius ? cornerRadius : 0;\n      rect.bottomRightCornerRadius = bottomRightCornerRadius ? cornerRadius : 0;\n      rect.bottomLeftCornerRadius = bottomLeftCornerRadius ? cornerRadius : 0;\n      rect.fillShadow = shadow;\n      rect.zIndex = isDatumHighlighted ? Series.highlightedZIndex : index;\n      rect.visible = datum.height > 0;\n    });\n  }\n  async updateLabelSelection(opts) {\n    const { labelData, labelSelection } = opts;\n    return labelSelection.update(labelData, (text) => {\n      text.tag = 1 /* Label */;\n      text.pointerEvents = 1 /* None */;\n      text.textAlign = \"center\";\n      text.textBaseline = \"middle\";\n    });\n  }\n  async updateLabelNodes(opts) {\n    const labelEnabled = this.isLabelEnabled();\n    opts.labelSelection.each((text, datum) => {\n      const label = datum.label;\n      if (label && labelEnabled) {\n        text.text = label.text;\n        text.x = label.x;\n        text.y = label.y;\n        text.fontStyle = label.fontStyle;\n        text.fontWeight = label.fontWeight;\n        text.fontSize = label.fontSize;\n        text.fontFamily = label.fontFamily;\n        text.fill = label.fill;\n        text.visible = true;\n      } else {\n        text.visible = false;\n      }\n    });\n  }\n  initQuadTree(quadtree) {\n    addHitTestersToQuadtree(quadtree, childrenIter(this.contentGroup.children[0]));\n  }\n  pickNodeClosestDatum(point) {\n    return findQuadtreeMatch(this, point);\n  }\n  getTooltipHtml(nodeDatum) {\n    const xAxis = this.axes[\"x\" /* X */];\n    const yAxis = this.axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, xName, yName, fill: color, aggregation, tooltip } = this.properties;\n    const {\n      aggregatedValue,\n      frequency,\n      domain: [rangeMin, rangeMax],\n      itemId\n    } = nodeDatum;\n    const title = `${sanitizeHtml(xName ?? xKey)}: ${xAxis.formatDatum(rangeMin)} - ${xAxis.formatDatum(rangeMax)}`;\n    let content = yKey ? `<b>${sanitizeHtml(yName ?? yKey)} (${aggregation})</b>: ${yAxis.formatDatum(aggregatedValue)}<br>` : \"\";\n    content += `<b>Frequency</b>: ${frequency}`;\n    const defaults = {\n      title,\n      backgroundColor: color,\n      content\n    };\n    return tooltip.toTooltipHtml(defaults, {\n      datum: {\n        data: nodeDatum.datum,\n        aggregatedValue: nodeDatum.aggregatedValue,\n        domain: nodeDatum.domain,\n        frequency: nodeDatum.frequency\n      },\n      itemId,\n      xKey,\n      xName,\n      yKey,\n      yName,\n      color,\n      title,\n      seriesId: this.id\n    });\n  }\n  getLegendData(legendType) {\n    if (!this.data?.length || legendType !== \"category\") {\n      return [];\n    }\n    const { xKey, yName, fill, fillOpacity, stroke, strokeWidth, strokeOpacity, visible } = this.properties;\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: xKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: yName ?? xKey ?? \"Frequency\"\n        },\n        symbols: [\n          {\n            marker: {\n              fill: fill ?? \"rgba(0, 0, 0, 0)\",\n              stroke: stroke ?? \"rgba(0, 0, 0, 0)\",\n              fillOpacity,\n              strokeOpacity,\n              strokeWidth\n            }\n          }\n        ]\n      }\n    ];\n  }\n  animateEmptyUpdateReady({ datumSelection, labelSelection }) {\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes, \"normal\"));\n    fromToMotion(this.id, \"datums\", this.ctx.animationManager, [datumSelection], fns);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n  }\n  animateWaitingUpdateReady(data) {\n    const dataDiff = this.processedData?.reduced?.diff;\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes, \"normal\"));\n    fromToMotion(\n      this.id,\n      \"datums\",\n      this.ctx.animationManager,\n      [data.datumSelection],\n      fns,\n      (_, datum) => createDatumId(datum.domain),\n      dataDiff\n    );\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, data.labelSelection);\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  computeFocusBounds({ datumIndex, seriesRect }) {\n    return computeBarFocusBounds(this.contextNodeData?.nodeData[datumIndex], this.contentGroup, seriesRect);\n  }\n};\nHistogramSeries.className = \"HistogramSeries\";\nHistogramSeries.type = \"histogram\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesModule.ts\nvar HistogramSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"histogram\",\n  instanceConstructor: HistogramSeries,\n  tooltipDefaults: { range: \"exact\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"bottom\" /* BOTTOM */\n    },\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      strokeWidth: 1,\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      lineDash: [0],\n      lineDashOffset: 0,\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR\n      },\n      shadow: {\n        enabled: false,\n        color: DEFAULT_SHADOW_COLOUR,\n        xOffset: 3,\n        yOffset: 3,\n        blur: 5\n      }\n    }\n  },\n  paletteFactory: ({ takeColors }) => {\n    const {\n      fills: [fill],\n      strokes: [stroke]\n    } = takeColors(1);\n    return { fill, stroke };\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesProperties.ts\nvar LineSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.stroke = \"#874349\";\n    this.strokeWidth = 2;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.interpolation = new InterpolationProperties();\n    this.marker = new SeriesMarker();\n    this.label = new Label();\n    this.tooltip = new SeriesTooltip();\n    this.connectMissingData = false;\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], LineSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], LineSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"stackGroup\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LineSeriesProperties.prototype, \"normalizedTo\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], LineSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LineSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], LineSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], LineSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LineSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"interpolation\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"tooltip\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], LineSeriesProperties.prototype, \"connectMissingData\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineSeries.ts\nvar LineSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      hasMarkers: true,\n      pickModes: [\n        2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */,\n        3 /* NEAREST_NODE */,\n        0 /* EXACT_SHAPE_MATCH */\n      ],\n      markerSelectionGarbageCollection: false,\n      animationResetFns: {\n        path: buildResetPathFn({ getOpacity: () => this.getOpacity() }),\n        label: resetLabelFn,\n        marker: (node, datum) => ({ ...resetMarkerFn(node), ...resetMarkerPositionFn(node, datum) })\n      }\n    });\n    this.properties = new LineSeriesProperties();\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    const { data, visible, seriesGrouping: { groupIndex = this.id, stackCount = 1 } = {} } = this;\n    const { xKey, yKey, connectMissingData, normalizedTo } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const common = { invalidValue: null };\n    if (connectMissingData && stackCount > 1) {\n      common.invalidValue = 0;\n    }\n    if (!visible) {\n      common.forceValue = 0;\n    }\n    const props = [];\n    if (!isContinuousX) {\n      props.push(keyProperty(xKey, xScaleType, { id: \"xKey\" }));\n    }\n    props.push(\n      valueProperty(xKey, xScaleType, { id: \"xValue\" }),\n      valueProperty(yKey, yScaleType, {\n        id: `yValueRaw`,\n        ...common,\n        invalidValue: void 0\n      })\n    );\n    if (stackCount > 1) {\n      const ids = [\n        `line-stack-${groupIndex}-yValues`,\n        `line-stack-${groupIndex}-yValues-trailing`,\n        `line-stack-${groupIndex}-yValues-marker`\n      ];\n      props.push(\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"window\",\n          \"current\",\n          {\n            id: `yValueEnd`,\n            ...common,\n            groupId: ids[0]\n          },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"window-trailing\",\n          \"current\",\n          {\n            id: `yValueStart`,\n            ...common,\n            groupId: ids[1]\n          },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"normal\",\n          \"current\",\n          {\n            id: `yValueCumulative`,\n            ...common,\n            groupId: ids[2]\n          },\n          yScaleType\n        )\n      );\n      if (isDefined(normalizedTo)) {\n        props.push(normaliseGroupTo([ids[0], ids[1], ids[2]], normalizedTo, \"range\"));\n      }\n    }\n    if (animationEnabled) {\n      props.push(animationValidation(isContinuousX ? [\"xValue\"] : void 0));\n      if (this.processedData) {\n        props.push(diff(this.processedData));\n      }\n    }\n    await this.requestDataModel(dataController, data, { props });\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel, axes } = this;\n    if (!processedData || !dataModel || processedData.data.length === 0)\n      return [];\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    const xDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n    if (direction === \"x\" /* X */) {\n      const domain = dataModel.getDomain(this, `xValue`, \"value\", processedData);\n      if (xDef?.def.type === \"value\" && xDef.def.valueType === \"category\") {\n        return domain;\n      }\n      return fixNumericExtent(extent(domain), xAxis);\n    } else {\n      const stackCount = this.seriesGrouping?.stackCount ?? 1;\n      const domain = stackCount > 1 ? dataModel.getDomain(this, `yValueEnd`, \"value\", processedData) : dataModel.getDomain(this, `yValueRaw`, \"value\", processedData);\n      return fixNumericExtent(domain, yAxis);\n    }\n  }\n  async createNodeData() {\n    const { processedData, dataModel, axes } = this;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!processedData || !dataModel || !xAxis || !yAxis) {\n      return;\n    }\n    const { xKey, yKey, xName, yName, marker, label, connectMissingData, legendItemName } = this.properties;\n    const stacked = (this.seriesGrouping?.stackCount ?? 1) > 1;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const yOffset = (yScale.bandwidth ?? 0) / 2;\n    const nodeData = [];\n    const size = marker.enabled ? marker.size : 0;\n    const xIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const yIdx = dataModel.resolveProcessedDataIndexById(this, `yValueRaw`);\n    const yCumulativeIdx = stacked ? dataModel.resolveProcessedDataIndexById(this, `yValueCumulative`) : yIdx;\n    const yEndIdx = stacked ? dataModel.resolveProcessedDataIndexById(this, `yValueEnd`) : void 0;\n    let moveTo = true;\n    processedData.data?.forEach(({ datum, values }) => {\n      const xDatum = values[xIdx];\n      const yDatum = values[yIdx];\n      const yCumulativeDatum = values[yCumulativeIdx];\n      const yEndDatum = yEndIdx != null ? values[yEndIdx] : void 0;\n      if (yDatum == null) {\n        moveTo || (moveTo = !connectMissingData);\n        return;\n      }\n      const x = xScale.convert(xDatum) + xOffset;\n      if (isNaN(x)) {\n        moveTo || (moveTo = !connectMissingData);\n        return;\n      }\n      const y = yScale.convert(yCumulativeDatum) + yOffset;\n      const labelText = this.getLabelText(\n        label,\n        { value: yDatum, datum, xKey, yKey, xName, yName, legendItemName },\n        (value) => isFiniteNumber(value) ? value.toFixed(2) : String(value)\n      );\n      nodeData.push({\n        series: this,\n        datum,\n        yKey,\n        xKey,\n        point: { x, y, moveTo, size },\n        midPoint: { x, y },\n        cumulativeValue: yEndDatum,\n        yValue: yDatum,\n        xValue: xDatum,\n        capDefaults: {\n          lengthRatioMultiplier: this.properties.marker.getDiameter(),\n          lengthMax: Infinity\n        },\n        label: labelText ? {\n          text: labelText,\n          fontStyle: label.fontStyle,\n          fontWeight: label.fontWeight,\n          fontSize: label.fontSize,\n          fontFamily: label.fontFamily,\n          textAlign: \"center\",\n          textBaseline: \"bottom\",\n          fill: label.color\n        } : void 0\n      });\n      moveTo = false;\n    });\n    return {\n      itemId: yKey,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      visible: this.visible\n    };\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  markerFactory() {\n    const { shape } = this.properties.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  async updatePathNodes(opts) {\n    const {\n      paths: [lineNode],\n      opacity,\n      visible,\n      animationEnabled\n    } = opts;\n    lineNode.setProperties({\n      fill: void 0,\n      lineJoin: \"round\",\n      pointerEvents: 1 /* None */,\n      opacity,\n      stroke: this.properties.stroke,\n      strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),\n      strokeOpacity: this.properties.strokeOpacity,\n      lineDash: this.properties.lineDash,\n      lineDashOffset: this.properties.lineDashOffset\n    });\n    if (!animationEnabled) {\n      lineNode.visible = visible;\n    }\n    updateClipPath(this, lineNode);\n  }\n  async updateMarkerSelection(opts) {\n    let { nodeData } = opts;\n    const { markerSelection } = opts;\n    const { shape, enabled } = this.properties.marker;\n    nodeData = shape && enabled ? nodeData : [];\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    return markerSelection.update(nodeData, void 0, (datum) => createDatumId(datum.xValue));\n  }\n  async updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, stroke, strokeWidth, strokeOpacity, marker, highlightStyle } = this.properties;\n    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle(), {\n      stroke,\n      strokeWidth,\n      strokeOpacity\n    });\n    const applyTranslation = this.ctx.animationManager.isSkipped();\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey }, baseStyle, { applyTranslation });\n    });\n    if (!highlighted) {\n      marker.markClean();\n    }\n  }\n  async updateLabelSelection(opts) {\n    return opts.labelSelection.update(this.isLabelEnabled() ? opts.labelData : []);\n  }\n  async updateLabelNodes(opts) {\n    const { enabled, fontStyle, fontWeight, fontSize, fontFamily, color } = this.properties.label;\n    opts.labelSelection.each((text, datum) => {\n      const { point, label } = datum;\n      if (datum && label && enabled) {\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.textAlign = label.textAlign;\n        text.textBaseline = label.textBaseline;\n        text.text = label.text;\n        text.x = point.x;\n        text.y = point.y - 10;\n        text.fill = color;\n        text.visible = true;\n      } else {\n        text.visible = false;\n      }\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const xAxis = this.axes[\"x\" /* X */];\n    const yAxis = this.axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, xName, yName, strokeWidth, marker, tooltip } = this.properties;\n    const { datum, xValue, yValue, itemId } = nodeDatum;\n    const xString = xAxis.formatDatum(xValue);\n    const yString = yAxis.formatDatum(yValue);\n    const title = sanitizeHtml(this.properties.title ?? yName);\n    const content = sanitizeHtml(xString + \": \" + yString);\n    const baseStyle = mergeDefaults({ fill: marker.stroke }, marker.getStyle(), { strokeWidth });\n    const { fill: color } = this.getMarkerStyle(\n      marker,\n      { datum: nodeDatum, xKey, yKey, highlighted: false },\n      baseStyle\n    );\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        datum,\n        itemId,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        title,\n        color,\n        seriesId: this.id,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  getLegendData(legendType) {\n    if (!(this.data?.length && this.properties.isValid() && legendType === \"category\")) {\n      return [];\n    }\n    const { yKey, yName, stroke, strokeOpacity, strokeWidth, lineDash, title, marker, visible, legendItemName } = this.properties;\n    const color0 = \"rgba(0, 0, 0, 0)\";\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: yKey,\n        legendItemName,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: legendItemName ?? title ?? yName ?? yKey\n        },\n        symbols: [\n          {\n            marker: {\n              shape: marker.shape,\n              fill: marker.fill ?? color0,\n              stroke: marker.stroke ?? stroke ?? color0,\n              fillOpacity: marker.fillOpacity ?? 1,\n              strokeOpacity: marker.strokeOpacity ?? strokeOpacity ?? 1,\n              strokeWidth: marker.strokeWidth ?? 0,\n              enabled: marker.enabled\n            },\n            line: {\n              stroke: stroke ?? color0,\n              strokeOpacity,\n              strokeWidth,\n              lineDash\n            }\n          }\n        ]\n      }\n    ];\n  }\n  async updatePaths(opts) {\n    this.updateLinePaths(opts.paths, opts.contextData);\n  }\n  updateLinePaths(paths, contextData) {\n    const { interpolation } = this.properties;\n    const { nodeData } = contextData;\n    const [lineNode] = paths;\n    lineNode.path.clear(true);\n    for (const range3 of pathRanges(nodeData)) {\n      plotPath(pathRangePoints(nodeData, range3), lineNode, interpolation);\n    }\n    lineNode.checkPathDirty();\n  }\n  animateEmptyUpdateReady(animationData) {\n    const { markerSelection, labelSelection, annotationSelections, contextData, paths } = animationData;\n    const { animationManager } = this.ctx;\n    this.updateLinePaths(paths, contextData);\n    pathSwipeInAnimation(this, animationManager, ...paths);\n    resetMotion([markerSelection], resetMarkerPositionFn);\n    markerSwipeScaleInAnimation(this, animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n    seriesLabelFadeInAnimation(this, \"annotations\", animationManager, ...annotationSelections);\n  }\n  animateReadyResize(animationData) {\n    const { contextData, paths } = animationData;\n    this.updateLinePaths(paths, contextData);\n    super.animateReadyResize(animationData);\n  }\n  animateWaitingUpdateReady(animationData) {\n    const { animationManager } = this.ctx;\n    const {\n      markerSelection: markerSelections,\n      labelSelection: labelSelections,\n      annotationSelections,\n      contextData,\n      paths,\n      previousContextData\n    } = animationData;\n    const [path] = paths;\n    super.resetAllAnimation(animationData);\n    const update = () => {\n      this.updateLinePaths(paths, contextData);\n    };\n    const skip = () => {\n      animationManager.skipCurrentBatch();\n      update();\n    };\n    if (contextData == null || previousContextData == null) {\n      update();\n      markerFadeInAnimation(this, animationManager, \"added\", markerSelections);\n      pathFadeInAnimation(this, \"path_properties\", animationManager, \"add\", path);\n      seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelections);\n      seriesLabelFadeInAnimation(this, \"annotations\", animationManager, ...annotationSelections);\n      return;\n    }\n    const fns = prepareLinePathAnimation(\n      contextData,\n      previousContextData,\n      this.processedData?.reduced?.diff,\n      this.properties.interpolation\n    );\n    if (fns === void 0) {\n      skip();\n      return;\n    } else if (fns.status === \"no-op\") {\n      return;\n    }\n    markerFadeInAnimation(this, animationManager, void 0, markerSelections);\n    fromToMotion(this.id, \"path_properties\", animationManager, [path], fns.pathProperties);\n    pathMotion(this.id, \"path_update\", animationManager, [path], fns.path);\n    if (fns.hasMotion) {\n      seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelections);\n      seriesLabelFadeInAnimation(this, \"annotations\", animationManager, ...annotationSelections);\n    }\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  getBandScalePadding() {\n    return { inner: 1, outer: 0.1 };\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey } = this.properties;\n    return this.getMarkerStyle(this.properties.marker, { datum, xKey, yKey, highlighted: true });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nLineSeries.className = \"LineSeries\";\nLineSeries.type = \"line\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesModule.ts\nvar LineSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"line\",\n  instanceConstructor: LineSeries,\n  stackable: true,\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    },\n    {\n      type: \"category\" /* CATEGORY */,\n      position: \"bottom\" /* BOTTOM */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      tooltip: { position: { type: \"node\" } },\n      strokeWidth: 2,\n      strokeOpacity: 1,\n      lineDash: [0],\n      lineDashOffset: 0,\n      interpolation: {\n        type: \"linear\",\n        // @ts-expect-error - users shouldn't specify all options, but we have to for theming to work\n        tension: 1,\n        position: \"end\"\n      },\n      marker: {\n        shape: \"circle\",\n        size: 7,\n        strokeWidth: 0\n      },\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      }\n    }\n  },\n  enterpriseThemeTemplate: {\n    series: {\n      errorBar: {\n        cap: {\n          lengthRatio: 1\n        }\n      }\n    }\n  },\n  paletteFactory: (params) => {\n    const { marker } = markerPaletteFactory(params);\n    return { stroke: marker.fill, marker };\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesProperties.ts\nvar ScatterSeriesLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.placement = \"top\";\n  }\n};\n__decorateClass([\n  Validate(LABEL_PLACEMENT)\n], ScatterSeriesLabel.prototype, \"placement\", 2);\nvar ScatterSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.colorRange = [\"#ffff00\", \"#00ff00\", \"#0000ff\"];\n    this.label = new ScatterSeriesLabel();\n    this.tooltip = new SeriesTooltip();\n    // No validation. Not a part of the options contract.\n    this.marker = new SeriesMarker();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], ScatterSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], ScatterSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"labelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"colorKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"labelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"colorName\", 2);\n__decorateClass([\n  Validate(NUMBER_ARRAY, { optional: true })\n], ScatterSeriesProperties.prototype, \"colorDomain\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], ScatterSeriesProperties.prototype, \"colorRange\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.shape\")\n], ScatterSeriesProperties.prototype, \"shape\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.size\")\n], ScatterSeriesProperties.prototype, \"size\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fill\")\n], ScatterSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fillOpacity\")\n], ScatterSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.stroke\")\n], ScatterSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeWidth\")\n], ScatterSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeOpacity\")\n], ScatterSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.itemStyler\", { optional: true })\n], ScatterSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ScatterSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ScatterSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/scatterSeries.ts\nvar ScatterSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [\n        2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */,\n        3 /* NEAREST_NODE */,\n        0 /* EXACT_SHAPE_MATCH */\n      ],\n      pathsPerSeries: 0,\n      hasMarkers: true,\n      markerSelectionGarbageCollection: false,\n      animationResetFns: {\n        marker: resetMarkerFn,\n        label: resetLabelFn\n      }\n    });\n    this.properties = new ScatterSeriesProperties();\n    this.colorScale = new ColorScale();\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid() || this.data == null || !this.visible)\n      return;\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const colorScaleType = this.colorScale.type;\n    const { xKey, yKey, labelKey, colorKey, colorDomain, colorRange } = this.properties;\n    const { dataModel, processedData } = await this.requestDataModel(dataController, this.data, {\n      props: [\n        keyProperty(xKey, xScaleType, { id: \"xKey-raw\" }),\n        keyProperty(yKey, yScaleType, { id: \"yKey-raw\" }),\n        ...labelKey ? [keyProperty(labelKey, \"band\", { id: `labelKey-raw` })] : [],\n        valueProperty(xKey, xScaleType, { id: `xValue` }),\n        valueProperty(yKey, yScaleType, { id: `yValue` }),\n        ...colorKey ? [valueProperty(colorKey, colorScaleType, { id: `colorValue` })] : [],\n        ...labelKey ? [valueProperty(labelKey, \"band\", { id: `labelValue` })] : []\n      ]\n    });\n    if (colorKey) {\n      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, `colorValue`);\n      this.colorScale.domain = colorDomain ?? processedData.domain.values[colorKeyIdx] ?? [];\n      this.colorScale.range = colorRange;\n      this.colorScale.update();\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { dataModel, processedData } = this;\n    if (!processedData || !dataModel)\n      return [];\n    const id = direction === \"x\" /* X */ ? `xValue` : `yValue`;\n    const dataDef = dataModel.resolveProcessedDataDefById(this, id);\n    const domain = dataModel.getDomain(this, id, \"value\", processedData);\n    if (dataDef?.def.type === \"value\" && dataDef?.def.valueType === \"category\") {\n      return domain;\n    }\n    const axis = this.axes[direction];\n    return fixNumericExtent(extent(domain), axis);\n  }\n  async createNodeData() {\n    const { axes, dataModel, processedData, colorScale } = this;\n    const { xKey, yKey, labelKey, colorKey, xName, yName, labelName, marker, label, visible } = this.properties;\n    const { placement } = label;\n    const markerShape = getMarker(marker.shape);\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!(dataModel && processedData && visible && xAxis && yAxis)) {\n      return;\n    }\n    const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`);\n    const colorDataIdx = colorKey ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : -1;\n    const labelDataIdx = labelKey ? dataModel.resolveProcessedDataIndexById(this, `labelValue`) : -1;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const yOffset = (yScale.bandwidth ?? 0) / 2;\n    const nodeData = [];\n    const font = label.getFont();\n    for (const { values, datum } of processedData.data ?? []) {\n      const xDatum = values[xDataIdx];\n      const yDatum = values[yDataIdx];\n      const x = xScale.convert(xDatum) + xOffset;\n      const y = yScale.convert(yDatum) + yOffset;\n      const labelText = this.getLabelText(label, {\n        value: labelKey ? values[labelDataIdx] : yDatum,\n        datum,\n        xKey,\n        yKey,\n        labelKey,\n        xName,\n        yName,\n        labelName\n      });\n      const size = Text.getTextSize(labelText, font);\n      const fill = colorKey ? colorScale.convert(values[colorDataIdx]) : void 0;\n      nodeData.push({\n        series: this,\n        itemId: yKey,\n        yKey,\n        xKey,\n        datum,\n        xValue: xDatum,\n        yValue: yDatum,\n        capDefaults: { lengthRatioMultiplier: marker.getDiameter(), lengthMax: Infinity },\n        point: { x, y, size: marker.size },\n        midPoint: { x, y },\n        fill,\n        label: { text: labelText, ...size },\n        marker: markerShape,\n        placement\n      });\n    }\n    return {\n      itemId: yKey,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      visible: this.visible\n    };\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  getLabelData() {\n    return this.contextNodeData?.labelData ?? [];\n  }\n  markerFactory() {\n    const { shape } = this.properties.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  async updateMarkerSelection(opts) {\n    const { nodeData, markerSelection } = opts;\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    return markerSelection.update(this.properties.marker.enabled ? nodeData : []);\n  }\n  async updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, labelKey, marker, highlightStyle } = this.properties;\n    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle());\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey, labelKey }, baseStyle);\n    });\n    if (!highlighted) {\n      marker.markClean();\n    }\n  }\n  async updateLabelSelection(opts) {\n    const placedLabels = this.isLabelEnabled() ? this.chart?.placeLabels().get(this) ?? [] : [];\n    return opts.labelSelection.update(\n      placedLabels.map(({ datum, x, y }) => ({\n        ...datum,\n        point: { x, y, size: datum.point.size },\n        placement: \"top\"\n      })),\n      (text) => {\n        text.pointerEvents = 1 /* None */;\n      }\n    );\n  }\n  async updateLabelNodes(opts) {\n    const { label } = this.properties;\n    opts.labelSelection.each((text, datum) => {\n      text.text = datum.label.text;\n      text.fill = label.color;\n      text.x = datum.point?.x ?? 0;\n      text.y = datum.point?.y ?? 0;\n      text.fontStyle = label.fontStyle;\n      text.fontWeight = label.fontWeight;\n      text.fontSize = label.fontSize;\n      text.fontFamily = label.fontFamily;\n      text.textAlign = \"left\";\n      text.textBaseline = \"top\";\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const xAxis = this.axes[\"x\" /* X */];\n    const yAxis = this.axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, labelKey, xName, yName, labelName, title = yName, marker, tooltip } = this.properties;\n    const { datum, xValue, yValue, label, itemId } = nodeDatum;\n    const baseStyle = mergeDefaults(\n      { fill: nodeDatum.fill, strokeWidth: this.getStrokeWidth(marker.strokeWidth) },\n      marker.getStyle()\n    );\n    const { fill: color = \"gray\" } = this.getMarkerStyle(\n      marker,\n      { datum: nodeDatum, highlighted: false, xKey, yKey, labelKey },\n      baseStyle\n    );\n    const xString = sanitizeHtml(xAxis.formatDatum(xValue));\n    const yString = sanitizeHtml(yAxis.formatDatum(yValue));\n    let content = `<b>${sanitizeHtml(xName ?? xKey)}</b>: ${xString}<br><b>${sanitizeHtml(yName ?? yKey)}</b>: ${yString}`;\n    if (labelKey) {\n      content = `<b>${sanitizeHtml(labelName ?? labelKey)}</b>: ${sanitizeHtml(label.text)}<br>` + content;\n    }\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        datum,\n        itemId,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        labelKey,\n        labelName,\n        title,\n        color,\n        seriesId: this.id,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  getLegendData(legendType) {\n    const { yKey, yName, title, marker, visible } = this.properties;\n    const { fill, stroke, fillOpacity, strokeOpacity, strokeWidth } = marker;\n    if (!this.data?.length || !this.properties.isValid() || legendType !== \"category\") {\n      return [];\n    }\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: yKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: title ?? yName ?? yKey\n        },\n        symbols: [\n          {\n            marker: {\n              shape: marker.shape,\n              fill: marker.fill ?? fill ?? \"rgba(0, 0, 0, 0)\",\n              stroke: marker.stroke ?? stroke ?? \"rgba(0, 0, 0, 0)\",\n              fillOpacity: fillOpacity ?? 1,\n              strokeOpacity: strokeOpacity ?? 1,\n              strokeWidth: strokeWidth ?? 0\n            }\n          }\n        ]\n      }\n    ];\n  }\n  animateEmptyUpdateReady(data) {\n    const { markerSelection, labelSelection, annotationSelections } = data;\n    markerScaleInAnimation(this, this.ctx.animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n    seriesLabelFadeInAnimation(this, \"annotations\", this.ctx.animationManager, ...annotationSelections);\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey, labelKey } = this.properties;\n    return this.getMarkerStyle(this.properties.marker, { datum, xKey, yKey, labelKey, highlighted: true });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nScatterSeries.className = \"ScatterSeries\";\nScatterSeries.type = \"scatter\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesModule.ts\nvar ScatterSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"scatter\",\n  instanceConstructor: ScatterSeries,\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"bottom\" /* BOTTOM */\n    },\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      shape: \"circle\",\n      size: 7,\n      fillOpacity: 0.8,\n      tooltip: { position: { type: \"node\" } },\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      }\n    }\n  },\n  enterpriseThemeTemplate: {\n    series: {\n      errorBar: {\n        cap: {\n          lengthRatio: 1\n        }\n      }\n    }\n  },\n  paletteFactory: singleSeriesPaletteFactory\n};\n\n// packages/ag-charts-community/src/scene/sectorBox.ts\nvar SectorBox = class _SectorBox {\n  constructor(startAngle, endAngle, innerRadius, outerRadius) {\n    this.startAngle = startAngle;\n    this.endAngle = endAngle;\n    this.innerRadius = innerRadius;\n    this.outerRadius = outerRadius;\n  }\n  clone() {\n    const { startAngle, endAngle, innerRadius, outerRadius } = this;\n    return new _SectorBox(startAngle, endAngle, innerRadius, outerRadius);\n  }\n  [interpolate](other, d) {\n    return new _SectorBox(\n      this.startAngle * (1 - d) + other.startAngle * d,\n      this.endAngle * (1 - d) + other.endAngle * d,\n      this.innerRadius * (1 - d) + other.innerRadius * d,\n      this.outerRadius * (1 - d) + other.outerRadius * d\n    );\n  }\n};\n\n// packages/ag-charts-community/src/scene/util/sector.ts\nfunction sectorBox({ startAngle, endAngle, innerRadius, outerRadius }) {\n  let x0 = Infinity;\n  let y0 = Infinity;\n  let x1 = -Infinity;\n  let y1 = -Infinity;\n  const addPoint = (x, y) => {\n    x0 = Math.min(x, x0);\n    y0 = Math.min(y, y0);\n    x1 = Math.max(x, x1);\n    y1 = Math.max(y, y1);\n  };\n  addPoint(innerRadius * Math.cos(startAngle), innerRadius * Math.sin(startAngle));\n  addPoint(innerRadius * Math.cos(endAngle), innerRadius * Math.sin(endAngle));\n  addPoint(outerRadius * Math.cos(startAngle), outerRadius * Math.sin(startAngle));\n  addPoint(outerRadius * Math.cos(endAngle), outerRadius * Math.sin(endAngle));\n  if (isBetweenAngles(0, startAngle, endAngle)) {\n    addPoint(outerRadius, 0);\n  }\n  if (isBetweenAngles(Math.PI * 0.5, startAngle, endAngle)) {\n    addPoint(0, outerRadius);\n  }\n  if (isBetweenAngles(Math.PI, startAngle, endAngle)) {\n    addPoint(-outerRadius, 0);\n  }\n  if (isBetweenAngles(Math.PI * 1.5, startAngle, endAngle)) {\n    addPoint(0, -outerRadius);\n  }\n  return new BBox(x0, y0, x1 - x0, y1 - y0);\n}\nfunction isPointInSector(x, y, sector) {\n  const radius = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\n  const { innerRadius, outerRadius } = sector;\n  if (sector.startAngle === sector.endAngle || radius < Math.min(innerRadius, outerRadius) || radius > Math.max(innerRadius, outerRadius)) {\n    return false;\n  }\n  const startAngle = normalizeAngle180(sector.startAngle);\n  const endAngle = normalizeAngle180(sector.endAngle);\n  const angle2 = Math.atan2(y, x);\n  return startAngle < endAngle ? angle2 <= endAngle && angle2 >= startAngle : angle2 <= endAngle && angle2 >= -Math.PI || angle2 >= startAngle && angle2 <= Math.PI;\n}\nfunction lineCollidesSector(line, sector) {\n  const { startAngle, endAngle, innerRadius, outerRadius } = sector;\n  const outerStart = { x: outerRadius * Math.cos(startAngle), y: outerRadius * Math.sin(startAngle) };\n  const outerEnd = { x: outerRadius * Math.cos(endAngle), y: outerRadius * Math.sin(endAngle) };\n  const innerStart = innerRadius === 0 ? { x: 0, y: 0 } : { x: innerRadius * Math.cos(startAngle), y: innerRadius * Math.sin(startAngle) };\n  const innerEnd = innerRadius === 0 ? { x: 0, y: 0 } : { x: innerRadius * Math.cos(endAngle), y: innerRadius * Math.sin(endAngle) };\n  return segmentIntersection(\n    line.start.x,\n    line.start.y,\n    line.end.x,\n    line.end.y,\n    outerStart.x,\n    outerStart.y,\n    innerStart.x,\n    innerStart.y\n  ) || segmentIntersection(\n    line.start.x,\n    line.start.y,\n    line.end.x,\n    line.end.y,\n    outerEnd.x,\n    outerEnd.y,\n    innerEnd.x,\n    innerEnd.y\n  ) || arcIntersections(\n    0,\n    0,\n    outerRadius,\n    startAngle,\n    endAngle,\n    true,\n    line.start.x,\n    line.start.y,\n    line.end.x,\n    line.end.y\n  );\n}\nfunction boxCollidesSector(box, sector) {\n  const topLeft = { x: box.x, y: box.y };\n  const topRight = { x: box.x + box.width, y: box.y };\n  const bottomLeft = { x: box.x, y: box.y + box.height };\n  const bottomRight = { x: box.x + box.width, y: box.y + box.height };\n  return lineCollidesSector({ start: topLeft, end: topRight }, sector) || lineCollidesSector({ start: bottomLeft, end: bottomRight }, sector);\n}\nfunction radiiScalingFactor(r, sweep, a, b) {\n  if (a === 0 && b === 0)\n    return 0;\n  const fs1 = Math.asin(Math.abs(1 * a) / (r + 1 * a)) + Math.asin(Math.abs(1 * b) / (r + 1 * b)) - sweep;\n  if (fs1 < 0)\n    return 1;\n  let start = 0;\n  let end = 1;\n  for (let i = 0; i < 8; i += 1) {\n    const s = (start + end) / 2;\n    const fs = Math.asin(Math.abs(s * a) / (r + s * a)) + Math.asin(Math.abs(s * b) / (r + s * b)) - sweep;\n    if (fs < 0) {\n      start = s;\n    } else {\n      end = s;\n    }\n  }\n  return start;\n}\nvar delta2 = 1e-6;\nfunction clockwiseAngle(angle2, relativeToStartAngle) {\n  if (angleBetween(angle2, relativeToStartAngle) < delta2) {\n    return relativeToStartAngle;\n  } else {\n    return normalizeAngle360(angle2 - relativeToStartAngle) + relativeToStartAngle;\n  }\n}\nfunction clockwiseAngles(startAngle, endAngle, relativeToStartAngle = 0) {\n  const fullPie = Math.abs(endAngle - startAngle) >= 2 * Math.PI;\n  const sweepAngle = fullPie ? 2 * Math.PI : normalizeAngle360(endAngle - startAngle);\n  startAngle = clockwiseAngle(startAngle, relativeToStartAngle);\n  endAngle = startAngle + sweepAngle;\n  return { startAngle, endAngle };\n}\nfunction arcRadialLineIntersectionAngle(cx, cy, r, startAngle, endAngle, clipAngle) {\n  const sinA = Math.sin(clipAngle);\n  const cosA = Math.cos(clipAngle);\n  const c = cx ** 2 + cy ** 2 - r ** 2;\n  let p0x = NaN;\n  let p0y = NaN;\n  let p1x = NaN;\n  let p1y = NaN;\n  if (cosA > 0.5) {\n    const tanA = sinA / cosA;\n    const a = 1 + tanA ** 2;\n    const b = -2 * (cx + cy * tanA);\n    const d = b ** 2 - 4 * a * c;\n    if (d < 0)\n      return;\n    const x0 = (-b + Math.sqrt(d)) / (2 * a);\n    const x1 = (-b - Math.sqrt(d)) / (2 * a);\n    p0x = x0;\n    p0y = x0 * tanA;\n    p1x = x1;\n    p1y = x1 * tanA;\n  } else {\n    const cotA = cosA / sinA;\n    const a = 1 + cotA ** 2;\n    const b = -2 * (cy + cx * cotA);\n    const d = b ** 2 - 4 * a * c;\n    if (d < 0)\n      return;\n    const y0 = (-b + Math.sqrt(d)) / (2 * a);\n    const y1 = (-b - Math.sqrt(d)) / (2 * a);\n    p0x = y0 * cotA;\n    p0y = y0;\n    p1x = y1 * cotA;\n    p1y = y1;\n  }\n  const normalisedX = cosA;\n  const normalisedY = sinA;\n  const p0DotNormalized = p0x * normalisedX + p0y * normalisedY;\n  const p1DotNormalized = p1x * normalisedX + p1y * normalisedY;\n  const a0 = p0DotNormalized > 0 ? clockwiseAngle(Math.atan2(p0y - cy, p0x - cx), startAngle) : NaN;\n  const a1 = p1DotNormalized > 0 ? clockwiseAngle(Math.atan2(p1y - cy, p1x - cx), startAngle) : NaN;\n  if (a0 >= startAngle && a0 <= endAngle) {\n    return a0;\n  } else if (a1 >= startAngle && a1 <= endAngle) {\n    return a1;\n  }\n}\nfunction arcCircleIntersectionAngle(cx, cy, r, startAngle, endAngle, circleR) {\n  const d = Math.hypot(cx, cy);\n  const d1 = (d ** 2 - r ** 2 + circleR ** 2) / (2 * d);\n  const d2 = d - d1;\n  const theta = Math.atan2(cy, cx);\n  const deltaTheta = Math.acos(-d2 / r);\n  const a0 = clockwiseAngle(theta + deltaTheta, startAngle);\n  const a1 = clockwiseAngle(theta - deltaTheta, startAngle);\n  if (a0 >= startAngle && a0 <= endAngle) {\n    return a0;\n  } else if (a1 >= startAngle && a1 <= endAngle) {\n    return a1;\n  }\n}\n\n// packages/ag-charts-community/src/scene/shape/sector.ts\nvar Arc = class {\n  constructor(cx, cy, r, a0, a1) {\n    this.cx = cx;\n    this.cy = cy;\n    this.r = r;\n    this.a0 = a0;\n    this.a1 = a1;\n    if (this.a0 >= this.a1) {\n      this.a0 = NaN;\n      this.a1 = NaN;\n    }\n  }\n  isValid() {\n    return Number.isFinite(this.a0) && Number.isFinite(this.a1);\n  }\n  pointAt(a) {\n    return {\n      x: this.cx + this.r * Math.cos(a),\n      y: this.cy + this.r * Math.sin(a)\n    };\n  }\n  clipStart(a) {\n    if (a == null || !this.isValid() || a < this.a0)\n      return;\n    this.a0 = a;\n    if (Number.isNaN(a) || this.a0 >= this.a1) {\n      this.a0 = NaN;\n      this.a1 = NaN;\n    }\n  }\n  clipEnd(a) {\n    if (a == null || !this.isValid() || a > this.a1)\n      return;\n    this.a1 = a;\n    if (Number.isNaN(a) || this.a0 >= this.a1) {\n      this.a0 = NaN;\n      this.a1 = NaN;\n    }\n  }\n};\nvar Sector = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.centerX = 0;\n    this.centerY = 0;\n    this.innerRadius = 10;\n    this.outerRadius = 20;\n    this.startAngle = 0;\n    this.endAngle = Math.PI * 2;\n    this.clipSector = void 0;\n    this.concentricEdgeInset = 0;\n    this.radialEdgeInset = 0;\n    this.startOuterCornerRadius = 0;\n    this.endOuterCornerRadius = 0;\n    this.startInnerCornerRadius = 0;\n    this.endInnerCornerRadius = 0;\n  }\n  set inset(value) {\n    this.concentricEdgeInset = value;\n    this.radialEdgeInset = value;\n  }\n  set cornerRadius(value) {\n    this.startOuterCornerRadius = value;\n    this.endOuterCornerRadius = value;\n    this.startInnerCornerRadius = value;\n    this.endInnerCornerRadius = value;\n  }\n  computeBBox() {\n    return sectorBox(this).translate(this.centerX, this.centerY);\n  }\n  normalizedRadii() {\n    const { concentricEdgeInset } = this;\n    return {\n      innerRadius: Math.max(Math.min(this.innerRadius, this.outerRadius) + concentricEdgeInset, 0),\n      outerRadius: Math.max(Math.max(this.innerRadius, this.outerRadius) - concentricEdgeInset, 0)\n    };\n  }\n  normalizedClipSector() {\n    const { clipSector } = this;\n    if (clipSector == null)\n      return;\n    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);\n    const { innerRadius, outerRadius } = this.normalizedRadii();\n    const clipAngles = clockwiseAngles(clipSector.startAngle, clipSector.endAngle, startAngle);\n    return new SectorBox(\n      Math.max(startAngle, clipAngles.startAngle),\n      Math.min(endAngle, clipAngles.endAngle),\n      Math.max(innerRadius, clipSector.innerRadius),\n      Math.min(outerRadius, clipSector.outerRadius)\n    );\n  }\n  getAngleOffset(radius) {\n    return radius > 0 ? this.radialEdgeInset / radius : 0;\n  }\n  arc(r, angleSweep, a0, a1, outerArc, innerArc, start, inner) {\n    if (r <= 0)\n      return;\n    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);\n    const { innerRadius, outerRadius } = this.normalizedRadii();\n    const clipSector = this.normalizedClipSector();\n    if (inner && innerRadius <= 0)\n      return;\n    const innerAngleOffset = this.getAngleOffset(innerRadius);\n    const outerAngleOffset = this.getAngleOffset(outerRadius);\n    const angleOffset = inner ? this.getAngleOffset(innerRadius + r) : this.getAngleOffset(outerRadius - r);\n    const angle2 = start ? startAngle + angleOffset + angleSweep : endAngle - angleOffset - angleSweep;\n    const radius = inner ? innerRadius + r : outerRadius - r;\n    const cx = radius * Math.cos(angle2);\n    const cy = radius * Math.sin(angle2);\n    if (clipSector != null) {\n      const delta3 = 1e-6;\n      if (!start && !(angle2 >= startAngle - delta3 && angle2 <= clipSector.endAngle - delta3))\n        return;\n      if (start && !(angle2 >= clipSector.startAngle + delta3 && angle2 <= endAngle - delta3))\n        return;\n      if (inner && !(radius >= clipSector.innerRadius - delta3))\n        return;\n      if (!inner && !(radius <= clipSector.outerRadius + delta3))\n        return;\n    }\n    const arc = new Arc(cx, cy, r, a0, a1);\n    if (clipSector != null) {\n      if (inner) {\n        arc.clipStart(\n          arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.endAngle - innerAngleOffset)\n        );\n        arc.clipEnd(\n          arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.startAngle + innerAngleOffset)\n        );\n      } else {\n        arc.clipStart(\n          arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.startAngle + outerAngleOffset)\n        );\n        arc.clipEnd(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.endAngle - outerAngleOffset));\n      }\n      let circleClipStart;\n      let circleClipEnd;\n      if (start) {\n        circleClipStart = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.innerRadius);\n        circleClipEnd = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.outerRadius);\n      } else {\n        circleClipStart = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.outerRadius);\n        circleClipEnd = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.innerRadius);\n      }\n      arc.clipStart(circleClipStart);\n      arc.clipEnd(circleClipEnd);\n      if (circleClipStart != null) {\n        const { x: x2, y: y2 } = arc.pointAt(circleClipStart);\n        const theta2 = clockwiseAngle(Math.atan2(y2, x2), startAngle);\n        if (start) {\n          innerArc?.clipStart(theta2);\n        } else {\n          outerArc.clipEnd(theta2);\n        }\n      }\n      if (circleClipEnd != null) {\n        const { x: x2, y: y2 } = arc.pointAt(circleClipEnd);\n        const theta2 = clockwiseAngle(Math.atan2(y2, x2), startAngle);\n        if (start) {\n          outerArc.clipStart(theta2);\n        } else {\n          innerArc?.clipEnd(theta2);\n        }\n      }\n    }\n    if (clipSector != null) {\n      const { x: x2, y: y2 } = arc.pointAt((arc.a0 + arc.a1) / 2);\n      if (!isPointInSector(x2, y2, clipSector))\n        return;\n    }\n    const { x, y } = arc.pointAt(start === inner ? arc.a0 : arc.a1);\n    const theta = clockwiseAngle(Math.atan2(y, x), startAngle);\n    const radialArc = inner ? innerArc : outerArc;\n    if (start) {\n      radialArc?.clipStart(theta);\n    } else {\n      radialArc?.clipEnd(theta);\n    }\n    return arc;\n  }\n  updatePath() {\n    const delta3 = 1e-6;\n    const { path, centerX, centerY, concentricEdgeInset, radialEdgeInset } = this;\n    let { startOuterCornerRadius, endOuterCornerRadius, startInnerCornerRadius, endInnerCornerRadius } = this;\n    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);\n    const { innerRadius, outerRadius } = this.normalizedRadii();\n    const clipSector = this.normalizedClipSector();\n    const sweepAngle = endAngle - startAngle;\n    const fullPie = sweepAngle >= 2 * Math.PI - delta3;\n    path.clear();\n    if (this.innerRadius === 0 && this.outerRadius === 0)\n      return;\n    if ((clipSector?.startAngle ?? startAngle) === (clipSector?.endAngle ?? endAngle)) {\n      return;\n    } else if (fullPie && this.clipSector == null && startOuterCornerRadius === 0 && endOuterCornerRadius === 0 && startInnerCornerRadius === 0 && endInnerCornerRadius === 0) {\n      path.moveTo(centerX + outerRadius * Math.cos(startAngle), centerY + outerRadius * Math.sin(startAngle));\n      path.arc(centerX, centerY, outerRadius, startAngle, endAngle);\n      if (innerRadius > concentricEdgeInset) {\n        path.moveTo(centerX + innerRadius * Math.cos(endAngle), centerY + innerRadius * Math.sin(endAngle));\n        path.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);\n      }\n      path.closePath();\n      return;\n    }\n    const innerAngleOffset = this.getAngleOffset(innerRadius);\n    const outerAngleOffset = this.getAngleOffset(outerRadius);\n    const outerAngleExceeded = sweepAngle < 2 * outerAngleOffset;\n    if (outerAngleExceeded)\n      return;\n    const hasInnerSweep = (clipSector?.innerRadius ?? innerRadius) > concentricEdgeInset;\n    const innerAngleExceeded = innerRadius < concentricEdgeInset || sweepAngle < 2 * innerAngleOffset;\n    const radialLength = outerRadius - innerRadius;\n    const maxRadialLength = Math.max(\n      startOuterCornerRadius,\n      startInnerCornerRadius,\n      endOuterCornerRadius,\n      endInnerCornerRadius\n    );\n    const initialScalingFactor = maxRadialLength > 0 ? Math.min(radialLength / maxRadialLength, 1) : 1;\n    startOuterCornerRadius *= initialScalingFactor;\n    endOuterCornerRadius *= initialScalingFactor;\n    startInnerCornerRadius *= initialScalingFactor;\n    endInnerCornerRadius *= initialScalingFactor;\n    const outerScalingFactor = radiiScalingFactor(\n      outerRadius,\n      sweepAngle - 2 * outerAngleOffset,\n      -startOuterCornerRadius,\n      -endOuterCornerRadius\n    );\n    startOuterCornerRadius *= outerScalingFactor;\n    endOuterCornerRadius *= outerScalingFactor;\n    if (!innerAngleExceeded && hasInnerSweep) {\n      const innerScalingFactor = radiiScalingFactor(\n        innerRadius,\n        sweepAngle - 2 * innerAngleOffset,\n        startInnerCornerRadius,\n        endInnerCornerRadius\n      );\n      startInnerCornerRadius *= innerScalingFactor;\n      endInnerCornerRadius *= innerScalingFactor;\n    } else {\n      startInnerCornerRadius = 0;\n      endInnerCornerRadius = 0;\n    }\n    const maxCombinedRadialLength = Math.max(\n      startOuterCornerRadius + startInnerCornerRadius,\n      endOuterCornerRadius + endInnerCornerRadius\n    );\n    const edgesScalingFactor = maxCombinedRadialLength > 0 ? Math.min(radialLength / maxCombinedRadialLength, 1) : 1;\n    startOuterCornerRadius *= edgesScalingFactor;\n    endOuterCornerRadius *= edgesScalingFactor;\n    startInnerCornerRadius *= edgesScalingFactor;\n    endInnerCornerRadius *= edgesScalingFactor;\n    let startOuterCornerRadiusAngleSweep = 0;\n    let endOuterCornerRadiusAngleSweep = 0;\n    const startOuterCornerRadiusSweep = startOuterCornerRadius / (outerRadius - startOuterCornerRadius);\n    const endOuterCornerRadiusSweep = endOuterCornerRadius / (outerRadius - endOuterCornerRadius);\n    if (startOuterCornerRadiusSweep >= 0 && startOuterCornerRadiusSweep < 1 - delta3) {\n      startOuterCornerRadiusAngleSweep = Math.asin(startOuterCornerRadiusSweep);\n    } else {\n      startOuterCornerRadiusAngleSweep = sweepAngle / 2;\n      const maxStartOuterCornerRadius = outerRadius / (1 / Math.sin(startOuterCornerRadiusAngleSweep) + 1);\n      startOuterCornerRadius = Math.min(maxStartOuterCornerRadius, startOuterCornerRadius);\n    }\n    if (endOuterCornerRadiusSweep >= 0 && endOuterCornerRadiusSweep < 1 - delta3) {\n      endOuterCornerRadiusAngleSweep = Math.asin(endOuterCornerRadiusSweep);\n    } else {\n      endOuterCornerRadiusAngleSweep = sweepAngle / 2;\n      const maxEndOuterCornerRadius = outerRadius / (1 / Math.sin(endOuterCornerRadiusAngleSweep) + 1);\n      endOuterCornerRadius = Math.min(maxEndOuterCornerRadius, endOuterCornerRadius);\n    }\n    const startInnerCornerRadiusAngleSweep = Math.asin(\n      startInnerCornerRadius / (innerRadius + startInnerCornerRadius)\n    );\n    const endInnerCornerRadiusAngleSweep = Math.asin(endInnerCornerRadius / (innerRadius + endInnerCornerRadius));\n    const outerArcRadius = clipSector?.outerRadius ?? outerRadius;\n    const outerArcRadiusOffset = this.getAngleOffset(outerArcRadius);\n    const outerArc = new Arc(\n      0,\n      0,\n      outerArcRadius,\n      startAngle + outerArcRadiusOffset,\n      endAngle - outerArcRadiusOffset\n    );\n    const innerArcRadius = clipSector?.innerRadius ?? innerRadius;\n    const innerArcRadiusOffset = this.getAngleOffset(innerArcRadius);\n    const innerArc = hasInnerSweep ? new Arc(0, 0, innerArcRadius, startAngle + innerArcRadiusOffset, endAngle - innerArcRadiusOffset) : void 0;\n    if (clipSector != null) {\n      outerArc.clipStart(clipSector.startAngle);\n      outerArc.clipEnd(clipSector.endAngle);\n      innerArc?.clipStart(clipSector.startAngle);\n      innerArc?.clipEnd(clipSector.endAngle);\n    }\n    const startOuterArc = this.arc(\n      startOuterCornerRadius,\n      startOuterCornerRadiusAngleSweep,\n      startAngle - Math.PI * 0.5,\n      startAngle + startOuterCornerRadiusAngleSweep,\n      outerArc,\n      innerArc,\n      true,\n      false\n    );\n    const endOuterArc = this.arc(\n      endOuterCornerRadius,\n      endOuterCornerRadiusAngleSweep,\n      endAngle - endOuterCornerRadiusAngleSweep,\n      endAngle + Math.PI * 0.5,\n      outerArc,\n      innerArc,\n      false,\n      false\n    );\n    const endInnerArc = this.arc(\n      endInnerCornerRadius,\n      endInnerCornerRadiusAngleSweep,\n      endAngle + Math.PI * 0.5,\n      endAngle + Math.PI - endInnerCornerRadiusAngleSweep,\n      outerArc,\n      innerArc,\n      false,\n      true\n    );\n    const startInnerArc = this.arc(\n      startInnerCornerRadius,\n      startInnerCornerRadiusAngleSweep,\n      startAngle + Math.PI + startInnerCornerRadiusAngleSweep,\n      startAngle + Math.PI * 1.5,\n      outerArc,\n      innerArc,\n      true,\n      true\n    );\n    if (innerAngleExceeded) {\n      const x = sweepAngle < Math.PI * 0.5 ? radialEdgeInset * (1 + Math.cos(sweepAngle)) / Math.sin(sweepAngle) : NaN;\n      let r;\n      if (x > 0 && x < outerRadius) {\n        r = Math.max(Math.hypot(radialEdgeInset, x), innerRadius);\n      } else {\n        r = innerRadius;\n      }\n      const midAngle = startAngle + sweepAngle * 0.5;\n      path.moveTo(centerX + r * Math.cos(midAngle), centerY + r * Math.sin(midAngle));\n    } else if (startInnerArc?.isValid() === true || innerArc?.isValid() === true) {\n    } else {\n      const midAngle = startAngle + sweepAngle / 2;\n      const cx = innerRadius * Math.cos(midAngle);\n      const cy = innerRadius * Math.sin(midAngle);\n      path.moveTo(centerX + cx, centerY + cy);\n    }\n    if (startOuterArc?.isValid() === true) {\n      const { cx, cy, r, a0, a1 } = startOuterArc;\n      path.arc(centerX + cx, centerY + cy, r, a0, a1);\n    }\n    if (outerArc.isValid()) {\n      const { r, a0, a1 } = outerArc;\n      path.arc(centerX, centerY, r, a0, a1);\n    }\n    if (endOuterArc?.isValid() === true) {\n      const { cx, cy, r, a0, a1 } = endOuterArc;\n      path.arc(centerX + cx, centerY + cy, r, a0, a1);\n    }\n    if (!innerAngleExceeded) {\n      if (endInnerArc?.isValid() === true) {\n        const { cx, cy, r, a0, a1 } = endInnerArc;\n        path.arc(centerX + cx, centerY + cy, r, a0, a1);\n      }\n      if (innerArc?.isValid() === true) {\n        const { r, a0, a1 } = innerArc;\n        path.arc(centerX, centerY, r, a1, a0, true);\n      }\n      if (startInnerArc?.isValid() === true) {\n        const { cx, cy, r, a0, a1 } = startInnerArc;\n        path.arc(centerX + cx, centerY + cy, r, a0, a1);\n      }\n    }\n    path.closePath();\n  }\n  isPointInPath(x, y) {\n    const point = this.transformPoint(x, y);\n    const { startAngle, endAngle, innerRadius, outerRadius } = this.clipSector ?? this;\n    return isPointInSector(point.x - this.centerX, point.y - this.centerY, {\n      startAngle,\n      endAngle,\n      innerRadius: Math.min(innerRadius, outerRadius),\n      outerRadius: Math.max(innerRadius, outerRadius)\n    });\n  }\n};\nSector.className = \"Sector\";\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"centerX\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"centerY\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"innerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"outerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"startAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"endAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"clipSector\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"concentricEdgeInset\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"radialEdgeInset\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"startOuterCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"endOuterCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"startInnerCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"endInnerCornerRadius\", 2);\n\n// packages/ag-charts-community/src/chart/themes/defaultColors.ts\nvar DEFAULT_FILLS = {\n  BLUE: \"#5090dc\",\n  ORANGE: \"#ffa03a\",\n  GREEN: \"#459d55\",\n  CYAN: \"#34bfe1\",\n  YELLOW: \"#e1cc00\",\n  VIOLET: \"#9669cb\",\n  GRAY: \"#b5b5b5\",\n  MAGENTA: \"#bd5aa7\",\n  BROWN: \"#8a6224\",\n  RED: \"#ef5452\"\n};\nvar DEFAULT_STROKES = {\n  BLUE: \"#2b5c95\",\n  ORANGE: \"#cc6f10\",\n  GREEN: \"#1e652e\",\n  CYAN: \"#18859e\",\n  YELLOW: \"#a69400\",\n  VIOLET: \"#603c88\",\n  GRAY: \"#575757\",\n  MAGENTA: \"#7d2f6d\",\n  BROWN: \"#4f3508\",\n  RED: \"#a82529\"\n};\n\n// packages/ag-charts-community/src/chart/series/polar/donutSeriesProperties.ts\nvar DonutTitle = class extends Caption {\n  constructor() {\n    super(...arguments);\n    this.showInLegend = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], DonutTitle.prototype, \"showInLegend\", 2);\nvar DonutInnerLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.spacing = 2;\n  }\n  set(properties, _reset) {\n    return super.set(properties);\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], DonutInnerLabel.prototype, \"text\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], DonutInnerLabel.prototype, \"spacing\", 2);\nvar DonutInnerCircle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.fill = \"transparent\";\n    this.fillOpacity = 1;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING)\n], DonutInnerCircle.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutInnerCircle.prototype, \"fillOpacity\", 2);\nvar DonutSeriesCalloutLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.offset = 3;\n    this.minAngle = 0;\n    this.minSpacing = 4;\n    this.maxCollisionOffset = 50;\n    this.avoidCollisions = true;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLabel.prototype, \"offset\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], DonutSeriesCalloutLabel.prototype, \"minAngle\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLabel.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLabel.prototype, \"maxCollisionOffset\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], DonutSeriesCalloutLabel.prototype, \"avoidCollisions\", 2);\nvar DonutSeriesSectorLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.positionOffset = 0;\n    this.positionRatio = 0.5;\n  }\n};\n__decorateClass([\n  Validate(NUMBER)\n], DonutSeriesSectorLabel.prototype, \"positionOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesSectorLabel.prototype, \"positionRatio\", 2);\nvar DonutSeriesCalloutLine = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.length = 10;\n    this.strokeWidth = 1;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY, { optional: true })\n], DonutSeriesCalloutLine.prototype, \"colors\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLine.prototype, \"length\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLine.prototype, \"strokeWidth\", 2);\nvar DonutSeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fills = Object.values(DEFAULT_FILLS);\n    this.strokes = Object.values(DEFAULT_STROKES);\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.rotation = 0;\n    this.outerRadiusOffset = 0;\n    this.outerRadiusRatio = 1;\n    this.strokeWidth = 1;\n    this.sectorSpacing = 0;\n    this.innerLabels = new PropertiesArray(DonutInnerLabel);\n    this.title = new DonutTitle();\n    this.innerCircle = new DonutInnerCircle();\n    this.shadow = new DropShadow();\n    this.calloutLabel = new DonutSeriesCalloutLabel();\n    this.sectorLabel = new DonutSeriesSectorLabel();\n    this.calloutLine = new DonutSeriesCalloutLine();\n    this.tooltip = new SeriesTooltip();\n  }\n  isValid() {\n    const superIsValid = super.isValid();\n    if (this.innerRadiusRatio == null && this.innerRadiusOffset == null) {\n      Logger.warnOnce(\n        \"Either an [innerRadiusRatio] or an [innerRadiusOffset] must be set to render a donut series.\"\n      );\n      return false;\n    }\n    return superIsValid;\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], DonutSeriesProperties.prototype, \"angleKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"angleName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusName\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusMin\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusMax\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"calloutLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"calloutLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"sectorLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"sectorLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"legendItemKey\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], DonutSeriesProperties.prototype, \"fills\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], DonutSeriesProperties.prototype, \"strokes\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], DonutSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], DonutSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], DonutSeriesProperties.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], DonutSeriesProperties.prototype, \"outerRadiusOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesProperties.prototype, \"outerRadiusRatio\", 2);\n__decorateClass([\n  Validate(NUMBER, { optional: true })\n], DonutSeriesProperties.prototype, \"innerRadiusOffset\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], DonutSeriesProperties.prototype, \"innerRadiusRatio\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], DonutSeriesProperties.prototype, \"sectorSpacing\", 2);\n__decorateClass([\n  Validate(OBJECT_ARRAY)\n], DonutSeriesProperties.prototype, \"innerLabels\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"innerCircle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"calloutLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"sectorLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"calloutLine\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/polar/pieUtil.ts\nfunction preparePieSeriesAnimationFunctions(initialLoad, rotationDegrees, scaleFn, oldScaleFn) {\n  const scale2 = [scaleFn.convert(0), scaleFn.convert(1)];\n  const oldScale = [oldScaleFn.convert(0), oldScaleFn.convert(1)];\n  const rotation = Math.PI / -2 + toRadians(rotationDegrees);\n  const phase = initialLoad ? \"initial\" : \"update\";\n  const scaleToNewRadius = ({ radius }) => {\n    return { innerRadius: scale2[0], outerRadius: scale2[0] + (scale2[1] - scale2[0]) * radius };\n  };\n  const scaleToOldRadius = ({ radius }) => {\n    return { innerRadius: oldScale[0], outerRadius: oldScale[0] + (oldScale[1] - oldScale[0]) * radius };\n  };\n  const fromFn = (sect, datum, status, { prevFromProps }) => {\n    let { startAngle, endAngle, innerRadius, outerRadius } = sect;\n    let { fill, stroke } = datum.sectorFormat;\n    if (status === \"unknown\" || status === \"added\" && !prevFromProps) {\n      startAngle = rotation;\n      endAngle = rotation;\n      innerRadius = datum.innerRadius;\n      outerRadius = datum.outerRadius;\n    } else if (status === \"added\" && prevFromProps) {\n      startAngle = prevFromProps.endAngle ?? rotation;\n      endAngle = prevFromProps.endAngle ?? rotation;\n      innerRadius = prevFromProps.innerRadius ?? datum.innerRadius;\n      outerRadius = prevFromProps.outerRadius ?? datum.outerRadius;\n    }\n    if (status === \"added\" && !initialLoad) {\n      const radii = scaleToOldRadius(datum);\n      innerRadius = radii.innerRadius;\n      outerRadius = radii.outerRadius;\n    }\n    if (status === \"updated\") {\n      fill = sect.fill ?? fill;\n      stroke = sect.stroke ?? stroke;\n    }\n    return { startAngle, endAngle, innerRadius, outerRadius, fill, stroke, phase };\n  };\n  const toFn = (_sect, datum, status, { prevLive }) => {\n    let { startAngle, endAngle, innerRadius, outerRadius } = datum;\n    const { stroke, fill } = datum.sectorFormat;\n    if (status === \"removed\" && prevLive) {\n      startAngle = prevLive.datum?.endAngle;\n      endAngle = prevLive.datum?.endAngle;\n    } else if (status === \"removed\" && !prevLive) {\n      startAngle = rotation;\n      endAngle = rotation;\n    }\n    if (status === \"removed\") {\n      const radii = scaleToNewRadius(datum);\n      innerRadius = radii.innerRadius;\n      outerRadius = radii.outerRadius;\n    }\n    return { startAngle, endAngle, outerRadius, innerRadius, stroke, fill };\n  };\n  const innerCircleFromFn = (node, _) => {\n    return { size: node.previousDatum?.radius ?? node.size ?? 0, phase };\n  };\n  const innerCircleToFn = (_, datum) => {\n    return { size: datum.radius ?? 0 };\n  };\n  return { nodes: { toFn, fromFn }, innerCircle: { fromFn: innerCircleFromFn, toFn: innerCircleToFn } };\n}\nfunction resetPieSelectionsFn(_node, datum) {\n  return {\n    startAngle: datum.startAngle,\n    endAngle: datum.endAngle,\n    innerRadius: datum.innerRadius,\n    outerRadius: datum.outerRadius,\n    fill: datum.sectorFormat.fill,\n    stroke: datum.sectorFormat.stroke\n  };\n}\nfunction pickByMatchingAngle(series, point) {\n  const dy = point.y - series.centerY;\n  const dx = point.x - series.centerX;\n  const angle2 = Math.atan2(dy, dx);\n  const sectors = series.getItemNodes();\n  for (const sector of sectors) {\n    if (sector.datum.missing === true)\n      continue;\n    if (isBetweenAngles(angle2, sector.startAngle, sector.endAngle)) {\n      const radius = Math.sqrt(dx * dx + dy * dy);\n      let distance3 = 0;\n      if (radius < sector.innerRadius) {\n        distance3 = sector.innerRadius - radius;\n      } else if (radius > sector.outerRadius) {\n        distance3 = radius - sector.outerRadius;\n      }\n      return { datum: sector.datum, distance: distance3 };\n    }\n  }\n  return void 0;\n}\nfunction computeSectorSeriesFocusBounds(series, opts) {\n  const nodeData = series.getNodeData();\n  if (nodeData === void 0)\n    return void 0;\n  return computeSectorFocusBounds(nodeData[opts.datumIndex], series.centerX, series.centerY);\n}\nfunction computeSectorFocusBounds(datum, centerX, centerY) {\n  return sectorBox(datum).translate(centerX, centerY);\n}\n\n// packages/ag-charts-community/src/chart/series/polar/polarSeries.ts\nvar PolarSeries = class extends DataModelSeries {\n  constructor({\n    useLabelLayer = false,\n    pickModes = [3 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n    canHaveAxes = false,\n    animationResetFns,\n    ...opts\n  }) {\n    super({\n      ...opts,\n      useLabelLayer,\n      pickModes,\n      contentGroupVirtual: false,\n      directionKeys: {\n        [\"x\" /* X */]: [\"angleKey\"],\n        [\"y\" /* Y */]: [\"radiusKey\"]\n      },\n      directionNames: {\n        [\"x\" /* X */]: [\"angleName\"],\n        [\"y\" /* Y */]: [\"radiusName\"]\n      },\n      canHaveAxes\n    });\n    this.itemGroup = this.contentGroup.appendChild(new Group());\n    this.nodeData = [];\n    this.itemSelection = Selection.select(\n      this.itemGroup,\n      () => this.nodeFactory(),\n      false\n    );\n    this.labelSelection = Selection.select(\n      this.labelGroup,\n      () => this.labelFactory(),\n      false\n    );\n    this.highlightSelection = Selection.select(\n      this.highlightGroup,\n      () => this.nodeFactory()\n    );\n    this.highlightLabelSelection = Selection.select(\n      this.highlightLabel,\n      () => this.labelFactory()\n    );\n    /**\n     * The center of the polar series (for example, the center of a pie).\n     * If the polar chart has multiple series, all of them will have their\n     * center set to the same value as a result of the polar chart layout.\n     * The center coordinates are not supposed to be set by the user.\n     */\n    this.centerX = 0;\n    this.centerY = 0;\n    /**\n     * The maximum radius the series can use.\n     * This value is set automatically as a result of the polar chart layout\n     * and is not supposed to be set by the user.\n     */\n    this.radius = 0;\n    this.itemGroup.zIndexSubOrder = [() => this._declarationOrder, 1];\n    this.animationResetFns = animationResetFns;\n    this.animationState = new StateMachine(\n      \"empty\",\n      {\n        empty: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateEmptyUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        ready: {\n          updateData: \"waiting\",\n          clear: \"clearing\",\n          highlight: (data) => this.animateReadyHighlight(data),\n          highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),\n          resize: (data) => this.animateReadyResize(data),\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        waiting: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateWaitingUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        clearing: {\n          update: {\n            target: \"empty\",\n            action: (data) => this.animateClearingUpdateEmpty(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        }\n      },\n      () => this.checkProcessedDataAnimatable()\n    );\n  }\n  getItemNodes() {\n    return this.itemGroup.children;\n  }\n  getNodeData() {\n    return this.nodeData;\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    } else if (phase === \"ready\") {\n      this.animationState.transition(\"skip\");\n    }\n  }\n  labelFactory() {\n    const text = new Text();\n    text.pointerEvents = 1 /* None */;\n    return text;\n  }\n  getInnerRadius() {\n    return 0;\n  }\n  getLabelData() {\n    return [];\n  }\n  computeLabelsBBox(_options, _seriesRect) {\n    return null;\n  }\n  resetAllAnimation() {\n    const { item, label } = this.animationResetFns ?? {};\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    if (item) {\n      resetMotion([this.itemSelection, this.highlightSelection], item);\n    }\n    if (label) {\n      resetMotion([this.labelSelection, this.highlightLabelSelection], label);\n    }\n    this.itemSelection.cleanup();\n    this.labelSelection.cleanup();\n    this.highlightSelection.cleanup();\n    this.highlightLabelSelection.cleanup();\n  }\n  animateEmptyUpdateReady(_data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation();\n  }\n  animateWaitingUpdateReady(_data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation();\n  }\n  animateReadyHighlight(_data) {\n    const { item, label } = this.animationResetFns ?? {};\n    if (item) {\n      resetMotion([this.highlightSelection], item);\n    }\n    if (label) {\n      resetMotion([this.highlightLabelSelection], label);\n    }\n  }\n  animateReadyHighlightMarkers(_data) {\n  }\n  animateReadyResize(_data) {\n    this.resetAllAnimation();\n  }\n  animateClearingUpdateEmpty(_data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation();\n  }\n  animationTransitionClear() {\n    this.animationState.transition(\"clear\", this.getAnimationData());\n  }\n  getAnimationData(seriesRect) {\n    return { seriesRect };\n  }\n  computeFocusBounds(opts) {\n    const datum = this.getNodeData()?.[opts.datumIndex];\n    if (datum !== void 0) {\n      return this.itemSelection.select((node) => node instanceof Path && node.datum === datum)[0];\n    }\n    return void 0;\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/polar/donutSeries.ts\nvar DonutSeriesNodeEvent = class extends SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.angleKey = series.properties.angleKey;\n    this.radiusKey = series.properties.radiusKey;\n    this.calloutLabelKey = series.properties.calloutLabelKey;\n    this.sectorLabelKey = series.properties.sectorLabelKey;\n  }\n};\nvar DonutSeries = class extends PolarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [3 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      useLabelLayer: true,\n      animationResetFns: { item: resetPieSelectionsFn, label: resetLabelFn }\n    });\n    this.properties = new DonutSeriesProperties();\n    this.previousRadiusScale = new LinearScale();\n    this.radiusScale = new LinearScale();\n    this.calloutLabelGroup = this.contentGroup.appendChild(new Group({ name: \"pieCalloutLabels\" }));\n    this.calloutLabelSelection = new Selection(\n      this.calloutLabelGroup,\n      Group\n    );\n    // The group node that contains the background graphics.\n    this.backgroundGroup = this.rootGroup.appendChild(\n      new Group({\n        name: `${this.id}-background`,\n        layer: true,\n        zIndex: 0 /* SERIES_BACKGROUND_ZINDEX */\n      })\n    );\n    // AG-6193 If the sum of all datums is 0, then we'll draw 1 or 2 rings to represent the empty series.\n    this.zerosumRingsGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-zerosumRings` }));\n    this.zerosumOuterRing = this.zerosumRingsGroup.appendChild(new Circle());\n    this.zerosumInnerRing = this.zerosumRingsGroup.appendChild(new Circle());\n    this.innerLabelsGroup = this.contentGroup.appendChild(new Group({ name: \"innerLabels\" }));\n    this.innerCircleGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-innerCircle` }));\n    this.innerLabelsSelection = Selection.select(this.innerLabelsGroup, Text);\n    this.innerCircleSelection = Selection.select(\n      this.innerCircleGroup,\n      Circle\n    );\n    // When a user toggles a series item (e.g. from the legend), its boolean state is recorded here.\n    this.seriesItemEnabled = [];\n    this.surroundingRadius = void 0;\n    this.NodeEvent = DonutSeriesNodeEvent;\n    this.angleScale = new LinearScale();\n    this.angleScale.domain = [0, 1];\n    this.angleScale.range = [-Math.PI, Math.PI].map((angle2) => angle2 + Math.PI / 2);\n  }\n  addChartEventListeners() {\n    this.destroyFns.push(\n      this.ctx.chartEventManager?.addListener(\"legend-item-click\", (event) => this.onLegendItemClick(event))\n    );\n  }\n  get visible() {\n    return super.visible && (this.seriesItemEnabled.length === 0 || this.seriesItemEnabled.some((visible) => visible));\n  }\n  nodeFactory() {\n    return new Sector();\n  }\n  getSeriesDomain(direction) {\n    if (direction === \"x\" /* X */) {\n      return this.angleScale.domain;\n    } else {\n      return this.radiusScale.domain;\n    }\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    let { data } = this;\n    const { visible, seriesItemEnabled } = this;\n    const { angleKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const extraKeyProps = [];\n    const extraProps = [];\n    if (legendItemKey) {\n      extraKeyProps.push(keyProperty(legendItemKey, \"band\", { id: `legendItemKey` }));\n    } else if (calloutLabelKey) {\n      extraKeyProps.push(keyProperty(calloutLabelKey, \"band\", { id: `calloutLabelKey` }));\n    } else if (sectorLabelKey) {\n      extraKeyProps.push(keyProperty(sectorLabelKey, \"band\", { id: `sectorLabelKey` }));\n    }\n    const radiusScaleType = this.radiusScale.type;\n    const angleScaleType = this.radiusScale.type;\n    if (radiusKey) {\n      extraProps.push(\n        rangedValueProperty(radiusKey, {\n          id: \"radiusValue\",\n          min: this.properties.radiusMin ?? 0,\n          max: this.properties.radiusMax\n        }),\n        valueProperty(radiusKey, radiusScaleType, { id: `radiusRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo(\n          { id: \"radiusValue\" },\n          [0, 1],\n          1,\n          this.properties.radiusMin ?? 0,\n          this.properties.radiusMax\n        )\n      );\n    }\n    if (calloutLabelKey) {\n      extraProps.push(valueProperty(calloutLabelKey, \"band\", { id: `calloutLabelValue` }));\n    }\n    if (sectorLabelKey) {\n      extraProps.push(valueProperty(sectorLabelKey, \"band\", { id: `sectorLabelValue` }));\n    }\n    if (legendItemKey) {\n      extraProps.push(valueProperty(legendItemKey, \"band\", { id: `legendItemValue` }));\n    }\n    if (animationEnabled && this.processedData && extraKeyProps.length > 0) {\n      extraProps.push(diff(this.processedData));\n    }\n    extraProps.push(animationValidation());\n    data = data.map((d, idx) => visible && seriesItemEnabled[idx] ? d : { ...d, [angleKey]: 0 });\n    await this.requestDataModel(dataController, data, {\n      props: [\n        ...extraKeyProps,\n        accumulativeValueProperty(angleKey, angleScaleType, { id: `angleValue`, onlyPositive: true }),\n        valueProperty(angleKey, angleScaleType, { id: `angleRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo({ id: \"angleValue\" }, [0, 1], 0, 0),\n        ...extraProps\n      ]\n    });\n    for (const valueDef of this.processedData?.defs?.values ?? []) {\n      const { id, missing, property } = valueDef;\n      const missCount = getMissCount(this, missing);\n      if (id !== \"angleRaw\" && missCount > 0) {\n        Logger.warnOnce(\n          `no value was found for the key '${String(property)}' on ${missCount} data element${missCount > 1 ? \"s\" : \"\"}`\n        );\n      }\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  async maybeRefreshNodeData() {\n    if (!this.nodeDataRefresh)\n      return;\n    const { nodeData = [] } = await this.createNodeData() ?? {};\n    this.nodeData = nodeData;\n    this.nodeDataRefresh = false;\n  }\n  getProcessedDataIndexes(dataModel) {\n    const angleIdx = dataModel.resolveProcessedDataIndexById(this, `angleValue`);\n    const radiusIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusValue`) : -1;\n    const calloutLabelIdx = this.properties.calloutLabelKey ? dataModel.resolveProcessedDataIndexById(this, `calloutLabelValue`) : -1;\n    const sectorLabelIdx = this.properties.sectorLabelKey ? dataModel.resolveProcessedDataIndexById(this, `sectorLabelValue`) : -1;\n    const legendItemIdx = this.properties.legendItemKey ? dataModel.resolveProcessedDataIndexById(this, `legendItemValue`) : -1;\n    return { angleIdx, radiusIdx, calloutLabelIdx, sectorLabelIdx, legendItemIdx };\n  }\n  async createNodeData() {\n    const { id: seriesId, processedData, dataModel, angleScale } = this;\n    const { rotation, innerRadiusRatio } = this.properties;\n    if (!this.properties.isValid()) {\n      this.zerosumOuterRing.visible = true;\n      this.zerosumInnerRing.visible = true;\n      return { itemId: seriesId, nodeData: [], labelData: [] };\n    }\n    if (!processedData || !dataModel || processedData.type !== \"ungrouped\")\n      return;\n    const { angleIdx, radiusIdx, calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);\n    let currentStart = 0;\n    let sum2 = 0;\n    const nodeData = processedData.data.map((group, index) => {\n      const { datum, values } = group;\n      const currentValue = values[angleIdx];\n      const startAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      currentStart = currentValue;\n      sum2 += currentValue;\n      const endAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      const span = Math.abs(endAngle - startAngle);\n      const midAngle = startAngle + span / 2;\n      const angleValue = values[angleIdx + 1];\n      const radius = radiusIdx >= 0 ? values[radiusIdx] ?? 1 : 1;\n      const radiusValue = radiusIdx >= 0 ? values[radiusIdx + 1] : void 0;\n      const legendItemValue = legendItemIdx >= 0 ? values[legendItemIdx] : void 0;\n      const labels = this.getLabels(\n        datum,\n        midAngle,\n        span,\n        true,\n        values[calloutLabelIdx],\n        values[sectorLabelIdx],\n        legendItemValue\n      );\n      const sectorFormat = this.getSectorFormat(datum, index, false);\n      return {\n        itemId: index,\n        series: this,\n        datum,\n        index,\n        angleValue,\n        midAngle,\n        midCos: Math.cos(midAngle),\n        midSin: Math.sin(midAngle),\n        startAngle,\n        endAngle,\n        sectorFormat,\n        radiusValue,\n        radius,\n        innerRadius: Math.max(this.radiusScale.convert(0), 0),\n        outerRadius: Math.max(this.radiusScale.convert(radius), 0),\n        legendItemValue,\n        enabled: this.seriesItemEnabled[index],\n        ...labels\n      };\n    });\n    this.zerosumOuterRing.visible = sum2 === 0;\n    this.zerosumInnerRing.visible = sum2 === 0 && innerRadiusRatio != null && innerRadiusRatio !== 1 && innerRadiusRatio > 0;\n    return { itemId: seriesId, nodeData, labelData: nodeData };\n  }\n  getLabels(datum, midAngle, span, skipDisabled, calloutLabelValue, sectorLabelValue, legendItemValue) {\n    const { calloutLabel, sectorLabel, legendItemKey } = this.properties;\n    const calloutLabelKey = !skipDisabled || calloutLabel.enabled ? this.properties.calloutLabelKey : void 0;\n    const sectorLabelKey = !skipDisabled || sectorLabel.enabled ? this.properties.sectorLabelKey : void 0;\n    if (!calloutLabelKey && !sectorLabelKey && !legendItemKey) {\n      return {};\n    }\n    const labelFormatterParams = {\n      datum,\n      angleKey: this.properties.angleKey,\n      angleName: this.properties.angleName,\n      radiusKey: this.properties.radiusKey,\n      radiusName: this.properties.radiusName,\n      calloutLabelKey: this.properties.calloutLabelKey,\n      calloutLabelName: this.properties.calloutLabelName,\n      sectorLabelKey: this.properties.sectorLabelKey,\n      sectorLabelName: this.properties.sectorLabelName,\n      legendItemKey: this.properties.legendItemKey\n    };\n    const result = {};\n    if (calloutLabelKey && span > toRadians(calloutLabel.minAngle)) {\n      result.calloutLabel = {\n        ...this.getTextAlignment(midAngle),\n        text: this.getLabelText(calloutLabel, {\n          ...labelFormatterParams,\n          value: calloutLabelValue\n        }),\n        hidden: false,\n        collisionTextAlign: void 0,\n        collisionOffsetY: 0,\n        box: void 0\n      };\n    }\n    if (sectorLabelKey) {\n      result.sectorLabel = {\n        text: this.getLabelText(sectorLabel, {\n          ...labelFormatterParams,\n          value: sectorLabelValue\n        })\n      };\n    }\n    if (legendItemKey != null && legendItemValue != null) {\n      result.legendItem = { key: legendItemKey, text: legendItemValue };\n    }\n    return result;\n  }\n  getTextAlignment(midAngle) {\n    const quadrantTextOpts = [\n      { textAlign: \"center\", textBaseline: \"bottom\" },\n      { textAlign: \"left\", textBaseline: \"middle\" },\n      { textAlign: \"center\", textBaseline: \"hanging\" },\n      { textAlign: \"right\", textBaseline: \"middle\" }\n    ];\n    const midAngle180 = normalizeAngle180(midAngle);\n    const quadrantStart = -0.75 * Math.PI;\n    const quadrantOffset = midAngle180 - quadrantStart;\n    const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));\n    const quadrantIndex = mod(quadrant, quadrantTextOpts.length);\n    return quadrantTextOpts[quadrantIndex];\n  }\n  getSectorFormat(datum, formatIndex, highlight) {\n    const { callbackCache, highlightManager } = this.ctx;\n    const { angleKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey, fills, strokes, itemStyler } = this.properties;\n    const highlightedDatum = highlightManager.getActiveHighlight();\n    const isDatumHighlighted = highlight && highlightedDatum?.series === this && formatIndex === highlightedDatum.itemId;\n    const defaultStroke = strokes[formatIndex % strokes.length];\n    const { fill, fillOpacity, stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = mergeDefaults(\n      isDatumHighlighted && this.properties.highlightStyle.item,\n      {\n        fill: fills.length > 0 ? fills[formatIndex % fills.length] : void 0,\n        stroke: defaultStroke,\n        strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),\n        strokeOpacity: this.getOpacity()\n      },\n      this.properties\n    );\n    let format;\n    if (itemStyler) {\n      format = callbackCache.call(itemStyler, {\n        datum,\n        angleKey,\n        radiusKey,\n        calloutLabelKey,\n        sectorLabelKey,\n        legendItemKey,\n        fill,\n        fillOpacity,\n        stroke,\n        strokeWidth,\n        strokeOpacity,\n        lineDash,\n        lineDashOffset,\n        cornerRadius,\n        highlighted: isDatumHighlighted,\n        seriesId: this.id\n      });\n    }\n    return {\n      fill: format?.fill ?? fill,\n      fillOpacity: format?.fillOpacity ?? fillOpacity,\n      stroke: format?.stroke ?? stroke,\n      strokeWidth: format?.strokeWidth ?? strokeWidth,\n      strokeOpacity: format?.strokeOpacity ?? strokeOpacity,\n      lineDash: format?.lineDash ?? lineDash,\n      lineDashOffset: format?.lineDashOffset ?? lineDashOffset,\n      cornerRadius: format?.cornerRadius ?? cornerRadius\n    };\n  }\n  getInnerRadius() {\n    const { radius } = this;\n    const { innerRadiusRatio = 1, innerRadiusOffset = 0 } = this.properties;\n    const innerRadius = radius * innerRadiusRatio + innerRadiusOffset;\n    if (innerRadius === radius || innerRadius < 0) {\n      return 0;\n    }\n    return innerRadius;\n  }\n  getOuterRadius() {\n    const { outerRadiusRatio, outerRadiusOffset } = this.properties;\n    return Math.max(this.radius * outerRadiusRatio + outerRadiusOffset, 0);\n  }\n  updateRadiusScale(resize) {\n    const newRange = [this.getInnerRadius(), this.getOuterRadius()];\n    this.radiusScale.range = newRange;\n    if (resize) {\n      this.previousRadiusScale.range = newRange;\n    }\n    this.nodeData = this.nodeData.map(({ radius, ...d }) => {\n      return {\n        ...d,\n        radius,\n        innerRadius: Math.max(this.radiusScale.convert(0), 0),\n        outerRadius: Math.max(this.radiusScale.convert(radius), 0)\n      };\n    });\n  }\n  getTitleTranslationY() {\n    const outerRadius = Math.max(0, this.radiusScale.range[1]);\n    if (outerRadius === 0) {\n      return NaN;\n    }\n    const spacing = this.properties.title?.spacing ?? 0;\n    const titleOffset = 2 + spacing;\n    const dy = Math.max(0, -outerRadius);\n    return -outerRadius - titleOffset - dy;\n  }\n  async update({ seriesRect }) {\n    const { title } = this.properties;\n    const newNodeDataDependencies = {\n      seriesRectWidth: seriesRect?.width,\n      seriesRectHeight: seriesRect?.height\n    };\n    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\n    if (resize) {\n      this._nodeDataDependencies = newNodeDataDependencies;\n    }\n    await this.maybeRefreshNodeData();\n    this.updateTitleNodes();\n    this.updateRadiusScale(resize);\n    this.contentGroup.translationX = this.centerX;\n    this.contentGroup.translationY = this.centerY;\n    this.highlightGroup.translationX = this.centerX;\n    this.highlightGroup.translationY = this.centerY;\n    this.backgroundGroup.translationX = this.centerX;\n    this.backgroundGroup.translationY = this.centerY;\n    if (this.labelGroup) {\n      this.labelGroup.translationX = this.centerX;\n      this.labelGroup.translationY = this.centerY;\n    }\n    if (title) {\n      const dy = this.getTitleTranslationY();\n      const titleBox = title.node.computeBBox();\n      title.node.visible = title.enabled && isFinite(dy) && !this.bboxIntersectsSurroundingSeries(titleBox, 0, dy);\n      title.node.translationY = isFinite(dy) ? dy : 0;\n    }\n    for (const circle of [this.zerosumInnerRing, this.zerosumOuterRing]) {\n      circle.fillOpacity = 0;\n      circle.stroke = this.properties.calloutLabel.color;\n      circle.strokeWidth = 1;\n      circle.strokeOpacity = 1;\n    }\n    this.updateNodeMidPoint();\n    await this.updateSelections();\n    await this.updateNodes(seriesRect);\n  }\n  updateTitleNodes() {\n    const { oldTitle } = this;\n    const { title } = this.properties;\n    if (oldTitle !== title) {\n      if (oldTitle) {\n        this.labelGroup?.removeChild(oldTitle.node);\n      }\n      if (title) {\n        title.node.textBaseline = \"bottom\";\n        this.labelGroup?.appendChild(title.node);\n      }\n      this.oldTitle = title;\n    }\n  }\n  updateNodeMidPoint() {\n    this.nodeData.forEach((d) => {\n      const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;\n      d.midPoint = {\n        x: d.midCos * Math.max(0, radius),\n        y: d.midSin * Math.max(0, radius)\n      };\n    });\n  }\n  async updateSelections() {\n    await this.updateGroupSelection();\n    this.updateInnerCircleSelection();\n  }\n  async updateGroupSelection() {\n    const {\n      itemSelection,\n      highlightSelection,\n      highlightLabelSelection,\n      calloutLabelSelection,\n      labelSelection,\n      innerLabelsSelection\n    } = this;\n    const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();\n    const highlightedNodeData = highlightedDatum?.series === this ? this.nodeData.filter((node) => node.itemId === highlightedDatum?.itemId) : [];\n    const update = (selection, clone) => {\n      let nodeData = this.nodeData;\n      if (clone) {\n        nodeData = nodeData.map((datum) => ({ ...datum, sectorFormat: { ...datum.sectorFormat } }));\n      }\n      selection.update(nodeData, void 0, (datum) => this.getDatumId(datum));\n      if (this.ctx.animationManager.isSkipped()) {\n        selection.cleanup();\n      }\n    };\n    update(itemSelection, false);\n    update(highlightSelection, true);\n    calloutLabelSelection.update(this.nodeData, (group) => {\n      const line = new Line();\n      line.tag = 0 /* Callout */;\n      line.pointerEvents = 1 /* None */;\n      group.appendChild(line);\n      const text = new Text();\n      text.tag = 1 /* Label */;\n      text.pointerEvents = 1 /* None */;\n      group.appendChild(text);\n    });\n    labelSelection.update(this.nodeData);\n    highlightLabelSelection.update(highlightedNodeData);\n    innerLabelsSelection.update(this.properties.innerLabels, (node) => {\n      node.pointerEvents = 1 /* None */;\n    });\n  }\n  updateInnerCircleSelection() {\n    const { innerCircle } = this.properties;\n    let radius = 0;\n    const innerRadius = this.getInnerRadius();\n    if (innerRadius > 0) {\n      const circleRadius = Math.min(innerRadius, this.getOuterRadius());\n      const antiAliasingPadding = 1;\n      radius = Math.ceil(circleRadius * 2 + antiAliasingPadding);\n    }\n    const datums = innerCircle ? [{ radius }] : [];\n    this.innerCircleSelection.update(datums);\n  }\n  async updateNodes(seriesRect) {\n    const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();\n    const isVisible = this.visible && this.seriesItemEnabled.indexOf(true) >= 0;\n    this.rootGroup.visible = isVisible;\n    this.backgroundGroup.visible = isVisible;\n    this.contentGroup.visible = isVisible;\n    this.highlightGroup.visible = isVisible && highlightedDatum?.series === this;\n    this.highlightLabel.visible = isVisible && highlightedDatum?.series === this;\n    if (this.labelGroup) {\n      this.labelGroup.visible = isVisible;\n    }\n    this.contentGroup.opacity = this.getOpacity();\n    this.innerCircleSelection.each((node, { radius }) => {\n      node.setProperties({\n        fill: this.properties.innerCircle?.fill,\n        opacity: this.properties.innerCircle?.fillOpacity,\n        size: radius\n      });\n    });\n    const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {\n      const format = this.getSectorFormat(datum.datum, datum.itemId, isDatumHighlighted);\n      datum.sectorFormat.fill = format.fill;\n      datum.sectorFormat.stroke = format.stroke;\n      const animationDisabled = this.ctx.animationManager.isSkipped();\n      if (animationDisabled) {\n        sector.startAngle = datum.startAngle;\n        sector.endAngle = datum.endAngle;\n        sector.innerRadius = datum.innerRadius;\n        sector.outerRadius = datum.outerRadius;\n      }\n      if (isDatumHighlighted || animationDisabled) {\n        sector.fill = format.fill;\n        sector.stroke = format.stroke;\n      }\n      sector.strokeWidth = format.strokeWidth;\n      sector.fillOpacity = format.fillOpacity;\n      sector.strokeOpacity = format.strokeOpacity;\n      sector.lineDash = format.lineDash;\n      sector.lineDashOffset = format.lineDashOffset;\n      sector.cornerRadius = format.cornerRadius;\n      sector.fillShadow = this.properties.shadow;\n      const inset = Math.max(\n        (this.properties.sectorSpacing + (format.stroke != null ? format.strokeWidth : 0)) / 2,\n        0\n      );\n      sector.inset = inset;\n      sector.lineJoin = this.properties.sectorSpacing >= 0 || inset > 0 ? \"miter\" : \"round\";\n    };\n    this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n    this.highlightSelection.each((node, datum, index) => {\n      const isDatumHighlighted = highlightedDatum?.series === this && node.datum.itemId === highlightedDatum.itemId;\n      updateSectorFn(node, datum, index, true);\n      node.visible = isDatumHighlighted;\n    });\n    this.updateCalloutLineNodes();\n    this.updateCalloutLabelNodes(seriesRect);\n    this.updateSectorLabelNodes();\n    this.updateInnerLabelNodes();\n    this.updateZerosumRings();\n    this.animationState.transition(\"update\");\n  }\n  updateCalloutLineNodes() {\n    const { calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const calloutStrokeWidth = calloutLine.strokeWidth;\n    const calloutColors = calloutLine.colors ?? this.properties.strokes;\n    const { offset: offset4 } = this.properties.calloutLabel;\n    this.calloutLabelSelection.selectByTag(0 /* Callout */).forEach((line, index) => {\n      const datum = line.datum;\n      const { calloutLabel: label, outerRadius } = datum;\n      if (label?.text && !label.hidden && outerRadius !== 0) {\n        line.visible = true;\n        line.strokeWidth = calloutStrokeWidth;\n        line.stroke = calloutColors[index % calloutColors.length];\n        line.fill = void 0;\n        const x1 = datum.midCos * outerRadius;\n        const y1 = datum.midSin * outerRadius;\n        let x2 = datum.midCos * (outerRadius + calloutLength);\n        let y2 = datum.midSin * (outerRadius + calloutLength);\n        const isMoved = label.collisionTextAlign ?? label.collisionOffsetY !== 0;\n        if (isMoved && label.box != null) {\n          const box = label.box;\n          let cx = x2;\n          let cy = y2;\n          if (x2 < box.x) {\n            cx = box.x;\n          } else if (x2 > box.x + box.width) {\n            cx = box.x + box.width;\n          }\n          if (y2 < box.y) {\n            cy = box.y;\n          } else if (y2 > box.y + box.height) {\n            cy = box.y + box.height;\n          }\n          const dx = cx - x2;\n          const dy = cy - y2;\n          const length2 = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n          const paddedLength = length2 - offset4;\n          if (paddedLength > 0) {\n            x2 = x2 + dx * paddedLength / length2;\n            y2 = y2 + dy * paddedLength / length2;\n          }\n        }\n        line.x1 = x1;\n        line.y1 = y1;\n        line.x2 = x2;\n        line.y2 = y2;\n      } else {\n        line.visible = false;\n      }\n    });\n  }\n  getLabelOverflow(text, box, seriesRect) {\n    const seriesLeft = seriesRect.x - this.centerX;\n    const seriesRight = seriesRect.x + seriesRect.width - this.centerX;\n    const seriesTop = seriesRect.y - this.centerY;\n    const seriesBottom = seriesRect.y + seriesRect.height - this.centerY;\n    const errPx = 1;\n    let visibleTextPart = 1;\n    if (box.x + errPx < seriesLeft) {\n      visibleTextPart = (box.x + box.width - seriesLeft) / box.width;\n    } else if (box.x + box.width - errPx > seriesRight) {\n      visibleTextPart = (seriesRight - box.x) / box.width;\n    }\n    const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;\n    const textLength = visibleTextPart === 1 ? text.length : Math.floor(text.length * visibleTextPart) - 1;\n    const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);\n    return { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow };\n  }\n  bboxIntersectsSurroundingSeries(box, dx = 0, dy = 0) {\n    const { surroundingRadius } = this;\n    if (surroundingRadius == null) {\n      return false;\n    }\n    const corners = [\n      { x: box.x + dx, y: box.y + dy },\n      { x: box.x + box.width + dx, y: box.y + dy },\n      { x: box.x + box.width + dx, y: box.y + box.height + dy },\n      { x: box.x + dx, y: box.y + box.height + dy }\n    ];\n    const sur2 = surroundingRadius ** 2;\n    return corners.some((corner) => corner.x ** 2 + corner.y ** 2 > sur2);\n  }\n  computeCalloutLabelCollisionOffsets() {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const { offset: offset4, minSpacing } = calloutLabel;\n    const innerRadius = radiusScale.convert(0);\n    const shouldSkip = (datum) => {\n      const label = datum.calloutLabel;\n      return !label || datum.outerRadius === 0;\n    };\n    const fullData = this.nodeData;\n    const data = this.nodeData.filter((t) => !shouldSkip(t));\n    data.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return;\n      label.hidden = false;\n      label.collisionTextAlign = void 0;\n      label.collisionOffsetY = 0;\n    });\n    if (data.length <= 1) {\n      return;\n    }\n    const leftLabels = data.filter((d) => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);\n    const rightLabels = data.filter((d) => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);\n    const topLabels = data.filter((d) => d.midSin < 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const bottomLabels = data.filter((d) => d.midSin >= 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const tempTextNode = new Text();\n    const getTextBBox = (datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return new BBox(0, 0, 0, 0);\n      const labelRadius = datum.outerRadius + calloutLine.length + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      tempTextNode.text = label.text;\n      tempTextNode.x = x;\n      tempTextNode.y = y;\n      tempTextNode.setFont(this.properties.calloutLabel);\n      tempTextNode.setAlign({\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      });\n      return tempTextNode.computeBBox();\n    };\n    const avoidNeighbourYCollision = (label, next, direction) => {\n      const box = getTextBBox(label).grow(minSpacing / 2);\n      const other = getTextBBox(next).grow(minSpacing / 2);\n      const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === \"to-top\" ? box.y < other.y + other.height : box.y + box.height > other.y);\n      if (collidesOrBehind) {\n        const dy = direction === \"to-top\" ? box.y - other.y - other.height : box.y + box.height - other.y;\n        next.calloutLabel.collisionOffsetY = dy;\n      }\n    };\n    const avoidYCollisions = (labels) => {\n      const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];\n      const midIndex = labels.indexOf(midLabel);\n      for (let i = midIndex - 1; i >= 0; i--) {\n        const prev = labels[i + 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-top\");\n      }\n      for (let i = midIndex + 1; i < labels.length; i++) {\n        const prev = labels[i - 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-bottom\");\n      }\n    };\n    const avoidXCollisions = (labels) => {\n      const labelsCollideLabelsByY = data.some((datum) => datum.calloutLabel.collisionOffsetY !== 0);\n      const boxes = labels.map((label) => getTextBBox(label));\n      const paddedBoxes = boxes.map((box) => box.clone().grow(minSpacing / 2));\n      let labelsCollideLabelsByX = false;\n      for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {\n        const box = paddedBoxes[i];\n        for (let j = i + 1; j < labels.length; j++) {\n          const other = paddedBoxes[j];\n          if (box.collidesBBox(other)) {\n            labelsCollideLabelsByX = true;\n            break;\n          }\n        }\n      }\n      const sectors = fullData.map((datum) => {\n        const { startAngle, endAngle, outerRadius } = datum;\n        return { startAngle, endAngle, innerRadius, outerRadius };\n      });\n      const labelsCollideSectors = boxes.some((box) => {\n        return sectors.some((sector) => boxCollidesSector(box, sector));\n      });\n      if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {\n        return;\n      }\n      labels.filter((d) => d.calloutLabel.textAlign === \"center\").forEach((d) => {\n        const label = d.calloutLabel;\n        if (d.midCos < 0) {\n          label.collisionTextAlign = \"right\";\n        } else if (d.midCos > 0) {\n          label.collisionTextAlign = \"left\";\n        } else {\n          label.collisionTextAlign = \"center\";\n        }\n      });\n    };\n    avoidYCollisions(leftLabels);\n    avoidYCollisions(rightLabels);\n    avoidXCollisions(topLabels);\n    avoidXCollisions(bottomLabels);\n  }\n  updateCalloutLabelNodes(seriesRect) {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, color } = calloutLabel;\n    const tempTextNode = new Text();\n    this.calloutLabelSelection.selectByTag(1 /* Label */).forEach((text) => {\n      const { datum } = text;\n      const label = datum.calloutLabel;\n      const radius = radiusScale.convert(datum.radius);\n      const outerRadius = Math.max(0, radius);\n      if (!label?.text || outerRadius === 0 || label.hidden) {\n        text.visible = false;\n        return;\n      }\n      const labelRadius = outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      const align = {\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      };\n      tempTextNode.text = label.text;\n      tempTextNode.x = x;\n      tempTextNode.y = y;\n      tempTextNode.setFont(this.properties.calloutLabel);\n      tempTextNode.setAlign(align);\n      const box = tempTextNode.computeBBox();\n      let displayText = label.text;\n      let visible = true;\n      if (calloutLabel.avoidCollisions) {\n        const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);\n        displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}\\u2026`;\n        visible = !hasVerticalOverflow;\n      }\n      text.text = displayText;\n      text.x = x;\n      text.y = y;\n      text.setFont(this.properties.calloutLabel);\n      text.setAlign(align);\n      text.fill = color;\n      text.visible = visible;\n    });\n  }\n  async computeLabelsBBox(options, seriesRect) {\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, maxCollisionOffset, minSpacing } = calloutLabel;\n    if (!calloutLabel.avoidCollisions) {\n      return null;\n    }\n    await this.maybeRefreshNodeData();\n    this.updateRadiusScale(false);\n    this.computeCalloutLabelCollisionOffsets();\n    const textBoxes = [];\n    const text = new Text();\n    let titleBox;\n    const { title } = this.properties;\n    if (title?.text && title.enabled) {\n      const dy = this.getTitleTranslationY();\n      if (isFinite(dy)) {\n        text.text = title.text;\n        text.x = 0;\n        text.y = dy;\n        text.setFont(title);\n        text.setAlign({\n          textBaseline: \"bottom\",\n          textAlign: \"center\"\n        });\n        titleBox = text.computeBBox();\n        textBoxes.push(titleBox);\n      }\n    }\n    this.nodeData.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (!label || datum.outerRadius === 0) {\n        return null;\n      }\n      const labelRadius = datum.outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      text.text = label.text;\n      text.x = x;\n      text.y = y;\n      text.setFont(this.properties.calloutLabel);\n      text.setAlign({\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      });\n      const box = text.computeBBox();\n      label.box = box;\n      if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {\n        label.hidden = true;\n        return;\n      }\n      if (titleBox) {\n        const seriesTop = seriesRect.y - this.centerY;\n        const titleCleanArea = new BBox(\n          titleBox.x - minSpacing,\n          seriesTop,\n          titleBox.width + 2 * minSpacing,\n          titleBox.y + titleBox.height + minSpacing - seriesTop\n        );\n        if (box.collidesBBox(titleCleanArea)) {\n          label.hidden = true;\n          return;\n        }\n      }\n      if (options.hideWhenNecessary) {\n        const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(\n          label.text,\n          box,\n          seriesRect\n        );\n        const isTooShort = label.text.length > 2 && textLength < 2;\n        if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {\n          label.hidden = true;\n          return;\n        }\n      }\n      label.hidden = false;\n      textBoxes.push(box);\n    });\n    if (textBoxes.length === 0) {\n      return null;\n    }\n    return BBox.merge(textBoxes);\n  }\n  updateSectorLabelNodes() {\n    const { radiusScale } = this;\n    const innerRadius = radiusScale.convert(0);\n    const { fontSize, fontStyle, fontWeight, fontFamily, positionOffset, positionRatio, color } = this.properties.sectorLabel;\n    const updateSectorLabel = (text, datum) => {\n      const { sectorLabel, outerRadius } = datum;\n      let isTextVisible = false;\n      if (sectorLabel && outerRadius !== 0) {\n        const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;\n        text.fill = color;\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.text = sectorLabel.text;\n        text.x = datum.midCos * labelRadius;\n        text.y = datum.midSin * labelRadius;\n        text.textAlign = \"center\";\n        text.textBaseline = \"middle\";\n        const bbox = text.computeBBox();\n        const corners = [\n          [bbox.x, bbox.y],\n          [bbox.x + bbox.width, bbox.y],\n          [bbox.x + bbox.width, bbox.y + bbox.height],\n          [bbox.x, bbox.y + bbox.height]\n        ];\n        const { startAngle, endAngle } = datum;\n        const sectorBounds = { startAngle, endAngle, innerRadius, outerRadius };\n        if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {\n          isTextVisible = true;\n        }\n      }\n      text.visible = isTextVisible;\n    };\n    this.labelSelection.each(updateSectorLabel);\n    this.highlightLabelSelection.each(updateSectorLabel);\n  }\n  updateInnerLabelNodes() {\n    const textBBoxes = [];\n    const margins = [];\n    this.innerLabelsSelection.each((text, datum) => {\n      const { fontStyle, fontWeight, fontSize, fontFamily, color } = datum;\n      text.fontStyle = fontStyle;\n      text.fontWeight = fontWeight;\n      text.fontSize = fontSize;\n      text.fontFamily = fontFamily;\n      text.text = datum.text;\n      text.x = 0;\n      text.y = 0;\n      text.fill = color;\n      text.textAlign = \"center\";\n      text.textBaseline = \"alphabetic\";\n      textBBoxes.push(text.computeBBox());\n      margins.push(datum.spacing);\n    });\n    const getMarginTop = (index) => index === 0 ? 0 : margins[index];\n    const getMarginBottom = (index) => index === margins.length - 1 ? 0 : margins[index];\n    const totalHeight = textBBoxes.reduce((sum2, bbox, i) => {\n      return sum2 + bbox.height + getMarginTop(i) + getMarginBottom(i);\n    }, 0);\n    const totalWidth = Math.max(...textBBoxes.map((bbox) => bbox.width));\n    const innerRadius = this.getInnerRadius();\n    const labelRadius = Math.sqrt(Math.pow(totalWidth / 2, 2) + Math.pow(totalHeight / 2, 2));\n    const labelsVisible = labelRadius <= (innerRadius > 0 ? innerRadius : this.getOuterRadius());\n    const textBottoms = [];\n    for (let i = 0, prev = -totalHeight / 2; i < textBBoxes.length; i++) {\n      const bbox = textBBoxes[i];\n      const bottom = bbox.height + prev + getMarginTop(i);\n      textBottoms.push(bottom);\n      prev = bottom + getMarginBottom(i);\n    }\n    this.innerLabelsSelection.each((text, _datum, index) => {\n      text.y = textBottoms[index];\n      text.visible = labelsVisible;\n    });\n  }\n  updateZerosumRings() {\n    this.zerosumOuterRing.size = this.getOuterRadius() * 2;\n    this.zerosumInnerRing.size = this.getInnerRadius() * 2;\n  }\n  getDatumLegendName(nodeDatum) {\n    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    const { sectorLabel, calloutLabel, legendItem } = nodeDatum;\n    if (legendItemKey && legendItem !== void 0) {\n      return legendItem.text;\n    } else if (calloutLabelKey && calloutLabelKey !== angleKey && calloutLabel?.text !== void 0) {\n      return calloutLabel.text;\n    } else if (sectorLabelKey && sectorLabelKey !== angleKey && sectorLabel?.text !== void 0) {\n      return sectorLabel.text;\n    }\n  }\n  pickNodeClosestDatum(point) {\n    return pickByMatchingAngle(this, point);\n  }\n  getTooltipHtml(nodeDatum) {\n    if (!this.properties.isValid()) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const {\n      datum,\n      angleValue,\n      sectorFormat: { fill: color },\n      itemId\n    } = nodeDatum;\n    const title = sanitizeHtml(this.properties.title?.text);\n    const content = isFiniteNumber(angleValue) ? toFixed(angleValue) : String(angleValue);\n    const labelText = this.getDatumLegendName(nodeDatum);\n    return this.properties.tooltip.toTooltipHtml(\n      {\n        title: title ?? labelText,\n        content: title && labelText ? `${labelText}: ${content}` : content,\n        backgroundColor: color\n      },\n      {\n        datum,\n        itemId,\n        title,\n        color,\n        seriesId: this.id,\n        angleKey: this.properties.angleKey,\n        angleName: this.properties.angleName,\n        radiusKey: this.properties.radiusKey,\n        radiusName: this.properties.radiusName,\n        calloutLabelKey: this.properties.calloutLabelKey,\n        calloutLabelName: this.properties.calloutLabelName,\n        sectorLabelKey: this.properties.sectorLabelKey,\n        sectorLabelName: this.properties.sectorLabelName,\n        legendItemKey: this.properties.legendItemKey\n      }\n    );\n  }\n  getLegendData(legendType) {\n    const { visible, processedData, dataModel } = this;\n    if (!dataModel || !processedData?.data.length || !this.properties.isValid() || legendType !== \"category\") {\n      return [];\n    }\n    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    if (!legendItemKey && (!calloutLabelKey || calloutLabelKey === angleKey) && (!sectorLabelKey || sectorLabelKey === angleKey))\n      return [];\n    const { calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);\n    const titleText = this.properties.title?.showInLegend && this.properties.title.text;\n    const legendData = [];\n    for (let index = 0; index < processedData.data.length; index++) {\n      const { datum, values } = processedData.data[index];\n      const labelParts = [];\n      if (titleText) {\n        labelParts.push(titleText);\n      }\n      const labels = this.getLabels(\n        datum,\n        2 * Math.PI,\n        2 * Math.PI,\n        false,\n        values[calloutLabelIdx],\n        values[sectorLabelIdx],\n        values[legendItemIdx]\n      );\n      if (legendItemKey && labels.legendItem !== void 0) {\n        labelParts.push(labels.legendItem.text);\n      } else if (calloutLabelKey && calloutLabelKey !== angleKey && labels.calloutLabel?.text !== void 0) {\n        labelParts.push(labels.calloutLabel?.text);\n      } else if (sectorLabelKey && sectorLabelKey !== angleKey && labels.sectorLabel?.text !== void 0) {\n        labelParts.push(labels.sectorLabel?.text);\n      }\n      if (labelParts.length === 0)\n        continue;\n      const sectorFormat = this.getSectorFormat(datum, index, false);\n      legendData.push({\n        legendType: \"category\",\n        id: this.id,\n        itemId: index,\n        seriesId: this.id,\n        enabled: visible && this.seriesItemEnabled[index],\n        label: {\n          text: labelParts.join(\" - \")\n        },\n        symbols: [\n          {\n            marker: {\n              fill: sectorFormat.fill,\n              stroke: sectorFormat.stroke,\n              fillOpacity: this.properties.fillOpacity,\n              strokeOpacity: this.properties.strokeOpacity,\n              strokeWidth: this.properties.strokeWidth\n            }\n          }\n        ],\n        legendItemName: legendItemKey != null ? datum[legendItemKey] : void 0\n      });\n    }\n    return legendData;\n  }\n  onLegendItemClick(event) {\n    const { enabled, itemId, series, legendItemName } = event;\n    if (series.id === this.id) {\n      this.toggleSeriesItem(itemId, enabled);\n    } else if (legendItemName != null) {\n      this.toggleOtherSeriesItems(legendItemName, enabled);\n    }\n  }\n  toggleSeriesItem(itemId, enabled) {\n    this.seriesItemEnabled[itemId] = enabled;\n    if (this.nodeData[itemId]) {\n      this.nodeData[itemId].enabled = enabled;\n    }\n    this.nodeDataRefresh = true;\n  }\n  toggleOtherSeriesItems(legendItemName, enabled) {\n    if (!this.properties.legendItemKey || !this.dataModel) {\n      return;\n    }\n    const legendItemIdx = this.dataModel.resolveProcessedDataIndexById(this, `legendItemValue`);\n    this.processedData?.data.forEach(({ values }, datumItemId) => {\n      if (values[legendItemIdx] === legendItemName) {\n        this.toggleSeriesItem(datumItemId, enabled);\n      }\n    });\n  }\n  animateEmptyUpdateReady(_data) {\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      true,\n      this.properties.rotation,\n      this.radiusScale,\n      this.previousRadiusScale\n    );\n    fromToMotion(this.id, \"nodes\", animationManager, [this.itemSelection, this.highlightSelection], fns.nodes);\n    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\n    seriesLabelFadeInAnimation(this, \"callout\", animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", animationManager, this.highlightLabelSelection);\n    seriesLabelFadeInAnimation(this, \"inner\", animationManager, this.innerLabelsSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateWaitingUpdateReady() {\n    const { itemSelection, highlightSelection, processedData, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const dataDiff = processedData?.reduced?.diff;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    const supportedDiff = (dataDiff?.moved.size ?? 0) === 0;\n    const hasKeys = (processedData?.defs.keys.length ?? 0) > 0;\n    const hasUniqueKeys = processedData?.reduced?.animationValidation?.uniqueKeys ?? true;\n    if (!supportedDiff || !hasKeys || !hasUniqueKeys) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [itemSelection, highlightSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum),\n      dataDiff\n    );\n    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\n    seriesLabelFadeInAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    seriesLabelFadeInAnimation(this, \"inner\", this.ctx.animationManager, this.innerLabelsSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateClearingUpdateEmpty() {\n    const { itemSelection, highlightSelection, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(this.id, \"nodes\", animationManager, [itemSelection, highlightSelection], fns.nodes);\n    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\n    seriesLabelFadeOutAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeOutAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeOutAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    seriesLabelFadeOutAnimation(this, \"inner\", this.ctx.animationManager, this.innerLabelsSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  getDatumIdFromData(datum) {\n    const { calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    if (!this.processedData?.reduced?.animationValidation?.uniqueKeys) {\n      return;\n    }\n    if (legendItemKey) {\n      return datum[legendItemKey];\n    } else if (calloutLabelKey) {\n      return datum[calloutLabelKey];\n    } else if (sectorLabelKey) {\n      return datum[sectorLabelKey];\n    }\n  }\n  getDatumId(datum) {\n    const { index } = datum;\n    const datumId = this.getDatumIdFromData(datum.datum);\n    return datumId != null ? String(datumId) : `${index}`;\n  }\n  onDataChange() {\n    const { data, seriesItemEnabled } = this;\n    this.seriesItemEnabled = data?.map((_, index) => seriesItemEnabled[index] ?? true) ?? [];\n  }\n};\nDonutSeries.className = \"DonutSeries\";\nDonutSeries.type = \"donut\";\n\n// packages/ag-charts-community/src/chart/series/polar/donutTheme.ts\nvar donutTheme = {\n  series: {\n    title: {\n      enabled: true,\n      fontWeight: \"normal\" /* NORMAL */,\n      fontSize: 14,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_MUTED_LABEL_COLOUR,\n      spacing: 5\n    },\n    calloutLabel: {\n      enabled: true,\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_LABEL_COLOUR,\n      offset: 3,\n      minAngle: 0\n    },\n    sectorLabel: {\n      enabled: true,\n      fontWeight: \"normal\" /* NORMAL */,\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n      positionOffset: 0,\n      positionRatio: 0.5\n    },\n    calloutLine: {\n      length: 10,\n      strokeWidth: 2\n    },\n    fillOpacity: 1,\n    strokeOpacity: 1,\n    strokeWidth: 0,\n    lineDash: [0],\n    lineDashOffset: 0,\n    rotation: 0,\n    sectorSpacing: 1,\n    shadow: {\n      enabled: false,\n      color: DEFAULT_SHADOW_COLOUR,\n      xOffset: 3,\n      yOffset: 3,\n      blur: 5\n    },\n    innerLabels: {\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_LABEL_COLOUR,\n      spacing: 2\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/polar/pieTheme.ts\nvar pieTheme = {\n  series: {\n    title: {\n      enabled: true,\n      fontWeight: \"normal\" /* NORMAL */,\n      fontSize: 14,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_MUTED_LABEL_COLOUR,\n      spacing: 5\n    },\n    calloutLabel: {\n      enabled: true,\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_LABEL_COLOUR,\n      offset: 3,\n      minAngle: 0\n    },\n    sectorLabel: {\n      enabled: true,\n      fontWeight: \"normal\" /* NORMAL */,\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n      positionOffset: 0,\n      positionRatio: 0.5\n    },\n    calloutLine: {\n      length: 10,\n      strokeWidth: 2\n    },\n    fillOpacity: 1,\n    strokeOpacity: 1,\n    strokeWidth: 0,\n    lineDash: [0],\n    lineDashOffset: 0,\n    rotation: 0,\n    sectorSpacing: 1,\n    shadow: {\n      enabled: false,\n      color: DEFAULT_SHADOW_COLOUR,\n      xOffset: 3,\n      yOffset: 3,\n      blur: 5\n    }\n  }\n};\nvar piePaletteFactory = ({ takeColors, colorsCount }) => {\n  const { fills, strokes } = takeColors(colorsCount);\n  return { fills, strokes, calloutLine: { colors: strokes } };\n};\n\n// packages/ag-charts-community/src/chart/series/polar/donutSeriesModule.ts\nvar DonutSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"polar\"],\n  identifier: \"donut\",\n  instanceConstructor: DonutSeries,\n  tooltipDefaults: { range: \"exact\" },\n  themeTemplate: donutTheme,\n  paletteFactory: piePaletteFactory\n};\n\n// packages/ag-charts-community/src/chart/series/polar/pieSeriesProperties.ts\nvar PieTitle = class extends Caption {\n  constructor() {\n    super(...arguments);\n    this.showInLegend = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], PieTitle.prototype, \"showInLegend\", 2);\nvar PieSeriesCalloutLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.offset = 3;\n    this.minAngle = 0;\n    this.minSpacing = 4;\n    this.maxCollisionOffset = 50;\n    this.avoidCollisions = true;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLabel.prototype, \"offset\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], PieSeriesCalloutLabel.prototype, \"minAngle\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLabel.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLabel.prototype, \"maxCollisionOffset\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], PieSeriesCalloutLabel.prototype, \"avoidCollisions\", 2);\nvar PieSeriesSectorLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.positionOffset = 0;\n    this.positionRatio = 0.5;\n  }\n};\n__decorateClass([\n  Validate(NUMBER)\n], PieSeriesSectorLabel.prototype, \"positionOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesSectorLabel.prototype, \"positionRatio\", 2);\nvar PieSeriesCalloutLine = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.length = 10;\n    this.strokeWidth = 1;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY, { optional: true })\n], PieSeriesCalloutLine.prototype, \"colors\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLine.prototype, \"length\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLine.prototype, \"strokeWidth\", 2);\nvar PieSeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fills = Object.values(DEFAULT_FILLS);\n    this.strokes = Object.values(DEFAULT_STROKES);\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.rotation = 0;\n    this.outerRadiusOffset = 0;\n    this.outerRadiusRatio = 1;\n    this.strokeWidth = 1;\n    this.sectorSpacing = 0;\n    this.title = new PieTitle();\n    this.shadow = new DropShadow();\n    this.calloutLabel = new PieSeriesCalloutLabel();\n    this.sectorLabel = new PieSeriesSectorLabel();\n    this.calloutLine = new PieSeriesCalloutLine();\n    this.tooltip = new SeriesTooltip();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], PieSeriesProperties.prototype, \"angleKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"angleName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"radiusKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"radiusName\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], PieSeriesProperties.prototype, \"radiusMin\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], PieSeriesProperties.prototype, \"radiusMax\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"calloutLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"calloutLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"sectorLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"sectorLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"legendItemKey\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], PieSeriesProperties.prototype, \"fills\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], PieSeriesProperties.prototype, \"strokes\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], PieSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], PieSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], PieSeriesProperties.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], PieSeriesProperties.prototype, \"outerRadiusOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesProperties.prototype, \"outerRadiusRatio\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], PieSeriesProperties.prototype, \"sectorSpacing\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"calloutLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"sectorLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"calloutLine\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/polar/pieSeries.ts\nvar PieSeriesNodeEvent = class extends SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.angleKey = series.properties.angleKey;\n    this.radiusKey = series.properties.radiusKey;\n    this.calloutLabelKey = series.properties.calloutLabelKey;\n    this.sectorLabelKey = series.properties.sectorLabelKey;\n  }\n};\nvar PieSeries = class extends PolarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [3 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      useLabelLayer: true,\n      animationResetFns: { item: resetPieSelectionsFn, label: resetLabelFn }\n    });\n    this.properties = new PieSeriesProperties();\n    this.previousRadiusScale = new LinearScale();\n    this.radiusScale = new LinearScale();\n    this.calloutLabelGroup = this.contentGroup.appendChild(new Group({ name: \"pieCalloutLabels\" }));\n    this.calloutLabelSelection = new Selection(\n      this.calloutLabelGroup,\n      Group\n    );\n    // The group node that contains the background graphics.\n    this.backgroundGroup = this.rootGroup.appendChild(\n      new Group({\n        name: `${this.id}-background`,\n        layer: true,\n        zIndex: 0 /* SERIES_BACKGROUND_ZINDEX */\n      })\n    );\n    // AG-6193 If the sum of all datums is 0, then we'll draw 1 or 2 rings to represent the empty series.\n    this.zerosumRingsGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-zerosumRings` }));\n    this.zerosumOuterRing = this.zerosumRingsGroup.appendChild(new Circle());\n    // When a user toggles a series item (e.g. from the legend), its boolean state is recorded here.\n    this.seriesItemEnabled = [];\n    this.surroundingRadius = void 0;\n    this.NodeEvent = PieSeriesNodeEvent;\n    this.angleScale = new LinearScale();\n    this.angleScale.domain = [0, 1];\n    this.angleScale.range = [-Math.PI, Math.PI].map((angle2) => angle2 + Math.PI / 2);\n  }\n  addChartEventListeners() {\n    this.destroyFns.push(\n      this.ctx.chartEventManager?.addListener(\"legend-item-click\", (event) => this.onLegendItemClick(event))\n    );\n  }\n  get visible() {\n    return super.visible && (this.seriesItemEnabled.length === 0 || this.seriesItemEnabled.some((visible) => visible));\n  }\n  nodeFactory() {\n    const sector = new Sector();\n    sector.miterLimit = 1e9;\n    return sector;\n  }\n  getSeriesDomain(direction) {\n    if (direction === \"x\" /* X */) {\n      return this.angleScale.domain;\n    } else {\n      return this.radiusScale.domain;\n    }\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    let { data } = this;\n    const { visible, seriesItemEnabled } = this;\n    const { angleKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const extraKeyProps = [];\n    const extraProps = [];\n    if (legendItemKey) {\n      extraKeyProps.push(keyProperty(legendItemKey, \"band\", { id: `legendItemKey` }));\n    } else if (calloutLabelKey) {\n      extraKeyProps.push(keyProperty(calloutLabelKey, \"band\", { id: `calloutLabelKey` }));\n    } else if (sectorLabelKey) {\n      extraKeyProps.push(keyProperty(sectorLabelKey, \"band\", { id: `sectorLabelKey` }));\n    }\n    const radiusScaleType = this.radiusScale.type;\n    const angleScaleType = this.radiusScale.type;\n    if (radiusKey) {\n      extraProps.push(\n        rangedValueProperty(radiusKey, {\n          id: \"radiusValue\",\n          min: this.properties.radiusMin ?? 0,\n          max: this.properties.radiusMax\n        }),\n        valueProperty(radiusKey, radiusScaleType, { id: `radiusRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo(\n          { id: \"radiusValue\" },\n          [0, 1],\n          1,\n          this.properties.radiusMin ?? 0,\n          this.properties.radiusMax\n        )\n      );\n    }\n    if (calloutLabelKey) {\n      extraProps.push(valueProperty(calloutLabelKey, \"band\", { id: `calloutLabelValue` }));\n    }\n    if (sectorLabelKey) {\n      extraProps.push(valueProperty(sectorLabelKey, \"band\", { id: `sectorLabelValue` }));\n    }\n    if (legendItemKey) {\n      extraProps.push(valueProperty(legendItemKey, \"band\", { id: `legendItemValue` }));\n    }\n    if (animationEnabled && this.processedData && extraKeyProps.length > 0) {\n      extraProps.push(diff(this.processedData));\n    }\n    extraProps.push(animationValidation());\n    data = data.map((d, idx) => visible && seriesItemEnabled[idx] ? d : { ...d, [angleKey]: 0 });\n    await this.requestDataModel(dataController, data, {\n      props: [\n        ...extraKeyProps,\n        accumulativeValueProperty(angleKey, angleScaleType, { id: `angleValue`, onlyPositive: true }),\n        valueProperty(angleKey, angleScaleType, { id: `angleRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo({ id: \"angleValue\" }, [0, 1], 0, 0),\n        ...extraProps\n      ]\n    });\n    for (const valueDef of this.processedData?.defs?.values ?? []) {\n      const { id, missing, property } = valueDef;\n      const missCount = getMissCount(this, missing);\n      if (id !== \"angleRaw\" && missCount > 0) {\n        Logger.warnOnce(\n          `no value was found for the key '${String(property)}' on ${missCount} data element${missCount > 1 ? \"s\" : \"\"}`\n        );\n      }\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  async maybeRefreshNodeData() {\n    if (!this.nodeDataRefresh)\n      return;\n    const { nodeData = [] } = await this.createNodeData() ?? {};\n    this.nodeData = nodeData;\n    this.nodeDataRefresh = false;\n  }\n  getProcessedDataIndexes(dataModel) {\n    const angleIdx = dataModel.resolveProcessedDataIndexById(this, `angleValue`);\n    const radiusIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusValue`) : -1;\n    const calloutLabelIdx = this.properties.calloutLabelKey ? dataModel.resolveProcessedDataIndexById(this, `calloutLabelValue`) : -1;\n    const sectorLabelIdx = this.properties.sectorLabelKey ? dataModel.resolveProcessedDataIndexById(this, `sectorLabelValue`) : -1;\n    const legendItemIdx = this.properties.legendItemKey ? dataModel.resolveProcessedDataIndexById(this, `legendItemValue`) : -1;\n    return { angleIdx, radiusIdx, calloutLabelIdx, sectorLabelIdx, legendItemIdx };\n  }\n  async createNodeData() {\n    const { id: seriesId, processedData, dataModel, angleScale } = this;\n    const { rotation } = this.properties;\n    if (!processedData || !dataModel || processedData.type !== \"ungrouped\")\n      return;\n    const { angleIdx, radiusIdx, calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);\n    let currentStart = 0;\n    let sum2 = 0;\n    const nodeData = processedData.data.map((group, index) => {\n      const { datum, values } = group;\n      const currentValue = values[angleIdx];\n      const startAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      currentStart = currentValue;\n      sum2 += currentValue;\n      const endAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      const span = Math.abs(endAngle - startAngle);\n      const midAngle = startAngle + span / 2;\n      const angleValue = values[angleIdx + 1];\n      const radius = radiusIdx >= 0 ? values[radiusIdx] ?? 1 : 1;\n      const radiusValue = radiusIdx >= 0 ? values[radiusIdx + 1] : void 0;\n      const legendItemValue = legendItemIdx >= 0 ? values[legendItemIdx] : void 0;\n      const labels = this.getLabels(\n        datum,\n        midAngle,\n        span,\n        true,\n        values[calloutLabelIdx],\n        values[sectorLabelIdx],\n        legendItemValue\n      );\n      const sectorFormat = this.getSectorFormat(datum, index, false);\n      return {\n        itemId: index,\n        series: this,\n        datum,\n        index,\n        angleValue,\n        midAngle,\n        midCos: Math.cos(midAngle),\n        midSin: Math.sin(midAngle),\n        startAngle,\n        endAngle,\n        sectorFormat,\n        radiusValue,\n        radius,\n        innerRadius: Math.max(this.radiusScale.convert(0), 0),\n        outerRadius: Math.max(this.radiusScale.convert(radius), 0),\n        legendItemValue,\n        enabled: this.seriesItemEnabled[index],\n        ...labels\n      };\n    });\n    this.zerosumOuterRing.visible = sum2 === 0;\n    return { itemId: seriesId, nodeData, labelData: nodeData };\n  }\n  getLabels(datum, midAngle, span, skipDisabled, calloutLabelValue, sectorLabelValue, legendItemValue) {\n    const { calloutLabel, sectorLabel, legendItemKey } = this.properties;\n    const calloutLabelKey = !skipDisabled || calloutLabel.enabled ? this.properties.calloutLabelKey : void 0;\n    const sectorLabelKey = !skipDisabled || sectorLabel.enabled ? this.properties.sectorLabelKey : void 0;\n    if (!calloutLabelKey && !sectorLabelKey && !legendItemKey) {\n      return {};\n    }\n    const labelFormatterParams = {\n      datum,\n      angleKey: this.properties.angleKey,\n      angleName: this.properties.angleName,\n      radiusKey: this.properties.radiusKey,\n      radiusName: this.properties.radiusName,\n      calloutLabelKey: this.properties.calloutLabelKey,\n      calloutLabelName: this.properties.calloutLabelName,\n      sectorLabelKey: this.properties.sectorLabelKey,\n      sectorLabelName: this.properties.sectorLabelName,\n      legendItemKey: this.properties.legendItemKey\n    };\n    const result = {};\n    if (calloutLabelKey && span > toRadians(calloutLabel.minAngle)) {\n      result.calloutLabel = {\n        ...this.getTextAlignment(midAngle),\n        text: this.getLabelText(calloutLabel, {\n          ...labelFormatterParams,\n          value: calloutLabelValue\n        }),\n        hidden: false,\n        collisionTextAlign: void 0,\n        collisionOffsetY: 0,\n        box: void 0\n      };\n    }\n    if (sectorLabelKey) {\n      result.sectorLabel = {\n        text: this.getLabelText(sectorLabel, {\n          ...labelFormatterParams,\n          value: sectorLabelValue\n        })\n      };\n    }\n    if (legendItemKey != null && legendItemValue != null) {\n      result.legendItem = { key: legendItemKey, text: legendItemValue };\n    }\n    return result;\n  }\n  getTextAlignment(midAngle) {\n    const quadrantTextOpts = [\n      { textAlign: \"center\", textBaseline: \"bottom\" },\n      { textAlign: \"left\", textBaseline: \"middle\" },\n      { textAlign: \"center\", textBaseline: \"hanging\" },\n      { textAlign: \"right\", textBaseline: \"middle\" }\n    ];\n    const midAngle180 = normalizeAngle180(midAngle);\n    const quadrantStart = -0.75 * Math.PI;\n    const quadrantOffset = midAngle180 - quadrantStart;\n    const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));\n    const quadrantIndex = mod(quadrant, quadrantTextOpts.length);\n    return quadrantTextOpts[quadrantIndex];\n  }\n  getSectorFormat(datum, formatIndex, highlight) {\n    const { callbackCache, highlightManager } = this.ctx;\n    const { angleKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey, fills, strokes, itemStyler } = this.properties;\n    const highlightedDatum = highlightManager.getActiveHighlight();\n    const isDatumHighlighted = highlight && highlightedDatum?.series === this && formatIndex === highlightedDatum.itemId;\n    const defaultStroke = strokes[formatIndex % strokes.length];\n    const { fill, fillOpacity, stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = mergeDefaults(\n      isDatumHighlighted && this.properties.highlightStyle.item,\n      {\n        fill: fills.length > 0 ? fills[formatIndex % fills.length] : void 0,\n        stroke: defaultStroke,\n        strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),\n        strokeOpacity: this.getOpacity()\n      },\n      this.properties\n    );\n    let format;\n    if (itemStyler) {\n      format = callbackCache.call(itemStyler, {\n        datum,\n        angleKey,\n        radiusKey,\n        calloutLabelKey,\n        sectorLabelKey,\n        legendItemKey,\n        fill,\n        strokeOpacity,\n        stroke,\n        strokeWidth,\n        fillOpacity,\n        lineDash,\n        lineDashOffset,\n        cornerRadius,\n        highlighted: isDatumHighlighted,\n        seriesId: this.id\n      });\n    }\n    return {\n      fill: format?.fill ?? fill,\n      fillOpacity: format?.fillOpacity ?? fillOpacity,\n      stroke: format?.stroke ?? stroke,\n      strokeWidth: format?.strokeWidth ?? strokeWidth,\n      strokeOpacity: format?.strokeOpacity ?? strokeOpacity,\n      lineDash: format?.lineDash ?? lineDash,\n      lineDashOffset: format?.lineDashOffset ?? lineDashOffset,\n      cornerRadius: format?.cornerRadius ?? cornerRadius\n    };\n  }\n  getOuterRadius() {\n    return Math.max(this.radius * this.properties.outerRadiusRatio + this.properties.outerRadiusOffset, 0);\n  }\n  updateRadiusScale(resize) {\n    const newRange = [0, this.getOuterRadius()];\n    this.radiusScale.range = newRange;\n    if (resize) {\n      this.previousRadiusScale.range = newRange;\n    }\n    this.nodeData = this.nodeData.map(({ radius, ...d }) => {\n      return {\n        ...d,\n        radius,\n        innerRadius: Math.max(this.radiusScale.convert(0), 0),\n        outerRadius: Math.max(this.radiusScale.convert(radius), 0)\n      };\n    });\n  }\n  getTitleTranslationY() {\n    const outerRadius = Math.max(0, this.radiusScale.range[1]);\n    if (outerRadius === 0) {\n      return NaN;\n    }\n    const spacing = this.properties.title?.spacing ?? 0;\n    const titleOffset = 2 + spacing;\n    const dy = Math.max(0, -outerRadius);\n    return -outerRadius - titleOffset - dy;\n  }\n  async update({ seriesRect }) {\n    const { title } = this.properties;\n    const newNodeDataDependencies = {\n      seriesRectWidth: seriesRect?.width,\n      seriesRectHeight: seriesRect?.height\n    };\n    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\n    if (resize) {\n      this._nodeDataDependencies = newNodeDataDependencies;\n    }\n    await this.maybeRefreshNodeData();\n    this.updateTitleNodes();\n    this.updateRadiusScale(resize);\n    this.contentGroup.translationX = this.centerX;\n    this.contentGroup.translationY = this.centerY;\n    this.highlightGroup.translationX = this.centerX;\n    this.highlightGroup.translationY = this.centerY;\n    this.backgroundGroup.translationX = this.centerX;\n    this.backgroundGroup.translationY = this.centerY;\n    if (this.labelGroup) {\n      this.labelGroup.translationX = this.centerX;\n      this.labelGroup.translationY = this.centerY;\n    }\n    if (title) {\n      const dy = this.getTitleTranslationY();\n      const titleBox = title.node.computeBBox();\n      title.node.visible = title.enabled && isFinite(dy) && !this.bboxIntersectsSurroundingSeries(titleBox, 0, dy);\n      title.node.translationY = isFinite(dy) ? dy : 0;\n    }\n    this.zerosumOuterRing.fillOpacity = 0;\n    this.zerosumOuterRing.stroke = this.properties.calloutLabel.color;\n    this.zerosumOuterRing.strokeWidth = 1;\n    this.zerosumOuterRing.strokeOpacity = 1;\n    this.updateNodeMidPoint();\n    await this.updateSelections();\n    await this.updateNodes(seriesRect);\n  }\n  updateTitleNodes() {\n    const { oldTitle } = this;\n    const { title } = this.properties;\n    if (oldTitle !== title) {\n      if (oldTitle) {\n        this.labelGroup?.removeChild(oldTitle.node);\n      }\n      if (title) {\n        title.node.textBaseline = \"bottom\";\n        this.labelGroup?.appendChild(title.node);\n      }\n      this.oldTitle = title;\n    }\n  }\n  updateNodeMidPoint() {\n    this.nodeData.forEach((d) => {\n      const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;\n      d.midPoint = {\n        x: d.midCos * Math.max(0, radius),\n        y: d.midSin * Math.max(0, radius)\n      };\n    });\n  }\n  async updateSelections() {\n    await this.updateGroupSelection();\n  }\n  async updateGroupSelection() {\n    const { itemSelection, highlightSelection, highlightLabelSelection, calloutLabelSelection, labelSelection } = this;\n    const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();\n    const highlightedNodeData = highlightedDatum?.series === this ? this.nodeData.filter((node) => node.itemId === highlightedDatum?.itemId) : [];\n    const update = (selection, clone) => {\n      let nodeData = this.nodeData;\n      if (clone) {\n        nodeData = nodeData.map((datum) => ({ ...datum, sectorFormat: { ...datum.sectorFormat } }));\n      }\n      selection.update(nodeData, void 0, (datum) => this.getDatumId(datum));\n      if (this.ctx.animationManager.isSkipped()) {\n        selection.cleanup();\n      }\n    };\n    update(itemSelection, false);\n    update(highlightSelection, true);\n    calloutLabelSelection.update(this.nodeData, (group) => {\n      const line = new Line();\n      line.tag = 0 /* Callout */;\n      line.pointerEvents = 1 /* None */;\n      group.appendChild(line);\n      const text = new Text();\n      text.tag = 1 /* Label */;\n      text.pointerEvents = 1 /* None */;\n      group.appendChild(text);\n    });\n    labelSelection.update(this.nodeData);\n    highlightLabelSelection.update(highlightedNodeData);\n  }\n  async updateNodes(seriesRect) {\n    const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();\n    const isVisible = this.visible && this.seriesItemEnabled.indexOf(true) >= 0;\n    this.rootGroup.visible = isVisible;\n    this.backgroundGroup.visible = isVisible;\n    this.contentGroup.visible = isVisible;\n    this.highlightGroup.visible = isVisible && highlightedDatum?.series === this;\n    this.highlightLabel.visible = isVisible && highlightedDatum?.series === this;\n    if (this.labelGroup) {\n      this.labelGroup.visible = isVisible;\n    }\n    this.contentGroup.opacity = this.getOpacity();\n    const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {\n      const format = this.getSectorFormat(datum.datum, datum.itemId, isDatumHighlighted);\n      datum.sectorFormat.fill = format.fill;\n      datum.sectorFormat.stroke = format.stroke;\n      const animationDisabled = this.ctx.animationManager.isSkipped();\n      if (animationDisabled) {\n        sector.startAngle = datum.startAngle;\n        sector.endAngle = datum.endAngle;\n        sector.innerRadius = datum.innerRadius;\n        sector.outerRadius = datum.outerRadius;\n      }\n      if (isDatumHighlighted || animationDisabled) {\n        sector.fill = format.fill;\n        sector.stroke = format.stroke;\n      }\n      sector.strokeWidth = format.strokeWidth;\n      sector.fillOpacity = format.fillOpacity;\n      sector.strokeOpacity = format.strokeOpacity;\n      sector.lineDash = format.lineDash;\n      sector.lineDashOffset = format.lineDashOffset;\n      sector.cornerRadius = format.cornerRadius;\n      sector.fillShadow = this.properties.shadow;\n      const inset = Math.max(\n        (this.properties.sectorSpacing + (format.stroke != null ? format.strokeWidth : 0)) / 2,\n        0\n      );\n      sector.inset = inset;\n      sector.lineJoin = this.properties.sectorSpacing >= 0 || inset > 0 ? \"miter\" : \"round\";\n    };\n    this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n    this.highlightSelection.each((node, datum, index) => updateSectorFn(node, datum, index, true));\n    this.updateCalloutLineNodes();\n    this.updateCalloutLabelNodes(seriesRect);\n    this.updateSectorLabelNodes();\n    this.updateZerosumRings();\n    this.animationState.transition(\"update\");\n  }\n  updateCalloutLineNodes() {\n    const { calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const calloutStrokeWidth = calloutLine.strokeWidth;\n    const calloutColors = calloutLine.colors ?? this.properties.strokes;\n    const { offset: offset4 } = this.properties.calloutLabel;\n    this.calloutLabelSelection.selectByTag(0 /* Callout */).forEach((line, index) => {\n      const datum = line.datum;\n      const { calloutLabel: label, outerRadius } = datum;\n      if (label?.text && !label.hidden && outerRadius !== 0) {\n        line.visible = true;\n        line.strokeWidth = calloutStrokeWidth;\n        line.stroke = calloutColors[index % calloutColors.length];\n        line.fill = void 0;\n        const x1 = datum.midCos * outerRadius;\n        const y1 = datum.midSin * outerRadius;\n        let x2 = datum.midCos * (outerRadius + calloutLength);\n        let y2 = datum.midSin * (outerRadius + calloutLength);\n        const isMoved = label.collisionTextAlign ?? label.collisionOffsetY !== 0;\n        if (isMoved && label.box != null) {\n          const box = label.box;\n          let cx = x2;\n          let cy = y2;\n          if (x2 < box.x) {\n            cx = box.x;\n          } else if (x2 > box.x + box.width) {\n            cx = box.x + box.width;\n          }\n          if (y2 < box.y) {\n            cy = box.y;\n          } else if (y2 > box.y + box.height) {\n            cy = box.y + box.height;\n          }\n          const dx = cx - x2;\n          const dy = cy - y2;\n          const length2 = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n          const paddedLength = length2 - offset4;\n          if (paddedLength > 0) {\n            x2 = x2 + dx * paddedLength / length2;\n            y2 = y2 + dy * paddedLength / length2;\n          }\n        }\n        line.x1 = x1;\n        line.y1 = y1;\n        line.x2 = x2;\n        line.y2 = y2;\n      } else {\n        line.visible = false;\n      }\n    });\n  }\n  getLabelOverflow(text, box, seriesRect) {\n    const seriesLeft = seriesRect.x - this.centerX;\n    const seriesRight = seriesRect.x + seriesRect.width - this.centerX;\n    const seriesTop = seriesRect.y - this.centerY;\n    const seriesBottom = seriesRect.y + seriesRect.height - this.centerY;\n    const errPx = 1;\n    let visibleTextPart = 1;\n    if (box.x + errPx < seriesLeft) {\n      visibleTextPart = (box.x + box.width - seriesLeft) / box.width;\n    } else if (box.x + box.width - errPx > seriesRight) {\n      visibleTextPart = (seriesRight - box.x) / box.width;\n    }\n    const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;\n    const textLength = visibleTextPart === 1 ? text.length : Math.floor(text.length * visibleTextPart) - 1;\n    const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);\n    return { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow };\n  }\n  bboxIntersectsSurroundingSeries(box, dx = 0, dy = 0) {\n    const { surroundingRadius } = this;\n    if (surroundingRadius == null) {\n      return false;\n    }\n    const corners = [\n      { x: box.x + dx, y: box.y + dy },\n      { x: box.x + box.width + dx, y: box.y + dy },\n      { x: box.x + box.width + dx, y: box.y + box.height + dy },\n      { x: box.x + dx, y: box.y + box.height + dy }\n    ];\n    const sur2 = surroundingRadius ** 2;\n    return corners.some((corner) => corner.x ** 2 + corner.y ** 2 > sur2);\n  }\n  computeCalloutLabelCollisionOffsets() {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const { offset: offset4, minSpacing } = calloutLabel;\n    const innerRadius = radiusScale.convert(0);\n    const shouldSkip = (datum) => {\n      const label = datum.calloutLabel;\n      return !label || datum.outerRadius === 0;\n    };\n    const fullData = this.nodeData;\n    const data = this.nodeData.filter((t) => !shouldSkip(t));\n    data.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return;\n      label.hidden = false;\n      label.collisionTextAlign = void 0;\n      label.collisionOffsetY = 0;\n    });\n    if (data.length <= 1) {\n      return;\n    }\n    const leftLabels = data.filter((d) => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);\n    const rightLabels = data.filter((d) => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);\n    const topLabels = data.filter((d) => d.midSin < 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const bottomLabels = data.filter((d) => d.midSin >= 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const tempTextNode = new Text();\n    const getTextBBox = (datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return new BBox(0, 0, 0, 0);\n      const labelRadius = datum.outerRadius + calloutLine.length + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      tempTextNode.text = label.text;\n      tempTextNode.x = x;\n      tempTextNode.y = y;\n      tempTextNode.setFont(this.properties.calloutLabel);\n      tempTextNode.setAlign({\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      });\n      return tempTextNode.computeBBox();\n    };\n    const avoidNeighbourYCollision = (label, next, direction) => {\n      const box = getTextBBox(label).grow(minSpacing / 2);\n      const other = getTextBBox(next).grow(minSpacing / 2);\n      const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === \"to-top\" ? box.y < other.y + other.height : box.y + box.height > other.y);\n      if (collidesOrBehind) {\n        const dy = direction === \"to-top\" ? box.y - other.y - other.height : box.y + box.height - other.y;\n        next.calloutLabel.collisionOffsetY = dy;\n      }\n    };\n    const avoidYCollisions = (labels) => {\n      const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];\n      const midIndex = labels.indexOf(midLabel);\n      for (let i = midIndex - 1; i >= 0; i--) {\n        const prev = labels[i + 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-top\");\n      }\n      for (let i = midIndex + 1; i < labels.length; i++) {\n        const prev = labels[i - 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-bottom\");\n      }\n    };\n    const avoidXCollisions = (labels) => {\n      const labelsCollideLabelsByY = data.some((datum) => datum.calloutLabel.collisionOffsetY !== 0);\n      const boxes = labels.map((label) => getTextBBox(label));\n      const paddedBoxes = boxes.map((box) => box.clone().grow(minSpacing / 2));\n      let labelsCollideLabelsByX = false;\n      for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {\n        const box = paddedBoxes[i];\n        for (let j = i + 1; j < labels.length; j++) {\n          const other = paddedBoxes[j];\n          if (box.collidesBBox(other)) {\n            labelsCollideLabelsByX = true;\n            break;\n          }\n        }\n      }\n      const sectors = fullData.map((datum) => {\n        const { startAngle, endAngle, outerRadius } = datum;\n        return { startAngle, endAngle, innerRadius, outerRadius };\n      });\n      const labelsCollideSectors = boxes.some((box) => {\n        return sectors.some((sector) => boxCollidesSector(box, sector));\n      });\n      if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {\n        return;\n      }\n      labels.filter((d) => d.calloutLabel.textAlign === \"center\").forEach((d) => {\n        const label = d.calloutLabel;\n        if (d.midCos < 0) {\n          label.collisionTextAlign = \"right\";\n        } else if (d.midCos > 0) {\n          label.collisionTextAlign = \"left\";\n        } else {\n          label.collisionTextAlign = \"center\";\n        }\n      });\n    };\n    avoidYCollisions(leftLabels);\n    avoidYCollisions(rightLabels);\n    avoidXCollisions(topLabels);\n    avoidXCollisions(bottomLabels);\n  }\n  updateCalloutLabelNodes(seriesRect) {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, color } = calloutLabel;\n    const tempTextNode = new Text();\n    this.calloutLabelSelection.selectByTag(1 /* Label */).forEach((text) => {\n      const { datum } = text;\n      const label = datum.calloutLabel;\n      const radius = radiusScale.convert(datum.radius);\n      const outerRadius = Math.max(0, radius);\n      if (!label?.text || outerRadius === 0 || label.hidden) {\n        text.visible = false;\n        return;\n      }\n      const labelRadius = outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      const align = {\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      };\n      tempTextNode.text = label.text;\n      tempTextNode.x = x;\n      tempTextNode.y = y;\n      tempTextNode.setFont(this.properties.calloutLabel);\n      tempTextNode.setAlign(align);\n      const box = tempTextNode.computeBBox();\n      let displayText = label.text;\n      let visible = true;\n      if (calloutLabel.avoidCollisions) {\n        const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);\n        displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}\\u2026`;\n        visible = !hasVerticalOverflow;\n      }\n      text.text = displayText;\n      text.x = x;\n      text.y = y;\n      text.setFont(this.properties.calloutLabel);\n      text.setAlign(align);\n      text.fill = color;\n      text.visible = visible;\n    });\n  }\n  async computeLabelsBBox(options, seriesRect) {\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, maxCollisionOffset, minSpacing } = calloutLabel;\n    if (!calloutLabel.avoidCollisions) {\n      return null;\n    }\n    await this.maybeRefreshNodeData();\n    this.updateRadiusScale(false);\n    this.computeCalloutLabelCollisionOffsets();\n    const textBoxes = [];\n    const text = new Text();\n    let titleBox;\n    const { title } = this.properties;\n    if (title?.text && title.enabled) {\n      const dy = this.getTitleTranslationY();\n      if (isFinite(dy)) {\n        text.text = title.text;\n        text.x = 0;\n        text.y = dy;\n        text.setFont(title);\n        text.setAlign({\n          textBaseline: \"bottom\",\n          textAlign: \"center\"\n        });\n        titleBox = text.computeBBox();\n        textBoxes.push(titleBox);\n      }\n    }\n    this.nodeData.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (!label || datum.outerRadius === 0) {\n        return null;\n      }\n      const labelRadius = datum.outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      text.text = label.text;\n      text.x = x;\n      text.y = y;\n      text.setFont(this.properties.calloutLabel);\n      text.setAlign({\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      });\n      const box = text.computeBBox();\n      label.box = box;\n      if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {\n        label.hidden = true;\n        return;\n      }\n      if (titleBox) {\n        const seriesTop = seriesRect.y - this.centerY;\n        const titleCleanArea = new BBox(\n          titleBox.x - minSpacing,\n          seriesTop,\n          titleBox.width + 2 * minSpacing,\n          titleBox.y + titleBox.height + minSpacing - seriesTop\n        );\n        if (box.collidesBBox(titleCleanArea)) {\n          label.hidden = true;\n          return;\n        }\n      }\n      if (options.hideWhenNecessary) {\n        const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(\n          label.text,\n          box,\n          seriesRect\n        );\n        const isTooShort = label.text.length > 2 && textLength < 2;\n        if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {\n          label.hidden = true;\n          return;\n        }\n      }\n      label.hidden = false;\n      textBoxes.push(box);\n    });\n    if (textBoxes.length === 0) {\n      return null;\n    }\n    return BBox.merge(textBoxes);\n  }\n  updateSectorLabelNodes() {\n    const { radiusScale } = this;\n    const innerRadius = radiusScale.convert(0);\n    const { fontSize, fontStyle, fontWeight, fontFamily, positionOffset, positionRatio, color } = this.properties.sectorLabel;\n    const isDonut = innerRadius > 0;\n    const singleVisibleSector = this.seriesItemEnabled.filter(Boolean).length === 1;\n    const updateSectorLabel = (text, datum) => {\n      const { sectorLabel, outerRadius } = datum;\n      let isTextVisible = false;\n      if (sectorLabel && outerRadius !== 0) {\n        const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;\n        text.fill = color;\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.text = sectorLabel.text;\n        const shouldPutTextInCenter = !isDonut && singleVisibleSector;\n        if (shouldPutTextInCenter) {\n          text.x = 0;\n          text.y = 0;\n        } else {\n          text.x = datum.midCos * labelRadius;\n          text.y = datum.midSin * labelRadius;\n        }\n        text.textAlign = \"center\";\n        text.textBaseline = \"middle\";\n        const bbox = text.computeBBox();\n        const corners = [\n          [bbox.x, bbox.y],\n          [bbox.x + bbox.width, bbox.y],\n          [bbox.x + bbox.width, bbox.y + bbox.height],\n          [bbox.x, bbox.y + bbox.height]\n        ];\n        const { startAngle, endAngle } = datum;\n        const sectorBounds = { startAngle, endAngle, innerRadius, outerRadius };\n        if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {\n          isTextVisible = true;\n        }\n      }\n      text.visible = isTextVisible;\n    };\n    this.labelSelection.each(updateSectorLabel);\n    this.highlightLabelSelection.each(updateSectorLabel);\n  }\n  updateZerosumRings() {\n    this.zerosumOuterRing.size = this.getOuterRadius() * 2;\n  }\n  getDatumLegendName(nodeDatum) {\n    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    const { sectorLabel, calloutLabel, legendItem } = nodeDatum;\n    if (legendItemKey && legendItem !== void 0) {\n      return legendItem.text;\n    } else if (calloutLabelKey && calloutLabelKey !== angleKey && calloutLabel?.text !== void 0) {\n      return calloutLabel.text;\n    } else if (sectorLabelKey && sectorLabelKey !== angleKey && sectorLabel?.text !== void 0) {\n      return sectorLabel.text;\n    }\n  }\n  pickNodeClosestDatum(point) {\n    return pickByMatchingAngle(this, point);\n  }\n  getTooltipHtml(nodeDatum) {\n    if (!this.properties.isValid()) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const {\n      datum,\n      angleValue,\n      sectorFormat: { fill: color },\n      itemId\n    } = nodeDatum;\n    const title = sanitizeHtml(this.properties.title?.text);\n    const content = isFiniteNumber(angleValue) ? toFixed(angleValue) : String(angleValue);\n    const labelText = this.getDatumLegendName(nodeDatum);\n    return this.properties.tooltip.toTooltipHtml(\n      {\n        title: title ?? labelText,\n        content: title && labelText ? `${labelText}: ${content}` : content,\n        backgroundColor: color\n      },\n      {\n        datum,\n        itemId,\n        title,\n        color,\n        seriesId: this.id,\n        angleKey: this.properties.angleKey,\n        angleName: this.properties.angleName,\n        radiusKey: this.properties.radiusKey,\n        radiusName: this.properties.radiusName,\n        calloutLabelKey: this.properties.calloutLabelKey,\n        calloutLabelName: this.properties.calloutLabelName,\n        sectorLabelKey: this.properties.sectorLabelKey,\n        sectorLabelName: this.properties.sectorLabelName,\n        legendItemKey: this.properties.legendItemKey\n      }\n    );\n  }\n  getLegendData(legendType) {\n    const { visible, processedData, dataModel } = this;\n    if (!dataModel || !processedData?.data.length || legendType !== \"category\") {\n      return [];\n    }\n    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    if (!legendItemKey && (!calloutLabelKey || calloutLabelKey === angleKey) && (!sectorLabelKey || sectorLabelKey === angleKey)) {\n      return [];\n    }\n    const { calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);\n    const titleText = this.properties.title?.showInLegend && this.properties.title.text;\n    const legendData = [];\n    for (let index = 0; index < processedData.data.length; index++) {\n      const { datum, values } = processedData.data[index];\n      const labelParts = [];\n      if (titleText) {\n        labelParts.push(titleText);\n      }\n      const labels = this.getLabels(\n        datum,\n        2 * Math.PI,\n        2 * Math.PI,\n        false,\n        values[calloutLabelIdx],\n        values[sectorLabelIdx],\n        values[legendItemIdx]\n      );\n      if (legendItemKey && labels.legendItem !== void 0) {\n        labelParts.push(labels.legendItem.text);\n      } else if (calloutLabelKey && calloutLabelKey !== angleKey && labels.calloutLabel?.text !== void 0) {\n        labelParts.push(labels.calloutLabel?.text);\n      } else if (sectorLabelKey && sectorLabelKey !== angleKey && labels.sectorLabel?.text !== void 0) {\n        labelParts.push(labels.sectorLabel?.text);\n      }\n      if (labelParts.length === 0)\n        continue;\n      const sectorFormat = this.getSectorFormat(datum, index, false);\n      legendData.push({\n        legendType: \"category\",\n        id: this.id,\n        itemId: index,\n        seriesId: this.id,\n        enabled: visible && this.seriesItemEnabled[index],\n        label: {\n          text: labelParts.join(\" - \")\n        },\n        symbols: [\n          {\n            marker: {\n              fill: sectorFormat.fill,\n              stroke: sectorFormat.stroke,\n              fillOpacity: this.properties.fillOpacity,\n              strokeOpacity: this.properties.strokeOpacity,\n              strokeWidth: this.properties.strokeWidth\n            }\n          }\n        ],\n        legendItemName: legendItemKey != null ? datum[legendItemKey] : void 0\n      });\n    }\n    return legendData;\n  }\n  onLegendItemClick(event) {\n    const { enabled, itemId, series, legendItemName } = event;\n    if (series.id === this.id) {\n      this.toggleSeriesItem(itemId, enabled);\n    } else if (legendItemName != null) {\n      this.toggleOtherSeriesItems(legendItemName, enabled);\n    }\n  }\n  toggleSeriesItem(itemId, enabled) {\n    this.seriesItemEnabled[itemId] = enabled;\n    if (this.nodeData[itemId]) {\n      this.nodeData[itemId].enabled = enabled;\n    }\n    this.nodeDataRefresh = true;\n  }\n  toggleOtherSeriesItems(legendItemName, enabled) {\n    if (!this.properties.legendItemKey || !this.dataModel) {\n      return;\n    }\n    const legendItemIdx = this.dataModel.resolveProcessedDataIndexById(this, `legendItemValue`);\n    this.processedData?.data.forEach(({ values }, datumItemId) => {\n      if (values[legendItemIdx] === legendItemName) {\n        this.toggleSeriesItem(datumItemId, enabled);\n      }\n    });\n  }\n  animateEmptyUpdateReady(_data) {\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      true,\n      this.properties.rotation,\n      this.radiusScale,\n      this.previousRadiusScale\n    );\n    fromToMotion(this.id, \"nodes\", animationManager, [this.itemSelection, this.highlightSelection], fns.nodes);\n    seriesLabelFadeInAnimation(this, \"callout\", animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", animationManager, this.highlightLabelSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateWaitingUpdateReady() {\n    const { itemSelection, highlightSelection, processedData, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const dataDiff = processedData?.reduced?.diff;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    const supportedDiff = (dataDiff?.moved.size ?? 0) === 0;\n    const hasKeys = (processedData?.defs.keys.length ?? 0) > 0;\n    const hasUniqueKeys = processedData?.reduced?.animationValidation?.uniqueKeys ?? true;\n    if (!supportedDiff || !hasKeys || !hasUniqueKeys) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [itemSelection, highlightSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum),\n      dataDiff\n    );\n    seriesLabelFadeInAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateClearingUpdateEmpty() {\n    const { itemSelection, highlightSelection, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(this.id, \"nodes\", animationManager, [itemSelection, highlightSelection], fns.nodes);\n    seriesLabelFadeOutAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeOutAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeOutAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  getDatumIdFromData(datum) {\n    const { calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    if (!this.processedData?.reduced?.animationValidation?.uniqueKeys) {\n      return;\n    }\n    if (legendItemKey) {\n      return datum[legendItemKey];\n    } else if (calloutLabelKey) {\n      return datum[calloutLabelKey];\n    } else if (sectorLabelKey) {\n      return datum[sectorLabelKey];\n    }\n  }\n  getDatumId(datum) {\n    const { index } = datum;\n    const datumId = this.getDatumIdFromData(datum.datum);\n    return datumId != null ? String(datumId) : `${index}`;\n  }\n  onDataChange() {\n    const { data, seriesItemEnabled } = this;\n    this.seriesItemEnabled = data?.map((_, index) => seriesItemEnabled[index] ?? true) ?? [];\n  }\n};\nPieSeries.className = \"PieSeries\";\nPieSeries.type = \"pie\";\n\n// packages/ag-charts-community/src/chart/series/polar/pieSeriesModule.ts\nvar PieSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"polar\"],\n  identifier: \"pie\",\n  instanceConstructor: PieSeries,\n  tooltipDefaults: { range: \"exact\" },\n  themeTemplate: pieTheme,\n  paletteFactory: piePaletteFactory\n};\n\n// packages/ag-charts-community/src/chart/toolbar/toolbarProperties.ts\nvar ToolbarGroupProperties = class extends BaseProperties {\n  constructor(onChange, onButtonsChange) {\n    super();\n    this.onChange = onChange;\n    this.onButtonsChange = onButtonsChange;\n    this.align = \"start\";\n    this.position = \"top\" /* Top */;\n    this.size = \"normal\";\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => {\n    target.onChange(target.enabled);\n  }),\n  Validate(BOOLEAN)\n], ToolbarGroupProperties.prototype, \"enabled\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    target.onChange(target.enabled);\n  }),\n  Validate(UNION([...TOOLBAR_ALIGNMENTS]), { optional: true })\n], ToolbarGroupProperties.prototype, \"align\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    target.onChange(target.enabled);\n  }),\n  Validate(UNION(TOOLBAR_POSITIONS), { optional: true })\n], ToolbarGroupProperties.prototype, \"position\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    target.onChange(target.enabled);\n  }),\n  Validate(UNION([\"small\", \"normal\"]), { optional: true })\n], ToolbarGroupProperties.prototype, \"size\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    target.onButtonsChange(target.buttons);\n  }),\n  Validate(ARRAY, { optional: true })\n], ToolbarGroupProperties.prototype, \"buttons\", 2);\n\n// packages/ag-charts-community/src/chart/toolbar/toolbarStyles.ts\nvar block2 = \"ag-charts-toolbar\";\nvar elements2 = {\n  align: \"ag-charts-toolbar__align\",\n  section: \"ag-charts-toolbar__section\",\n  button: \"ag-charts-toolbar__button\",\n  icon: \"ag-charts-toolbar__icon\",\n  label: \"ag-charts-toolbar__label\"\n};\nvar modifiers2 = {\n  [\"top\" /* Top */]: \"ag-charts-toolbar--top\",\n  [\"right\" /* Right */]: \"ag-charts-toolbar--right\",\n  [\"bottom\" /* Bottom */]: \"ag-charts-toolbar--bottom\",\n  [\"left\" /* Left */]: \"ag-charts-toolbar--left\",\n  [\"floating\" /* Floating */]: \"ag-charts-toolbar--floating\",\n  [\"floating-top\" /* FloatingTop */]: \"ag-charts-toolbar--floating-top\",\n  [\"floating-bottom\" /* FloatingBottom */]: \"ag-charts-toolbar--floating-bottom\",\n  small: \"ag-charts-toolbar--small\",\n  normal: \"ag-charts-toolbar--normal\",\n  hidden: \"ag-charts-toolbar--hidden\",\n  preventFlash: \"ag-charts-toolbar--prevent-flash\",\n  floatingHidden: \"ag-charts-toolbar--floating-hidden\",\n  align: {\n    start: \"ag-charts-toolbar__align--start\",\n    center: \"ag-charts-toolbar__align--center\",\n    end: \"ag-charts-toolbar__align--end\"\n  },\n  button: {\n    active: `ag-charts-toolbar__button--active`,\n    hiddenValue: `ag-charts-toolbar__button--hidden-value`,\n    hiddenToggled: `ag-charts-toolbar__button--hidden-toggled`\n  }\n};\n\n// packages/ag-charts-community/src/chart/toolbar/toolbarStyles.css\nvar toolbarStyles_default = \".ag-charts-toolbar{align-items:center;background:none;border:none;display:flex;flex-wrap:nowrap;opacity:1;position:absolute;transform:translateY(0);transition:opacity 0.2s ease-in-out,transform 0.2s ease-in-out}.ag-charts-toolbar--hidden,\\n.ag-charts-toolbar--prevent-flash{visibility:hidden}.ag-charts-toolbar--floating-hidden{opacity:0;transition:opacity 0.4s ease-in-out}.ag-charts-toolbar--small{--ag-charts-toolbar-size:var(--ag-charts-toolbar-size-small);--ag-charts-toolbar-font-size:var(--ag-charts-toolbar-font-size-small);--ag-charts-toolbar-button-padding:var(--ag-charts-toolbar-button-padding-small)}.ag-charts-toolbar--top,\\n.ag-charts-toolbar--bottom{flex-direction:row;width:100%}.ag-charts-toolbar--left,\\n.ag-charts-toolbar--right{flex-direction:column}.ag-charts-toolbar--floating,\\n.ag-charts-toolbar--floating-top,\\n.ag-charts-toolbar--floating-bottom{background:none;border:none;flex-direction:row;overflow:hidden;pointer-events:none;width:100%}.ag-charts-toolbar--floating{padding:0;width:auto;z-index:var(--ag-charts-layer-toolbar)}.ag-charts-toolbar--floating-top{height:calc(var(--ag-charts-toolbar-size) + 10px);padding-top:10px}.ag-charts-toolbar--floating-bottom{height:calc(var(--ag-charts-toolbar-size) + 10px);padding-bottom:10px}.ag-charts-toolbar__align{display:flex;flex-direction:inherit;flex-wrap:inherit;gap:var(--ag-charts-toolbar-gap);max-width:100%;width:100%}.ag-charts-toolbar__align--start{justify-content:start}.ag-charts-toolbar__align--center{justify-content:center}.ag-charts-toolbar__align--end{justify-content:end}.ag-charts-toolbar__align--center,\\n.ag-charts-toolbar__align--end{margin-left:auto}.ag-charts-toolbar--left .ag-charts-toolbar__align--center,\\n.ag-charts-toolbar--left .ag-charts-toolbar__align--end,\\n.ag-charts-toolbar--right .ag-charts-toolbar__align--center,\\n.ag-charts-toolbar--right .ag-charts-toolbar__align--end{margin-left:0;margin-top:auto}.ag-charts-toolbar--floating-top .ag-charts-toolbar__align,\\n.ag-charts-toolbar--floating-bottom .ag-charts-toolbar__align{transition:transform 0.4s ease-in-out;width:auto}.ag-charts-toolbar__section{display:inherit;flex-direction:inherit;flex-wrap:inherit;justify-content:inherit;max-width:inherit;width:inherit}.ag-charts-toolbar__button{align-items:center;background:var(--ag-charts-toolbar-background-color);border:var(--ag-charts-toolbar-border);color:var(--ag-charts-toolbar-foreground-color);display:flex;font-size:var(--ag-charts-toolbar-font-size);font-weight:500;justify-content:center;margin:0 0 0 -1px;min-height:var(--ag-charts-toolbar-size);min-width:var(--ag-charts-toolbar-size);padding:var(--ag-charts-toolbar-button-padding);pointer-events:all;transition:background-color 0.25s ease-in-out,color 0.25s ease-in-out;white-space:nowrap}.ag-charts-toolbar__button:first-child{border-bottom-left-radius:var(--ag-charts-button-radius);border-top-left-radius:var(--ag-charts-button-radius);margin:0}.ag-charts-toolbar__button:last-child{border-bottom-right-radius:var(--ag-charts-button-radius);border-right:var(--ag-charts-toolbar-border);border-top-right-radius:var(--ag-charts-button-radius)}.ag-charts-toolbar--left .ag-charts-toolbar__button,\\n.ag-charts-toolbar--right .ag-charts-toolbar__button{border-left:var(--ag-charts-toolbar-border);border-right:var(--ag-charts-toolbar-border);border-radius:0;margin:-1px 0 0 0;max-width:100%;overflow:hidden}.ag-charts-toolbar--left .ag-charts-toolbar__button:first-child,\\n.ag-charts-toolbar--right .ag-charts-toolbar__button:first-child{border-top-left-radius:var(--ag-charts-button-radius);border-top-right-radius:var(--ag-charts-button-radius);margin:0}.ag-charts-toolbar--left .ag-charts-toolbar__button:last-child,\\n.ag-charts-toolbar--right .ag-charts-toolbar__button:last-child{border-bottom:var(--ag-charts-toolbar-border);border-bottom-left-radius:var(--ag-charts-button-radius);border-bottom-right-radius:var(--ag-charts-button-radius)}.ag-charts-toolbar__button--hidden-value,\\n.ag-charts-toolbar__button--hidden-toggled{display:none}.ag-charts-toolbar__button:hover{background:var(--ag-charts-toolbar-hover-color)}.ag-charts-toolbar .ag-charts-toolbar__button:focus-visible{border-left:var(--ag-charts-toolbar-border);border-color:var(--ag-charts-toolbar-focus-color);box-shadow:var(--ag-charts-focus-border-shadow);z-index:1}.ag-charts-toolbar__button.ag-charts-toolbar__button--active{background:var(--ag-charts-toolbar-active-background-color);color:var(--ag-charts-toolbar-active-color)}.ag-charts-toolbar__button[aria-disabled='true']{background:var(--ag-charts-toolbar-disabled-background-color);color:var(--ag-charts-toolbar-disabled-foreground-color)}.ag-charts-toolbar__button:not([aria-disabled='true']){cursor:pointer}.ag-charts-toolbar__icon{height:1.2em;width:1.2em}.ag-charts-toolbar__icon + .ag-charts-toolbar__label{margin-left:var(--ag-charts-toolbar-gap)}.ag-charts-toolbar__icon,\\n.ag-charts-toolbar__label{pointer-events:none}\";\n\n// packages/ag-charts-community/src/chart/toolbar/toolbar.ts\nvar Toolbar = class extends BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.enabled = true;\n    this.annotations = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"annotations\"),\n      this.onGroupButtonsChanged.bind(this, \"annotations\")\n    );\n    this.annotationOptions = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"annotationOptions\"),\n      this.onGroupButtonsChanged.bind(this, \"annotationOptions\")\n    );\n    this.ranges = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"ranges\"),\n      this.onGroupButtonsChanged.bind(this, \"ranges\")\n    );\n    this.zoom = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"zoom\"),\n      this.onGroupButtonsChanged.bind(this, \"zoom\")\n    );\n    this.horizontalSpacing = 10;\n    this.verticalSpacing = 10;\n    this.floatingDetectionRange = 38;\n    this.positions = {\n      [\"top\" /* Top */]: /* @__PURE__ */ new Set(),\n      [\"right\" /* Right */]: /* @__PURE__ */ new Set(),\n      [\"bottom\" /* Bottom */]: /* @__PURE__ */ new Set(),\n      [\"left\" /* Left */]: /* @__PURE__ */ new Set(),\n      [\"floating\" /* Floating */]: /* @__PURE__ */ new Set(),\n      [\"floating-top\" /* FloatingTop */]: /* @__PURE__ */ new Set(),\n      [\"floating-bottom\" /* FloatingBottom */]: /* @__PURE__ */ new Set()\n    };\n    this.positionAlignments = {\n      [\"top\" /* Top */]: {},\n      [\"right\" /* Right */]: {},\n      [\"bottom\" /* Bottom */]: {},\n      [\"left\" /* Left */]: {},\n      [\"floating\" /* Floating */]: {},\n      [\"floating-top\" /* FloatingTop */]: {},\n      [\"floating-bottom\" /* FloatingBottom */]: {}\n    };\n    this.groupCallers = {\n      annotations: /* @__PURE__ */ new Set(),\n      annotationOptions: /* @__PURE__ */ new Set(),\n      ranges: /* @__PURE__ */ new Set(),\n      zoom: /* @__PURE__ */ new Set()\n    };\n    this.groupButtons = {\n      annotations: [],\n      annotationOptions: [],\n      ranges: [],\n      zoom: []\n    };\n    this.groupDestroyFns = {\n      annotations: [],\n      annotationOptions: [],\n      ranges: [],\n      zoom: []\n    };\n    this.pendingButtonToggledEvents = [];\n    this.groupProxied = /* @__PURE__ */ new Map();\n    this.hasNewLocale = true;\n    ctx.domManager.addStyles(block2, toolbarStyles_default);\n    this.elements = {};\n    for (const position of TOOLBAR_POSITIONS) {\n      this.elements[position] = ctx.domManager.addChild(\"canvas-overlay\", `toolbar-${position}`);\n      this.renderToolbar(position);\n    }\n    this.toggleVisibilities();\n    this.destroyFns.push(\n      ctx.interactionManager.addListener(\"hover\", this.onHover.bind(this), 31 /* All */),\n      ctx.interactionManager.addListener(\"leave\", this.onLeave.bind(this), 31 /* All */),\n      ctx.toolbarManager.addListener(\"button-toggled\", this.onButtonToggled.bind(this)),\n      ctx.toolbarManager.addListener(\"group-toggled\", this.onGroupToggled.bind(this)),\n      ctx.toolbarManager.addListener(\"floating-anchor-changed\", this.onFloatingAnchorChanged.bind(this)),\n      ctx.toolbarManager.addListener(\"proxy-group-options\", this.onProxyGroupOptions.bind(this)),\n      ctx.layoutService.addListener(\"layout-complete\", this.onLayoutComplete.bind(this)),\n      ctx.localeManager.addListener(\"locale-changed\", () => {\n        this.hasNewLocale = true;\n      }),\n      () => this.destroyElements()\n    );\n  }\n  destroyElements() {\n    this.ctx.domManager.removeStyles(block2);\n    for (const element2 of Object.keys(this.elements)) {\n      this.ctx.domManager.removeChild(\"canvas-overlay\", `toolbar-${element2}`);\n    }\n  }\n  onHover(event) {\n    const {\n      enabled,\n      elements: elements3,\n      floatingDetectionRange,\n      ctx: { scene }\n    } = this;\n    const {\n      offsetY,\n      sourceEvent: { target }\n    } = event;\n    const { FloatingBottom, FloatingTop } = ToolbarPosition;\n    if (!enabled)\n      return;\n    const bottom = elements3[FloatingBottom];\n    const top = elements3[FloatingTop];\n    const bottomDetectionY = bottom.offsetTop - floatingDetectionRange;\n    const bottomVisible = offsetY > bottomDetectionY && offsetY < scene.canvas.element.offsetHeight || target === bottom;\n    const topDetectionY = top.offsetTop + top.offsetHeight + floatingDetectionRange;\n    const topVisible = offsetY > 0 && offsetY < topDetectionY || target === top;\n    this.translateFloatingElements(FloatingBottom, bottomVisible);\n    this.translateFloatingElements(FloatingTop, topVisible);\n  }\n  onLeave(event) {\n    const {\n      enabled,\n      ctx: { scene }\n    } = this;\n    const { relatedElement, targetElement } = event;\n    const { FloatingBottom, FloatingTop } = ToolbarPosition;\n    if (!enabled || targetElement !== scene.canvas.element)\n      return;\n    const isTargetButton = TOOLBAR_GROUPS.some(\n      (group) => this.groupButtons[group].some((button) => button === relatedElement)\n    );\n    if (isTargetButton)\n      return;\n    this.translateFloatingElements(FloatingBottom, false);\n    this.translateFloatingElements(FloatingTop, false);\n  }\n  onGroupChanged(group) {\n    if (this[group] == null || this.groupProxied.has(group))\n      return;\n    this.createGroup(group);\n    this.toggleVisibilities();\n  }\n  onGroupButtonsChanged(group, buttons) {\n    if (!this.enabled || this.groupProxied.has(group))\n      return;\n    this.createGroupButtons(group, buttons);\n    this.toggleVisibilities();\n  }\n  onLayoutComplete() {\n    for (const position of TOOLBAR_POSITIONS) {\n      this.elements[position].classList.remove(modifiers2.preventFlash);\n    }\n  }\n  onButtonToggled(event) {\n    const { group, value, active, enabled, visible } = event;\n    if (this.groupButtons[group].length === 0) {\n      this.pendingButtonToggledEvents.push(event);\n      return;\n    }\n    for (const button of this.groupButtons[group]) {\n      if (button.dataset.toolbarValue !== `${value}`)\n        continue;\n      button.ariaDisabled = `${!enabled}`;\n      button.classList.toggle(modifiers2.button.hiddenToggled, !visible);\n      button.classList.toggle(modifiers2.button.active, active);\n    }\n  }\n  onGroupToggled(event) {\n    const { caller, group, visible } = event;\n    this.toggleGroup(caller, group, visible);\n    this.toggleVisibilities();\n  }\n  onFloatingAnchorChanged(event) {\n    const {\n      elements: elements3,\n      groupButtons,\n      positions,\n      horizontalSpacing,\n      verticalSpacing,\n      ctx: { domManager, toolbarManager }\n    } = this;\n    const { group, anchor } = event;\n    if (!positions[\"floating\" /* Floating */].has(group))\n      return;\n    const element2 = elements3[\"floating\" /* Floating */];\n    if (element2.classList.contains(modifiers2.hidden))\n      return;\n    let top = anchor.y - element2.offsetHeight - verticalSpacing;\n    let left = anchor.x - element2.offsetWidth / 2;\n    if (anchor.position === \"above\") {\n      top = anchor.y - element2.offsetHeight / 2;\n      left = anchor.x + horizontalSpacing;\n    }\n    const canvasRect = domManager.getBoundingClientRect();\n    top = clamp(0, top, canvasRect.height - element2.offsetHeight);\n    left = clamp(0, left, canvasRect.width - element2.offsetWidth);\n    element2.style.top = `${top}px`;\n    element2.style.left = `${left}px`;\n    for (const button of groupButtons[group]) {\n      if (button.classList.contains(modifiers2.button.hiddenToggled))\n        return;\n      const parent = button.offsetParent;\n      toolbarManager.buttonMoved(\n        group,\n        button.dataset.toolbarValue,\n        new BBox(\n          button.offsetLeft - button.offsetWidth + (parent?.offsetLeft ?? 0),\n          button.offsetTop + (parent?.offsetTop ?? 0),\n          button.offsetWidth,\n          button.offsetWidth\n        )\n      );\n    }\n  }\n  onProxyGroupOptions(event) {\n    if (!this.enabled)\n      return;\n    const { caller, group, options } = event;\n    this.groupProxied.set(group, options);\n    this[group].set(options);\n    this.toggleGroup(caller, group, options.enabled);\n    this.createGroup(group, options.enabled, options.position);\n    if (options.enabled) {\n      this.createGroupButtons(group, options.buttons);\n    }\n  }\n  createGroup(group, enabled, position) {\n    enabled ?? (enabled = this[group].enabled);\n    position ?? (position = this[group].position);\n    for (const pos of TOOLBAR_POSITIONS) {\n      if (enabled && position === pos) {\n        this.positions[pos].add(group);\n      } else {\n        this.positions[pos].delete(group);\n      }\n    }\n  }\n  createGroupButtons(group, buttons = []) {\n    for (const button of this.groupButtons[group]) {\n      button.remove();\n    }\n    this.groupButtons[group] = [];\n    this.groupDestroyFns[group].forEach((d) => d());\n    this.groupDestroyFns[group] = [];\n    if (buttons.length === 0)\n      return;\n    const { align, position } = this[group];\n    const alignElement = this.positionAlignments[position][align];\n    if (!alignElement)\n      return;\n    let index = 0;\n    const nextSection = () => {\n      let newSection = alignElement.children.item(index);\n      if (!newSection) {\n        newSection = createElement(\"div\");\n        alignElement.appendChild(newSection);\n        this.destroyFns.push(() => newSection.remove());\n      }\n      newSection.classList.add(elements2.section, modifiers2[this[group].size]);\n      index++;\n      return newSection;\n    };\n    let section = nextSection();\n    let prevSection = buttons.at(0)?.section;\n    for (const options of buttons) {\n      if (prevSection !== options.section) {\n        section = nextSection();\n      }\n      prevSection = options.section;\n      const button = this.createButtonElement(group, options);\n      section.appendChild(button);\n      this.groupButtons[group].push(button);\n    }\n    const onEscape = () => {\n      this.ctx.toolbarManager.cancel(group);\n    };\n    let onFocus;\n    let onBlur;\n    if (isAnimatingFloatingPosition(position)) {\n      onFocus = () => this.translateFloatingElements(position, true);\n      onBlur = () => this.translateFloatingElements(position, false);\n    }\n    const orientation = this.computeAriaOrientation(this[group].position);\n    this.groupDestroyFns[group] = initToolbarKeyNav({\n      orientation,\n      toolbar: alignElement,\n      buttons: this.groupButtons[group],\n      onEscape,\n      onFocus,\n      onBlur\n    });\n    this.updateToolbarAriaLabel(group, alignElement);\n  }\n  computeAriaOrientation(position) {\n    return {\n      top: \"horizontal\",\n      right: \"vertical\",\n      bottom: \"horizontal\",\n      left: \"vertical\",\n      floating: \"horizontal\",\n      \"floating-top\": \"horizontal\",\n      \"floating-bottom\": \"horizontal\"\n    }[position];\n  }\n  toggleGroup(caller, group, enabled) {\n    if (enabled) {\n      this.groupCallers[group].add(caller);\n    } else {\n      this.groupCallers[group].delete(caller);\n    }\n  }\n  processPendingEvents() {\n    const pendingButtonToggledEvents = (this.pendingButtonToggledEvents ?? []).slice();\n    for (const event of pendingButtonToggledEvents) {\n      this.onButtonToggled(event);\n    }\n    this.pendingButtonToggledEvents = [];\n  }\n  async performLayout(ctx) {\n    if (!this.enabled)\n      return ctx;\n    this.refreshOuterLayout(ctx.shrinkRect);\n    this.refreshLocale();\n    return ctx;\n  }\n  async performCartesianLayout(opts) {\n    if (!this.enabled)\n      return;\n    this.refreshInnerLayout(opts.seriesRect);\n  }\n  refreshOuterLayout(shrinkRect) {\n    const { elements: elements3, horizontalSpacing, verticalSpacing } = this;\n    if (!elements3.top.classList.contains(modifiers2.hidden)) {\n      shrinkRect.shrink(elements3.top.offsetHeight + verticalSpacing, \"top\");\n    }\n    if (!elements3.right.classList.contains(modifiers2.hidden)) {\n      shrinkRect.shrink(elements3.right.offsetWidth + horizontalSpacing, \"right\");\n    }\n    if (!elements3.bottom.classList.contains(modifiers2.hidden)) {\n      shrinkRect.shrink(elements3.bottom.offsetHeight + verticalSpacing, \"bottom\");\n      elements3.bottom.style.top = `${shrinkRect.y + shrinkRect.height + verticalSpacing}px`;\n    }\n    if (!elements3.left.classList.contains(modifiers2.hidden)) {\n      shrinkRect.shrink(elements3.left.offsetWidth + horizontalSpacing, \"left\");\n    }\n  }\n  refreshLocale() {\n    const { groupButtons, groupProxied, hasNewLocale } = this;\n    if (!hasNewLocale)\n      return;\n    for (const group of TOOLBAR_GROUPS) {\n      const groupProxyOptions = groupProxied.get(group);\n      groupButtons[group].forEach((element2) => this.refreshButtonLocale(element2, this[group], groupProxyOptions));\n      this.updateToolbarAriaLabel(group);\n    }\n    this.hasNewLocale = false;\n  }\n  refreshInnerLayout(rect) {\n    const { elements: elements3, verticalSpacing } = this;\n    const { FloatingBottom, FloatingTop } = ToolbarPosition;\n    elements3.top.style.top = `${rect.y - elements3.top.offsetHeight - verticalSpacing}px`;\n    elements3.top.style.left = `${rect.x}px`;\n    elements3.top.style.width = `${rect.width}px`;\n    elements3.bottom.style.left = `${rect.x}px`;\n    elements3.bottom.style.width = `${rect.width}px`;\n    elements3.right.style.top = `${rect.y}px`;\n    elements3.right.style.right = `0px`;\n    elements3.right.style.height = `${rect.height}px`;\n    elements3.left.style.top = `${rect.y}px`;\n    elements3.left.style.left = `0px`;\n    elements3.left.style.height = `${rect.height}px`;\n    elements3[FloatingTop].style.top = `${rect.y}px`;\n    elements3[FloatingBottom].style.top = `${rect.y + rect.height - elements3[FloatingBottom].offsetHeight}px`;\n  }\n  refreshButtonLocale(element2, group, groupProxyOptions) {\n    const {\n      dataset: { toolbarValue }\n    } = element2;\n    const button = groupProxyOptions?.buttons?.find(({ value }) => value === toolbarValue) ?? group.buttons?.find(({ value }) => value === toolbarValue);\n    if (!button)\n      return;\n    this.updateButtonText(element2, button);\n  }\n  toggleVisibilities() {\n    if (this.elements == null)\n      return;\n    const isGroupVisible = (group) => this[group].enabled && this.groupCallers[group].size > 0;\n    const isButtonVisible = (element2) => (button) => typeof button.value !== \"string\" && typeof button.value !== \"number\" || `${button.value}` === element2.dataset.toolbarValue;\n    for (const position of TOOLBAR_POSITIONS) {\n      const visible = this.enabled && Array.from(this.positions[position].values()).some(isGroupVisible);\n      this.elements[position].classList.toggle(modifiers2.hidden, !visible);\n    }\n    for (const group of TOOLBAR_GROUPS) {\n      if (this[group] == null)\n        continue;\n      const groupVisible = isGroupVisible(group);\n      for (const button of this.groupButtons[group]) {\n        const buttonVisible = groupVisible && this[group].buttons?.some(isButtonVisible(button));\n        button.classList.toggle(modifiers2.button.hiddenValue, !buttonVisible);\n      }\n    }\n  }\n  translateFloatingElements(position, visible) {\n    const { elements: elements3, verticalSpacing: verticalMargin, positionAlignments } = this;\n    const element2 = elements3[position];\n    const alignments = Object.values(positionAlignments[position]);\n    element2.classList.toggle(modifiers2.floatingHidden, !visible);\n    const dir = position === \"floating-bottom\" /* FloatingBottom */ ? 1 : -1;\n    for (const align of alignments) {\n      align.style.transform = visible && align.style.transform !== \"\" ? \"translateY(0)\" : `translateY(${(element2.offsetHeight + verticalMargin) * dir}px)`;\n    }\n  }\n  renderToolbar(position = \"top\" /* Top */) {\n    const element2 = this.elements[position];\n    element2.classList.add(block2, modifiers2[position], modifiers2.preventFlash);\n    if (isAnimatingFloatingPosition(position)) {\n      element2.classList.add(modifiers2.floatingHidden);\n    }\n    for (const align of TOOLBAR_ALIGNMENTS) {\n      const alignmentElement = createElement(\"div\");\n      alignmentElement.classList.add(elements2.align, modifiers2.align[align]);\n      element2.appendChild(alignmentElement);\n      this.positionAlignments[position][align] = alignmentElement;\n    }\n  }\n  createButtonElement(group, options) {\n    const button = createElement(\"button\");\n    button.classList.add(elements2.button);\n    button.dataset.toolbarGroup = group;\n    button.tabIndex = -1;\n    if (typeof options.value === \"string\" || typeof options.value === \"number\") {\n      button.dataset.toolbarValue = `${options.value}`;\n    }\n    button.onclick = makeAccessibleClickListener(button, this.onButtonPress.bind(this, group, options.value));\n    this.updateButtonText(button, options);\n    this.destroyFns.push(() => button.remove());\n    return button;\n  }\n  updateToolbarAriaLabel(group, alignElement) {\n    if (!alignElement) {\n      const { align, position } = this[group];\n      alignElement = this.positionAlignments[position][align];\n      if (!alignElement)\n        return;\n    }\n    const map = {\n      annotations: \"ariaLabelAnnotationsToolbar\",\n      annotationOptions: \"ariaLabelAnnotationOptionsToolbar\",\n      ranges: \"ariaLabelRangesToolbar\",\n      zoom: \"ariaLabelZoomToolbar\"\n    };\n    alignElement.ariaLabel = this.ctx.localeManager.t(map[group]);\n  }\n  updateButtonText(button, options) {\n    if (options.tooltip) {\n      const tooltip = this.ctx.localeManager.t(options.tooltip);\n      button.title = tooltip;\n    }\n    let inner = \"\";\n    if (options.icon != null) {\n      inner = `<span class=\"ag-charts-icon-${options.icon} ${elements2.icon}\"></span>`;\n    }\n    if (options.label != null) {\n      const label = this.ctx.localeManager.t(options.label);\n      inner = `${inner}<span class=\"${elements2.label}\">${label}</span>`;\n    }\n    button.innerHTML = inner;\n    const ariaLabel = options.ariaLabel ? this.ctx.localeManager.t(options.ariaLabel) : void 0;\n    setAttribute(button, \"aria-label\", ariaLabel);\n  }\n  onButtonPress(group, value) {\n    this.ctx.toolbarManager.pressButton(group, value);\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => {\n    target.processPendingEvents();\n    target.toggleVisibilities();\n  }),\n  Validate(BOOLEAN)\n], Toolbar.prototype, \"enabled\", 2);\n\n// packages/ag-charts-community/src/chart/toolbar/toolbarModule.ts\nvar DAY = 1e3 * 60 * 60 * 24;\nvar MONTH = DAY * 30;\nvar YEAR = DAY * 365;\nvar annotations = {\n  enabled: true,\n  position: \"left\",\n  align: \"start\",\n  buttons: [\n    {\n      icon: \"trend-line\",\n      tooltip: \"toolbarAnnotationsTrendLine\",\n      value: \"line\",\n      section: \"create\"\n    },\n    {\n      icon: \"parallel-channel\",\n      tooltip: \"toolbarAnnotationsParallelChannel\",\n      value: \"parallel-channel\",\n      section: \"create\"\n    },\n    {\n      icon: \"disjoint-channel\",\n      tooltip: \"toolbarAnnotationsDisjointChannel\",\n      value: \"disjoint-channel\",\n      section: \"create\"\n    },\n    {\n      icon: \"horizontal-line\",\n      tooltip: \"toolbarAnnotationsHorizontalLine\",\n      value: \"horizontal-line\",\n      section: \"create\"\n    },\n    {\n      icon: \"vertical-line\",\n      tooltip: \"toolbarAnnotationsVerticalLine\",\n      value: \"vertical-line\",\n      section: \"create\"\n    },\n    {\n      icon: \"delete\",\n      tooltip: \"toolbarAnnotationsClearAll\",\n      value: \"clear\",\n      section: \"tools\"\n    }\n  ]\n};\nvar annotationOptions = {\n  enabled: true,\n  position: \"floating\",\n  align: \"start\",\n  buttons: [\n    {\n      icon: \"line-color\",\n      tooltip: \"toolbarAnnotationsColor\",\n      value: \"line-color\"\n    },\n    {\n      icon: \"lock\",\n      tooltip: \"toolbarAnnotationsLock\",\n      value: \"lock\"\n    },\n    {\n      icon: \"unlock\",\n      tooltip: \"toolbarAnnotationsUnlock\",\n      value: \"unlock\"\n    },\n    {\n      icon: \"delete\",\n      tooltip: \"toolbarAnnotationsDelete\",\n      value: \"delete\"\n    }\n  ]\n};\nvar ranges = {\n  enabled: false,\n  position: DEFAULT_TOOLBAR_POSITION,\n  align: \"start\",\n  buttons: [\n    {\n      label: \"toolbarRange1Month\",\n      ariaLabel: \"toolbarRange1MonthAria\",\n      value: MONTH\n    },\n    {\n      label: \"toolbarRange3Months\",\n      ariaLabel: \"toolbarRange3MonthsAria\",\n      value: 3 * MONTH\n    },\n    {\n      label: \"toolbarRange6Months\",\n      ariaLabel: \"toolbarRange6MonthsAria\",\n      value: 6 * MONTH\n    },\n    {\n      label: \"toolbarRangeYearToDate\",\n      ariaLabel: \"toolbarRangeYearToDateAria\",\n      value: (_start, end) => [(/* @__PURE__ */ new Date(`${new Date(end).getFullYear()}-01-01`)).getTime(), end]\n    },\n    {\n      label: \"toolbarRange1Year\",\n      ariaLabel: \"toolbarRange1YearAria\",\n      value: YEAR\n    },\n    {\n      label: \"toolbarRangeAll\",\n      ariaLabel: \"toolbarRangeAllAria\",\n      value: (start, end) => [start, end]\n    }\n  ]\n};\nvar zoom = {\n  enabled: true,\n  position: \"top\",\n  align: \"end\",\n  buttons: [\n    {\n      icon: \"zoom-out-alt\",\n      tooltip: \"toolbarZoomZoomOut\",\n      value: \"zoom-out\"\n    },\n    {\n      icon: \"zoom-in-alt\",\n      tooltip: \"toolbarZoomZoomIn\",\n      value: \"zoom-in\"\n    },\n    {\n      icon: \"pan-left\",\n      tooltip: \"toolbarZoomPanLeft\",\n      value: \"pan-left\"\n    },\n    {\n      icon: \"pan-right\",\n      tooltip: \"toolbarZoomPanRight\",\n      value: \"pan-right\"\n    },\n    {\n      icon: \"pan-start\",\n      tooltip: \"toolbarZoomPanStart\",\n      value: \"pan-start\"\n    },\n    {\n      icon: \"pan-end\",\n      tooltip: \"toolbarZoomPanEnd\",\n      value: \"pan-end\"\n    },\n    {\n      icon: \"reset\",\n      tooltip: \"toolbarZoomReset\",\n      value: \"reset\"\n    }\n  ]\n};\nvar ToolbarModule = {\n  type: \"root\",\n  optionsKey: \"toolbar\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  instanceConstructor: Toolbar,\n  themeTemplate: {\n    toolbar: {\n      enabled: true,\n      annotations,\n      annotationOptions,\n      ranges,\n      zoom\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/factory/registerInbuiltModules.ts\nfunction registerInbuiltModules() {\n  moduleRegistry.register(\n    BackgroundModule,\n    CommunityLegendModule,\n    LocaleModule,\n    NavigatorModule,\n    ToolbarModule,\n    AreaSeriesModule,\n    BarSeriesModule,\n    BubbleSeriesModule,\n    LineSeriesModule,\n    ScatterSeriesModule,\n    DonutSeriesModule,\n    PieSeriesModule,\n    HistogramSeriesModule\n  );\n  for (const AxisConstructor of [NumberAxis, CategoryAxis, TimeAxis, GroupedCategoryAxis, LogAxis]) {\n    axisRegistry.register(AxisConstructor.type, {\n      instanceConstructor: AxisConstructor,\n      hidden: AxisConstructor === GroupedCategoryAxis\n    });\n  }\n}\n\n// packages/ag-charts-community/src/chart/factory/setupModules.ts\nfunction setupModules() {\n  for (const m of moduleRegistry.modules) {\n    if (m.packageType === \"enterprise\" && !verifyIfModuleExpected(m)) {\n      Logger.errorOnce(\"Unexpected enterprise module registered: \" + m.identifier);\n    }\n    if (m.type === \"root\" && m.themeTemplate) {\n      for (const chartType2 of m.chartTypes) {\n        chartDefaults.set(chartType2, m.themeTemplate);\n      }\n    }\n    if (m.type === \"series\") {\n      if (m.chartTypes.length > 1) {\n        throw new Error(`AG Charts - Module definition error: ${m.identifier}`);\n      }\n      seriesRegistry.register(m.identifier, m);\n    }\n    if (m.type === \"series-option\" && m.themeTemplate) {\n      for (const seriesType of m.seriesTypes) {\n        seriesRegistry.setThemeTemplate(seriesType, m.themeTemplate);\n      }\n    }\n    if (m.type === \"axis-option\" && m.themeTemplate) {\n      for (const axisType of m.axisTypes) {\n        const axisTypeTheme = m.themeTemplate[axisType];\n        const theme = { ...m.themeTemplate, ...axisTypeTheme };\n        for (const innerAxisType of m.axisTypes) {\n          delete theme[innerAxisType];\n        }\n        axisRegistry.setThemeTemplate(axisType, theme);\n      }\n    }\n    if (m.type === \"axis\") {\n      axisRegistry.register(m.identifier, m);\n    }\n    if (m.type === \"legend\") {\n      legendRegistry.register(m.identifier, m);\n    }\n  }\n  if (moduleRegistry.hasEnterpriseModules()) {\n    const expectedButUnused = getUnusedExpectedModules();\n    if (expectedButUnused.length > 0) {\n      Logger.errorOnce(\"Enterprise modules expected but not registered: \", expectedButUnused);\n    }\n  }\n}\n\n// packages/ag-charts-community/src/chart/flowProportionChart.ts\nfunction isFlowProportion(series) {\n  return series.type === \"sankey\" || series.type === \"chord\";\n}\nvar FlowProportionChart = class extends Chart {\n  async updateData() {\n    await super.updateData();\n    const { nodes } = this.getOptions();\n    this.series.forEach((series) => {\n      if (isFlowProportion(series)) {\n        series.setChartNodes(nodes);\n      }\n    });\n  }\n  async performLayout() {\n    const shrinkRect = await super.performLayout();\n    const {\n      seriesArea: { padding },\n      seriesRoot,\n      annotationRoot,\n      highlightRoot\n    } = this;\n    const fullSeriesRect = shrinkRect.clone();\n    shrinkRect.shrink(padding.left, \"left\");\n    shrinkRect.shrink(padding.top, \"top\");\n    shrinkRect.shrink(padding.right, \"right\");\n    shrinkRect.shrink(padding.bottom, \"bottom\");\n    this.seriesRect = shrinkRect;\n    this.animationRect = shrinkRect;\n    this.hoverRect = shrinkRect;\n    const seriesVisible = this.series.some((s) => s.visible);\n    seriesRoot.visible = seriesVisible;\n    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n      group.translationX = Math.floor(shrinkRect.x);\n      group.translationY = Math.floor(shrinkRect.y);\n      group.setClipRectInGroupCoordinateSpace(\n        new BBox(fullSeriesRect.x, fullSeriesRect.y, fullSeriesRect.width, fullSeriesRect.height)\n      );\n    }\n    this.ctx.layoutService.dispatchLayoutComplete({\n      type: \"layout-complete\",\n      chart: { width: this.ctx.scene.width, height: this.ctx.scene.height },\n      clipSeries: false,\n      series: { rect: fullSeriesRect, paddedRect: shrinkRect, visible: seriesVisible },\n      axes: []\n    });\n    return shrinkRect;\n  }\n};\nFlowProportionChart.className = \"FlowProportionChart\";\nFlowProportionChart.type = \"flow-proportion\";\n\n// packages/ag-charts-community/src/chart/hierarchyChart.ts\nvar HierarchyChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n  }\n  async performLayout() {\n    const shrinkRect = await super.performLayout();\n    const {\n      seriesArea: { padding },\n      seriesRoot,\n      annotationRoot,\n      highlightRoot\n    } = this;\n    const fullSeriesRect = shrinkRect.clone();\n    shrinkRect.shrink(padding.left, \"left\");\n    shrinkRect.shrink(padding.top, \"top\");\n    shrinkRect.shrink(padding.right, \"right\");\n    shrinkRect.shrink(padding.bottom, \"bottom\");\n    this.seriesRect = shrinkRect;\n    this.animationRect = shrinkRect;\n    this.hoverRect = shrinkRect;\n    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n      group.translationX = Math.floor(shrinkRect.x);\n      group.translationY = Math.floor(shrinkRect.y);\n    }\n    await Promise.all(\n      this.series.map(async (series) => {\n        await series.update({ seriesRect: shrinkRect });\n      })\n    );\n    seriesRoot.visible = this.series[0].visible;\n    seriesRoot.setClipRectInGroupCoordinateSpace(\n      new BBox(shrinkRect.x, shrinkRect.y, shrinkRect.width, shrinkRect.height)\n    );\n    this.ctx.layoutService.dispatchLayoutComplete({\n      type: \"layout-complete\",\n      chart: { width: this.ctx.scene.width, height: this.ctx.scene.height },\n      clipSeries: false,\n      series: { rect: fullSeriesRect, paddedRect: shrinkRect, visible: true },\n      axes: []\n    });\n    return shrinkRect;\n  }\n  getAriaLabel() {\n    const captionText = this.getCaptionText();\n    return `hierarchical chart, ${captionText}`;\n  }\n  handleSeriesFocus(otherIndexDelta, datumIndexDelta) {\n    this.focus.series = this.series[0];\n    const {\n      focus: { series, seriesIndex: otherIndex, datumIndex },\n      seriesRect\n    } = this;\n    if (series === void 0)\n      return;\n    const pick = series.pickFocus({ datumIndex, datumIndexDelta, otherIndex, otherIndexDelta, seriesRect });\n    this.updatePickedFocus(pick);\n  }\n};\nHierarchyChart.className = \"HierarchyChart\";\nHierarchyChart.type = \"hierarchy\";\n\n// packages/ag-charts-community/src/chart/axis/polarAxis.ts\nvar PolarAxis = class extends Axis {\n  constructor() {\n    super(...arguments);\n    this.shape = \"polygon\";\n    this.innerRadiusRatio = 0;\n    this.defaultTickMinSpacing = 20;\n  }\n  computeLabelsBBox(_options, _seriesRect) {\n    return null;\n  }\n};\n__decorateClass([\n  Validate(UNION([\"polygon\", \"circle\"], \"a polar axis shape\"))\n], PolarAxis.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PolarAxis.prototype, \"innerRadiusRatio\", 2);\n\n// packages/ag-charts-community/src/chart/polarChart.ts\nvar PolarChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n    this.padding = new Padding(40);\n    this.ctx.axisManager.axisGroup.zIndex = 6 /* AXIS_FOREGROUND_ZINDEX */;\n  }\n  async performLayout() {\n    const shrinkRect = await super.performLayout();\n    const fullSeriesRect = shrinkRect.clone();\n    this.computeSeriesRect(shrinkRect);\n    await this.computeCircle(shrinkRect);\n    this.axes.forEach((axis) => axis.update());\n    this.hoverRect = shrinkRect;\n    this.ctx.layoutService.dispatchLayoutComplete({\n      type: \"layout-complete\",\n      chart: { width: this.ctx.scene.width, height: this.ctx.scene.height },\n      clipSeries: false,\n      series: { rect: fullSeriesRect, paddedRect: shrinkRect, visible: true },\n      axes: []\n    });\n    return shrinkRect;\n  }\n  updateAxes(cx, cy, radius) {\n    const angleAxis = this.axes.find((axis) => axis.direction === \"x\" /* X */);\n    const radiusAxis = this.axes.find((axis) => axis.direction === \"y\" /* Y */);\n    if (!(angleAxis instanceof PolarAxis) || !(radiusAxis instanceof PolarAxis)) {\n      return;\n    }\n    const angleScale = angleAxis.scale;\n    const angles = angleScale.ticks?.().map((value) => angleScale.convert(value));\n    const innerRadiusRatio = radiusAxis.innerRadiusRatio;\n    angleAxis.innerRadiusRatio = innerRadiusRatio;\n    angleAxis.computeRange?.();\n    angleAxis.gridLength = radius;\n    radiusAxis.gridAngles = angles;\n    radiusAxis.gridRange = angleAxis.range;\n    radiusAxis.range = [radius, radius * innerRadiusRatio];\n    [angleAxis, radiusAxis].forEach((axis) => {\n      axis.translation.x = cx;\n      axis.translation.y = cy;\n      axis.calculateLayout();\n    });\n  }\n  computeSeriesRect(shrinkRect) {\n    const {\n      seriesArea: { padding }\n    } = this;\n    shrinkRect.shrink(padding.left, \"left\");\n    shrinkRect.shrink(padding.top, \"top\");\n    shrinkRect.shrink(padding.right, \"right\");\n    shrinkRect.shrink(padding.bottom, \"bottom\");\n    this.seriesRect = shrinkRect;\n    this.animationRect = shrinkRect;\n  }\n  async computeCircle(seriesBox) {\n    const polarSeries = this.series.filter((series) => {\n      return series instanceof PolarSeries;\n    });\n    const polarAxes = this.axes.filter((axis) => {\n      return axis instanceof PolarAxis;\n    });\n    const setSeriesCircle = (cx, cy, r) => {\n      this.updateAxes(cx, cy, r);\n      polarSeries.forEach((series) => {\n        series.centerX = cx;\n        series.centerY = cy;\n        series.radius = r;\n      });\n      const pieSeries = polarSeries.filter((s) => s.type === \"donut\" || s.type === \"pie\");\n      if (pieSeries.length > 1) {\n        const innerRadii = pieSeries.map((series) => {\n          const innerRadius = series.getInnerRadius();\n          return { series, innerRadius };\n        }).sort((a, b) => a.innerRadius - b.innerRadius);\n        innerRadii.at(-1).series.surroundingRadius = void 0;\n        for (let i = 0; i < innerRadii.length - 1; i++) {\n          innerRadii[i].series.surroundingRadius = innerRadii[i + 1].innerRadius;\n        }\n      }\n    };\n    const centerX = seriesBox.x + seriesBox.width / 2;\n    const centerY = seriesBox.y + seriesBox.height / 2;\n    const initialRadius = Math.max(0, Math.min(seriesBox.width, seriesBox.height) / 2);\n    let radius = initialRadius;\n    setSeriesCircle(centerX, centerY, radius);\n    const shake = async ({ hideWhenNecessary = false } = {}) => {\n      const labelBoxes = [];\n      for (const series of [...polarAxes, ...polarSeries]) {\n        const box = await series.computeLabelsBBox({ hideWhenNecessary }, seriesBox);\n        if (box) {\n          labelBoxes.push(box);\n        }\n      }\n      if (labelBoxes.length === 0) {\n        setSeriesCircle(centerX, centerY, initialRadius);\n        return;\n      }\n      const labelBox = BBox.merge(labelBoxes);\n      const refined = this.refineCircle(labelBox, radius, seriesBox);\n      setSeriesCircle(refined.centerX, refined.centerY, refined.radius);\n      if (refined.radius === radius) {\n        return;\n      }\n      radius = refined.radius;\n    };\n    await shake();\n    await shake();\n    await shake();\n    await shake({ hideWhenNecessary: true });\n    await shake({ hideWhenNecessary: true });\n    return { radius, centerX, centerY };\n  }\n  refineCircle(labelsBox, radius, seriesBox) {\n    const minCircleRatio = 0.5;\n    const circleLeft = -radius;\n    const circleTop = -radius;\n    const circleRight = radius;\n    const circleBottom = radius;\n    let padLeft = Math.max(0, circleLeft - labelsBox.x);\n    let padTop = Math.max(0, circleTop - labelsBox.y);\n    let padRight = Math.max(0, labelsBox.x + labelsBox.width - circleRight);\n    let padBottom = Math.max(0, labelsBox.y + labelsBox.height - circleBottom);\n    padLeft = padRight = Math.max(padLeft, padRight);\n    padTop = padBottom = Math.max(padTop, padBottom);\n    const availCircleWidth = seriesBox.width - padLeft - padRight;\n    const availCircleHeight = seriesBox.height - padTop - padBottom;\n    let newRadius = Math.min(availCircleWidth, availCircleHeight) / 2;\n    const minHorizontalRadius = minCircleRatio * seriesBox.width / 2;\n    const minVerticalRadius = minCircleRatio * seriesBox.height / 2;\n    const minRadius = Math.min(minHorizontalRadius, minVerticalRadius);\n    if (newRadius < minRadius) {\n      newRadius = minRadius;\n      const horizontalPadding = padLeft + padRight;\n      const verticalPadding = padTop + padBottom;\n      if (2 * newRadius + verticalPadding > seriesBox.height) {\n        const padHeight = seriesBox.height - 2 * newRadius;\n        if (Math.min(padTop, padBottom) * 2 > padHeight) {\n          padTop = padHeight / 2;\n          padBottom = padHeight / 2;\n        } else if (padTop > padBottom) {\n          padTop = padHeight - padBottom;\n        } else {\n          padBottom = padHeight - padTop;\n        }\n      }\n      if (2 * newRadius + horizontalPadding > seriesBox.width) {\n        const padWidth = seriesBox.width - 2 * newRadius;\n        if (Math.min(padLeft, padRight) * 2 > padWidth) {\n          padLeft = padWidth / 2;\n          padRight = padWidth / 2;\n        } else if (padLeft > padRight) {\n          padLeft = padWidth - padRight;\n        } else {\n          padRight = padWidth - padLeft;\n        }\n      }\n    }\n    const newWidth = padLeft + 2 * newRadius + padRight;\n    const newHeight = padTop + 2 * newRadius + padBottom;\n    return {\n      centerX: seriesBox.x + (seriesBox.width - newWidth) / 2 + padLeft + newRadius,\n      centerY: seriesBox.y + (seriesBox.height - newHeight) / 2 + padTop + newRadius,\n      radius: newRadius\n    };\n  }\n};\nPolarChart.className = \"PolarChart\";\nPolarChart.type = \"polar\";\n\n// packages/ag-charts-community/src/chart/series/topology/mercatorScale.ts\nvar radsInDeg = Math.PI / 180;\nvar lonX = (lon) => lon * radsInDeg;\nvar latY = (lat) => -Math.log(Math.tan(Math.PI * 0.25 + lat * radsInDeg * 0.5));\nvar xLon = (x) => x / radsInDeg;\nvar yLat = (y) => (Math.atan(Math.exp(-y)) - Math.PI * 0.25) / (radsInDeg * 0.5);\nvar MercatorScale = class _MercatorScale {\n  constructor(domain, range3) {\n    this.domain = domain;\n    this.range = range3;\n    this.type = \"mercator\";\n    this.bounds = _MercatorScale.bounds(domain);\n  }\n  static bounds(domain) {\n    const [[lon0, lat0], [lon1, lat1]] = domain;\n    const x0 = lonX(lon0);\n    const y0 = latY(lat0);\n    const x1 = lonX(lon1);\n    const y1 = latY(lat1);\n    return new BBox(Math.min(x0, x1), Math.min(y0, y1), Math.abs(x1 - x0), Math.abs(y1 - y0));\n  }\n  static fixedScale() {\n    return new _MercatorScale(\n      [\n        [xLon(0), yLat(0)],\n        [xLon(1), yLat(1)]\n      ],\n      [\n        [0, 0],\n        [1, 1]\n      ]\n    );\n  }\n  convert([lon, lat]) {\n    const [[x0, y0], [x1, y1]] = this.range;\n    const xScale = (x1 - x0) / this.bounds.width;\n    const yScale = (y1 - y0) / this.bounds.height;\n    return [(lonX(lon) - this.bounds.x) * xScale + x0, (latY(lat) - this.bounds.y) * yScale + y0];\n  }\n  invert([x, y]) {\n    const [[x0, y0], [x1, y1]] = this.range;\n    const xScale = (x1 - x0) / this.bounds.width;\n    const yScale = (y1 - y0) / this.bounds.height;\n    return [xLon((x - x0) / xScale + this.bounds.x), yLat((y - y0) / yScale + this.bounds.y)];\n  }\n};\n\n// packages/ag-charts-community/src/chart/topologyChart.ts\nfunction isTopologySeries(series) {\n  return series.type === \"map-shape\" || series.type === \"map-line\" || series.type === \"map-marker\" || series.type === \"map-shape-background\" || series.type === \"map-line-background\";\n}\nvar TopologyChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n    this.xAxis = new NumberAxis(this.getModuleContext());\n    this.xAxis.position = \"bottom\";\n    this.yAxis = new NumberAxis(this.getModuleContext());\n    this.yAxis.position = \"left\";\n    this.ctx.zoomManager.updateAxes([this.xAxis, this.yAxis]);\n  }\n  async updateData() {\n    await super.updateData();\n    const { topology } = this.getOptions();\n    this.series.forEach((series) => {\n      if (isTopologySeries(series)) {\n        series.setChartTopology(topology);\n      }\n    });\n  }\n  async performLayout() {\n    const shrinkRect = await super.performLayout();\n    const {\n      seriesArea: { padding },\n      seriesRoot,\n      annotationRoot,\n      highlightRoot\n    } = this;\n    const fullSeriesRect = shrinkRect.clone();\n    shrinkRect.shrink(padding.left, \"left\");\n    shrinkRect.shrink(padding.top, \"top\");\n    shrinkRect.shrink(padding.right, \"right\");\n    shrinkRect.shrink(padding.bottom, \"bottom\");\n    this.seriesRect = shrinkRect;\n    this.animationRect = shrinkRect;\n    this.hoverRect = shrinkRect;\n    const mapSeries = this.series.filter(isTopologySeries);\n    const combinedBbox = mapSeries.reduce((combined, series) => {\n      if (!series.visible)\n        return combined;\n      const bbox = series.topologyBounds;\n      if (bbox == null)\n        return combined;\n      if (combined == null)\n        return bbox;\n      combined.merge(bbox);\n      return combined;\n    }, void 0);\n    let scale2;\n    if (combinedBbox != null) {\n      const { lon0, lat0, lon1, lat1 } = combinedBbox;\n      const domain = [\n        [lon0, lat0],\n        [lon1, lat1]\n      ];\n      const bounds = MercatorScale.bounds(domain);\n      const { width, height } = shrinkRect;\n      const viewBoxScale = Math.min(width / bounds.width, height / bounds.height);\n      const viewBoxWidth = bounds.width * viewBoxScale;\n      const viewBoxHeight = bounds.height * viewBoxScale;\n      const viewBoxOriginX = (width - viewBoxWidth) / 2;\n      const viewBoxOriginY = (height - viewBoxHeight) / 2;\n      const x0 = viewBoxOriginX;\n      const y0 = viewBoxOriginY;\n      const x1 = viewBoxOriginX + viewBoxWidth;\n      const y1 = viewBoxOriginY + viewBoxHeight;\n      const xZoom = this.ctx.zoomManager.getAxisZoom(this.xAxis.id);\n      const yZoom = this.ctx.zoomManager.getAxisZoom(this.yAxis.id);\n      const xSpan = (x1 - x0) / (xZoom.max - xZoom.min);\n      const xStart = x0 - xSpan * xZoom.min;\n      const ySpan = (y1 - y0) / (1 - yZoom.min - (1 - yZoom.max));\n      const yStart = y0 - ySpan * (1 - yZoom.max);\n      scale2 = new MercatorScale(domain, [\n        [xStart, yStart],\n        [xStart + xSpan, yStart + ySpan]\n      ]);\n    }\n    mapSeries.forEach((series) => {\n      series.scale = scale2;\n    });\n    const seriesVisible = this.series.some((s) => s.visible);\n    seriesRoot.visible = seriesVisible;\n    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n      group.translationX = Math.floor(shrinkRect.x);\n      group.translationY = Math.floor(shrinkRect.y);\n      group.setClipRectInGroupCoordinateSpace(\n        new BBox(shrinkRect.x, shrinkRect.y, shrinkRect.width, shrinkRect.height)\n      );\n    }\n    this.ctx.layoutService.dispatchLayoutComplete({\n      type: \"layout-complete\",\n      chart: { width: this.ctx.scene.width, height: this.ctx.scene.height },\n      clipSeries: false,\n      series: { rect: fullSeriesRect, paddedRect: shrinkRect, visible: seriesVisible },\n      axes: []\n    });\n    return shrinkRect;\n  }\n};\nTopologyChart.className = \"TopologyChart\";\nTopologyChart.type = \"topology\";\n\n// packages/ag-charts-community/src/api/preset/priceVolumePreset.ts\nfunction fromTheme(theme, cb) {\n  if (isObject(theme)) {\n    return cb(theme);\n  }\n}\nfunction priceVolume(opts, getTheme) {\n  const {\n    xKey = \"date\",\n    highKey = \"high\",\n    openKey = \"open\",\n    lowKey = \"low\",\n    closeKey = \"close\",\n    volumeKey = \"volume\",\n    chartType: chartType2 = \"candlestick\",\n    navigator: navigator2 = false,\n    volume = true,\n    rangeToolbar = true,\n    statusBar = true,\n    annotations: annotations2 = true,\n    zoom: zoom2 = true,\n    theme,\n    data,\n    ...unusedOpts\n  } = opts;\n  const priceSeries = createPriceSeries(theme, chartType2, xKey, highKey, lowKey, openKey, closeKey);\n  const volumeSeries = createVolumeSeries(theme, getTheme, openKey, closeKey, volume, volumeKey);\n  const miniChart = volume ? {\n    miniChart: {\n      enabled: navigator2,\n      series: [\n        {\n          type: \"line\",\n          xKey: \"date\",\n          yKey: volumeKey,\n          marker: { enabled: false }\n        }\n      ]\n    }\n  } : null;\n  const navigatorOpts = {\n    navigator: {\n      enabled: navigator2,\n      ...miniChart\n    }\n  };\n  const statusBarOpts = statusBar ? {\n    statusBar: {\n      enabled: true,\n      data,\n      highKey,\n      openKey,\n      lowKey,\n      closeKey,\n      volumeKey: volume ? volumeKey : void 0\n    }\n  } : null;\n  const zoomOpts = {\n    zoom: {\n      enabled: zoom2,\n      // @ts-expect-error\n      enableIndependentAxes: true\n    }\n  };\n  const toolbarOpts = annotations2 || rangeToolbar ? {\n    toolbar: {\n      annotationOptions: {\n        enabled: annotations2\n      },\n      annotations: {\n        enabled: annotations2\n      },\n      ranges: {\n        enabled: rangeToolbar\n      }\n    }\n  } : null;\n  const volumeAxis = volume ? [\n    {\n      type: \"number\",\n      position: \"left\",\n      keys: [volumeKey],\n      label: { enabled: false },\n      crosshair: { enabled: false },\n      gridLine: { enabled: false },\n      nice: false,\n      // @ts-expect-error\n      layoutConstraints: {\n        stacked: false,\n        width: 20,\n        unit: \"percentage\",\n        align: \"end\"\n      },\n      disableZoom: true\n    }\n  ] : [];\n  return {\n    theme: typeof theme === \"string\" ? theme : {\n      baseTheme: \"ag-financial\",\n      ...theme ?? {}\n    },\n    animation: { enabled: false },\n    legend: { enabled: false },\n    series: [...volumeSeries, ...priceSeries],\n    padding: {\n      top: 6,\n      right: 8\n    },\n    axes: [\n      {\n        type: \"number\",\n        position: \"right\",\n        keys: [openKey, closeKey, highKey, lowKey],\n        interval: {\n          maxSpacing: fromTheme(theme, (t) => t.overrides?.common?.axes?.number?.interval?.maxSpacing) ?? 45\n        },\n        label: {\n          format: fromTheme(theme, (t) => t.overrides?.common?.axes?.number?.label?.format) ?? \".2f\"\n        },\n        crosshair: {\n          enabled: true,\n          snap: false\n        },\n        // @ts-expect-error\n        layoutConstraints: {\n          stacked: false,\n          width: 100,\n          unit: \"percentage\",\n          align: \"start\"\n        }\n      },\n      ...volumeAxis,\n      {\n        type: \"ordinal-time\",\n        position: \"bottom\",\n        line: {\n          enabled: false\n        },\n        label: {\n          enabled: true\n        },\n        crosshair: {\n          enabled: true\n        }\n      }\n    ],\n    annotations: {\n      enabled: annotations2\n    },\n    tooltip: { enabled: false },\n    data,\n    // @ts-expect-error\n    titlePadding: 4,\n    ...navigatorOpts,\n    ...statusBarOpts,\n    ...zoomOpts,\n    ...toolbarOpts,\n    ...unusedOpts\n  };\n}\nfunction createVolumeSeries(theme, getTheme, openKey, closeKey, volume, volumeKey) {\n  if (!volume)\n    return [];\n  const barSeriesFill = fromTheme(theme, (t) => t.overrides?.bar?.series?.fill);\n  const itemStyler = barSeriesFill ? { fill: barSeriesFill } : {\n    itemStyler({ datum }) {\n      const { up, down } = getTheme().palette;\n      return { fill: datum[openKey] < datum[closeKey] ? up?.fill : down?.fill };\n    }\n  };\n  return [\n    {\n      type: \"bar\",\n      xKey: \"date\",\n      yKey: volumeKey,\n      tooltip: { enabled: false },\n      fillOpacity: fromTheme(theme, (t) => t.overrides?.bar?.series?.fillOpacity) ?? 0.5,\n      ...itemStyler\n    }\n  ];\n}\nvar RANGE_AREA_TYPE = \"range-area\";\nfunction createPriceSeries(theme, chartType2, xKey, highKey, lowKey, openKey, closeKey) {\n  const keys = {\n    xKey,\n    openKey,\n    closeKey,\n    highKey,\n    lowKey\n  };\n  const singleKeys = {\n    xKey,\n    yKey: closeKey\n  };\n  switch (chartType2) {\n    case \"ohlc\":\n      return [\n        {\n          type: \"ohlc\",\n          ...keys\n        }\n      ];\n    case \"line\":\n      return [\n        {\n          type: \"line\",\n          ...singleKeys,\n          stroke: fromTheme(theme, (t) => t.overrides?.line?.series?.stroke) ?? PALETTE_NEUTRAL_STROKE,\n          marker: fromTheme(theme, (t) => t.overrides?.line?.series?.marker) ?? { enabled: false }\n        }\n      ];\n    case \"step-line\":\n      return [\n        {\n          type: \"line\",\n          ...singleKeys,\n          stroke: fromTheme(theme, (t) => t.overrides?.line?.series?.stroke) ?? PALETTE_NEUTRAL_STROKE,\n          interpolation: fromTheme(theme, (t) => t.overrides?.line?.series?.interpolation) ?? {\n            type: \"step\"\n          },\n          marker: fromTheme(theme, (t) => t.overrides?.line?.series?.marker) ?? { enabled: false }\n        }\n      ];\n    case RANGE_AREA_TYPE:\n      const fill = fromTheme(theme, (t) => t.overrides?.[\"range-area\"]?.series?.fill);\n      const stoke = fromTheme(theme, (t) => t.overrides?.[\"range-area\"]?.series?.stroke);\n      return [\n        {\n          type: RANGE_AREA_TYPE,\n          xKey,\n          yHighKey: highKey,\n          yLowKey: closeKey,\n          fill: fill ?? PALETTE_UP_STROKE,\n          stroke: stoke ?? PALETTE_UP_STROKE\n        },\n        {\n          type: RANGE_AREA_TYPE,\n          xKey,\n          yHighKey: closeKey,\n          yLowKey: lowKey,\n          fill: fill ?? PALETTE_DOWN_STROKE,\n          stroke: stoke ?? PALETTE_DOWN_STROKE\n        }\n      ];\n    default:\n    case \"candlestick\":\n      return [\n        {\n          type: \"candlestick\",\n          ...keys\n        }\n      ];\n    case \"hollow-candlestick\":\n      const item = fromTheme(theme, (t) => t.overrides?.candlestick?.series?.item);\n      return [\n        {\n          type: \"candlestick\",\n          ...keys,\n          item: {\n            up: {\n              fill: item?.up?.fill ?? \"transparent\"\n            }\n          }\n        }\n      ];\n  }\n}\n\n// packages/ag-charts-community/src/api/preset/presets.ts\nvar PRESETS = {\n  \"price-volume\": priceVolume\n};\n\n// packages/ag-charts-community/src/chart/factory/processEnterpriseOptions.ts\nfunction removeUsedEnterpriseOptions(options) {\n  const usedOptions = [];\n  const optionsChartType = chartTypes.get(optionsType(options));\n  for (const {\n    type,\n    chartTypes: moduleChartTypes,\n    optionsKey,\n    optionsInnerKey,\n    identifier\n  } of EXPECTED_ENTERPRISE_MODULES) {\n    if (optionsChartType !== \"unknown\" && !moduleChartTypes.includes(optionsChartType))\n      continue;\n    if (type === \"root\" || type === \"legend\") {\n      const optionValue = options[optionsKey];\n      if (optionValue == null)\n        continue;\n      if (!optionsInnerKey) {\n        usedOptions.push(optionsKey);\n        delete options[optionsKey];\n      } else if (optionValue[optionsInnerKey]) {\n        usedOptions.push(`${optionsKey}.${optionsInnerKey}`);\n        delete optionValue[optionsInnerKey];\n      }\n    } else if (type === \"axis\") {\n      if (!(\"axes\" in options) || !options.axes?.some((axis) => axis.type === identifier))\n        continue;\n      usedOptions.push(`axis[type=${identifier}]`);\n      options.axes = options.axes.filter((axis) => axis.type !== identifier);\n    } else if (type === \"axis-option\") {\n      if (!(\"axes\" in options) || !options.axes?.some((axis) => axis[optionsKey]))\n        continue;\n      usedOptions.push(`axis.${optionsKey}`);\n      options.axes.forEach((axis) => {\n        if (axis[optionsKey]) {\n          delete axis[optionsKey];\n        }\n      });\n    } else if (type === \"series\") {\n      if (!options.series?.some((series) => series.type === identifier))\n        continue;\n      usedOptions.push(`series[type=${identifier}]`);\n      options.series = options.series.filter((series) => series.type !== identifier);\n    } else if (type === \"series-option\") {\n      if (!options.series?.some((series) => series[optionsKey]))\n        continue;\n      usedOptions.push(`series.${optionsKey}`);\n      options.series.forEach((series) => {\n        if (series[optionsKey]) {\n          delete series[optionsKey];\n        }\n      });\n    }\n  }\n  if (usedOptions.length) {\n    let enterprisePackageName = \"ag-charts-enterprise\";\n    let enterpriseReferenceUrl = \"https://charts.ag-grid.com/javascript/installation/\";\n    if (options.mode === \"integrated\") {\n      enterprisePackageName = \"ag-grid-charts-enterprise' or 'ag-grid-enterprise/charts-enterprise\";\n      enterpriseReferenceUrl = \"https://www.ag-grid.com/javascript-data-grid/integrated-charts-installation/\";\n    }\n    Logger.warnOnce(\n      [\n        `unable to use these enterprise features as '${enterprisePackageName}' has not been loaded:`,\n        \"\",\n        ...usedOptions,\n        \"\",\n        `See: ${enterpriseReferenceUrl}`\n      ].join(\"\\n\")\n    );\n  }\n}\n\n// packages/ag-charts-community/src/module/coreModulesTypes.ts\nfunction paletteType(partial) {\n  if (partial?.up || partial?.down || partial?.neutral) {\n    return \"user-full\";\n  } else if (partial?.fills || partial?.strokes) {\n    return \"user-indexed\";\n  }\n  return \"inbuilt\";\n}\n\n// packages/ag-charts-community/src/chart/themes/chartTheme.ts\nvar DEFAULT_BACKGROUND_FILL = \"white\";\nvar DEFAULT_PALETTE = {\n  fills: Object.values(DEFAULT_FILLS),\n  strokes: Object.values(DEFAULT_STROKES)\n};\nvar CHART_TYPE_CONFIG = {\n  get cartesian() {\n    return { seriesTypes: chartTypes.cartesianTypes, commonOptions: [\"zoom\", \"navigator\"] };\n  },\n  get polar() {\n    return { seriesTypes: chartTypes.polarTypes, commonOptions: [] };\n  },\n  get hierarchy() {\n    return { seriesTypes: chartTypes.hierarchyTypes, commonOptions: [] };\n  },\n  get topology() {\n    return { seriesTypes: chartTypes.topologyTypes, commonOptions: [] };\n  },\n  get \"flow-proportion\"() {\n    return { seriesTypes: chartTypes.flowProportionTypes, commonOptions: [] };\n  }\n};\nvar CHART_TYPE_SPECIFIC_COMMON_OPTIONS = Object.values(CHART_TYPE_CONFIG).reduce((r, { commonOptions }) => r.concat(commonOptions), []);\nvar _ChartTheme = class _ChartTheme {\n  getPalette() {\n    return DEFAULT_PALETTE;\n  }\n  static getAxisDefaults(overrideDefaults) {\n    return mergeDefaults(overrideDefaults, {\n      title: {\n        enabled: false,\n        text: \"Axis Title\",\n        spacing: 25,\n        fontWeight: \"normal\" /* NORMAL */,\n        fontSize: 13 /* MEDIUM */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      },\n      label: {\n        fontSize: 12 /* SMALL */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        padding: 5,\n        color: DEFAULT_LABEL_COLOUR,\n        avoidCollisions: true\n      },\n      line: {\n        enabled: true,\n        width: 1,\n        stroke: DEFAULT_AXIS_LINE_COLOUR\n      },\n      tick: {\n        enabled: false,\n        width: 1,\n        stroke: DEFAULT_AXIS_LINE_COLOUR\n      },\n      gridLine: {\n        enabled: true,\n        style: [{ stroke: DEFAULT_AXIS_GRID_COLOUR, lineDash: [] }]\n      },\n      crossLines: {\n        enabled: false,\n        fill: DEFAULT_CROSS_LINES_COLOUR,\n        stroke: DEFAULT_CROSS_LINES_COLOUR,\n        fillOpacity: 0.1,\n        strokeWidth: 1,\n        label: {\n          enabled: false,\n          fontSize: 12 /* SMALL */,\n          fontFamily: DEFAULT_FONT_FAMILY,\n          padding: 5,\n          color: DEFAULT_LABEL_COLOUR\n        }\n      }\n    });\n  }\n  getChartDefaults() {\n    return {\n      minHeight: 300,\n      minWidth: 300,\n      background: { visible: true, fill: DEFAULT_BACKGROUND_COLOUR },\n      padding: { top: DEFAULT_PADDING, right: DEFAULT_PADDING, bottom: DEFAULT_PADDING, left: DEFAULT_PADDING },\n      keyboard: { enabled: true },\n      title: {\n        enabled: false,\n        text: \"Title\",\n        fontWeight: \"normal\" /* NORMAL */,\n        fontSize: 17 /* LARGE */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR,\n        wrapping: \"hyphenate\",\n        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,\n        textAlign: DEFAULT_CAPTION_ALIGNMENT\n      },\n      subtitle: {\n        enabled: false,\n        text: \"Subtitle\",\n        spacing: 20,\n        fontSize: 13 /* MEDIUM */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_MUTED_LABEL_COLOUR,\n        wrapping: \"hyphenate\",\n        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,\n        textAlign: DEFAULT_CAPTION_ALIGNMENT\n      },\n      footnote: {\n        enabled: false,\n        text: \"Footnote\",\n        spacing: 20,\n        fontSize: 13 /* MEDIUM */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: \"rgb(140, 140, 140)\",\n        wrapping: \"hyphenate\",\n        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,\n        textAlign: DEFAULT_CAPTION_ALIGNMENT\n      },\n      legend: {\n        position: \"bottom\" /* BOTTOM */,\n        spacing: 30,\n        listeners: {},\n        toggleSeries: true,\n        item: {\n          paddingX: 16,\n          paddingY: 8,\n          marker: { size: 15, padding: 8 },\n          showSeriesStroke: true,\n          label: {\n            color: DEFAULT_LABEL_COLOUR,\n            fontSize: 12 /* SMALL */,\n            fontFamily: DEFAULT_FONT_FAMILY\n          }\n        },\n        reverseOrder: false,\n        pagination: {\n          marker: { size: 12 },\n          activeStyle: { fill: DEFAULT_LABEL_COLOUR },\n          inactiveStyle: { fill: DEFAULT_MUTED_LABEL_COLOUR },\n          highlightStyle: { fill: DEFAULT_LABEL_COLOUR },\n          label: { color: DEFAULT_LABEL_COLOUR }\n        }\n      },\n      tooltip: {\n        enabled: true,\n        darkTheme: IS_DARK_THEME,\n        range: void 0,\n        delay: 0\n      },\n      overlays: { darkTheme: IS_DARK_THEME },\n      listeners: {}\n    };\n  }\n  constructor(options = {}) {\n    const { overrides, palette: palette12 } = deepClone(options);\n    const defaults = this.createChartConfigPerChartType(this.getDefaults());\n    if (overrides) {\n      this.mergeOverrides(defaults, overrides);\n    }\n    const { fills: _fills, strokes: _strokes, ...otherColors } = this.getDefaultColors();\n    this.palette = mergeDefaults(palette12, this.getPalette(), { ...otherColors });\n    this.paletteType = paletteType(palette12);\n    this.config = Object.freeze(this.templateTheme(defaults));\n  }\n  mergeOverrides(defaults, overrides) {\n    for (const { seriesTypes, commonOptions } of Object.values(CHART_TYPE_CONFIG)) {\n      const cleanedCommon = { ...overrides.common };\n      for (const commonKey of CHART_TYPE_SPECIFIC_COMMON_OPTIONS) {\n        if (!commonOptions.includes(commonKey)) {\n          delete cleanedCommon[commonKey];\n        }\n      }\n      if (!cleanedCommon)\n        continue;\n      for (const s of seriesTypes) {\n        const seriesType = s;\n        defaults[seriesType] = mergeDefaults(cleanedCommon, defaults[seriesType]);\n      }\n    }\n    chartTypes.seriesTypes.forEach((s) => {\n      const seriesType = s;\n      if (overrides[seriesType]) {\n        defaults[seriesType] = mergeDefaults(overrides[seriesType], defaults[seriesType]);\n      }\n    });\n  }\n  createChartConfigPerChartType(config) {\n    for (const [nextType, { seriesTypes }] of Object.entries(CHART_TYPE_CONFIG)) {\n      const typeDefaults = chartDefaults.get(nextType);\n      for (const seriesType of seriesTypes) {\n        config[seriesType] || (config[seriesType] = deepClone(typeDefaults));\n      }\n    }\n    return config;\n  }\n  getDefaults() {\n    const getOverridesByType = (chartType2, seriesTypes) => {\n      const result = {};\n      const chartTypeDefaults = {\n        axes: {},\n        ...legendRegistry.getThemeTemplates(),\n        ...this.getChartDefaults(),\n        ...chartDefaults.get(chartType2)\n      };\n      for (const seriesType of seriesTypes) {\n        result[seriesType] = mergeDefaults(\n          seriesRegistry.getThemeTemplate(seriesType),\n          result[seriesType] ?? deepClone(chartTypeDefaults)\n        );\n        const { axes } = result[seriesType];\n        for (const axisType of axisRegistry.keys()) {\n          axes[axisType] = mergeDefaults(\n            axes[axisType],\n            axisRegistry.getThemeTemplate(axisType),\n            _ChartTheme.cartesianAxisDefault[axisType]\n          );\n        }\n      }\n      return result;\n    };\n    return mergeDefaults(\n      getOverridesByType(\"cartesian\", chartTypes.cartesianTypes),\n      getOverridesByType(\"polar\", chartTypes.polarTypes),\n      getOverridesByType(\"hierarchy\", chartTypes.hierarchyTypes),\n      getOverridesByType(\"topology\", chartTypes.topologyTypes),\n      getOverridesByType(\"flow-proportion\", chartTypes.flowProportionTypes)\n    );\n  }\n  templateTheme(themeTemplate) {\n    const themeInstance = deepClone(themeTemplate);\n    const params = this.getTemplateParameters();\n    jsonWalk(themeInstance, (node) => {\n      if (isArray(node)) {\n        for (let i = 0; i < node.length; i++) {\n          const symbol = node[i];\n          if (params.has(symbol)) {\n            node[i] = params.get(symbol);\n          }\n        }\n      } else {\n        for (const [name, value] of Object.entries(node)) {\n          if (params.has(value)) {\n            node[name] = params.get(value);\n          }\n        }\n      }\n    });\n    return deepClone(themeInstance);\n  }\n  getDefaultColors() {\n    return {\n      fills: DEFAULT_FILLS,\n      strokes: DEFAULT_STROKES,\n      up: { fill: DEFAULT_FILLS.BLUE, stroke: DEFAULT_STROKES.BLUE },\n      down: { fill: DEFAULT_FILLS.ORANGE, stroke: DEFAULT_STROKES.ORANGE },\n      neutral: { fill: DEFAULT_FILLS.GRAY, stroke: DEFAULT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = /* @__PURE__ */ new Map();\n    params.set(IS_DARK_THEME, false);\n    params.set(DEFAULT_FONT_FAMILY, \"Verdana, sans-serif\");\n    params.set(DEFAULT_LABEL_COLOUR, \"rgb(70, 70, 70)\");\n    params.set(DEFAULT_INVERTED_LABEL_COLOUR, \"white\");\n    params.set(DEFAULT_MUTED_LABEL_COLOUR, \"rgb(140, 140, 140)\");\n    params.set(DEFAULT_AXIS_GRID_COLOUR, \"rgb(224,234,241)\");\n    params.set(DEFAULT_AXIS_LINE_COLOUR, \"rgb(195, 195, 195)\");\n    params.set(DEFAULT_CROSS_LINES_COLOUR, \"rgb(70, 70, 70)\");\n    params.set(DEFAULT_INSIDE_SERIES_LABEL_COLOUR, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_BACKGROUND_COLOUR, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_SHADOW_COLOUR, \"rgba(0, 0, 0, 0.5)\");\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      DEFAULT_FILLS.ORANGE,\n      DEFAULT_FILLS.YELLOW,\n      DEFAULT_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_PADDING, 20);\n    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, \"block\");\n    params.set(DEFAULT_CAPTION_ALIGNMENT, \"center\");\n    params.set(DEFAULT_HIERARCHY_FILLS, [\"#ffffff\", \"#e0e5ea\", \"#c1ccd5\", \"#a3b4c1\", \"#859cad\"]);\n    params.set(DEFAULT_HIERARCHY_STROKES, [\"#ffffff\", \"#c5cbd1\", \"#a4b1bd\", \"#8498a9\", \"#648096\"]);\n    params.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_ANNOTATION_STROKE, DEFAULT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, DEFAULT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_HANDLE_FILL, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_TOOLBAR_POSITION, \"top\");\n    params.set(DEFAULT_GRIDLINE_ENABLED, false);\n    const defaultColors = this.getDefaultColors();\n    params.set(PALETTE_UP_STROKE, this.palette.up?.stroke ?? defaultColors.up.stroke);\n    params.set(PALETTE_UP_FILL, this.palette.up?.fill ?? defaultColors.up.fill);\n    params.set(PALETTE_DOWN_STROKE, this.palette.down?.stroke ?? defaultColors.down.stroke);\n    params.set(PALETTE_DOWN_FILL, this.palette.down?.fill ?? defaultColors.down.fill);\n    params.set(PALETTE_NEUTRAL_STROKE, this.palette.neutral?.stroke ?? defaultColors.neutral.stroke);\n    params.set(PALETTE_NEUTRAL_FILL, this.palette.neutral?.fill ?? defaultColors.neutral.fill);\n    return params;\n  }\n};\n_ChartTheme.cartesianAxisDefault = {\n  [\"number\" /* NUMBER */]: _ChartTheme.getAxisDefaults({\n    line: { enabled: false }\n  }),\n  [\"log\" /* LOG */]: _ChartTheme.getAxisDefaults({\n    base: 10,\n    line: { enabled: false }\n  }),\n  [\"category\" /* CATEGORY */]: _ChartTheme.getAxisDefaults({\n    groupPaddingInner: 0.1,\n    label: { autoRotate: true },\n    gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED }\n  }),\n  [\"time\" /* TIME */]: _ChartTheme.getAxisDefaults({ gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED } }),\n  [\"ordinal-time\" /* ORDINAL_TIME */]: _ChartTheme.getAxisDefaults({\n    groupPaddingInner: 0,\n    label: { autoRotate: false },\n    gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED },\n    crosshair: {\n      enabled: true,\n      snap: true,\n      stroke: DEFAULT_MUTED_LABEL_COLOUR,\n      strokeWidth: 1,\n      strokeOpacity: 1,\n      lineDash: [5, 6],\n      lineDashOffset: 0,\n      label: { enabled: true }\n    }\n  }),\n  [\"angle-category\" /* ANGLE_CATEGORY */]: _ChartTheme.getAxisDefaults({\n    gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED }\n  }),\n  [\"angle-number\" /* ANGLE_NUMBER */]: _ChartTheme.getAxisDefaults({ gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED } }),\n  [\"radius-category\" /* RADIUS_CATEGORY */]: _ChartTheme.getAxisDefaults({\n    line: { enabled: false },\n    tick: { enabled: false }\n  }),\n  [\"radius-number\" /* RADIUS_NUMBER */]: _ChartTheme.getAxisDefaults({\n    line: { enabled: false },\n    tick: { enabled: false }\n  }),\n  \"grouped-category\": _ChartTheme.getAxisDefaults()\n};\nvar ChartTheme = _ChartTheme;\n\n// packages/ag-charts-community/src/chart/themes/darkTheme.ts\nvar DEFAULT_DARK_BACKGROUND_FILL = \"#192232\";\nvar DEFAULT_DARK_FILLS = {\n  BLUE: \"#5090dc\",\n  ORANGE: \"#ffa03a\",\n  GREEN: \"#459d55\",\n  CYAN: \"#34bfe1\",\n  YELLOW: \"#e1cc00\",\n  VIOLET: \"#9669cb\",\n  GRAY: \"#b5b5b5\",\n  MAGENTA: \"#bd5aa7\",\n  BROWN: \"#8a6224\",\n  RED: \"#ef5452\"\n};\nvar DEFAULT_DARK_STROKES = {\n  BLUE: \"#74a8e6\",\n  ORANGE: \"#ffbe70\",\n  GREEN: \"#6cb176\",\n  CYAN: \"#75d4ef\",\n  YELLOW: \"#f6e559\",\n  VIOLET: \"#aa86d8\",\n  GRAY: \"#a1a1a1\",\n  MAGENTA: \"#ce7ab9\",\n  BROWN: \"#997b52\",\n  RED: \"#ff7872\"\n};\nvar palette = {\n  fills: Object.values(DEFAULT_DARK_FILLS),\n  strokes: Object.values(DEFAULT_DARK_STROKES)\n};\nvar DarkTheme = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: DEFAULT_DARK_FILLS,\n      strokes: DEFAULT_DARK_STROKES,\n      up: { fill: DEFAULT_DARK_FILLS.BLUE, stroke: DEFAULT_DARK_STROKES.BLUE },\n      down: { fill: DEFAULT_DARK_FILLS.ORANGE, stroke: DEFAULT_DARK_STROKES.ORANGE },\n      neutral: { fill: DEFAULT_DARK_FILLS.GRAY, stroke: DEFAULT_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(IS_DARK_THEME, true);\n    params.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_DARK_BACKGROUND_FILL);\n    params.set(DEFAULT_LABEL_COLOUR, \"white\");\n    params.set(DEFAULT_MUTED_LABEL_COLOUR, \"#7D91A0\");\n    params.set(DEFAULT_AXIS_GRID_COLOUR, \"#545A6E\");\n    params.set(DEFAULT_CROSS_LINES_COLOUR, \"white\");\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      DEFAULT_DARK_FILLS.ORANGE,\n      DEFAULT_DARK_FILLS.YELLOW,\n      DEFAULT_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_HIERARCHY_FILLS, [\"#192834\", \"#253746\", \"#324859\", \"#3f596c\", \"#4d6a80\"]);\n    params.set(DEFAULT_HIERARCHY_STROKES, [\"#192834\", \"#3b5164\", \"#496275\", \"#577287\", \"#668399\"]);\n    params.set(DEFAULT_BACKGROUND_COLOUR, DEFAULT_DARK_BACKGROUND_FILL);\n    params.set(DEFAULT_INSIDE_SERIES_LABEL_COLOUR, DEFAULT_DARK_BACKGROUND_FILL);\n    params.set(DEFAULT_ANNOTATION_STROKE, DEFAULT_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, DEFAULT_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_HANDLE_FILL, DEFAULT_DARK_BACKGROUND_FILL);\n    return params;\n  }\n  getPalette() {\n    return palette;\n  }\n  constructor(options) {\n    super(options);\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/financialDark.ts\nvar FINANCIAL_DARK_FILLS = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\"\n};\nvar FINANCIAL_DARK_STROKES = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\"\n};\nvar palette2 = {\n  fills: Object.values(FINANCIAL_DARK_FILLS),\n  strokes: Object.values(FINANCIAL_DARK_STROKES)\n};\nvar FinancialDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...FINANCIAL_DARK_FILLS },\n      strokes: { ...FINANCIAL_DARK_STROKES },\n      up: { fill: FINANCIAL_DARK_FILLS.GREEN, stroke: FINANCIAL_DARK_STROKES.GREEN },\n      down: { fill: FINANCIAL_DARK_FILLS.RED, stroke: FINANCIAL_DARK_STROKES.RED },\n      neutral: { fill: FINANCIAL_DARK_FILLS.BLUE, stroke: FINANCIAL_DARK_STROKES.BLUE }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      FINANCIAL_DARK_FILLS.GREEN,\n      FINANCIAL_DARK_FILLS.BLUE,\n      FINANCIAL_DARK_FILLS.RED\n    ]);\n    params.set(DEFAULT_ANNOTATION_STROKE, FINANCIAL_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, FINANCIAL_DARK_FILLS.BLUE);\n    params.set(DEFAULT_AXIS_GRID_COLOUR, \"#343A4E\");\n    params.set(DEFAULT_PADDING, 0);\n    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, \"overlay\");\n    params.set(DEFAULT_CAPTION_ALIGNMENT, \"left\");\n    params.set(DEFAULT_TOOLBAR_POSITION, \"bottom\");\n    params.set(DEFAULT_GRIDLINE_ENABLED, true);\n    return params;\n  }\n  getPalette() {\n    return palette2;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/financialLight.ts\nvar FINANCIAL_LIGHT_FILLS = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\"\n};\nvar FINANCIAL_LIGHT_STROKES = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\"\n};\nvar palette3 = {\n  fills: Object.values(FINANCIAL_LIGHT_FILLS),\n  strokes: Object.values(FINANCIAL_LIGHT_STROKES)\n};\nvar FinancialLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...FINANCIAL_LIGHT_FILLS },\n      strokes: { ...FINANCIAL_LIGHT_STROKES },\n      up: { fill: FINANCIAL_LIGHT_FILLS.GREEN, stroke: FINANCIAL_LIGHT_STROKES.GREEN },\n      down: { fill: FINANCIAL_LIGHT_FILLS.RED, stroke: FINANCIAL_LIGHT_STROKES.RED },\n      neutral: { fill: FINANCIAL_LIGHT_FILLS.BLUE, stroke: FINANCIAL_LIGHT_STROKES.BLUE }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      FINANCIAL_LIGHT_FILLS.GREEN,\n      FINANCIAL_LIGHT_FILLS.BLUE,\n      FINANCIAL_LIGHT_FILLS.RED\n    ]);\n    params.set(DEFAULT_ANNOTATION_STROKE, FINANCIAL_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, FINANCIAL_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_AXIS_GRID_COLOUR, \"#F2F3F3\");\n    params.set(DEFAULT_PADDING, 0);\n    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, \"overlay\");\n    params.set(DEFAULT_CAPTION_ALIGNMENT, \"left\");\n    params.set(DEFAULT_TOOLBAR_POSITION, \"bottom\");\n    params.set(DEFAULT_GRIDLINE_ENABLED, true);\n    return params;\n  }\n  getPalette() {\n    return palette3;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/materialDark.ts\nvar MATERIAL_DARK_FILLS = {\n  BLUE: \"#2196F3\",\n  ORANGE: \"#FF9800\",\n  GREEN: \"#4CAF50\",\n  CYAN: \"#00BCD4\",\n  YELLOW: \"#FFEB3B\",\n  VIOLET: \"#7E57C2\",\n  GRAY: \"#9E9E9E\",\n  MAGENTA: \"#F06292\",\n  BROWN: \"#795548\",\n  RED: \"#F44336\"\n};\nvar MATERIAL_DARK_STROKES = {\n  BLUE: \"#90CAF9\",\n  ORANGE: \"#FFCC80\",\n  GREEN: \"#A5D6A7\",\n  CYAN: \"#80DEEA\",\n  YELLOW: \"#FFF9C4\",\n  VIOLET: \"#B39DDB\",\n  GRAY: \"#E0E0E0\",\n  MAGENTA: \"#F48FB1\",\n  BROWN: \"#A1887F\",\n  RED: \"#EF9A9A\"\n};\nvar palette4 = {\n  fills: Object.values(MATERIAL_DARK_FILLS),\n  strokes: Object.values(MATERIAL_DARK_STROKES)\n};\nvar MaterialDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: MATERIAL_DARK_FILLS,\n      strokes: MATERIAL_DARK_STROKES,\n      up: { fill: MATERIAL_DARK_FILLS.BLUE, stroke: MATERIAL_DARK_STROKES.BLUE },\n      down: { fill: MATERIAL_DARK_FILLS.RED, stroke: MATERIAL_DARK_STROKES.RED },\n      neutral: { fill: MATERIAL_DARK_FILLS.GRAY, stroke: MATERIAL_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      MATERIAL_DARK_FILLS.ORANGE,\n      MATERIAL_DARK_FILLS.YELLOW,\n      MATERIAL_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_ANNOTATION_STROKE, MATERIAL_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, MATERIAL_DARK_FILLS.BLUE);\n    return params;\n  }\n  getPalette() {\n    return palette4;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/materialLight.ts\nvar MATERIAL_LIGHT_FILLS = {\n  BLUE: \"#2196F3\",\n  ORANGE: \"#FF9800\",\n  GREEN: \"#4CAF50\",\n  CYAN: \"#00BCD4\",\n  YELLOW: \"#FFEB3B\",\n  VIOLET: \"#7E57C2\",\n  GRAY: \"#9E9E9E\",\n  MAGENTA: \"#F06292\",\n  BROWN: \"#795548\",\n  RED: \"#F44336\"\n};\nvar MATERIAL_LIGHT_STROKES = {\n  BLUE: \"#1565C0\",\n  ORANGE: \"#E65100\",\n  GREEN: \"#2E7D32\",\n  CYAN: \"#00838F\",\n  YELLOW: \"#F9A825\",\n  VIOLET: \"#4527A0\",\n  GRAY: \"#616161\",\n  MAGENTA: \"#C2185B\",\n  BROWN: \"#4E342E\",\n  RED: \"#B71C1C\"\n};\nvar palette5 = {\n  fills: Object.values(MATERIAL_LIGHT_FILLS),\n  strokes: Object.values(MATERIAL_LIGHT_STROKES)\n};\nvar MaterialLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: MATERIAL_LIGHT_FILLS,\n      strokes: MATERIAL_LIGHT_STROKES,\n      up: { fill: MATERIAL_LIGHT_FILLS.BLUE, stroke: MATERIAL_LIGHT_STROKES.BLUE },\n      down: { fill: MATERIAL_LIGHT_FILLS.RED, stroke: MATERIAL_LIGHT_STROKES.RED },\n      neutral: { fill: MATERIAL_LIGHT_FILLS.GRAY, stroke: MATERIAL_LIGHT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      MATERIAL_LIGHT_FILLS.ORANGE,\n      MATERIAL_LIGHT_FILLS.YELLOW,\n      MATERIAL_LIGHT_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_ANNOTATION_STROKE, MATERIAL_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, MATERIAL_LIGHT_FILLS.BLUE);\n    return params;\n  }\n  getPalette() {\n    return palette5;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/polychromaDark.ts\nvar POLYCHROMA_DARK_FILLS = {\n  BLUE: \"#436ff4\",\n  PURPLE: \"#9a7bff\",\n  MAGENTA: \"#d165d2\",\n  PINK: \"#f0598b\",\n  RED: \"#f47348\",\n  ORANGE: \"#f2a602\",\n  YELLOW: \"#e9e201\",\n  GREEN: \"#21b448\",\n  CYAN: \"#00b9a2\",\n  MODERATE_BLUE: \"#00aee4\"\n};\nvar POLYCHROMA_DARK_STROKES = {\n  BLUE: \"#6698ff\",\n  PURPLE: \"#c0a3ff\",\n  MAGENTA: \"#fc8dfc\",\n  PINK: \"#ff82b1\",\n  RED: \"#ff9b70\",\n  ORANGE: \"#ffcf4e\",\n  YELLOW: \"#ffff58\",\n  GREEN: \"#58dd70\",\n  CYAN: \"#51e2c9\",\n  MODERATE_BLUE: \"#4fd7ff\"\n};\nvar POLYCHROMA_DARK_FILL_GRAY = \"#bbbbbb\";\nvar POLYCHROMA_DARK_STROKE_GRAY = \"#eeeeee\";\nvar palette6 = {\n  fills: Object.values(POLYCHROMA_DARK_FILLS),\n  strokes: Object.values(POLYCHROMA_DARK_STROKES)\n};\nvar PolychromaDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: POLYCHROMA_DARK_FILLS,\n      strokes: POLYCHROMA_DARK_STROKES,\n      up: { fill: POLYCHROMA_DARK_FILLS.BLUE, stroke: POLYCHROMA_DARK_STROKES.BLUE },\n      down: { fill: POLYCHROMA_DARK_FILLS.RED, stroke: POLYCHROMA_DARK_STROKES.RED },\n      neutral: { fill: POLYCHROMA_DARK_FILL_GRAY, stroke: POLYCHROMA_DARK_STROKE_GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [POLYCHROMA_DARK_FILLS.BLUE, POLYCHROMA_DARK_FILLS.RED]);\n    params.set(DEFAULT_ANNOTATION_STROKE, POLYCHROMA_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, POLYCHROMA_DARK_FILLS.BLUE);\n    return params;\n  }\n  getPalette() {\n    return palette6;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/polychromaLight.ts\nvar POLYCHROMA_LIGHT_FILLS = {\n  BLUE: \"#436ff4\",\n  PURPLE: \"#9a7bff\",\n  MAGENTA: \"#d165d2\",\n  PINK: \"#f0598b\",\n  RED: \"#f47348\",\n  ORANGE: \"#f2a602\",\n  YELLOW: \"#e9e201\",\n  GREEN: \"#21b448\",\n  CYAN: \"#00b9a2\",\n  MODERATE_BLUE: \"#00aee4\"\n};\nvar POLYCHROMA_LIGHT_STROKES = {\n  BLUE: \"#2346c9\",\n  PURPLE: \"#7653d4\",\n  MAGENTA: \"#a73da9\",\n  PINK: \"#c32d66\",\n  RED: \"#c84b1c\",\n  ORANGE: \"#c87f00\",\n  YELLOW: \"#c1b900\",\n  GREEN: \"#008c1c\",\n  CYAN: \"#00927c\",\n  MODERATE_BLUE: \"#0087bb\"\n};\nvar POLYCHROMA_LIGHT_FILL_GRAY = \"#bbbbbb\";\nvar POLYCHROMA_LIGHT_STROKE_GRAY = \"#888888\";\nvar palette7 = {\n  fills: Object.values(POLYCHROMA_LIGHT_FILLS),\n  strokes: Object.values(POLYCHROMA_LIGHT_STROKES)\n};\nvar PolychromaLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: POLYCHROMA_LIGHT_FILLS,\n      strokes: POLYCHROMA_LIGHT_STROKES,\n      up: { fill: POLYCHROMA_LIGHT_FILLS.BLUE, stroke: POLYCHROMA_LIGHT_STROKES.BLUE },\n      down: { fill: POLYCHROMA_LIGHT_FILLS.RED, stroke: POLYCHROMA_LIGHT_STROKES.RED },\n      neutral: { fill: POLYCHROMA_LIGHT_FILL_GRAY, stroke: POLYCHROMA_LIGHT_STROKE_GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [POLYCHROMA_LIGHT_FILLS.BLUE, POLYCHROMA_LIGHT_FILLS.RED]);\n    params.set(DEFAULT_ANNOTATION_STROKE, POLYCHROMA_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, POLYCHROMA_LIGHT_FILLS.BLUE);\n    return params;\n  }\n  getPalette() {\n    return palette7;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/sheetsDark.ts\nvar SHEETS_DARK_FILLS = {\n  BLUE: \"#4472C4\",\n  ORANGE: \"#ED7D31\",\n  GRAY: \"#A5A5A5\",\n  YELLOW: \"#FFC000\",\n  MODERATE_BLUE: \"#5B9BD5\",\n  GREEN: \"#70AD47\",\n  DARK_GRAY: \"#7B7B7B\",\n  DARK_BLUE: \"#264478\",\n  VERY_DARK_GRAY: \"#636363\",\n  DARK_YELLOW: \"#997300\"\n};\nvar SHEETS_DARK_STROKES = {\n  BLUE: \"#6899ee\",\n  ORANGE: \"#ffa55d\",\n  GRAY: \"#cdcdcd\",\n  YELLOW: \"#ffea53\",\n  MODERATE_BLUE: \"#82c3ff\",\n  GREEN: \"#96d56f\",\n  DARK_GRAY: \"#a1a1a1\",\n  DARK_BLUE: \"#47689f\",\n  VERY_DARK_GRAY: \"#878787\",\n  DARK_YELLOW: \"#c0993d\"\n};\nvar palette8 = {\n  fills: Object.values(SHEETS_DARK_FILLS),\n  strokes: Object.values(SHEETS_DARK_STROKES)\n};\nvar SheetsDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...SHEETS_DARK_FILLS, RED: SHEETS_DARK_FILLS.ORANGE },\n      strokes: { ...SHEETS_DARK_STROKES, RED: SHEETS_DARK_STROKES.ORANGE },\n      up: { fill: SHEETS_DARK_FILLS.BLUE, stroke: SHEETS_DARK_STROKES.BLUE },\n      down: { fill: SHEETS_DARK_FILLS.ORANGE, stroke: SHEETS_DARK_STROKES.ORANGE },\n      neutral: { fill: SHEETS_DARK_FILLS.GRAY, stroke: SHEETS_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      SHEETS_DARK_FILLS.ORANGE,\n      SHEETS_DARK_FILLS.YELLOW,\n      SHEETS_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_ANNOTATION_STROKE, SHEETS_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, SHEETS_DARK_FILLS.BLUE);\n    return params;\n  }\n  getPalette() {\n    return palette8;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/sheetsLight.ts\nvar SHEETS_LIGHT_FILLS = {\n  BLUE: \"#5281d5\",\n  ORANGE: \"#ff8d44\",\n  GRAY: \"#b5b5b5\",\n  YELLOW: \"#ffd02f\",\n  MODERATE_BLUE: \"#6aabe6\",\n  GREEN: \"#7fbd57\",\n  DARK_GRAY: \"#8a8a8a\",\n  DARK_BLUE: \"#335287\",\n  VERY_DARK_GRAY: \"#717171\",\n  DARK_YELLOW: \"#a98220\"\n};\nvar SHEETS_LIGHT_STROKES = {\n  BLUE: \"#214d9b\",\n  ORANGE: \"#c25600\",\n  GRAY: \"#7f7f7f\",\n  YELLOW: \"#d59800\",\n  MODERATE_BLUE: \"#3575ac\",\n  GREEN: \"#4b861a\",\n  DARK_GRAY: \"#575757\",\n  DARK_BLUE: \"#062253\",\n  VERY_DARK_GRAY: \"#414141\",\n  DARK_YELLOW: \"#734f00\"\n};\nvar palette9 = {\n  fills: Object.values(SHEETS_LIGHT_FILLS),\n  strokes: Object.values(SHEETS_LIGHT_STROKES)\n};\nvar SheetsLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...SHEETS_LIGHT_FILLS, RED: SHEETS_LIGHT_FILLS.ORANGE },\n      strokes: { ...SHEETS_LIGHT_STROKES, RED: SHEETS_LIGHT_STROKES.ORANGE },\n      up: { fill: SHEETS_LIGHT_STROKES.BLUE, stroke: SHEETS_LIGHT_FILLS.BLUE },\n      down: { fill: SHEETS_LIGHT_STROKES.ORANGE, stroke: SHEETS_LIGHT_FILLS.ORANGE },\n      neutral: { fill: SHEETS_LIGHT_STROKES.GRAY, stroke: SHEETS_LIGHT_FILLS.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      SHEETS_LIGHT_FILLS.ORANGE,\n      SHEETS_LIGHT_FILLS.YELLOW,\n      SHEETS_LIGHT_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_ANNOTATION_STROKE, SHEETS_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, SHEETS_LIGHT_FILLS.BLUE);\n    return params;\n  }\n  getPalette() {\n    return palette9;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/vividDark.ts\nvar VIVID_DARK_FILLS = {\n  BLUE: \"#0083ff\",\n  ORANGE: \"#ff6600\",\n  GREEN: \"#00af00\",\n  CYAN: \"#00ccff\",\n  YELLOW: \"#f7c700\",\n  VIOLET: \"#ac26ff\",\n  GRAY: \"#a7a7b7\",\n  MAGENTA: \"#e800c5\",\n  BROWN: \"#b54300\",\n  RED: \"#ff0000\"\n};\nvar VIVID_DARK_STROKES = {\n  BLUE: \"#67b7ff\",\n  ORANGE: \"#ffc24d\",\n  GREEN: \"#5cc86f\",\n  CYAN: \"#54ebff\",\n  VIOLET: \"#fff653\",\n  YELLOW: \"#c18aff\",\n  GRAY: \"#aeaeae\",\n  MAGENTA: \"#f078d4\",\n  BROWN: \"#ba8438\",\n  RED: \"#ff726e\"\n};\nvar palette10 = {\n  fills: Object.values(VIVID_DARK_FILLS),\n  strokes: Object.values(VIVID_DARK_STROKES)\n};\nvar VividDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: VIVID_DARK_FILLS,\n      strokes: VIVID_DARK_STROKES,\n      up: { fill: VIVID_DARK_FILLS.BLUE, stroke: VIVID_DARK_STROKES.BLUE },\n      down: { fill: VIVID_DARK_FILLS.ORANGE, stroke: VIVID_DARK_STROKES.ORANGE },\n      neutral: { fill: VIVID_DARK_FILLS.GRAY, stroke: VIVID_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      VIVID_DARK_FILLS.ORANGE,\n      VIVID_DARK_FILLS.YELLOW,\n      VIVID_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_ANNOTATION_STROKE, VIVID_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, VIVID_DARK_FILLS.BLUE);\n    return params;\n  }\n  getPalette() {\n    return palette10;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/vividLight.ts\nvar VIVID_FILLS = {\n  BLUE: \"#0083ff\",\n  ORANGE: \"#ff6600\",\n  GREEN: \"#00af00\",\n  CYAN: \"#00ccff\",\n  YELLOW: \"#f7c700\",\n  VIOLET: \"#ac26ff\",\n  GRAY: \"#a7a7b7\",\n  MAGENTA: \"#e800c5\",\n  BROWN: \"#b54300\",\n  RED: \"#ff0000\"\n};\nvar VIVID_STROKES = {\n  BLUE: \"#0f68c0\",\n  ORANGE: \"#d47100\",\n  GREEN: \"#007922\",\n  CYAN: \"#009ac2\",\n  VIOLET: \"#bca400\",\n  YELLOW: \"#753cac\",\n  GRAY: \"#646464\",\n  MAGENTA: \"#9b2685\",\n  BROWN: \"#6c3b00\",\n  RED: \"#cb0021\"\n};\nvar palette11 = {\n  fills: Object.values(VIVID_FILLS),\n  strokes: Object.values(VIVID_STROKES)\n};\nvar VividLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: VIVID_FILLS,\n      strokes: VIVID_STROKES,\n      up: { fill: VIVID_FILLS.BLUE, stroke: VIVID_STROKES.BLUE },\n      down: { fill: VIVID_FILLS.ORANGE, stroke: VIVID_STROKES.ORANGE },\n      neutral: { fill: VIVID_FILLS.GRAY, stroke: VIVID_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [VIVID_FILLS.ORANGE, VIVID_FILLS.YELLOW, VIVID_FILLS.GREEN]);\n    params.set(DEFAULT_ANNOTATION_STROKE, VIVID_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, VIVID_FILLS.BLUE);\n    return params;\n  }\n  getPalette() {\n    return palette11;\n  }\n};\n\n// packages/ag-charts-community/src/chart/mapping/themes.ts\nvar lightTheme = () => new ChartTheme();\nvar darkTheme = () => new DarkTheme();\nvar lightThemes = {\n  undefined: lightTheme,\n  null: lightTheme,\n  \"ag-default\": lightTheme,\n  \"ag-sheets\": () => new SheetsLight(),\n  \"ag-polychroma\": () => new PolychromaLight(),\n  \"ag-vivid\": () => new VividLight(),\n  \"ag-material\": () => new MaterialLight(),\n  \"ag-financial\": () => new FinancialLight()\n};\nvar darkThemes = {\n  undefined: darkTheme,\n  null: darkTheme,\n  \"ag-default-dark\": darkTheme,\n  \"ag-sheets-dark\": () => new SheetsDark(),\n  \"ag-polychroma-dark\": () => new PolychromaDark(),\n  \"ag-vivid-dark\": () => new VividDark(),\n  \"ag-material-dark\": () => new MaterialDark(),\n  \"ag-financial-dark\": () => new FinancialDark()\n};\nvar themes = {\n  ...darkThemes,\n  ...lightThemes\n};\nfunction validateChartThemeObject(unknownObject) {\n  if (unknownObject === null) {\n    return;\n  }\n  let valid = true;\n  const { baseTheme, palette: palette12, overrides } = unknownObject;\n  if (baseTheme !== void 0 && typeof baseTheme !== \"string\" && typeof baseTheme !== \"object\") {\n    Logger.warn(`invalid theme.baseTheme type ${typeof baseTheme}, expected (string | object).`);\n    valid = false;\n  }\n  if (overrides !== void 0 && typeof overrides !== \"object\") {\n    Logger.warn(`invalid theme.overrides type ${typeof overrides}, expected object.`);\n    valid = false;\n  }\n  if (typeof palette12 === \"object\") {\n    if (palette12 !== null) {\n      const { fills, strokes } = palette12;\n      if (fills !== void 0 && !Array.isArray(fills)) {\n        Logger.warn(`theme.overrides.fills must be undefined or an array`);\n        valid = false;\n      }\n      if (strokes !== void 0 && !Array.isArray(strokes)) {\n        Logger.warn(`theme.overrides.strokes must be undefined or an array`);\n        valid = false;\n      }\n    }\n  } else if (palette12 !== void 0) {\n    Logger.warn(`invalid theme.palette type ${typeof palette12}, expected object.`);\n    valid = false;\n  }\n  if (valid) {\n    return unknownObject;\n  }\n}\nfunction validateChartTheme(value) {\n  if (value === void 0 || typeof value === \"string\" || value instanceof ChartTheme) {\n    return value;\n  }\n  if (typeof value === \"object\") {\n    return validateChartThemeObject(value);\n  }\n  Logger.warn(`invalid theme value type ${typeof value}, expected object or string.`);\n}\nfunction getChartTheme(unvalidatedValue) {\n  let value = validateChartTheme(unvalidatedValue);\n  if (value instanceof ChartTheme) {\n    return value;\n  }\n  if (value == null || typeof value === \"string\") {\n    const stockTheme = themes[value];\n    if (stockTheme) {\n      return stockTheme();\n    }\n    Logger.warnOnce(`the theme [${value}] is invalid, using [ag-default] instead.`);\n    return lightTheme();\n  }\n  const overrides = [];\n  let palette12;\n  while (typeof value === \"object\") {\n    overrides.push(value.overrides);\n    palette12 ?? (palette12 = value.palette);\n    value = value.baseTheme;\n  }\n  const flattenedTheme = {\n    baseTheme: value,\n    overrides: mergeDefaults(...overrides),\n    palette: palette12\n  };\n  const baseTheme = flattenedTheme.baseTheme ? getChartTheme(flattenedTheme.baseTheme) : lightTheme();\n  return new baseTheme.constructor(flattenedTheme);\n}\n\n// packages/ag-charts-community/src/module/optionsModule.ts\nvar unthemedSeries = /* @__PURE__ */ new Set([\"map-shape-background\", \"map-line-background\"]);\nvar ChartOptions = class {\n  constructor(userOptions, specialOverrides) {\n    this.debug = Debug.create(true, \"opts\");\n    var _a;\n    const cloneOptions = { shallow: [\"data\"] };\n    this.userOptions = deepClone(userOptions, cloneOptions);\n    const chartType2 = this.optionsType(this.userOptions);\n    let options = deepClone(userOptions, cloneOptions);\n    this.type = specialOverrides?.type;\n    if (this.type != null) {\n      const presetOptions = PRESETS[this.type]?.(options, () => this.activeTheme) ?? options;\n      this.debug(\">>> AgCharts.createOrUpdate() - applying preset\", options, presetOptions);\n      options = presetOptions;\n    }\n    this.activeTheme = getChartTheme(options.theme);\n    if (this.type) {\n      options = this.activeTheme.templateTheme(options);\n    }\n    this.sanityCheckAndCleanup(options);\n    this.defaultAxes = this.getDefaultAxes(options);\n    this.specialOverrides = this.specialOverridesDefaults({ ...specialOverrides });\n    const {\n      axes: axesThemes = {},\n      annotations: { axesButtons = void 0, ...annotationsThemes } = {},\n      series: _,\n      ...themeDefaults\n    } = this.getSeriesThemeConfig(chartType2);\n    this.processedOptions = deepClone(\n      mergeDefaults(\n        options,\n        axesButtons != null ? { annotations: { axesButtons } } : {},\n        themeDefaults,\n        this.defaultAxes\n      ),\n      cloneOptions\n    );\n    this.processAxesOptions(this.processedOptions, axesThemes);\n    this.processSeriesOptions(this.processedOptions);\n    this.processMiniChartSeriesOptions(this.processedOptions);\n    this.annotationThemes = annotationsThemes;\n    if ((isAgCartesianChartOptions(this.processedOptions) || isAgPolarChartOptionsWithSeriesBasedLegend(this.processedOptions)) && this.processedOptions.legend?.enabled == null) {\n      (_a = this.processedOptions).legend ?? (_a.legend = {});\n      this.processedOptions.legend.enabled = this.processedOptions.series.length > 1;\n    }\n    this.enableConfiguredOptions(this.processedOptions);\n    if (!enterpriseModule.isEnterprise) {\n      removeUsedEnterpriseOptions(this.processedOptions);\n    }\n  }\n  getOptions() {\n    return this.processedOptions ?? {};\n  }\n  diffOptions(options) {\n    return jsonDiff(options, this.processedOptions);\n  }\n  getSeriesThemeConfig(seriesType) {\n    return deepClone(this.activeTheme?.config[seriesType] ?? {});\n  }\n  getDefaultAxes(options) {\n    const optionsType2 = this.optionsType(options);\n    const axesDefaults = seriesRegistry.cloneDefaultAxes(optionsType2);\n    if (seriesRegistry.isDefaultAxisSwapNeeded(options)) {\n      this.swapAxesPosition(axesDefaults);\n    }\n    return axesDefaults;\n  }\n  optionsType(options) {\n    return options.series?.[0]?.type ?? \"line\";\n  }\n  sanityCheckAndCleanup(options) {\n    this.deprecationWarnings(options);\n    this.axesTypeIntegrity(options);\n    this.seriesTypeIntegrity(options);\n    this.soloSeriesIntegrity(options);\n    this.removeDisabledOptions(options);\n    this.removeLeftoverSymbols(options);\n    if (options.series?.some((s) => s.type === \"bullet\") && options.sync != null && options.sync.enabled !== false) {\n      Logger.warnOnce(\"bullet series cannot be synced, disabling synchronization.\");\n      delete options.sync;\n    }\n  }\n  swapAxesPosition(options) {\n    if (isAgCartesianChartOptions(options)) {\n      const [axis0, axis1] = options.axes ?? [];\n      options.axes = [\n        { ...axis0, position: axis1.position },\n        { ...axis1, position: axis0.position }\n      ];\n    }\n  }\n  processAxesOptions(options, axesThemes) {\n    if (!(\"axes\" in options))\n      return;\n    options.axes = options.axes.map((axis) => {\n      const { crossLines: crossLinesTheme, ...axisTheme } = mergeDefaults(\n        axesThemes[axis.type]?.[axis.position],\n        axesThemes[axis.type]\n      );\n      if (axis.crossLines) {\n        axis.crossLines = mergeArrayDefaults(axis.crossLines, crossLinesTheme);\n      }\n      const gridLineStyle = axisTheme.gridLine?.style;\n      if (axis.gridLine?.style && gridLineStyle?.length) {\n        axis.gridLine.style = axis.gridLine.style.map(\n          (style, index) => style.stroke != null || style.lineDash != null ? mergeDefaults(style, gridLineStyle.at(index % gridLineStyle.length)) : style\n        );\n      }\n      const { top: _1, right: _2, bottom: _3, left: _4, ...axisOptions } = mergeDefaults(axis, axisTheme);\n      return axisOptions;\n    });\n  }\n  processSeriesOptions(options) {\n    const defaultSeriesType = this.getDefaultSeriesType(options);\n    const defaultTooltipPosition = this.getTooltipPositionDefaults(options);\n    const userPalette = isObject(options.theme) ? paletteType(options.theme?.palette) : \"inbuilt\";\n    const paletteOptions = {\n      colourIndex: 0,\n      userPalette\n    };\n    const processedSeries = options.series?.map((series) => {\n      series.type ?? (series.type = defaultSeriesType);\n      const { innerLabels: innerLabelsTheme, ...seriesTheme } = this.getSeriesThemeConfig(series.type).series ?? {};\n      const seriesPaletteOptions = unthemedSeries.has(series.type) ? { colourIndex: 0, userPalette } : paletteOptions;\n      const palette12 = this.getSeriesPalette(series.type, seriesPaletteOptions);\n      const defaultTooltipRange = this.getTooltipRangeDefaults(options, series.type);\n      const seriesOptions = mergeDefaults(\n        this.getSeriesGroupingOptions(series),\n        series,\n        defaultTooltipPosition,\n        defaultTooltipRange,\n        seriesTheme,\n        palette12,\n        { visible: true }\n      );\n      if (seriesOptions.innerLabels) {\n        seriesOptions.innerLabels = mergeArrayDefaults(seriesOptions.innerLabels, innerLabelsTheme);\n      }\n      return this.activeTheme.templateTheme(seriesOptions);\n    });\n    options.series = this.setSeriesGroupingOptions(processedSeries ?? []);\n  }\n  processMiniChartSeriesOptions(options) {\n    let miniChartSeries = options.navigator?.miniChart?.series;\n    if (miniChartSeries == null)\n      return;\n    const paletteOptions = {\n      colourIndex: 0,\n      userPalette: isObject(options.theme) ? paletteType(options.theme.palette) : \"inbuilt\"\n    };\n    miniChartSeries = miniChartSeries.map((series) => {\n      series.type ?? (series.type = \"line\");\n      const { innerLabels: _, ...seriesTheme } = this.getSeriesThemeConfig(series.type).series ?? {};\n      const seriesOptions = mergeDefaults(\n        this.getSeriesGroupingOptions(series),\n        series,\n        seriesTheme,\n        this.getSeriesPalette(series.type, paletteOptions)\n      );\n      return this.activeTheme.templateTheme(seriesOptions);\n    });\n    options.navigator.miniChart.series = this.setSeriesGroupingOptions(miniChartSeries);\n  }\n  getSeriesPalette(seriesType, options) {\n    const paletteFactory = seriesRegistry.getPaletteFactory(seriesType);\n    const { colourIndex: colourOffset, userPalette } = options;\n    const { fills = [], strokes = [] } = this.activeTheme.palette;\n    return paletteFactory?.({\n      userPalette,\n      colorsCount: Math.max(fills.length, strokes.length),\n      themeTemplateParameters: this.activeTheme.getTemplateParameters(),\n      palette: this.activeTheme.palette,\n      takeColors(count) {\n        options.colourIndex += count;\n        return {\n          fills: circularSliceArray(fills, count, colourOffset),\n          strokes: circularSliceArray(strokes, count, colourOffset)\n        };\n      }\n    });\n  }\n  getSeriesGroupingOptions(series) {\n    const groupable = seriesRegistry.isGroupable(series.type);\n    const stackable = seriesRegistry.isStackable(series.type);\n    const stackedByDefault = seriesRegistry.isStackedByDefault(series.type);\n    if (series.grouped && !groupable) {\n      Logger.warnOnce(`unsupported grouping of series type \"${series.type}\".`);\n    }\n    if ((series.stacked || series.stackGroup) && !stackable) {\n      Logger.warnOnce(`unsupported stacking of series type \"${series.type}\".`);\n    }\n    let { grouped, stacked } = series;\n    stacked ?? (stacked = (stackedByDefault || series.stackGroup != null) && !(groupable && grouped));\n    grouped ?? (grouped = true);\n    return {\n      stacked: stackable && stacked,\n      grouped: groupable && grouped && !(stackable && stacked)\n    };\n  }\n  setSeriesGroupingOptions(allSeries) {\n    const seriesGroups = this.getSeriesGrouping(allSeries);\n    this.debug(\"setSeriesGroupingOptions() - series grouping: \", seriesGroups);\n    const groupIdx = {};\n    const groupCount2 = seriesGroups.reduce((countMap, seriesGroup) => {\n      var _a;\n      if (seriesGroup.groupType === \"default\" /* DEFAULT */) {\n        return countMap;\n      }\n      countMap[_a = seriesGroup.seriesType] ?? (countMap[_a] = 0);\n      countMap[seriesGroup.seriesType] += seriesGroup.groupType === \"stack\" /* STACK */ ? 1 : seriesGroup.series.length;\n      return countMap;\n    }, {});\n    return seriesGroups.flatMap((seriesGroup) => {\n      var _a;\n      groupIdx[_a = seriesGroup.seriesType] ?? (groupIdx[_a] = 0);\n      switch (seriesGroup.groupType) {\n        case \"stack\" /* STACK */:\n          const groupIndex = groupIdx[seriesGroup.seriesType]++;\n          return seriesGroup.series.map(\n            (series, stackIndex) => Object.assign(series, {\n              seriesGrouping: {\n                groupIndex,\n                groupCount: groupCount2[seriesGroup.seriesType],\n                stackIndex,\n                stackCount: seriesGroup.series.length\n              }\n            })\n          );\n        case \"group\" /* GROUP */:\n          return seriesGroup.series.map(\n            (series) => Object.assign(series, {\n              seriesGrouping: {\n                groupIndex: groupIdx[seriesGroup.seriesType]++,\n                groupCount: groupCount2[seriesGroup.seriesType],\n                stackIndex: 0,\n                stackCount: 0\n              }\n            })\n          );\n      }\n      return seriesGroup.series;\n    }).map(({ stacked: _, grouped: __, ...seriesOptions }) => seriesOptions);\n  }\n  getSeriesGroupId(series) {\n    return [series.type, series.xKey, series.stacked ? series.stackGroup ?? \"stacked\" : \"grouped\"].filter(Boolean).join(\"-\");\n  }\n  getSeriesGrouping(allSeries) {\n    const groupMap = /* @__PURE__ */ new Map();\n    return allSeries.reduce((result, series) => {\n      const seriesType = series.type;\n      if (!series.stacked && !series.grouped) {\n        result.push({ groupType: \"default\" /* DEFAULT */, seriesType, series: [series] });\n      } else {\n        const groupId = this.getSeriesGroupId(series);\n        if (!groupMap.has(groupId)) {\n          const groupType = series.stacked ? \"stack\" /* STACK */ : \"group\" /* GROUP */;\n          const record = { groupType, seriesType, series: [] };\n          groupMap.set(groupId, record);\n          result.push(record);\n        }\n        groupMap.get(groupId).series.push(series);\n      }\n      return result;\n    }, []);\n  }\n  getDefaultSeriesType(options) {\n    if (isAgCartesianChartOptions(options)) {\n      return \"line\";\n    } else if (isAgPolarChartOptions(options)) {\n      return \"pie\";\n    } else if (isAgHierarchyChartOptions(options)) {\n      return \"treemap\";\n    } else if (isAgTopologyChartOptions(options)) {\n      return \"map-shape\";\n    } else if (isAgFlowProportionChartOptions(options)) {\n      return \"sankey\";\n    }\n    throw new Error(\"Invalid chart options type detected.\");\n  }\n  getTooltipPositionDefaults(options) {\n    const position = options.tooltip?.position;\n    if (!isPlainObject(position)) {\n      return;\n    }\n    const { type, xOffset, yOffset } = position;\n    const result = {};\n    if (isString(type) && isEnumValue(AgTooltipPositionType, type)) {\n      result.type = type;\n    }\n    if (isFiniteNumber(xOffset)) {\n      result.xOffset = xOffset;\n    }\n    if (isFiniteNumber(yOffset)) {\n      result.yOffset = yOffset;\n    }\n    return { tooltip: { position: result } };\n  }\n  // AG-11591 Support for new series-specific & legacy chart-global 'tooltip.range' options\n  //\n  // The `chart.series[].tooltip.range` option is a bit different for legacy reason. This use to be\n  // global option (`chart.tooltip.range`) that could override the theme. But now, the tooltip range\n  // option is series-specific.\n  //\n  // To preserve backward compatiblity, the `chart.tooltip.range` theme default has been changed from\n  // 'nearest' to undefined.\n  getTooltipRangeDefaults(options, seriesType) {\n    return {\n      tooltip: {\n        range: options.tooltip?.range ?? seriesRegistry.getTooltipDefauls(seriesType)?.range\n      }\n    };\n  }\n  deprecationWarnings(options) {\n    const deprecatedArrayProps = { yKeys: \"yKey\", yNames: \"yName\" };\n    Object.entries(deprecatedArrayProps).forEach(([oldProp, newProp]) => {\n      if (options.series?.some((s) => s[oldProp] != null)) {\n        Logger.warnOnce(\n          `Property [series.${oldProp}] is deprecated, please use [series.${newProp}] and multiple series instead.`\n        );\n      }\n    });\n  }\n  axesTypeIntegrity(options) {\n    if (\"axes\" in options) {\n      const axes = options.axes ?? [];\n      for (const { type } of axes) {\n        if (!isAxisOptionType(type)) {\n          delete options.axes;\n          const expectedTypes = Array.from(axisRegistry.publicKeys()).join(\", \");\n          Logger.warnOnce(`unknown axis type: ${type}; expected one of: ${expectedTypes}`);\n        }\n      }\n    }\n  }\n  seriesTypeIntegrity(options) {\n    options.series = options.series?.filter(({ type }) => {\n      if (type == null || isSeriesOptionType(type) || isEnterpriseSeriesType(type)) {\n        return true;\n      }\n      Logger.warnOnce(\n        `unknown series type: ${type}; expected one of: ${publicChartTypes.seriesTypes.join(\", \")}`\n      );\n    });\n  }\n  soloSeriesIntegrity(options) {\n    const allSeries = options.series;\n    if (allSeries && allSeries.length > 1 && allSeries.some((series) => seriesRegistry.isSolo(series.type))) {\n      const mainSeriesType = this.optionsType(options);\n      if (seriesRegistry.isSolo(mainSeriesType)) {\n        Logger.warn(\n          `series[0] of type '${mainSeriesType}' is incompatible with other series types. Only processing series[0]`\n        );\n        options.series = allSeries.slice(0, 1);\n      } else {\n        const { solo, nonSolo } = groupBy(\n          allSeries,\n          (s) => seriesRegistry.isSolo(s.type) ? \"solo\" : \"nonSolo\"\n        );\n        const rejects = unique(solo.map((s) => s.type)).join(\", \");\n        Logger.warn(`Unable to mix these series types with the lead series type: ${rejects}`);\n        options.series = nonSolo;\n      }\n    }\n  }\n  enableConfiguredOptions(options) {\n    jsonWalk(\n      this.userOptions,\n      (visitingUserOpts, visitingMergedOpts) => {\n        if (visitingMergedOpts && \"enabled\" in visitingMergedOpts && !visitingMergedOpts._enabledFromTheme && visitingUserOpts.enabled == null) {\n          visitingMergedOpts.enabled = true;\n        }\n      },\n      { skip: [\"data\", \"theme\"] },\n      options\n    );\n    jsonWalk(\n      options,\n      (visitingMergedOpts) => {\n        if (visitingMergedOpts._enabledFromTheme != null) {\n          delete visitingMergedOpts._enabledFromTheme;\n        }\n      },\n      { skip: [\"data\", \"theme\"] }\n    );\n  }\n  removeDisabledOptions(options) {\n    jsonWalk(\n      options,\n      (optionsNode) => {\n        if (\"enabled\" in optionsNode && optionsNode.enabled === false) {\n          Object.keys(optionsNode).forEach((key) => {\n            if (key === \"enabled\")\n              return;\n            delete optionsNode[key];\n          });\n        }\n      },\n      { skip: [\"data\", \"theme\"] }\n    );\n  }\n  removeLeftoverSymbols(options) {\n    jsonWalk(\n      options,\n      (optionsNode) => {\n        if (!optionsNode || !isObject(optionsNode))\n          return;\n        for (const [key, value] of Object.entries(optionsNode)) {\n          if (isSymbol(value)) {\n            delete optionsNode[key];\n          }\n        }\n      },\n      { skip: [\"data\"] }\n    );\n  }\n  specialOverridesDefaults(options) {\n    if (options.window != null) {\n      setWindow(options.window);\n    } else if (typeof window !== \"undefined\") {\n      options.window = window;\n    } else if (typeof global !== \"undefined\") {\n      options.window = global.window;\n    }\n    if (options.document != null) {\n      setDocument(options.document);\n    } else if (typeof document !== \"undefined\") {\n      options.document = document;\n    } else if (typeof global !== \"undefined\") {\n      options.document = global.document;\n    }\n    if (options.window == null) {\n      throw new Error(\"AG Charts - unable to resolve global window\");\n    }\n    if (options.document == null) {\n      throw new Error(\"AG Charts - unable to resolve global document\");\n    }\n    return options;\n  }\n};\n\n// packages/ag-charts-community/src/api/agCharts.ts\nvar debug2 = Debug.create(true, \"opts\");\nfunction chartType(options) {\n  if (isAgCartesianChartOptions(options)) {\n    return \"cartesian\";\n  } else if (isAgPolarChartOptions(options)) {\n    return \"polar\";\n  } else if (isAgHierarchyChartOptions(options)) {\n    return \"hierarchy\";\n  } else if (isAgTopologyChartOptions(options)) {\n    return \"topology\";\n  } else if (isAgFlowProportionChartOptions(options)) {\n    return \"flow-proportion\";\n  }\n  throw new Error(`AG Chart - unknown type of chart for options with type: ${options.type}`);\n}\nvar AgCharts = class {\n  static licenseCheck(options) {\n    if (this.licenseChecked)\n      return;\n    this.licenseManager = enterpriseModule.licenseManager?.(options);\n    this.licenseManager?.setLicenseKey(this.licenseKey, this.gridContext);\n    this.licenseManager?.validateLicense();\n    this.licenseChecked = true;\n  }\n  static setLicenseKey(licenseKey) {\n    this.licenseKey = licenseKey;\n  }\n  static setGridContext(gridContext) {\n    this.gridContext = gridContext;\n  }\n  static getLicenseDetails(licenseKey) {\n    return enterpriseModule.licenseManager?.({}).getLicenseDetails(licenseKey);\n  }\n  /**\n   * Returns the `AgChartInstance` for a DOM node, if there is one.\n   */\n  static getInstance(element2) {\n    return AgChartsInternal.getInstance(element2);\n  }\n  /**\n   * Create a new `AgChartInstance` based upon the given configuration options.\n   */\n  static create(options) {\n    this.licenseCheck(options);\n    const chart = AgChartsInternal.createOrUpdate(options);\n    if (this.licenseManager?.isDisplayWatermark()) {\n      enterpriseModule.injectWatermark?.(chart.chart.ctx.domManager, this.licenseManager.getWatermarkMessage());\n    }\n    return chart;\n  }\n  static createFinancialChart(options) {\n    return this.create({\n      _type: \"price-volume\",\n      ...options\n    });\n  }\n};\nAgCharts.licenseChecked = false;\nAgCharts.gridContext = false;\nvar _AgChartsInternal = class _AgChartsInternal {\n  static getInstance(element2) {\n    const chart = Chart.getInstance(element2);\n    return chart ? AgChartInstanceProxy.chartInstances.get(chart) : void 0;\n  }\n  static initialiseModules() {\n    if (_AgChartsInternal.initialised)\n      return;\n    registerInbuiltModules();\n    setupModules();\n    _AgChartsInternal.initialised = true;\n  }\n  static createOrUpdate(options, proxy) {\n    _AgChartsInternal.initialiseModules();\n    debug2(\">>> AgCharts.createOrUpdate() user options\", options);\n    const defaultType = proxy?.chart.chartOptions.type;\n    const { _type = defaultType, ...otherOptions } = options;\n    let mutableOptions = otherOptions;\n    if (AgCharts.optionsMutationFn) {\n      mutableOptions = AgCharts.optionsMutationFn(mutableOptions, _type);\n      debug2(\">>> AgCharts.createOrUpdate() MUTATED user options\", options);\n    }\n    const { overrideDevicePixelRatio, document: document2, window: userWindow, ...userOptions } = mutableOptions;\n    const chartOptions = new ChartOptions(userOptions, {\n      overrideDevicePixelRatio,\n      document: document2,\n      window: userWindow,\n      type: _type\n    });\n    let chart = proxy?.chart;\n    if (chart == null || chartType(userOptions) !== chartType(chart?.chartOptions.processedOptions)) {\n      chart = _AgChartsInternal.createChartInstance(chartOptions, chart);\n    }\n    if (proxy == null) {\n      proxy = new AgChartInstanceProxy(chart, _AgChartsInternal.callbackApi);\n    } else {\n      proxy.chart = chart;\n    }\n    if (debug2.check() && typeof window !== \"undefined\") {\n      window.agChartInstances ?? (window.agChartInstances = {});\n      window.agChartInstances[chart.id] = chart;\n    }\n    chart.queuedUserOptions.push(userOptions);\n    chart.requestFactoryUpdate((chartRef) => {\n      chartRef.applyOptions(chartOptions);\n      const queueIdx = chartRef.queuedUserOptions.indexOf(userOptions) + 1;\n      chartRef.queuedUserOptions.splice(0, queueIdx);\n      chartRef.applyInitialState();\n    });\n    return proxy;\n  }\n  static updateUserDelta(proxy, deltaOptions) {\n    deltaOptions = deepClone(deltaOptions, { shallow: [\"data\"] });\n    jsonWalk(\n      deltaOptions,\n      (node) => {\n        if (typeof node !== \"object\")\n          return;\n        for (const [key, value] of Object.entries(node)) {\n          if (typeof value === \"undefined\") {\n            Object.assign(node, { [key]: Symbol(\"UNSET\") });\n          }\n        }\n      },\n      { skip: [\"data\"] }\n    );\n    const { chart } = proxy;\n    const lastUpdateOptions = chart.getOptions();\n    const userOptions = mergeDefaults(deltaOptions, lastUpdateOptions);\n    debug2(\">>> AgCharts.updateUserDelta() user delta\", deltaOptions);\n    debug2(\"AgCharts.updateUserDelta() - base options\", lastUpdateOptions);\n    _AgChartsInternal.createOrUpdate(userOptions, proxy);\n  }\n  static createChartInstance(options, oldChart) {\n    const transferableResource = oldChart?.destroy({ keepTransferableResources: true });\n    const ChartConstructor = _AgChartsInternal.getChartByOptions(options.processedOptions);\n    return new ChartConstructor(options, transferableResource);\n  }\n  static getChartByOptions(options) {\n    if (isAgCartesianChartOptions(options)) {\n      return CartesianChart;\n    } else if (isAgHierarchyChartOptions(options)) {\n      return HierarchyChart;\n    } else if (isAgPolarChartOptions(options)) {\n      return PolarChart;\n    } else if (isAgTopologyChartOptions(options)) {\n      return TopologyChart;\n    } else if (isAgFlowProportionChartOptions(options)) {\n      return FlowProportionChart;\n    }\n    throw new Error(\n      `AG Charts - couldn't apply configuration, check options are correctly structured and series types are specified`\n    );\n  }\n};\n_AgChartsInternal.caretaker = new MementoCaretaker(VERSION);\n_AgChartsInternal.initialised = false;\n_AgChartsInternal.callbackApi = {\n  caretaker: _AgChartsInternal.caretaker,\n  createOrUpdate(opts, chart) {\n    return _AgChartsInternal.createOrUpdate(opts, chart);\n  },\n  updateUserDelta(chart, deltaOptions) {\n    return _AgChartsInternal.updateUserDelta(chart, deltaOptions);\n  }\n};\nvar AgChartsInternal = _AgChartsInternal;\n\n// packages/ag-charts-community/src/integrated-charts-scene.ts\nvar integrated_charts_scene_exports = {};\n__export(integrated_charts_scene_exports, {\n  Arc: () => Arc2,\n  BBox: () => BBox,\n  BandScale: () => BandScale,\n  Caption: () => Caption,\n  ChangeDetectableProperties: () => ChangeDetectableProperties,\n  Circle: () => Circle,\n  ContinuousScale: () => ContinuousScale,\n  Diamond: () => Diamond,\n  DropShadow: () => DropShadow,\n  ExtendedPath2D: () => ExtendedPath2D,\n  Group: () => Group,\n  HdpiCanvas: () => HdpiCanvas,\n  Image: () => Image,\n  Label: () => Label,\n  Line: () => Line,\n  LinearGradientFill: () => LinearGradientFill,\n  LinearScale: () => LinearScale,\n  Marker: () => Marker,\n  Node: () => Node,\n  OrdinalTimeScale: () => OrdinalTimeScale,\n  Path: () => Path,\n  PointerEvents: () => PointerEvents,\n  RadialColumnShape: () => RadialColumnShape,\n  Rect: () => Rect,\n  RedrawType: () => RedrawType,\n  Scene: () => Scene,\n  SceneChangeDetection: () => SceneChangeDetection,\n  ScenePathChangeDetection: () => ScenePathChangeDetection,\n  Sector: () => Sector,\n  SectorBox: () => SectorBox,\n  Selection: () => Selection,\n  Shape: () => Shape,\n  Square: () => Square,\n  Text: () => Text,\n  Tooltip: () => Tooltip,\n  Triangle: () => Triangle,\n  easing: () => easing_exports,\n  getFont: () => getFont,\n  getMarker: () => getMarker,\n  getRadialColumnWidth: () => getRadialColumnWidth,\n  motion: () => motion,\n  sectorBox: () => sectorBox,\n  toRadians: () => toRadians,\n  toTooltipHtml: () => toTooltipHtml\n});\n\n// packages/ag-charts-community/src/scene/shape/arc.ts\nvar Arc2 = class extends Path {\n  constructor() {\n    super();\n    this.centerX = 0;\n    this.centerY = 0;\n    this.radius = 10;\n    this.startAngle = 0;\n    this.endAngle = Math.PI * 2;\n    this.counterClockwise = false;\n    this.type = 0 /* Open */;\n    this.restoreOwnStyles();\n  }\n  get fullPie() {\n    return isEqual(normalizeAngle360(this.startAngle), normalizeAngle360(this.endAngle));\n  }\n  updatePath() {\n    const path = this.path;\n    path.clear();\n    path.arc(this.centerX, this.centerY, this.radius, this.startAngle, this.endAngle, this.counterClockwise);\n    if (this.type === 1 /* Chord */) {\n      path.closePath();\n    } else if (this.type === 2 /* Round */ && !this.fullPie) {\n      path.lineTo(this.centerX, this.centerY);\n      path.closePath();\n    }\n  }\n  computeBBox() {\n    return new BBox(this.centerX - this.radius, this.centerY - this.radius, this.radius * 2, this.radius * 2);\n  }\n  isPointInPath(x, y) {\n    const point = this.transformPoint(x, y);\n    const bbox = this.computeBBox();\n    return this.type !== 0 /* Open */ && bbox.containsPoint(point.x, point.y) && this.path.isPointInPath(point.x, point.y);\n  }\n};\nArc2.className = \"Arc\";\nArc2.defaultStyles = Object.assign({}, Shape.defaultStyles, {\n  lineWidth: 1,\n  fillStyle: null\n});\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"centerX\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"centerY\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"radius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"startAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"endAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"counterClockwise\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"type\", 2);\n\n// packages/ag-charts-community/src/scene/shape/linearGradientFill.ts\nvar LinearGradientFill = class extends Shape {\n  constructor() {\n    super(...arguments);\n    this.direction = \"to-right\";\n    this.stops = void 0;\n    this._mask = void 0;\n  }\n  get mask() {\n    return this._mask;\n  }\n  set mask(newMask) {\n    if (this._mask != null) {\n      this.removeChild(this._mask);\n    }\n    if (newMask != null) {\n      this.appendChild(newMask);\n    }\n    this._mask = newMask;\n  }\n  isPointInPath(x, y) {\n    return this.mask?.isPointInPath(x, y) ?? false;\n  }\n  computeBBox() {\n    return this.mask?.computeBBox();\n  }\n  render(renderCtx) {\n    const { mask, stops } = this;\n    const { ctx, devicePixelRatio } = renderCtx;\n    const pixelLength = 1 / devicePixelRatio;\n    const maskBbox = mask?.computeTransformedBBox();\n    if (mask == null || stops == null || maskBbox == null)\n      return;\n    if (mask.dirtyPath) {\n      mask.updatePath();\n      mask.dirtyPath = false;\n    }\n    ctx.save();\n    ctx.clip(mask.path.getPath2D());\n    ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);\n    const x0 = Math.floor(maskBbox.x);\n    const x1 = Math.ceil(maskBbox.x + maskBbox.width);\n    const y0 = Math.floor(maskBbox.y);\n    const y1 = Math.ceil(maskBbox.y + maskBbox.height);\n    const horizontal = this.direction === \"to-right\" || this.direction === \"to-left\";\n    const reversed = this.direction === \"to-top\" || this.direction === \"to-left\";\n    const colorScale = new ColorScale();\n    const [i0, i1] = horizontal ? [x0, x1] : [y0, y1];\n    colorScale.domain = stops.map((_, index) => {\n      return i0 + (i1 - i0) * index / (stops.length - 1);\n    });\n    colorScale.range = reversed ? stops.slice().reverse() : stops;\n    colorScale.update();\n    const height = y1 - y0;\n    const width = x1 - x0;\n    switch (this.direction) {\n      case \"to-right\":\n      case \"to-left\":\n        for (let x = x0; x <= x1; x += pixelLength) {\n          ctx.fillStyle = colorScale.convert(x);\n          ctx.fillRect(x, y0, pixelLength, height);\n        }\n        break;\n      case \"to-bottom\":\n      case \"to-top\":\n        for (let y = y0; y <= y1; y += pixelLength) {\n          ctx.fillStyle = colorScale.convert(y);\n          ctx.fillRect(x0, y, width, pixelLength);\n        }\n        break;\n    }\n    ctx.restore();\n  }\n};\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], LinearGradientFill.prototype, \"direction\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], LinearGradientFill.prototype, \"stops\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], LinearGradientFill.prototype, \"_mask\", 2);\n\n// packages/ag-charts-community/src/scene/shape/radialColumnShape.ts\nfunction rotatePoint(x, y, rotation) {\n  const radius = Math.sqrt(x ** 2 + y ** 2);\n  const angle2 = Math.atan2(y, x);\n  const rotated = angle2 + rotation;\n  return {\n    x: Math.cos(rotated) * radius,\n    y: Math.sin(rotated) * radius\n  };\n}\nvar RadialColumnShape = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.isBeveled = true;\n    this.columnWidth = 0;\n    this.startAngle = 0;\n    this.endAngle = 0;\n    this.outerRadius = 0;\n    this.innerRadius = 0;\n    this.axisInnerRadius = 0;\n    this.axisOuterRadius = 0;\n    this.isRadiusAxisReversed = false;\n  }\n  set cornerRadius(_value) {\n  }\n  computeBBox() {\n    const { innerRadius, outerRadius, columnWidth } = this;\n    const rotation = this.getRotation();\n    const left = -columnWidth / 2;\n    const right = columnWidth / 2;\n    const top = -outerRadius;\n    const bottom = -innerRadius;\n    let x0 = Infinity;\n    let y0 = Infinity;\n    let x1 = -Infinity;\n    let y1 = -Infinity;\n    for (let i = 0; i < 4; i += 1) {\n      const { x, y } = rotatePoint(i % 2 === 0 ? left : right, i < 2 ? top : bottom, rotation);\n      x0 = Math.min(x, x0);\n      y0 = Math.min(y, y0);\n      x1 = Math.max(x, x1);\n      y1 = Math.max(y, y1);\n    }\n    return new BBox(x0, y0, x1 - x0, y1 - y0);\n  }\n  getRotation() {\n    const { startAngle, endAngle } = this;\n    const midAngle = angleBetween(startAngle, endAngle);\n    return normalizeAngle360(startAngle + midAngle / 2 + Math.PI / 2);\n  }\n  updatePath() {\n    const { isBeveled } = this;\n    if (isBeveled) {\n      this.updateBeveledPath();\n    } else {\n      this.updateRectangularPath();\n    }\n    this.checkPathDirty();\n  }\n  updateRectangularPath() {\n    const { columnWidth, innerRadius, outerRadius, path } = this;\n    const left = -columnWidth / 2;\n    const right = columnWidth / 2;\n    const top = -outerRadius;\n    const bottom = -innerRadius;\n    const rotation = this.getRotation();\n    const points = [\n      [left, bottom],\n      [left, top],\n      [right, top],\n      [right, bottom]\n    ].map(([x, y]) => rotatePoint(x, y, rotation));\n    path.clear(true);\n    path.moveTo(points[0].x, points[0].y);\n    path.lineTo(points[1].x, points[1].y);\n    path.lineTo(points[2].x, points[2].y);\n    path.lineTo(points[3].x, points[3].y);\n    path.closePath();\n  }\n  updateBeveledPath() {\n    const { columnWidth, path, outerRadius, innerRadius, axisInnerRadius, axisOuterRadius, isRadiusAxisReversed } = this;\n    const isStackBottom = isEqual(innerRadius, axisInnerRadius);\n    const sideRotation = Math.asin(columnWidth / 2 / innerRadius);\n    const pointRotation = this.getRotation();\n    const rotate2 = (x, y) => rotatePoint(x, y, pointRotation);\n    const getTriangleHypotenuse = (leg, otherLeg) => Math.sqrt(leg ** 2 + otherLeg ** 2);\n    const getTriangleLeg = (hypotenuse, otherLeg) => {\n      if (otherLeg > hypotenuse) {\n        return 0;\n      }\n      return Math.sqrt(hypotenuse ** 2 - otherLeg ** 2);\n    };\n    const compare = (value, otherValue, lessThan) => lessThan ? value < otherValue : value > otherValue;\n    const shouldConnectBottomCircle = isStackBottom && !isNaN(sideRotation) && sideRotation < Math.PI / 6;\n    let left = -columnWidth / 2;\n    let right = columnWidth / 2;\n    const top = -outerRadius;\n    const bottom = -innerRadius * (shouldConnectBottomCircle ? Math.cos(sideRotation) : 1);\n    const hasBottomIntersection = compare(\n      axisOuterRadius,\n      getTriangleHypotenuse(innerRadius, columnWidth / 2),\n      !isRadiusAxisReversed\n    );\n    if (hasBottomIntersection) {\n      const bottomIntersectionX = getTriangleLeg(axisOuterRadius, innerRadius);\n      left = -bottomIntersectionX;\n      right = bottomIntersectionX;\n    }\n    path.clear(true);\n    const bottomLeftPt = rotate2(left, bottom);\n    path.moveTo(bottomLeftPt.x, bottomLeftPt.y);\n    const isEmpty = isEqual(innerRadius, outerRadius);\n    const hasSideIntersection = compare(\n      axisOuterRadius,\n      getTriangleHypotenuse(outerRadius, columnWidth / 2),\n      !isRadiusAxisReversed\n    );\n    if (isEmpty && shouldConnectBottomCircle) {\n      path.arc(\n        0,\n        0,\n        innerRadius,\n        normalizeAngle360(-sideRotation - Math.PI / 2) + pointRotation,\n        normalizeAngle360(sideRotation - Math.PI / 2) + pointRotation,\n        false\n      );\n    } else if (hasSideIntersection) {\n      const sideIntersectionY = -getTriangleLeg(axisOuterRadius, columnWidth / 2);\n      const topIntersectionX = getTriangleLeg(axisOuterRadius, outerRadius);\n      if (!hasBottomIntersection) {\n        const topLeftPt = rotate2(left, sideIntersectionY);\n        path.lineTo(topLeftPt.x, topLeftPt.y);\n      }\n      path.arc(\n        0,\n        0,\n        axisOuterRadius,\n        Math.atan2(sideIntersectionY, left) + pointRotation,\n        Math.atan2(top, -topIntersectionX) + pointRotation,\n        false\n      );\n      if (!isEqual(topIntersectionX, 0)) {\n        const topRightBevelPt = rotate2(topIntersectionX, top);\n        path.lineTo(topRightBevelPt.x, topRightBevelPt.y);\n      }\n      path.arc(\n        0,\n        0,\n        axisOuterRadius,\n        Math.atan2(top, topIntersectionX) + pointRotation,\n        Math.atan2(sideIntersectionY, right) + pointRotation,\n        false\n      );\n    } else {\n      const topLeftPt = rotate2(left, top);\n      const topRightPt = rotate2(right, top);\n      path.lineTo(topLeftPt.x, topLeftPt.y);\n      path.lineTo(topRightPt.x, topRightPt.y);\n    }\n    const bottomRightPt = rotate2(right, bottom);\n    path.lineTo(bottomRightPt.x, bottomRightPt.y);\n    if (shouldConnectBottomCircle) {\n      path.arc(\n        0,\n        0,\n        innerRadius,\n        normalizeAngle360(sideRotation - Math.PI / 2) + pointRotation,\n        normalizeAngle360(-sideRotation - Math.PI / 2) + pointRotation,\n        true\n      );\n    } else {\n      const rotatedBottomLeftPt = rotate2(left, bottom);\n      path.lineTo(rotatedBottomLeftPt.x, rotatedBottomLeftPt.y);\n    }\n    path.closePath();\n  }\n};\nRadialColumnShape.className = \"RadialColumnShape\";\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"isBeveled\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"columnWidth\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"startAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"endAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"outerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"innerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"axisInnerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"axisOuterRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"isRadiusAxisReversed\", 2);\nfunction getRadialColumnWidth(startAngle, endAngle, axisOuterRadius, columnWidthRatio, maxColumnWidthRatio) {\n  const rotation = angleBetween(startAngle, endAngle);\n  const pad2 = rotation * (1 - columnWidthRatio) / 2;\n  startAngle += pad2;\n  endAngle -= pad2;\n  if (rotation < 1e-3) {\n    return 2 * axisOuterRadius * maxColumnWidthRatio;\n  }\n  if (rotation >= 2 * Math.PI) {\n    const midAngle = startAngle + rotation / 2;\n    startAngle = midAngle - Math.PI;\n    endAngle = midAngle + Math.PI;\n  }\n  const startX = axisOuterRadius * Math.cos(startAngle);\n  const startY = axisOuterRadius * Math.sin(startAngle);\n  const endX = axisOuterRadius * Math.cos(endAngle);\n  const endY = axisOuterRadius * Math.sin(endAngle);\n  const colWidth = Math.floor(Math.sqrt((startX - endX) ** 2 + (startY - endY) ** 2));\n  const maxWidth = 2 * axisOuterRadius * maxColumnWidthRatio;\n  return Math.max(1, Math.min(maxWidth, colWidth));\n}\n\n// packages/ag-charts-community/src/scene/image.ts\nvar Image = class extends Node {\n  constructor(sourceImage) {\n    super();\n    this.x = 0;\n    this.y = 0;\n    this.width = 0;\n    this.height = 0;\n    this.opacity = 1;\n    this.sourceImage = sourceImage;\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped++;\n      return;\n    }\n    this.computeTransformMatrix();\n    this.matrix.toContext(ctx);\n    const image = this.sourceImage;\n    ctx.globalAlpha = this.opacity;\n    ctx.drawImage(image, 0, 0, image.width, image.height, this.x, this.y, this.width, this.height);\n    super.render(renderCtx);\n  }\n};\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"x\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"y\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"width\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"height\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"opacity\", 2);\n\n// packages/ag-charts-community/src/integrated-charts-scene.ts\nvar motion = { ...fromToMotion_exports, ...resetMotion_exports };\n\n// packages/ag-charts-community/src/integrated-charts-theme.ts\nvar integrated_charts_theme_exports = {};\n__export(integrated_charts_theme_exports, {\n  CARTESIAN_AXIS_TYPE: () => CARTESIAN_AXIS_TYPE,\n  ChartTheme: () => ChartTheme,\n  DEFAULT_ANNOTATION_BACKGROUND_FILL: () => DEFAULT_ANNOTATION_BACKGROUND_FILL,\n  DEFAULT_ANNOTATION_HANDLE_FILL: () => DEFAULT_ANNOTATION_HANDLE_FILL,\n  DEFAULT_ANNOTATION_STROKE: () => DEFAULT_ANNOTATION_STROKE,\n  DEFAULT_AXIS_GRID_COLOUR: () => DEFAULT_AXIS_GRID_COLOUR,\n  DEFAULT_AXIS_LINE_COLOUR: () => DEFAULT_AXIS_LINE_COLOUR,\n  DEFAULT_BACKGROUND_COLOUR: () => DEFAULT_BACKGROUND_COLOUR,\n  DEFAULT_CAPTION_ALIGNMENT: () => DEFAULT_CAPTION_ALIGNMENT,\n  DEFAULT_CAPTION_LAYOUT_STYLE: () => DEFAULT_CAPTION_LAYOUT_STYLE,\n  DEFAULT_COLOURS: () => DEFAULT_COLOURS,\n  DEFAULT_CROSS_LINES_COLOUR: () => DEFAULT_CROSS_LINES_COLOUR,\n  DEFAULT_DIVERGING_SERIES_COLOUR_RANGE: () => DEFAULT_DIVERGING_SERIES_COLOUR_RANGE,\n  DEFAULT_FONT_FAMILY: () => DEFAULT_FONT_FAMILY,\n  DEFAULT_GRIDLINE_ENABLED: () => DEFAULT_GRIDLINE_ENABLED,\n  DEFAULT_HIERARCHY_FILLS: () => DEFAULT_HIERARCHY_FILLS,\n  DEFAULT_HIERARCHY_STROKES: () => DEFAULT_HIERARCHY_STROKES,\n  DEFAULT_INSIDE_SERIES_LABEL_COLOUR: () => DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n  DEFAULT_INVERTED_LABEL_COLOUR: () => DEFAULT_INVERTED_LABEL_COLOUR,\n  DEFAULT_LABEL_COLOUR: () => DEFAULT_LABEL_COLOUR,\n  DEFAULT_MUTED_LABEL_COLOUR: () => DEFAULT_MUTED_LABEL_COLOUR,\n  DEFAULT_PADDING: () => DEFAULT_PADDING,\n  DEFAULT_POLAR_SERIES_STROKE: () => DEFAULT_POLAR_SERIES_STROKE,\n  DEFAULT_SHADOW_COLOUR: () => DEFAULT_SHADOW_COLOUR,\n  DEFAULT_TOOLBAR_POSITION: () => DEFAULT_TOOLBAR_POSITION,\n  FONT_SIZE: () => FONT_SIZE,\n  FONT_WEIGHT: () => FONT_WEIGHT2,\n  IS_DARK_THEME: () => IS_DARK_THEME,\n  PALETTE_DOWN_FILL: () => PALETTE_DOWN_FILL,\n  PALETTE_DOWN_STROKE: () => PALETTE_DOWN_STROKE,\n  PALETTE_NEUTRAL_FILL: () => PALETTE_NEUTRAL_FILL,\n  PALETTE_NEUTRAL_STROKE: () => PALETTE_NEUTRAL_STROKE,\n  PALETTE_UP_FILL: () => PALETTE_UP_FILL,\n  PALETTE_UP_STROKE: () => PALETTE_UP_STROKE,\n  POLAR_AXIS_SHAPE: () => POLAR_AXIS_SHAPE,\n  POLAR_AXIS_TYPE: () => POLAR_AXIS_TYPE,\n  POSITION: () => POSITION2,\n  getChartTheme: () => getChartTheme,\n  markerPaletteFactory: () => markerPaletteFactory,\n  singleSeriesPaletteFactory: () => singleSeriesPaletteFactory,\n  themes: () => themes2\n});\nvar themes2 = mapValues(\n  themes,\n  (themeFactory) => themeFactory?.()\n);\n\n// packages/ag-charts-community/src/sparklines-scale.ts\nvar sparklines_scale_exports = {};\n__export(sparklines_scale_exports, {\n  BandScale: () => BandScale,\n  ColorScale: () => ColorScale,\n  ContinuousScale: () => ContinuousScale,\n  Invalidating: () => Invalidating,\n  LinearScale: () => LinearScale,\n  OrdinalTimeScale: () => OrdinalTimeScale,\n  TimeScale: () => TimeScale\n});\n\n// packages/ag-charts-community/src/sparklines-util.ts\nvar sparklines_util_exports = {};\n__export(sparklines_util_exports, {\n  Color: () => Color,\n  Debug: () => Debug,\n  Logger: () => Logger,\n  Padding: () => Padding,\n  TimeInterval: () => TimeInterval,\n  Vec2: () => Vec2,\n  angleBetween: () => angleBetween,\n  angleDiff: () => angleDiff,\n  areArrayItemsStrictlyEqual: () => areArrayItemsStrictlyEqual,\n  areArrayNumbersEqual: () => areArrayNumbersEqual,\n  bifurcate: () => bifurcate,\n  checkDatum: () => checkDatum,\n  clamp: () => clamp,\n  clampArray: () => clampArray,\n  countFractionDigits: () => countFractionDigits,\n  createId: () => createId,\n  day: () => day,\n  deepClone: () => deepClone,\n  displacePointFromVector: () => displacePointFromVector,\n  extent: () => extent,\n  findMinMax: () => findMinMax,\n  findRangeExtent: () => findRangeExtent,\n  formatNormalizedPercentage: () => formatNormalizedPercentage,\n  formatPercentage: () => formatPercentage,\n  friday: () => friday,\n  hour: () => hour,\n  interpolateColor: () => interpolateColor,\n  interpolateNumber: () => interpolateNumber,\n  isBetweenAngles: () => isBetweenAngles,\n  isContinuous: () => isContinuous,\n  isDate: () => isValidDate,\n  isDenseInterval: () => isDenseInterval,\n  isEqual: () => isEqual,\n  isNegative: () => isNegative,\n  isNumber: () => isFiniteNumber,\n  isNumberEqual: () => isEqual,\n  isNumberObject: () => isNumberObject,\n  isString: () => isString,\n  isStringObject: () => isStringObject,\n  jsonApply: () => jsonApply,\n  jsonDiff: () => jsonDiff,\n  jsonWalk: () => jsonWalk,\n  millisecond: () => millisecond,\n  minute: () => minute,\n  mod: () => mod,\n  monday: () => monday,\n  month: () => month,\n  normalisedExtent: () => normalisedExtent,\n  normalisedExtentWithMetadata: () => normalisedExtentWithMetadata,\n  normalizeAngle180: () => normalizeAngle180,\n  normalizeAngle360: () => normalizeAngle360,\n  normalizeAngle360Inclusive: () => normalizeAngle360Inclusive,\n  range: () => range,\n  resetIds: () => resetIds,\n  round: () => round,\n  sanitizeHtml: () => sanitizeHtml,\n  saturday: () => saturday,\n  second: () => second,\n  setAttribute: () => setAttribute,\n  shallowClone: () => shallowClone,\n  sunday: () => sunday,\n  thursday: () => thursday,\n  tickFormat: () => tickFormat,\n  tickStep: () => tickStep,\n  ticks: () => createTicks,\n  toDegrees: () => toDegrees,\n  toFixed: () => toFixed,\n  toRadians: () => toRadians,\n  transformIntegratedCategoryValue: () => transformIntegratedCategoryValue,\n  tuesday: () => tuesday,\n  utcDay: () => utcDay,\n  utcHour: () => utcHour,\n  utcMinute: () => utcMinute,\n  utcMonth: () => utcMonth,\n  utcYear: () => utcYear,\n  uuid: () => uuid,\n  wednesday: () => wednesday,\n  year: () => year,\n  zipObject: () => zipObject\n});\n\n// packages/ag-charts-community/src/util/vector.ts\nvar Vec2 = {\n  add,\n  angle,\n  apply,\n  equal,\n  distance: distance2,\n  distanceSquared: distanceSquared2,\n  from,\n  fromOffset,\n  length,\n  lengthSquared,\n  required,\n  rotate,\n  sub\n};\nfunction add(a, b) {\n  return { x: a.x + b.x, y: a.y + b.y };\n}\nfunction sub(a, b) {\n  return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction length(a) {\n  return Math.sqrt(a.x * a.x + a.y * a.y);\n}\nfunction lengthSquared(a) {\n  return a.x * a.x + a.y * a.y;\n}\nfunction distance2(a, b) {\n  const d = sub(a, b);\n  return Math.sqrt(d.x * d.x + d.y * d.y);\n}\nfunction distanceSquared2(a, b) {\n  const d = sub(a, b);\n  return d.x * d.x + d.y * d.y;\n}\nfunction angle(a, b) {\n  return Math.atan2(a.y, a.x) - Math.atan2(b.y, b.x);\n}\nfunction rotate(a, theta, b = required()) {\n  const l = Vec2.length(a);\n  return { x: b.x + l * Math.cos(theta), y: b.y + l * Math.sin(theta) };\n}\nfunction equal(a, b) {\n  return a.x === b.x && a.y === b.y;\n}\nfunction from(x, y) {\n  return { x, y };\n}\nfunction fromOffset(a) {\n  return { x: a.offsetX, y: a.offsetY };\n}\nfunction apply(a, b) {\n  a.x = b.x;\n  a.y = b.y;\n  return a;\n}\nfunction required(a) {\n  return { x: a?.x ?? 0, y: a?.y ?? 0 };\n}\n\n// packages/ag-charts-community/src/util/zip.ts\nfunction zipObject(keys, values) {\n  const zipped = {};\n  if (Array.isArray(values)) {\n    for (let i = 0; i < keys.length; i++) {\n      zipped[`${keys[i]}`] = values[i];\n    }\n  } else {\n    for (let i = 0; i < keys.length; i++) {\n      zipped[`${keys[i]}`] = values;\n    }\n  }\n  return zipped;\n}\n\n// packages/ag-charts-community/src/module-support.ts\nvar module_support_exports = {};\n__export(module_support_exports, {\n  AND: () => AND,\n  ARRAY: () => ARRAY,\n  ARRAY_OF: () => ARRAY_OF,\n  AbstractBarSeries: () => AbstractBarSeries,\n  AbstractBarSeriesProperties: () => AbstractBarSeriesProperties,\n  ActionOnSet: () => ActionOnSet,\n  Animation: () => Animation,\n  AnimationManager: () => AnimationManager,\n  AreaSeriesTag: () => AreaSeriesTag,\n  Axis: () => Axis,\n  AxisInterval: () => AxisInterval,\n  AxisLabel: () => AxisLabel,\n  AxisTick: () => AxisTick,\n  BOOLEAN: () => BOOLEAN,\n  BOOLEAN_ARRAY: () => BOOLEAN_ARRAY,\n  Background: () => Background,\n  BackgroundModule: () => BackgroundModule,\n  BaseModuleInstance: () => BaseModuleInstance,\n  BaseProperties: () => BaseProperties,\n  COLOR_STRING: () => COLOR_STRING,\n  COLOR_STRING_ARRAY: () => COLOR_STRING_ARRAY,\n  CartesianAxis: () => CartesianAxis,\n  CartesianSeries: () => CartesianSeries,\n  CartesianSeriesNodeEvent: () => CartesianSeriesNodeEvent,\n  CartesianSeriesProperties: () => CartesianSeriesProperties,\n  CategoryAxis: () => CategoryAxis,\n  ChartAxisDirection: () => ChartAxisDirection,\n  ChartEventManager: () => ChartEventManager,\n  ChartOptions: () => ChartOptions,\n  ChartUpdateType: () => ChartUpdateType,\n  ContextMenuRegistry: () => ContextMenuRegistry,\n  Cursor: () => Cursor,\n  CursorManager: () => CursorManager,\n  DATE: () => DATE,\n  DATE_ARRAY: () => DATE_ARRAY,\n  DATE_OR_DATETIME_MS: () => DATE_OR_DATETIME_MS,\n  DEFAULT_CARTESIAN_DIRECTION_KEYS: () => DEFAULT_CARTESIAN_DIRECTION_KEYS,\n  DEFAULT_CARTESIAN_DIRECTION_NAMES: () => DEFAULT_CARTESIAN_DIRECTION_NAMES,\n  DEFAULT_TOOLTIP_CLASS: () => DEFAULT_TOOLTIP_CLASS,\n  DEFAULT_TOOLTIP_DARK_CLASS: () => DEFAULT_TOOLTIP_DARK_CLASS,\n  DEGREE: () => DEGREE,\n  DIRECTION: () => DIRECTION,\n  DOMManager: () => DOMManager,\n  DataController: () => DataController,\n  DataModel: () => DataModel,\n  DataModelSeries: () => DataModelSeries,\n  DataService: () => DataService,\n  Default: () => Default,\n  Deprecated: () => Deprecated,\n  DeprecatedAndRenamedTo: () => DeprecatedAndRenamedTo,\n  EMPTY_TOOLTIP_CONTENT: () => EMPTY_TOOLTIP_CONTENT,\n  FONT_STYLE: () => FONT_STYLE,\n  FONT_WEIGHT: () => FONT_WEIGHT,\n  FUNCTION: () => FUNCTION,\n  GREATER_THAN: () => GREATER_THAN,\n  GestureDetector: () => GestureDetector,\n  GroupedCategoryAxis: () => GroupedCategoryAxis,\n  HierarchyNode: () => HierarchyNode,\n  HierarchySeries: () => HierarchySeries,\n  HierarchySeriesProperties: () => HierarchySeriesProperties,\n  HighlightManager: () => HighlightManager,\n  HighlightStyle: () => HighlightStyle,\n  INTERACTION_RANGE: () => INTERACTION_RANGE,\n  INTERPOLATION_STEP_POSITION: () => INTERPOLATION_STEP_POSITION,\n  INTERPOLATION_TYPE: () => INTERPOLATION_TYPE,\n  InteractionManager: () => InteractionManager,\n  InteractionState: () => InteractionState,\n  InterpolationProperties: () => InterpolationProperties,\n  KeyNavManager: () => KeyNavManager,\n  LABEL_PLACEMENT: () => LABEL_PLACEMENT,\n  LARGEST_KEY_INTERVAL: () => LARGEST_KEY_INTERVAL,\n  LESS_THAN: () => LESS_THAN,\n  LINE_CAP: () => LINE_CAP,\n  LINE_DASH: () => LINE_DASH,\n  LINE_JOIN: () => LINE_JOIN,\n  Layers: () => Layers,\n  LayoutService: () => LayoutService,\n  LonLatBBox: () => LonLatBBox,\n  MARKER_SHAPE: () => MARKER_SHAPE,\n  MATCHING_CROSSLINE_TYPE: () => MATCHING_CROSSLINE_TYPE,\n  MAX_SPACING: () => MAX_SPACING,\n  MIN_SPACING: () => MIN_SPACING,\n  MercatorScale: () => MercatorScale,\n  ModuleRegistry: () => ModuleRegistry,\n  Motion: () => easing_exports,\n  NAN: () => NAN,\n  NODE_UPDATE_STATE_TO_PHASE_MAPPING: () => NODE_UPDATE_STATE_TO_PHASE_MAPPING,\n  NUMBER: () => NUMBER,\n  NUMBER_ARRAY: () => NUMBER_ARRAY,\n  NUMBER_OR_NAN: () => NUMBER_OR_NAN,\n  Navigator: () => Navigator,\n  NavigatorModule: () => NavigatorModule,\n  OBJECT: () => OBJECT,\n  OBJECT_ARRAY: () => OBJECT_ARRAY,\n  OR: () => OR,\n  OVERFLOW_STRATEGY: () => OVERFLOW_STRATEGY,\n  ObserveChanges: () => ObserveChanges,\n  PHASE_METADATA: () => PHASE_METADATA,\n  PHASE_ORDER: () => PHASE_ORDER,\n  PLACEMENT: () => PLACEMENT,\n  PLAIN_OBJECT: () => PLAIN_OBJECT,\n  POINTER_INTERACTION_TYPES: () => POINTER_INTERACTION_TYPES,\n  POSITION: () => POSITION,\n  POSITION_TOP_COORDINATES: () => POSITION_TOP_COORDINATES,\n  POSITIVE_NUMBER: () => POSITIVE_NUMBER,\n  PolarAxis: () => PolarAxis,\n  PolarSeries: () => PolarSeries,\n  PropertiesArray: () => PropertiesArray,\n  ProxyOnWrite: () => ProxyOnWrite,\n  ProxyProperty: () => ProxyProperty,\n  ProxyPropertyOnWrite: () => ProxyPropertyOnWrite,\n  QUICK_TRANSITION: () => QUICK_TRANSITION,\n  RATIO: () => RATIO,\n  REGIONS: () => REGIONS,\n  RepeatType: () => RepeatType,\n  SKIP_JS_BUILTINS: () => SKIP_JS_BUILTINS,\n  SMALLEST_KEY_INTERVAL: () => SMALLEST_KEY_INTERVAL,\n  SORT_DOMAIN_GROUPS: () => SORT_DOMAIN_GROUPS,\n  STRING: () => STRING,\n  STRING_ARRAY: () => STRING_ARRAY,\n  Series: () => Series,\n  SeriesGroupingChangedEvent: () => SeriesGroupingChangedEvent,\n  SeriesItemHighlightStyle: () => SeriesItemHighlightStyle,\n  SeriesMarker: () => SeriesMarker,\n  SeriesNodeEvent: () => SeriesNodeEvent,\n  SeriesNodePickMode: () => SeriesNodePickMode,\n  SeriesProperties: () => SeriesProperties,\n  SeriesTooltip: () => SeriesTooltip,\n  StateMachine: () => StateMachine,\n  TEXT_ALIGN: () => TEXT_ALIGN,\n  TEXT_WRAP: () => TEXT_WRAP,\n  TICK_INTERVAL: () => TICK_INTERVAL,\n  ToolbarManager: () => ToolbarManager,\n  Tooltip: () => Tooltip,\n  TooltipManager: () => TooltipManager,\n  TooltipPosition: () => TooltipPosition,\n  UNION: () => UNION,\n  UpdateService: () => UpdateService,\n  VERTICAL_ALIGN: () => VERTICAL_ALIGN,\n  Validate: () => Validate,\n  ZoomManager: () => ZoomManager,\n  __FORCE_MODULE_DETECTION: () => __FORCE_MODULE_DETECTION,\n  accumulateContinuity: () => accumulateContinuity,\n  accumulateGroup: () => accumulateGroup,\n  accumulatedValue: () => accumulatedValue,\n  accumulativeValueProperty: () => accumulativeValueProperty,\n  addHitTestersToQuadtree: () => addHitTestersToQuadtree,\n  adjustLabelPlacement: () => adjustLabelPlacement,\n  allInStringUnion: () => allInStringUnion,\n  animationValidation: () => animationValidation,\n  area: () => area,\n  arraysEqual: () => arraysEqual,\n  assignJsonApplyConstructedArray: () => assignJsonApplyConstructedArray,\n  backfillPathPointData: () => backfillPathPointData,\n  basicContinuousCheckDatumValidation: () => basicContinuousCheckDatumValidation,\n  bifurcate: () => bifurcate,\n  buildFormatter: () => buildFormatter,\n  buildResetPathFn: () => buildResetPathFn,\n  calculateDefaultTimeTickFormat: () => calculateDefaultTimeTickFormat,\n  calculateLabelChartPadding: () => calculateLabelChartPadding,\n  calculateLabelTranslation: () => calculateLabelTranslation,\n  calculatePlacement: () => calculatePlacement,\n  checkCrisp: () => checkCrisp,\n  childrenIter: () => childrenIter,\n  circularSliceArray: () => circularSliceArray,\n  clamp: () => clamp,\n  clampArray: () => clampArray,\n  collapsedStartingBarPosition: () => collapsedStartingBarPosition,\n  computeBarFocusBounds: () => computeBarFocusBounds,\n  computeMarkerFocusBounds: () => computeMarkerFocusBounds,\n  computeSectorFocusBounds: () => computeSectorFocusBounds,\n  computeSectorSeriesFocusBounds: () => computeSectorSeriesFocusBounds,\n  convertValuesToScaleByDefs: () => convertValuesToScaleByDefs,\n  countFractionDigits: () => countFractionDigits,\n  createDatumId: () => createDatumId,\n  createDeprecationWarning: () => createDeprecationWarning,\n  createElement: () => createElement,\n  dateToNumber: () => dateToNumber,\n  deconstructSelectionsOrNodes: () => deconstructSelectionsOrNodes,\n  deepClone: () => deepClone,\n  deepMerge: () => deepMerge,\n  defaultTimeTickFormat: () => defaultTimeTickFormat,\n  determinePathStatus: () => determinePathStatus,\n  diff: () => diff,\n  downloadUrl: () => downloadUrl,\n  enterpriseModule: () => enterpriseModule,\n  extent: () => extent,\n  extractDecoratedProperties: () => extractDecoratedProperties,\n  findMinMax: () => findMinMax,\n  findQuadtreeMatch: () => findQuadtreeMatch,\n  findRangeExtent: () => findRangeExtent,\n  fixNumericExtent: () => fixNumericExtent,\n  formatNormalizedPercentage: () => formatNormalizedPercentage,\n  formatPercentage: () => formatPercentage,\n  fromToMotion: () => fromToMotion,\n  getDocument: () => getDocument,\n  getMissCount: () => getMissCount,\n  getPath: () => getPath,\n  getPathComponents: () => getPathComponents,\n  getRectConfig: () => getRectConfig,\n  getWindow: () => getWindow,\n  groupAccumulativeContinuityProperty: () => groupAccumulativeContinuityProperty,\n  groupAccumulativeValueProperty: () => groupAccumulativeValueProperty,\n  groupAverage: () => groupAverage,\n  groupBy: () => groupBy,\n  groupCount: () => groupCount,\n  groupSum: () => groupSum,\n  initMenuKeyNav: () => initMenuKeyNav,\n  initToolbarKeyNav: () => initToolbarKeyNav,\n  isArray: () => isArray,\n  isBoolean: () => isBoolean,\n  isDate: () => isDate,\n  isDecoratedObject: () => isDecoratedObject,\n  isDefined: () => isDefined,\n  isEnumKey: () => isEnumKey,\n  isEnumValue: () => isEnumValue,\n  isEqual: () => isEqual,\n  isFiniteNumber: () => isFiniteNumber,\n  isFunction: () => isFunction,\n  isHtmlElement: () => isHtmlElement,\n  isNegative: () => isNegative,\n  isNumber: () => isNumber,\n  isObject: () => isObject,\n  isObjectLike: () => isObjectLike,\n  isPlainObject: () => isPlainObject,\n  isProperties: () => isProperties,\n  isRegExp: () => isRegExp,\n  isString: () => isString,\n  isSymbol: () => isSymbol,\n  isValidDate: () => isValidDate,\n  jsonApply: () => jsonApply,\n  jsonDiff: () => jsonDiff,\n  jsonWalk: () => jsonWalk,\n  keyProperty: () => keyProperty,\n  labelDirectionHandling: () => labelDirectionHandling,\n  listDecoratedProperties: () => listDecoratedProperties,\n  makeAccessibleClickListener: () => makeAccessibleClickListener,\n  mapIterable: () => mapIterable,\n  mapValues: () => mapValues,\n  markerFadeInAnimation: () => markerFadeInAnimation,\n  markerPaletteFactory: () => markerPaletteFactory,\n  markerScaleInAnimation: () => markerScaleInAnimation,\n  markerSwipeScaleInAnimation: () => markerSwipeScaleInAnimation,\n  mergeArrayDefaults: () => mergeArrayDefaults,\n  mergeDefaults: () => mergeDefaults,\n  midpointStartingBarPosition: () => midpointStartingBarPosition,\n  minMax: () => minMax,\n  mod: () => mod,\n  moduleRegistry: () => moduleRegistry,\n  nearestSquared: () => nearestSquared,\n  nearestSquaredInContainer: () => nearestSquaredInContainer,\n  normaliseGroupTo: () => normaliseGroupTo,\n  normalisePropertyTo: () => normalisePropertyTo,\n  normalisedExtent: () => normalisedExtent,\n  normalisedExtentWithMetadata: () => normalisedExtentWithMetadata,\n  pairCategoryData: () => pairCategoryData,\n  pairContinuousData: () => pairContinuousData,\n  partialAssign: () => partialAssign,\n  pathFadeInAnimation: () => pathFadeInAnimation,\n  pathFadeOutAnimation: () => pathFadeOutAnimation,\n  pathRangePoints: () => pathRangePoints,\n  pathRangePointsReverse: () => pathRangePointsReverse,\n  pathRanges: () => pathRanges,\n  pathSwipeInAnimation: () => pathSwipeInAnimation,\n  pickByMatchingAngle: () => pickByMatchingAngle,\n  plotPath: () => plotPath,\n  predicateWithMessage: () => predicateWithMessage,\n  prepareAreaPathAnimation: () => prepareAreaPathAnimation,\n  prepareAreaPathAnimationFns: () => prepareAreaPathAnimationFns,\n  prepareAxisAnimationContext: () => prepareAxisAnimationContext,\n  prepareAxisAnimationFunctions: () => prepareAxisAnimationFunctions,\n  prepareBarAnimationFunctions: () => prepareBarAnimationFunctions,\n  prepareLinePathAnimation: () => prepareLinePathAnimation,\n  prepareLinePathAnimationFns: () => prepareLinePathAnimationFns,\n  prepareLinePathPropertyAnimation: () => prepareLinePathPropertyAnimation,\n  prepareMarkerAnimation: () => prepareMarkerAnimation,\n  preparePieSeriesAnimationFunctions: () => preparePieSeriesAnimationFunctions,\n  range: () => range2,\n  rangedValueProperty: () => rangedValueProperty,\n  renderPartialPath: () => renderPartialPath,\n  resetAxisGroupFn: () => resetAxisGroupFn,\n  resetAxisLabelSelectionFn: () => resetAxisLabelSelectionFn,\n  resetAxisLineSelectionFn: () => resetAxisLineSelectionFn,\n  resetAxisSelectionFn: () => resetAxisSelectionFn,\n  resetBarSelectionsFn: () => resetBarSelectionsFn,\n  resetIds: () => resetIds,\n  resetLabelFn: () => resetLabelFn,\n  resetMarkerFn: () => resetMarkerFn,\n  resetMarkerPositionFn: () => resetMarkerPositionFn,\n  resetMotion: () => resetMotion,\n  resetPieSelectionsFn: () => resetPieSelectionsFn,\n  round: () => round,\n  seriesLabelFadeInAnimation: () => seriesLabelFadeInAnimation,\n  seriesLabelFadeOutAnimation: () => seriesLabelFadeOutAnimation,\n  setDocument: () => setDocument,\n  setElementBBox: () => setElementBBox,\n  setPath: () => setPath,\n  setWindow: () => setWindow,\n  shallowClone: () => shallowClone,\n  singleSeriesPaletteFactory: () => singleSeriesPaletteFactory,\n  splitPairData: () => splitPairData,\n  staticFromToMotion: () => staticFromToMotion,\n  stringify: () => stringify,\n  sum: () => sum,\n  sumValues: () => sumValues,\n  times: () => times,\n  toArray: () => toArray,\n  toFixed: () => toFixed,\n  toTooltipHtml: () => toTooltipHtml,\n  trailingAccumulatedValue: () => trailingAccumulatedValue,\n  trailingAccumulatedValueProperty: () => trailingAccumulatedValueProperty,\n  unique: () => unique,\n  updateClipPath: () => updateClipPath,\n  updateLabelNode: () => updateLabelNode,\n  updateRect: () => updateRect,\n  validateCrossLineValues: () => validateCrossLineValues,\n  valueProperty: () => valueProperty,\n  without: () => without\n});\n\n// packages/ag-charts-community/src/util/deprecation.ts\nfunction createDeprecationWarning() {\n  return (key, message) => {\n    const msg = [`Property [${key}] is deprecated.`, message].filter(Boolean).join(\" \");\n    Logger.warnOnce(msg);\n  };\n}\nfunction Deprecated(message, opts) {\n  const warnDeprecated = createDeprecationWarning();\n  const def = opts?.default;\n  return addTransformToInstanceProperty((_, key, value) => {\n    if (value !== def) {\n      warnDeprecated(key.toString(), message);\n    }\n    return value;\n  });\n}\nfunction DeprecatedAndRenamedTo(newPropName, mapValue) {\n  const warnDeprecated = createDeprecationWarning();\n  return addTransformToInstanceProperty(\n    (target, key, value) => {\n      if (value !== target[newPropName]) {\n        warnDeprecated(key.toString(), `Use [${newPropName}] instead.`);\n        setPath(target, newPropName, mapValue ? mapValue(value) : value);\n      }\n      return BREAK_TRANSFORM_CHAIN;\n    },\n    (target, key) => {\n      warnDeprecated(key.toString(), `Use [${newPropName}] instead.`);\n      return getPath(target, newPropName);\n    }\n  );\n}\n\n// packages/ag-charts-community/src/chart/series/util.ts\nfunction convertValuesToScaleByDefs({\n  defs,\n  values,\n  xAxis,\n  yAxis\n}) {\n  if (!(xAxis && yAxis)) {\n    throw new Error(\"Axes must be defined\");\n  }\n  const result = {};\n  for (const [searchId, { def }] of defs) {\n    if (Object.hasOwn(values, searchId)) {\n      const { scale: scale2 } = def.type === \"key\" ? xAxis : yAxis;\n      result[searchId] = Math.round(scale2.convert(values[searchId]));\n    }\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/chart/series/hierarchy/hierarchySeries.ts\nvar _HierarchyNode = class _HierarchyNode {\n  constructor(series, index, datum, size, colorValue, fill, stroke, sumSize, depth, parent, children) {\n    this.series = series;\n    this.index = index;\n    this.datum = datum;\n    this.size = size;\n    this.colorValue = colorValue;\n    this.fill = fill;\n    this.stroke = stroke;\n    this.sumSize = sumSize;\n    this.depth = depth;\n    this.parent = parent;\n    this.children = children;\n    this.midPoint = { x: 0, y: 0 };\n  }\n  contains(other) {\n    let current = other;\n    while (current != null && current.index >= this.index) {\n      if (current === this) {\n        return true;\n      }\n      current = current.parent;\n    }\n    return false;\n  }\n  walk(callback, order = _HierarchyNode.Walk.PreOrder) {\n    if (order === _HierarchyNode.Walk.PreOrder) {\n      callback(this);\n    }\n    this.children.forEach((child) => {\n      child.walk(callback, order);\n    });\n    if (order === _HierarchyNode.Walk.PostOrder) {\n      callback(this);\n    }\n  }\n  *[Symbol.iterator]() {\n    yield this;\n    for (const child of this.children) {\n      yield* child;\n    }\n  }\n};\n_HierarchyNode.Walk = {\n  PreOrder: 0,\n  PostOrder: 1\n};\nvar HierarchyNode = _HierarchyNode;\nvar HierarchySeries = class extends Series {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [3 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      contentGroupVirtual: false\n    });\n    this.rootNode = new HierarchyNode(\n      this,\n      0,\n      void 0,\n      0,\n      void 0,\n      void 0,\n      void 0,\n      0,\n      void 0,\n      void 0,\n      []\n    );\n    this.colorDomain = [0, 0];\n    this.maxDepth = 0;\n    this.focusPath = [];\n    this.animationState = new StateMachine(\n      \"empty\",\n      {\n        empty: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateEmptyUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        ready: {\n          updateData: \"waiting\",\n          clear: \"clearing\",\n          highlight: (data) => this.animateReadyHighlight(data),\n          resize: (data) => this.animateReadyResize(data),\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        waiting: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateWaitingUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        clearing: {\n          update: {\n            target: \"empty\",\n            action: (data) => this.animateClearingUpdateEmpty(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        }\n      },\n      () => this.checkProcessedDataAnimatable()\n    );\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    } else if (phase === \"ready\") {\n      this.animationState.transition(\"skip\");\n    }\n  }\n  async processData() {\n    const { childrenKey, sizeKey, colorKey, fills, strokes, colorRange } = this.properties;\n    let index = 0;\n    const getIndex = () => {\n      index += 1;\n      return index;\n    };\n    let maxDepth = 0;\n    let minColor = Infinity;\n    let maxColor = -Infinity;\n    const colors = new Array((this.data?.length ?? 0) + 1).fill(void 0);\n    const createNode = (datum, parent) => {\n      const nodeIndex = getIndex();\n      const depth = parent.depth != null ? parent.depth + 1 : 0;\n      const children = childrenKey != null ? datum[childrenKey] : void 0;\n      const isLeaf = children == null || children.length === 0;\n      let size = sizeKey != null ? datum[sizeKey] : void 0;\n      if (Number.isFinite(size)) {\n        size = Math.max(size, 0);\n      } else {\n        size = isLeaf ? 1 : 0;\n      }\n      const sumSize = size;\n      maxDepth = Math.max(maxDepth, depth);\n      const color = colorKey != null ? datum[colorKey] : void 0;\n      if (typeof color === \"number\") {\n        colors[nodeIndex] = color;\n        minColor = Math.min(minColor, color);\n        maxColor = Math.max(maxColor, color);\n      }\n      return appendChildren(\n        new HierarchyNode(\n          this,\n          nodeIndex,\n          datum,\n          size,\n          color,\n          void 0,\n          void 0,\n          sumSize,\n          depth,\n          parent,\n          []\n        ),\n        children\n      );\n    };\n    const appendChildren = (node, data) => {\n      data?.forEach((datum) => {\n        const child = createNode(datum, node);\n        node.children.push(child);\n        node.sumSize += child.sumSize;\n      });\n      return node;\n    };\n    const rootNode = appendChildren(\n      new HierarchyNode(\n        this,\n        0,\n        void 0,\n        0,\n        void 0,\n        void 0,\n        void 0,\n        0,\n        void 0,\n        void 0,\n        []\n      ),\n      this.data\n    );\n    const colorDomain = [minColor, maxColor];\n    let colorScale;\n    if (colorRange != null && Number.isFinite(minColor) && Number.isFinite(maxColor)) {\n      colorScale = new ColorScale();\n      colorScale.domain = colorDomain;\n      colorScale.range = colorRange;\n      colorScale.update();\n    }\n    rootNode.children.forEach((child, childIndex) => {\n      child.walk((node) => {\n        let fill;\n        const color = colors[node.index];\n        if (color != null) {\n          fill = colorScale?.convert(color);\n        }\n        fill ?? (fill = fills?.[childIndex % fills.length]);\n        node.fill = fill;\n        node.stroke = colorScale == null ? strokes?.[childIndex % strokes.length] : \"rgba(0, 0, 0, 0.2)\";\n      });\n    });\n    this.rootNode = rootNode;\n    this.maxDepth = maxDepth;\n    this.colorDomain = colorDomain;\n    this.focusPath = [{ nodeDatum: this.rootNode, childIndex: 0 }];\n  }\n  async update({ seriesRect }) {\n    await this.updateSelections();\n    await this.updateNodes();\n    const animationData = this.getAnimationData();\n    const resize = this.checkResize(seriesRect);\n    if (resize) {\n      this.animationState.transition(\"resize\", animationData);\n    }\n    this.animationState.transition(\"update\", animationData);\n  }\n  resetAllAnimation(data) {\n    const datum = this.animationResetFns?.datum;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    if (datum != null) {\n      resetMotion(data.datumSelections, datum);\n    }\n  }\n  animateEmptyUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateWaitingUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateReadyHighlight(data) {\n    const datum = this.animationResetFns?.datum;\n    if (datum != null) {\n      resetMotion([data], datum);\n    }\n  }\n  animateReadyResize(data) {\n    this.resetAllAnimation(data);\n  }\n  animateClearingUpdateEmpty(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animationTransitionClear() {\n    this.animationState.transition(\"clear\", this.getAnimationData());\n  }\n  getAnimationData() {\n    const animationData = {\n      datumSelections: [this.groupSelection]\n    };\n    return animationData;\n  }\n  isProcessedDataAnimatable() {\n    return true;\n  }\n  checkProcessedDataAnimatable() {\n    if (!this.isProcessedDataAnimatable()) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n  }\n  getLabelData() {\n    return [];\n  }\n  getSeriesDomain() {\n    return [NaN, NaN];\n  }\n  getLegendData(legendType) {\n    const { colorKey, colorName, colorRange, visible } = this.properties;\n    return legendType === \"gradient\" && colorKey != null && colorRange != null ? [\n      {\n        legendType: \"gradient\",\n        enabled: visible,\n        seriesId: this.id,\n        colorName,\n        colorRange,\n        colorDomain: this.colorDomain\n      }\n    ] : [];\n  }\n  getDatumIdFromData(node) {\n    return `${node.index}`;\n  }\n  getDatumId(node) {\n    return this.getDatumIdFromData(node);\n  }\n  pickFocus(opts) {\n    if (this.rootNode.children.length === 0)\n      return void 0;\n    if (this.focusPath.length === 0) {\n      Logger.error(\"this.focusPath should not be empty\");\n    }\n    const { datumIndexDelta: childDelta, otherIndexDelta: depthDelta } = opts;\n    const { focusPath: path } = this;\n    const depth = path.length - 2;\n    if (depthDelta !== 0 || path.length === 1) {\n      const targetDepth = Math.max(0, depth + depthDelta);\n      if (path[targetDepth + 1] !== void 0) {\n        path.length = targetDepth + 2;\n        return this.computeFocusOutputs(path[targetDepth + 1]);\n      } else {\n        let deepest = path[path.length - 1];\n        while (deepest.nodeDatum.children.length > 0 && (deepest.nodeDatum.depth ?? -1) < targetDepth) {\n          const nextDeepest = { nodeDatum: deepest.nodeDatum.children[0], childIndex: 0 };\n          path.push(nextDeepest);\n          deepest = nextDeepest;\n        }\n        return this.computeFocusOutputs(deepest);\n      }\n    } else if (childDelta !== 0) {\n      const targetChild = path[depth + 1].childIndex + childDelta;\n      const currentParent = path[depth].nodeDatum;\n      const childCount = currentParent?.children?.length;\n      if (childCount !== void 0) {\n        const newChild = clamp(0, targetChild, childCount - 1);\n        const newFocus = { nodeDatum: currentParent.children[newChild], childIndex: newChild };\n        path[depth + 1] = newFocus;\n        path.length = depth + 2;\n        return this.computeFocusOutputs(newFocus);\n      }\n    } else {\n      return this.computeFocusOutputs(path[path.length - 1]);\n    }\n  }\n  getDatumAriaText(datum, description) {\n    if (!(datum instanceof HierarchyNode)) {\n      Logger.error(`datum is not HierarchyNode: ${datum}`);\n      return;\n    }\n    return this.ctx.localeManager.t(\"ariaAnnounceHierarchyDatum\", {\n      level: (datum.depth ?? -1) + 1,\n      count: datum.children.length,\n      description\n    });\n  }\n  computeFocusOutputs({ nodeDatum, childIndex }) {\n    const bounds = this.computeFocusBounds(nodeDatum);\n    if (bounds) {\n      return {\n        datum: nodeDatum,\n        datumIndex: childIndex,\n        otherIndex: nodeDatum.depth,\n        bounds,\n        showFocusBox: true\n      };\n    }\n    return void 0;\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/hierarchy/hierarchySeriesProperties.ts\nvar HierarchySeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.childrenKey = \"children\";\n    this.fills = Object.values(DEFAULT_FILLS);\n    this.strokes = Object.values(DEFAULT_STROKES);\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], HierarchySeriesProperties.prototype, \"childrenKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HierarchySeriesProperties.prototype, \"sizeKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HierarchySeriesProperties.prototype, \"colorKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HierarchySeriesProperties.prototype, \"colorName\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], HierarchySeriesProperties.prototype, \"fills\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], HierarchySeriesProperties.prototype, \"strokes\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY, { optional: true })\n], HierarchySeriesProperties.prototype, \"colorRange\", 2);\n\n// packages/ag-charts-community/src/chart/series/topology/lonLatBbox.ts\nvar LonLatBBox = class {\n  constructor(lon0, lat0, lon1, lat1) {\n    this.lon0 = lon0;\n    this.lat0 = lat0;\n    this.lon1 = lon1;\n    this.lat1 = lat1;\n  }\n  merge(other) {\n    this.lon0 = Math.min(this.lon0, other.lon0);\n    this.lat0 = Math.min(this.lat0, other.lat0);\n    this.lon1 = Math.max(this.lon1, other.lon1);\n    this.lat1 = Math.max(this.lat1, other.lat1);\n  }\n};\n\n// packages/ag-charts-community/src/chart/legendDatum.ts\nvar __FORCE_MODULE_DETECTION = 0;\n\n\n\n//# sourceURL=webpack://utils/./node_modules/ag-charts-community/dist/package/main.esm.mjs?");

/***/ }),

/***/ "./node_modules/ag-charts-enterprise/dist/package/main.esm.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/ag-charts-enterprise/dist/package/main.esm.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AG_CHARTS_LOCALE_EN_US: () => (/* reexport safe */ ag_charts_community__WEBPACK_IMPORTED_MODULE_0__.AG_CHARTS_LOCALE_EN_US),\n/* harmony export */   AgCharts: () => (/* reexport safe */ ag_charts_community__WEBPACK_IMPORTED_MODULE_0__.AgCharts),\n/* harmony export */   AgErrorBarSupportedSeriesTypes: () => (/* reexport safe */ ag_charts_community__WEBPACK_IMPORTED_MODULE_0__.AgErrorBarSupportedSeriesTypes),\n/* harmony export */   AgTooltipPositionType: () => (/* reexport safe */ ag_charts_community__WEBPACK_IMPORTED_MODULE_0__.AgTooltipPositionType),\n/* harmony export */   Marker: () => (/* reexport safe */ ag_charts_community__WEBPACK_IMPORTED_MODULE_0__.Marker),\n/* harmony export */   VERSION: () => (/* reexport safe */ ag_charts_community__WEBPACK_IMPORTED_MODULE_0__.VERSION),\n/* harmony export */   _ModuleSupport: () => (/* reexport safe */ ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport),\n/* harmony export */   _Scale: () => (/* reexport safe */ ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scale),\n/* harmony export */   _Scene: () => (/* reexport safe */ ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene),\n/* harmony export */   _Theme: () => (/* reexport safe */ ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme),\n/* harmony export */   _Util: () => (/* reexport safe */ ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util),\n/* harmony export */   time: () => (/* reexport safe */ ag_charts_community__WEBPACK_IMPORTED_MODULE_0__.time)\n/* harmony export */ });\n/* harmony import */ var ag_charts_community__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ag-charts-community */ \"./node_modules/ag-charts-community/dist/package/main.esm.mjs\");\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp(target, key, result);\n  return result;\n};\n\n// packages/ag-charts-enterprise/src/main.ts\n\n\n// packages/ag-charts-enterprise/src/setup.ts\n\n\n// packages/ag-charts-enterprise/src/axes/angle-category/angleCategoryAxis.ts\n\n\n// packages/ag-charts-enterprise/src/utils/polar.ts\nfunction loopSymmetrically(items, step, iterator) {\n  const loop = (start, end, loopStep, loopIterator) => {\n    let prev = items[0];\n    for (let i = start; loopStep > 0 ? i <= end : i > end; i += loopStep) {\n      const curr = items[i];\n      if (loopIterator(prev, curr))\n        return true;\n      prev = curr;\n    }\n    return false;\n  };\n  const midIndex = Math.floor(items.length / 2);\n  if (loop(step, midIndex, step, iterator))\n    return true;\n  return loop(items.length - step, midIndex, -step, iterator);\n}\n\n// packages/ag-charts-enterprise/src/axes/angle-number/angleAxisInterval.ts\n\nvar { OR, POSITIVE_NUMBER, NAN, AxisInterval, Validate } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar AngleAxisInterval = class extends AxisInterval {\n  constructor() {\n    super(...arguments);\n    this.minSpacing = NaN;\n  }\n};\n__decorateClass([\n  Validate(OR(POSITIVE_NUMBER, NAN))\n], AngleAxisInterval.prototype, \"minSpacing\", 2);\n\n// packages/ag-charts-enterprise/src/axes/angle/angleAxis.ts\n\n\n// packages/ag-charts-enterprise/src/axes/polar-crosslines/angleCrossLine.ts\n\n\n// packages/ag-charts-enterprise/src/axes/polar-crosslines/polarCrossLine.ts\n\nvar {\n  ChartAxisDirection,\n  Layers,\n  ARRAY,\n  BOOLEAN,\n  COLOR_STRING,\n  FONT_STYLE,\n  FONT_WEIGHT,\n  LINE_DASH,\n  NUMBER,\n  POSITIVE_NUMBER: POSITIVE_NUMBER2,\n  RATIO,\n  STRING,\n  UNION,\n  AND,\n  Validate: Validate2,\n  MATCHING_CROSSLINE_TYPE\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { Group } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar { createId } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar PolarCrossLineLabel = class {\n  constructor() {\n    this.enabled = void 0;\n    this.text = void 0;\n    this.fontStyle = void 0;\n    this.fontWeight = void 0;\n    this.fontSize = 14;\n    this.fontFamily = \"Verdana, sans-serif\";\n    this.padding = 5;\n    this.color = \"rgba(87, 87, 87, 1)\";\n    this.parallel = void 0;\n  }\n};\n__decorateClass([\n  Validate2(BOOLEAN, { optional: true })\n], PolarCrossLineLabel.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate2(STRING, { optional: true })\n], PolarCrossLineLabel.prototype, \"text\", 2);\n__decorateClass([\n  Validate2(FONT_STYLE, { optional: true })\n], PolarCrossLineLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate2(FONT_WEIGHT, { optional: true })\n], PolarCrossLineLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate2(POSITIVE_NUMBER2)\n], PolarCrossLineLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate2(STRING)\n], PolarCrossLineLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate2(NUMBER)\n], PolarCrossLineLabel.prototype, \"padding\", 2);\n__decorateClass([\n  Validate2(COLOR_STRING, { optional: true })\n], PolarCrossLineLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate2(BOOLEAN, { optional: true })\n], PolarCrossLineLabel.prototype, \"parallel\", 2);\nvar _PolarCrossLine = class _PolarCrossLine {\n  constructor() {\n    this.id = createId(this);\n    this.enabled = void 0;\n    this.type = void 0;\n    this.range = void 0;\n    this.value = void 0;\n    this.fill = void 0;\n    this.fillOpacity = void 0;\n    this.stroke = void 0;\n    this.strokeWidth = void 0;\n    this.strokeOpacity = void 0;\n    this.lineDash = void 0;\n    this.shape = \"polygon\";\n    this.label = new PolarCrossLineLabel();\n    this.scale = void 0;\n    this.clippedRange = [-Infinity, Infinity];\n    this.gridLength = 0;\n    this.sideFlag = -1;\n    this.parallelFlipRotation = 0;\n    this.regularFlipRotation = 0;\n    this.direction = ChartAxisDirection.X;\n    this.axisInnerRadius = 0;\n    this.axisOuterRadius = 0;\n    this.group = new Group({ name: `${this.id}`, layer: true, zIndex: _PolarCrossLine.LINE_LAYER_ZINDEX });\n    this.labelGroup = new Group({ name: `${this.id}`, layer: true, zIndex: _PolarCrossLine.LABEL_LAYER_ZINDEX });\n  }\n  setSectorNodeProps(node) {\n    node.fill = this.fill;\n    node.fillOpacity = this.fillOpacity ?? 1;\n    node.stroke = this.stroke;\n    node.strokeOpacity = this.strokeOpacity ?? 1;\n    node.strokeWidth = this.strokeWidth ?? 1;\n    node.lineDash = this.lineDash;\n  }\n  setLabelNodeProps(node, x, y, baseline, rotation) {\n    const { label } = this;\n    node.x = x;\n    node.y = y;\n    node.text = label.text;\n    node.textAlign = \"center\";\n    node.textBaseline = baseline;\n    node.rotation = rotation;\n    node.rotationCenterX = x;\n    node.rotationCenterY = y;\n    node.fill = label.color;\n    node.fontFamily = label.fontFamily;\n    node.fontSize = label.fontSize;\n    node.fontStyle = label.fontStyle;\n    node.visible = true;\n  }\n  calculateLayout(_visible) {\n    return;\n  }\n};\n_PolarCrossLine.LINE_LAYER_ZINDEX = Layers.SERIES_CROSSLINE_LINE_ZINDEX;\n_PolarCrossLine.RANGE_LAYER_ZINDEX = Layers.SERIES_CROSSLINE_RANGE_ZINDEX;\n_PolarCrossLine.LABEL_LAYER_ZINDEX = Layers.SERIES_LABEL_ZINDEX;\n__decorateClass([\n  Validate2(BOOLEAN, { optional: true })\n], _PolarCrossLine.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate2(UNION([\"range\", \"line\"], \"a crossLine type\"), { optional: true })\n], _PolarCrossLine.prototype, \"type\", 2);\n__decorateClass([\n  Validate2(AND(MATCHING_CROSSLINE_TYPE(\"range\"), ARRAY.restrict({ length: 2 })), {\n    optional: true\n  })\n], _PolarCrossLine.prototype, \"range\", 2);\n__decorateClass([\n  Validate2(MATCHING_CROSSLINE_TYPE(\"value\"), { optional: true })\n], _PolarCrossLine.prototype, \"value\", 2);\n__decorateClass([\n  Validate2(COLOR_STRING, { optional: true })\n], _PolarCrossLine.prototype, \"fill\", 2);\n__decorateClass([\n  Validate2(RATIO, { optional: true })\n], _PolarCrossLine.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate2(COLOR_STRING, { optional: true })\n], _PolarCrossLine.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate2(NUMBER, { optional: true })\n], _PolarCrossLine.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate2(RATIO, { optional: true })\n], _PolarCrossLine.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate2(LINE_DASH, { optional: true })\n], _PolarCrossLine.prototype, \"lineDash\", 2);\nvar PolarCrossLine = _PolarCrossLine;\n\n// packages/ag-charts-enterprise/src/axes/polar-crosslines/angleCrossLine.ts\nvar { ChartAxisDirection: ChartAxisDirection2, validateCrossLineValues } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { Path, Sector, Text } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar { normalizeAngle360, isNumberEqual } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar _AngleCrossLine = class _AngleCrossLine extends PolarCrossLine {\n  constructor() {\n    super();\n    this.direction = ChartAxisDirection2.X;\n    this.polygonNode = new Path();\n    this.sectorNode = new Sector();\n    this.lineNode = new Path();\n    this.labelNode = new Text();\n    this.group.append(this.polygonNode);\n    this.group.append(this.sectorNode);\n    this.group.append(this.lineNode);\n    this.labelGroup.append(this.labelNode);\n  }\n  update(visible) {\n    const { scale, shape, type, value, range: range2 } = this;\n    if (!scale || !type || !validateCrossLineValues(type, value, range2, scale)) {\n      this.group.visible = false;\n      this.labelGroup.visible = false;\n      return;\n    }\n    this.group.visible = visible;\n    this.labelGroup.visible = visible;\n    if (type === \"line\" && shape === \"circle\" && scale instanceof ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scale.BandScale) {\n      this.type = \"range\";\n      this.range = [value, value];\n    }\n    this.updateLineNode(visible);\n    this.updatePolygonNode(visible);\n    this.updateSectorNode(visible);\n    this.updateLabelNode(visible);\n  }\n  updateLineNode(visible) {\n    const { scale, type, value, lineNode: line } = this;\n    let angle;\n    if (!visible || type !== \"line\" || !scale || isNaN(angle = scale.convert(value))) {\n      line.visible = false;\n      return;\n    }\n    const { axisInnerRadius, axisOuterRadius } = this;\n    line.visible = true;\n    line.stroke = this.stroke;\n    line.strokeOpacity = this.strokeOpacity ?? 1;\n    line.strokeWidth = this.strokeWidth ?? 1;\n    line.fill = void 0;\n    line.lineDash = this.lineDash;\n    const x = axisOuterRadius * Math.cos(angle);\n    const y = axisOuterRadius * Math.sin(angle);\n    const x0 = axisInnerRadius * Math.cos(angle);\n    const y0 = axisInnerRadius * Math.sin(angle);\n    line.path.clear(true);\n    line.path.moveTo(x0, y0);\n    line.path.lineTo(x, y);\n    this.group.zIndex = _AngleCrossLine.LINE_LAYER_ZINDEX;\n  }\n  updatePolygonNode(visible) {\n    const { polygonNode: polygon, range: range2, scale, shape, type } = this;\n    let ticks;\n    if (!visible || type !== \"range\" || shape !== \"polygon\" || !scale || !range2 || !(ticks = scale.ticks?.())) {\n      polygon.visible = false;\n      return;\n    }\n    const { axisInnerRadius, axisOuterRadius } = this;\n    const startIndex = ticks.indexOf(range2[0]);\n    const endIndex = ticks.indexOf(range2[1]);\n    const stops = startIndex <= endIndex ? ticks.slice(startIndex, endIndex + 1) : ticks.slice(startIndex).concat(ticks.slice(0, endIndex + 1));\n    const angles = stops.map((value) => scale.convert(value));\n    polygon.visible = true;\n    this.setSectorNodeProps(polygon);\n    const { path } = polygon;\n    path.clear(true);\n    angles.forEach((angle, index) => {\n      const x = axisOuterRadius * Math.cos(angle);\n      const y = axisOuterRadius * Math.sin(angle);\n      if (index === 0) {\n        path.moveTo(x, y);\n      } else {\n        path.lineTo(x, y);\n      }\n    });\n    if (axisInnerRadius === 0) {\n      path.lineTo(0, 0);\n    } else {\n      angles.slice().reverse().forEach((angle) => {\n        const x = axisInnerRadius * Math.cos(angle);\n        const y = axisInnerRadius * Math.sin(angle);\n        path.lineTo(x, y);\n      });\n    }\n    polygon.path.closePath();\n    this.group.zIndex = _AngleCrossLine.RANGE_LAYER_ZINDEX;\n  }\n  updateSectorNode(visible) {\n    const { sectorNode: sector, range: range2, scale, shape, type } = this;\n    if (!visible || type !== \"range\" || shape !== \"circle\" || !scale || !range2) {\n      sector.visible = false;\n      return;\n    }\n    const { axisInnerRadius, axisOuterRadius } = this;\n    const angles = range2.map((value) => scale.convert(value));\n    const step = scale.step ?? 0;\n    const padding = scale instanceof ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scale.BandScale ? step / 2 : 0;\n    sector.visible = true;\n    this.setSectorNodeProps(sector);\n    sector.centerX = 0;\n    sector.centerY = 0;\n    sector.innerRadius = axisInnerRadius;\n    sector.outerRadius = axisOuterRadius;\n    sector.startAngle = angles[0] - padding;\n    sector.endAngle = angles[1] + padding;\n    this.group.zIndex = _AngleCrossLine.RANGE_LAYER_ZINDEX;\n  }\n  updateLabelNode(visible) {\n    const { label, labelNode: node, range: range2, scale, type } = this;\n    if (!visible || label.enabled === false || !label.text || !scale || type === \"range\" && !range2) {\n      node.visible = true;\n      return;\n    }\n    const { axisInnerRadius, axisOuterRadius } = this;\n    let labelX;\n    let labelY;\n    let rotation;\n    let textBaseline;\n    if (type === \"line\") {\n      const angle = normalizeAngle360(scale.convert(this.value));\n      const angle270 = 1.5 * Math.PI;\n      const isRightSide = isNumberEqual(angle, angle270) || angle > angle270 || angle < Math.PI / 2;\n      const midX = (axisInnerRadius + axisOuterRadius) / 2 * Math.cos(angle);\n      const midY = (axisInnerRadius + axisOuterRadius) / 2 * Math.sin(angle);\n      labelX = midX + label.padding * Math.cos(angle + Math.PI / 2);\n      labelY = midY + label.padding * Math.sin(angle + Math.PI / 2);\n      textBaseline = isRightSide ? \"top\" : \"bottom\";\n      rotation = isRightSide ? angle : angle - Math.PI;\n    } else {\n      const [startAngle, endAngle] = range2.map((value) => normalizeAngle360(scale.convert(value)));\n      let angle = (startAngle + endAngle) / 2;\n      if (startAngle > endAngle) {\n        angle -= Math.PI;\n      }\n      angle = normalizeAngle360(angle);\n      const isBottomSide = (isNumberEqual(angle, 0) || angle > 0) && angle < Math.PI;\n      let distance;\n      const ticks = scale.ticks?.() ?? [];\n      if (this.shape === \"circle\" || ticks.length < 3) {\n        distance = axisOuterRadius - label.padding;\n      } else {\n        distance = axisOuterRadius * Math.cos(Math.PI / ticks.length) - label.padding;\n      }\n      labelX = distance * Math.cos(angle);\n      labelY = distance * Math.sin(angle);\n      textBaseline = isBottomSide ? \"bottom\" : \"top\";\n      rotation = isBottomSide ? angle - Math.PI / 2 : angle + Math.PI / 2;\n    }\n    this.setLabelNodeProps(node, labelX, labelY, textBaseline, rotation);\n  }\n};\n_AngleCrossLine.className = \"AngleCrossLine\";\nvar AngleCrossLine = _AngleCrossLine;\n\n// packages/ag-charts-enterprise/src/axes/angle/angleAxis.ts\nvar {\n  AND: AND2,\n  assignJsonApplyConstructedArray,\n  ChartAxisDirection: ChartAxisDirection3,\n  GREATER_THAN,\n  NUMBER: NUMBER2,\n  UNION: UNION2,\n  ProxyOnWrite,\n  Validate: Validate3\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { Path: Path2, Text: Text2 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar { angleBetween, isNumberEqual: isNumberEqual2, toRadians, normalizeAngle360: normalizeAngle3602 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar AngleAxisLabel = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.AxisLabel {\n  constructor() {\n    super(...arguments);\n    this.orientation = \"fixed\";\n  }\n};\n__decorateClass([\n  Validate3(UNION2([\"fixed\", \"parallel\", \"perpendicular\"], \"a label orientation\"))\n], AngleAxisLabel.prototype, \"orientation\", 2);\nvar AngleAxis = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.PolarAxis {\n  constructor(moduleCtx, scale) {\n    super(moduleCtx, scale);\n    this.startAngle = 0;\n    this.endAngle = void 0;\n    this.labelData = [];\n    this.tickData = [];\n    this.radiusLine = this.axisGroup.appendChild(new Path2());\n    this.computeRange = () => {\n      const startAngle = normalizeAngle3602(-Math.PI / 2 + toRadians(this.startAngle));\n      let endAngle = this.endAngle == null ? startAngle + Math.PI * 2 : -Math.PI / 2 + toRadians(this.endAngle);\n      if (endAngle < startAngle) {\n        endAngle += 2 * Math.PI;\n      }\n      this.range = [startAngle, endAngle];\n    };\n    this.includeInvisibleDomains = true;\n  }\n  get direction() {\n    return ChartAxisDirection3.X;\n  }\n  assignCrossLineArrayConstructor(crossLines) {\n    assignJsonApplyConstructedArray(crossLines, AngleCrossLine);\n  }\n  createLabel() {\n    return new AngleAxisLabel();\n  }\n  update() {\n    this.updateScale();\n    this.updatePosition();\n    this.updateGridLines();\n    this.updateTickLines();\n    this.updateLabels();\n    this.updateRadiusLine();\n    this.updateCrossLines();\n    return this.tickData.length;\n  }\n  calculateAvailableRange() {\n    const { range: range2, gridLength: radius } = this;\n    return angleBetween(range2[0], range2[1]) * radius;\n  }\n  updatePosition() {\n    const { translation, axisGroup, gridGroup, crossLineGroup } = this;\n    const translationX = Math.floor(translation.x);\n    const translationY = Math.floor(translation.y);\n    axisGroup.translationX = translationX;\n    axisGroup.translationY = translationY;\n    gridGroup.translationX = translationX;\n    gridGroup.translationY = translationY;\n    crossLineGroup.translationX = translationX;\n    crossLineGroup.translationY = translationY;\n  }\n  updateRadiusLine() {\n    const node = this.radiusLine;\n    const { path } = node;\n    path.clear(true);\n    const { points, closePath } = this.getAxisLinePoints();\n    points.forEach(({ x, y, moveTo, arc, radius = 0, startAngle = 0, endAngle = 0 }) => {\n      if (arc) {\n        path.arc(x, y, radius, startAngle, endAngle);\n      } else if (moveTo) {\n        path.moveTo(x, y);\n      } else {\n        path.lineTo(x, y);\n      }\n    });\n    if (closePath) {\n      path.closePath();\n    }\n    node.visible = this.line.enabled;\n    node.stroke = this.line.stroke;\n    node.strokeWidth = this.line.width;\n    node.fill = void 0;\n  }\n  getAxisLinePoints() {\n    const { scale, shape, gridLength: radius } = this;\n    const [startAngle, endAngle] = this.range;\n    const isFullCircle = isNumberEqual2(endAngle - startAngle, 2 * Math.PI);\n    const points = [];\n    if (shape === \"circle\") {\n      if (isFullCircle) {\n        points.push({ x: radius, y: 0, moveTo: true });\n        points.push({\n          x: 0,\n          y: 0,\n          radius,\n          startAngle: 0,\n          endAngle: 2 * Math.PI,\n          arc: true,\n          moveTo: false\n        });\n      } else {\n        points.push({\n          x: radius * Math.cos(startAngle),\n          y: radius * Math.sin(startAngle),\n          moveTo: true\n        });\n        points.push({\n          x: 0,\n          y: 0,\n          radius,\n          startAngle: normalizeAngle3602(startAngle),\n          endAngle: normalizeAngle3602(endAngle),\n          arc: true,\n          moveTo: false\n        });\n      }\n    } else if (shape === \"polygon\") {\n      const angles = (scale.ticks?.() ?? []).map((value) => scale.convert(value));\n      if (angles.length > 2) {\n        angles.forEach((angle, i) => {\n          const x = radius * Math.cos(angle);\n          const y = radius * Math.sin(angle);\n          const moveTo = i === 0;\n          points.push({ x, y, moveTo });\n        });\n      }\n    }\n    return { points, closePath: isFullCircle };\n  }\n  updateGridLines() {\n    const {\n      scale,\n      gridLength: radius,\n      gridLine: { enabled, style, width },\n      innerRadiusRatio\n    } = this;\n    if (!(style && radius > 0)) {\n      return;\n    }\n    const ticks = this.tickData;\n    const innerRadius = radius * innerRadiusRatio;\n    const styleCount = style.length;\n    const idFn = (datum) => datum.value;\n    this.gridLineGroupSelection.update(enabled ? ticks : [], void 0, idFn).each((line, datum, index) => {\n      const { value } = datum;\n      const { stroke, lineDash } = style[index % styleCount];\n      const angle = scale.convert(value);\n      line.x1 = innerRadius * Math.cos(angle);\n      line.y1 = innerRadius * Math.sin(angle);\n      line.x2 = radius * Math.cos(angle);\n      line.y2 = radius * Math.sin(angle);\n      line.stroke = stroke;\n      line.strokeWidth = width;\n      line.lineDash = lineDash;\n      line.fill = void 0;\n    });\n    this.gridLineGroupSelection.cleanup();\n  }\n  updateLabels() {\n    const { label, tickLabelGroupSelection } = this;\n    const ticks = this.tickData;\n    tickLabelGroupSelection.update(label.enabled ? ticks : []).each((node, _, index) => {\n      const labelDatum = this.labelData[index];\n      if (!labelDatum || labelDatum.hidden) {\n        node.visible = false;\n        return;\n      }\n      node.text = labelDatum.text;\n      node.setFont(label);\n      node.fill = label.color;\n      node.x = labelDatum.x;\n      node.y = labelDatum.y;\n      node.textAlign = labelDatum.textAlign;\n      node.textBaseline = labelDatum.textBaseline;\n      node.visible = true;\n      if (labelDatum.rotation) {\n        node.rotation = labelDatum.rotation;\n        node.rotationCenterX = labelDatum.x;\n        node.rotationCenterY = labelDatum.y;\n      } else {\n        node.rotation = 0;\n      }\n    });\n  }\n  updateTickLines() {\n    const { scale, gridLength: radius, tick, tickLineGroupSelection } = this;\n    const ticks = this.tickData;\n    tickLineGroupSelection.update(tick.enabled ? ticks : []).each((line, datum) => {\n      const { value } = datum;\n      const angle = scale.convert(value);\n      const cos = Math.cos(angle);\n      const sin = Math.sin(angle);\n      line.x1 = radius * cos;\n      line.y1 = radius * sin;\n      line.x2 = (radius + tick.size) * cos;\n      line.y2 = (radius + tick.size) * sin;\n      line.stroke = tick.stroke;\n      line.strokeWidth = tick.width;\n    });\n  }\n  createLabelNodeData(ticks, options, seriesRect) {\n    const { label, gridLength: radius, scale, tick } = this;\n    if (!label.enabled) {\n      return [];\n    }\n    const tempText2 = new Text2();\n    const seriesLeft = seriesRect.x - this.translation.x;\n    const seriesRight = seriesRect.x + seriesRect.width - this.translation.x;\n    const labelData = ticks.map((datum, index) => {\n      const { value } = datum;\n      const distance = radius + label.padding + tick.size;\n      const angle = scale.convert(value);\n      const cos = Math.cos(angle);\n      const sin = Math.sin(angle);\n      const x = distance * cos;\n      const y = distance * sin;\n      const { textAlign, textBaseline } = this.getLabelAlign(angle);\n      const isLastTickOverFirst = index === ticks.length - 1 && value !== ticks[0] && isNumberEqual2(normalizeAngle3602(angle), normalizeAngle3602(scale.convert(ticks[0])));\n      const rotation = this.getLabelRotation(angle);\n      let text = String(value);\n      if (label.formatter) {\n        const { callbackCache } = this.moduleCtx;\n        text = callbackCache.call(label.formatter, { value, index }) ?? \"\";\n      }\n      tempText2.text = text;\n      tempText2.x = x;\n      tempText2.y = y;\n      tempText2.setFont(label);\n      tempText2.textAlign = textAlign;\n      tempText2.textBaseline = textBaseline;\n      tempText2.rotation = rotation;\n      if (rotation) {\n        tempText2.rotationCenterX = x;\n        tempText2.rotationCenterY = y;\n      }\n      let box = rotation ? tempText2.computeTransformedBBox() : tempText2.computeBBox();\n      if (box && options.hideWhenNecessary && !rotation) {\n        const overflowLeft = seriesLeft - box.x;\n        const overflowRight = box.x + box.width - seriesRight;\n        const pixelError = 1;\n        if (overflowLeft > pixelError || overflowRight > pixelError) {\n          const availWidth = box.width - Math.max(overflowLeft, overflowRight);\n          text = Text2.wrap(text, availWidth, Infinity, label, \"never\");\n          if (text === \"\\u2026\") {\n            text = \"\";\n          }\n          tempText2.text = text;\n          box = tempText2.computeBBox();\n        }\n      }\n      return {\n        text,\n        x,\n        y,\n        textAlign,\n        textBaseline,\n        hidden: text === \"\" || datum.hidden || isLastTickOverFirst,\n        rotation,\n        box\n      };\n    });\n    if (label.avoidCollisions) {\n      this.avoidLabelCollisions(labelData);\n    }\n    return labelData;\n  }\n  computeLabelsBBox(options, seriesRect) {\n    this.tickData = this.generateAngleTicks();\n    this.labelData = this.createLabelNodeData(this.tickData, options, seriesRect);\n    const textBoxes = this.labelData.map(({ box }) => box).filter((box) => box != null);\n    if (!this.label.enabled || textBoxes.length === 0) {\n      return null;\n    }\n    return ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.BBox.merge(textBoxes);\n  }\n  getLabelOrientation() {\n    const { label } = this;\n    return label instanceof AngleAxisLabel ? label.orientation : \"fixed\";\n  }\n  getLabelRotation(tickAngle) {\n    let rotation = toRadians(this.label.rotation ?? 0);\n    tickAngle = normalizeAngle3602(tickAngle);\n    const orientation = this.getLabelOrientation();\n    if (orientation === \"parallel\") {\n      rotation += tickAngle;\n      if (tickAngle >= 0 && tickAngle < Math.PI) {\n        rotation -= Math.PI / 2;\n      } else {\n        rotation += Math.PI / 2;\n      }\n    } else if (orientation === \"perpendicular\") {\n      rotation += tickAngle;\n      if (tickAngle >= Math.PI / 2 && tickAngle < 1.5 * Math.PI) {\n        rotation += Math.PI;\n      }\n    }\n    return rotation;\n  }\n  getLabelAlign(tickAngle) {\n    const cos = Math.cos(tickAngle);\n    const sin = Math.sin(tickAngle);\n    let textAlign;\n    let textBaseline;\n    const orientation = this.getLabelOrientation();\n    const isCos0 = isNumberEqual2(cos, 0);\n    const isSin0 = isNumberEqual2(sin, 0);\n    const isCos1 = isNumberEqual2(cos, 1);\n    const isSinMinus1 = isNumberEqual2(sin, -1);\n    const isCosPositive = cos > 0 && !isCos0;\n    const isSinPositive = sin > 0 && !isSin0;\n    if (orientation === \"parallel\") {\n      textAlign = \"center\";\n      textBaseline = isCos1 && isSin0 || isSinPositive ? \"top\" : \"bottom\";\n    } else if (orientation === \"perpendicular\") {\n      textAlign = isSinMinus1 || isCosPositive ? \"left\" : \"right\";\n      textBaseline = \"middle\";\n    } else {\n      textAlign = \"right\";\n      if (isCos0) {\n        textAlign = \"center\";\n      } else if (isCosPositive) {\n        textAlign = \"left\";\n      }\n      textBaseline = \"bottom\";\n      if (isSin0) {\n        textBaseline = \"middle\";\n      } else if (isSinPositive) {\n        textBaseline = \"top\";\n      }\n    }\n    return { textAlign, textBaseline };\n  }\n  updateCrossLines() {\n    this.crossLines?.forEach((crossLine) => {\n      if (crossLine instanceof AngleCrossLine) {\n        const { shape, gridLength: radius, innerRadiusRatio } = this;\n        crossLine.shape = shape;\n        crossLine.axisOuterRadius = radius;\n        crossLine.axisInnerRadius = radius * innerRadiusRatio;\n      }\n    });\n    super.updateCrossLines({ rotation: 0, parallelFlipRotation: 0, regularFlipRotation: 0 });\n  }\n};\n__decorateClass([\n  ProxyOnWrite(\"rotation\"),\n  Validate3(NUMBER2.restrict({ min: 0, max: 360 }))\n], AngleAxis.prototype, \"startAngle\", 2);\n__decorateClass([\n  Validate3(AND2(NUMBER2.restrict({ min: 0, max: 720 }), GREATER_THAN(\"startAngle\")), { optional: true })\n], AngleAxis.prototype, \"endAngle\", 2);\n\n// packages/ag-charts-enterprise/src/axes/angle-category/angleCategoryAxis.ts\nvar { RATIO: RATIO2, OBJECT, Validate: Validate4 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { BandScale } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scale;\nvar { isNumberEqual: isNumberEqual3 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar AngleCategoryAxis = class extends AngleAxis {\n  constructor(moduleCtx) {\n    super(moduleCtx, new BandScale());\n    this.groupPaddingInner = 0;\n    this.paddingInner = 0;\n    this.interval = new AngleAxisInterval();\n  }\n  generateAngleTicks() {\n    const { scale, gridLength: radius } = this;\n    const { values, minSpacing } = this.interval;\n    const ticks = values ?? scale.ticks() ?? [];\n    if (ticks.length < 2 || isNaN(minSpacing)) {\n      return ticks.map((value) => {\n        return { value, visible: true };\n      });\n    }\n    const startTick = ticks[0];\n    const startAngle = scale.convert(startTick);\n    const startX = radius * Math.cos(startAngle);\n    const startY = radius * Math.sin(startAngle);\n    for (let step = 1; step < ticks.length - 1; step++) {\n      const nextTick = ticks[step];\n      const nextAngle = scale.convert(nextTick);\n      if (nextAngle - startAngle > Math.PI) {\n        break;\n      }\n      const nextX = radius * Math.cos(nextAngle);\n      const nextY = radius * Math.sin(nextAngle);\n      const spacing = Math.sqrt((nextX - startX) ** 2 + (nextY - startY) ** 2);\n      if (spacing > minSpacing) {\n        const visibleTicks = /* @__PURE__ */ new Set([startTick]);\n        loopSymmetrically(ticks, step, (_, next) => {\n          visibleTicks.add(next);\n        });\n        return ticks.map((value) => {\n          const visible = visibleTicks.has(value);\n          return { value, visible };\n        });\n      }\n    }\n    return [{ value: startTick, visible: true }];\n  }\n  avoidLabelCollisions(labelData) {\n    let { minSpacing } = this.label;\n    if (!Number.isFinite(minSpacing)) {\n      minSpacing = 0;\n    }\n    if (labelData.length < 3) {\n      return;\n    }\n    const labelsCollide = (prev, next) => {\n      if (prev.hidden || next.hidden) {\n        return false;\n      }\n      const prevBox = prev.box.clone().grow(minSpacing / 2);\n      const nextBox = next.box.clone().grow(minSpacing / 2);\n      return prevBox.collidesBBox(nextBox);\n    };\n    const firstLabel = labelData[0];\n    const lastLabel = labelData.at(-1);\n    const visibleLabels = /* @__PURE__ */ new Set([firstLabel]);\n    const lastLabelIsOverFirst = isNumberEqual3(firstLabel.x, lastLabel.x) && isNumberEqual3(firstLabel.y, lastLabel.y);\n    const maxStep = Math.floor(labelData.length / 2);\n    for (let step = 1; step <= maxStep; step++) {\n      const labels = lastLabelIsOverFirst ? labelData.slice(0, -1) : labelData;\n      const collisionDetected = loopSymmetrically(labels, step, labelsCollide);\n      if (!collisionDetected) {\n        loopSymmetrically(labels, step, (_, next) => {\n          visibleLabels.add(next);\n        });\n        break;\n      }\n    }\n    labelData.forEach((datum) => {\n      if (!visibleLabels.has(datum)) {\n        datum.hidden = true;\n        datum.box = void 0;\n      }\n    });\n  }\n};\nAngleCategoryAxis.className = \"AngleCategoryAxis\";\nAngleCategoryAxis.type = \"angle-category\";\n__decorateClass([\n  Validate4(RATIO2)\n], AngleCategoryAxis.prototype, \"groupPaddingInner\", 2);\n__decorateClass([\n  Validate4(RATIO2)\n], AngleCategoryAxis.prototype, \"paddingInner\", 2);\n__decorateClass([\n  Validate4(OBJECT)\n], AngleCategoryAxis.prototype, \"interval\", 2);\n\n// packages/ag-charts-enterprise/src/axes/angle-category/angleCategoryAxisModule.ts\nvar AngleCategoryAxisModule = {\n  type: \"axis\",\n  optionsKey: \"axes[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"polar\"],\n  identifier: \"angle-category\",\n  instanceConstructor: AngleCategoryAxis\n};\n\n// packages/ag-charts-enterprise/src/axes/angle-number/angleNumberAxis.ts\n\n\n// packages/ag-charts-enterprise/src/axes/angle-number/linearAngleScale.ts\n\nvar { LinearScale, Invalidating } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scale;\nvar { isNumberEqual: isNumberEqual4, range, isDenseInterval } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar LinearAngleScale = class extends LinearScale {\n  constructor() {\n    super(...arguments);\n    this.arcLength = 0;\n    this.niceTickStep = 0;\n  }\n  ticks() {\n    if (!this.domain || this.domain.length < 2 || this.domain.some((d) => !isFinite(d)) || this.arcLength <= 0) {\n      return [];\n    }\n    this.refresh();\n    const { interval } = this;\n    const [d0, d1] = this.getDomain();\n    if (interval) {\n      const step2 = Math.abs(interval);\n      const availableRange = this.getPixelRange();\n      if (!isDenseInterval((d1 - d0) / step2, availableRange)) {\n        return range(d0, d1, step2);\n      }\n    }\n    const step = this.nice && this.niceTickStep ? this.niceTickStep : this.getTickStep(d0, d1);\n    return range(d0, d1, step);\n  }\n  hasNiceRange() {\n    const sortedRange = this.range.slice().sort((a, b) => a - b);\n    const niceRanges = [Math.PI, 2 * Math.PI];\n    return niceRanges.some((r) => isNumberEqual4(r, sortedRange[1] - sortedRange[0]));\n  }\n  getNiceStepAndTickCount() {\n    const [start, stop] = this.niceDomain;\n    let step = this.getTickStep(start, stop);\n    const maxTickCount = isNaN(this.maxTickCount) ? Infinity : this.maxTickCount;\n    const expectedTickCount = Math.abs(stop - start) / step;\n    let niceTickCount = Math.pow(2, Math.ceil(Math.log(expectedTickCount) / Math.log(2)));\n    if (niceTickCount > maxTickCount) {\n      niceTickCount /= 2;\n      step *= 2;\n    }\n    return {\n      count: niceTickCount,\n      step\n    };\n  }\n  updateNiceDomain() {\n    super.updateNiceDomain();\n    if (!this.hasNiceRange()) {\n      return;\n    }\n    const reversed = this.niceDomain[0] > this.niceDomain[1];\n    const start = reversed ? this.niceDomain[1] : this.niceDomain[0];\n    const { step, count } = this.getNiceStepAndTickCount();\n    const s = 1 / step;\n    const stop = step >= 1 ? Math.ceil(start / step + count) * step : Math.ceil((start + count * step) * s) / s;\n    this.niceDomain = reversed ? [stop, start] : [start, stop];\n    this.niceTickStep = step;\n  }\n  getPixelRange() {\n    return this.arcLength;\n  }\n};\n__decorateClass([\n  Invalidating\n], LinearAngleScale.prototype, \"arcLength\", 2);\n\n// packages/ag-charts-enterprise/src/axes/angle-number/angleNumberAxis.ts\nvar { AND: AND3, Default, GREATER_THAN: GREATER_THAN2, LESS_THAN, NUMBER_OR_NAN, OBJECT: OBJECT2, Validate: Validate5 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { angleBetween: angleBetween2, isNumberEqual: isNumberEqual5, normalisedExtentWithMetadata } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar AngleNumberAxis = class extends AngleAxis {\n  constructor(moduleCtx) {\n    super(moduleCtx, new LinearAngleScale());\n    this.shape = \"circle\";\n    this.min = NaN;\n    this.max = NaN;\n    this.interval = new AngleAxisInterval();\n  }\n  normaliseDataDomain(d) {\n    const { min, max } = this;\n    const { extent: extent6, clipped } = normalisedExtentWithMetadata(d, min, max);\n    return { domain: extent6, clipped };\n  }\n  getRangeArcLength() {\n    const { range: requestedRange } = this;\n    const min = Math.min(...requestedRange);\n    const max = Math.max(...requestedRange);\n    const rotation = angleBetween2(min, max) || 2 * Math.PI;\n    const radius = this.gridLength;\n    return rotation * radius;\n  }\n  generateAngleTicks() {\n    const arcLength = this.getRangeArcLength();\n    const { scale, range: requestedRange } = this;\n    const { values, minSpacing, maxSpacing } = this.interval;\n    const minTicksCount = maxSpacing ? Math.floor(arcLength / maxSpacing) : 1;\n    const maxTicksCount = minSpacing ? Math.floor(arcLength / minSpacing) : Infinity;\n    const preferredTicksCount = Math.floor(4 / Math.PI * Math.abs(requestedRange[0] - requestedRange[1]));\n    scale.tickCount = Math.max(minTicksCount, Math.min(maxTicksCount, preferredTicksCount));\n    scale.minTickCount = minTicksCount;\n    scale.maxTickCount = maxTicksCount;\n    scale.arcLength = arcLength;\n    const ticks = values ?? scale.ticks();\n    return ticks.map((value) => {\n      return { value, visible: true };\n    });\n  }\n  avoidLabelCollisions(labelData) {\n    let { minSpacing } = this.label;\n    if (!Number.isFinite(minSpacing)) {\n      minSpacing = 0;\n    }\n    const labelsCollide = (prev, next) => {\n      if (prev.hidden || next.hidden) {\n        return false;\n      }\n      const prevBox = prev.box.clone().grow(minSpacing / 2);\n      const nextBox = next.box.clone().grow(minSpacing / 2);\n      return prevBox.collidesBBox(nextBox);\n    };\n    const firstLabel = labelData[0];\n    const lastLabel = labelData.at(-1);\n    if (firstLabel !== lastLabel && isNumberEqual5(firstLabel.x, lastLabel.x) && isNumberEqual5(firstLabel.y, lastLabel.y)) {\n      lastLabel.hidden = true;\n    }\n    for (let step = 1; step < labelData.length; step *= 2) {\n      let collisionDetected = false;\n      for (let i = step; i < labelData.length; i += step) {\n        const next = labelData[i];\n        const prev = labelData[i - step];\n        if (labelsCollide(prev, next)) {\n          collisionDetected = true;\n          break;\n        }\n      }\n      if (!collisionDetected) {\n        labelData.forEach((datum, i) => {\n          if (i % step > 0) {\n            datum.hidden = true;\n            datum.box = void 0;\n          }\n        });\n        return;\n      }\n    }\n    labelData.forEach((datum, i) => {\n      if (i > 0) {\n        datum.hidden = true;\n        datum.box = void 0;\n      }\n    });\n  }\n};\nAngleNumberAxis.className = \"AngleNumberAxis\";\nAngleNumberAxis.type = \"angle-number\";\n__decorateClass([\n  Validate5(AND3(NUMBER_OR_NAN, LESS_THAN(\"max\"))),\n  Default(NaN)\n], AngleNumberAxis.prototype, \"min\", 2);\n__decorateClass([\n  Validate5(AND3(NUMBER_OR_NAN, GREATER_THAN2(\"min\"))),\n  Default(NaN)\n], AngleNumberAxis.prototype, \"max\", 2);\n__decorateClass([\n  Validate5(OBJECT2)\n], AngleNumberAxis.prototype, \"interval\", 2);\n\n// packages/ag-charts-enterprise/src/axes/angle-number/angleNumberAxisModule.ts\nvar AngleNumberAxisModule = {\n  type: \"axis\",\n  optionsKey: \"axes[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"polar\"],\n  identifier: \"angle-number\",\n  instanceConstructor: AngleNumberAxis\n};\n\n// packages/ag-charts-enterprise/src/axes/ordinal/ordinalTimeAxis.ts\n\nvar { OrdinalTimeScale } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scale;\nvar { dateToNumber } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar OrdinalTimeAxis = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.CategoryAxis {\n  constructor(moduleCtx) {\n    super(moduleCtx, new OrdinalTimeScale());\n  }\n  normaliseDataDomain(d) {\n    const domain = [];\n    const uniqueValues = /* @__PURE__ */ new Set();\n    for (let v of d) {\n      if (typeof v === \"number\") {\n        v = new Date(v);\n      }\n      const key = dateToNumber(v);\n      if (!uniqueValues.has(key)) {\n        uniqueValues.add(key);\n        domain.push(v);\n      }\n    }\n    domain.sort((a, b) => dateToNumber(a) - dateToNumber(b));\n    return { domain, clipped: false };\n  }\n  onFormatChange(ticks, fractionDigits, domain, format) {\n    if (format) {\n      super.onFormatChange(ticks, fractionDigits, domain, format);\n    } else {\n      this.labelFormatter = this.scale.tickFormat({ ticks, domain });\n    }\n  }\n};\nOrdinalTimeAxis.className = \"OrdinalTimeAxis\";\nOrdinalTimeAxis.type = \"ordinal-time\";\n\n// packages/ag-charts-enterprise/src/axes/ordinal/ordinalTimeAxisModule.ts\nvar OrdinalTimeAxisModule = {\n  type: \"axis\",\n  optionsKey: \"axes[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"ordinal-time\",\n  instanceConstructor: OrdinalTimeAxis\n};\n\n// packages/ag-charts-enterprise/src/axes/radius-category/radiusCategoryAxis.ts\n\n\n// packages/ag-charts-enterprise/src/axes/radius/radiusAxis.ts\n\n\n// packages/ag-charts-enterprise/src/axes/polar-crosslines/radiusCrossLine.ts\n\nvar { ChartAxisDirection: ChartAxisDirection4, Validate: Validate6, DEGREE, validateCrossLineValues: validateCrossLineValues2 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { Path: Path3, Sector: Sector2, Text: Text3 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar { normalizeAngle360: normalizeAngle3603, toRadians: toRadians2, isNumberEqual: isNumberEqual6 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar RadiusCrossLineLabel = class extends PolarCrossLineLabel {\n  constructor() {\n    super(...arguments);\n    this.positionAngle = void 0;\n  }\n};\n__decorateClass([\n  Validate6(DEGREE, { optional: true })\n], RadiusCrossLineLabel.prototype, \"positionAngle\", 2);\nvar _RadiusCrossLine = class _RadiusCrossLine extends PolarCrossLine {\n  constructor() {\n    super();\n    this.direction = ChartAxisDirection4.Y;\n    this.label = new RadiusCrossLineLabel();\n    this.polygonNode = new Path3();\n    this.sectorNode = new Sector2();\n    this.labelNode = new Text3();\n    this.outerRadius = 0;\n    this.innerRadius = 0;\n    this.group.append(this.polygonNode);\n    this.group.append(this.sectorNode);\n    this.labelGroup.append(this.labelNode);\n  }\n  update(visible) {\n    const { scale, type, value, range: range2 } = this;\n    if (!scale || !type || !validateCrossLineValues2(type, value, range2, scale)) {\n      this.group.visible = false;\n      this.labelGroup.visible = false;\n      return;\n    }\n    if (type === \"line\" && scale instanceof ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scale.BandScale) {\n      this.type = \"range\";\n      this.range = [value, value];\n    }\n    this.updateRadii();\n    const { innerRadius, outerRadius } = this;\n    visible && (visible = innerRadius >= this.axisInnerRadius && outerRadius <= this.axisOuterRadius);\n    this.group.visible = visible;\n    this.labelGroup.visible = visible;\n    this.updatePolygonNode(visible);\n    this.updateSectorNode(visible);\n    this.updateLabelNode(visible);\n    this.group.zIndex = this.type === \"line\" ? _RadiusCrossLine.LINE_LAYER_ZINDEX : _RadiusCrossLine.RANGE_LAYER_ZINDEX;\n  }\n  updateRadii() {\n    const { range: range2, scale, type, axisInnerRadius, axisOuterRadius } = this;\n    if (!scale)\n      return { innerRadius: 0, outerRadius: 0 };\n    const getRadius = (value) => axisOuterRadius + axisInnerRadius - value;\n    let outerRadius = 0;\n    let innerRadius = 0;\n    if (type === \"line\") {\n      outerRadius = getRadius(scale.convert(this.value));\n      innerRadius = outerRadius;\n    } else {\n      const bandwidth = Math.abs(scale?.bandwidth ?? 0);\n      const convertedRange = range2.map((r) => scale.convert(r));\n      outerRadius = getRadius(Math.max(...convertedRange));\n      innerRadius = getRadius(Math.min(...convertedRange)) + bandwidth;\n    }\n    this.outerRadius = outerRadius;\n    this.innerRadius = innerRadius;\n  }\n  drawPolygon(radius, angles, polygon) {\n    angles.forEach((angle, index) => {\n      const x = radius * Math.cos(angle);\n      const y = radius * Math.sin(angle);\n      if (index === 0) {\n        polygon.path.moveTo(x, y);\n      } else {\n        polygon.path.lineTo(x, y);\n      }\n    });\n    polygon.path.closePath();\n  }\n  updatePolygonNode(visible) {\n    const { gridAngles, polygonNode: polygon, scale, shape, type, innerRadius, outerRadius } = this;\n    if (!visible || shape !== \"polygon\" || !scale || !gridAngles) {\n      polygon.visible = false;\n      return;\n    }\n    polygon.visible = true;\n    const padding = this.getPadding();\n    polygon.path.clear(true);\n    this.drawPolygon(outerRadius - padding, gridAngles, polygon);\n    const reversedAngles = gridAngles.slice().reverse();\n    const innerPolygonRadius = type === \"line\" ? outerRadius - padding : innerRadius + padding;\n    this.drawPolygon(innerPolygonRadius, reversedAngles, polygon);\n    this.setSectorNodeProps(polygon);\n  }\n  updateSectorNode(visible) {\n    const { axisInnerRadius, axisOuterRadius, scale, sectorNode: sector, shape, innerRadius, outerRadius } = this;\n    if (!visible || shape !== \"circle\" || !scale) {\n      sector.visible = false;\n      return;\n    }\n    sector.visible = true;\n    sector.startAngle = 0;\n    sector.endAngle = 2 * Math.PI;\n    const padding = this.getPadding();\n    sector.innerRadius = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util.clamp(axisInnerRadius, innerRadius + padding, axisOuterRadius);\n    sector.outerRadius = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util.clamp(axisInnerRadius, outerRadius - padding, axisOuterRadius);\n    this.setSectorNodeProps(sector);\n  }\n  updateLabelNode(visible) {\n    const { innerRadius, label, labelNode: node, scale, shape, type } = this;\n    if (!visible || label.enabled === false || !label.text || !scale) {\n      node.visible = false;\n      return;\n    }\n    const angle = normalizeAngle3603(toRadians2((label.positionAngle ?? 0) - 90));\n    const isBottomSide = (isNumberEqual6(angle, 0) || angle > 0) && angle < Math.PI;\n    const rotation = isBottomSide ? angle - Math.PI / 2 : angle + Math.PI / 2;\n    let distance = 0;\n    const angles = this.gridAngles ?? [];\n    if (type === \"line\") {\n      distance = innerRadius + label.padding;\n    } else if (shape === \"circle\" || angles.length < 3) {\n      distance = innerRadius - label.padding;\n    } else {\n      distance = innerRadius * Math.cos(Math.PI / angles.length) - label.padding;\n    }\n    const labelX = distance * Math.cos(angle);\n    const labelY = distance * Math.sin(angle);\n    let textBaseline;\n    if (type === \"line\") {\n      textBaseline = isBottomSide ? \"top\" : \"bottom\";\n    } else {\n      textBaseline = isBottomSide ? \"bottom\" : \"top\";\n    }\n    this.setLabelNodeProps(node, labelX, labelY, textBaseline, rotation);\n  }\n  getPadding() {\n    const { scale } = this;\n    if (!scale)\n      return 0;\n    const bandwidth = Math.abs(scale.bandwidth ?? 0);\n    const step = Math.abs(scale.step ?? 0);\n    return scale instanceof ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scale.BandScale ? (step - bandwidth) / 2 : 0;\n  }\n};\n_RadiusCrossLine.className = \"RadiusCrossLine\";\nvar RadiusCrossLine = _RadiusCrossLine;\n\n// packages/ag-charts-enterprise/src/axes/radius/radiusAxis.ts\nvar { assignJsonApplyConstructedArray: assignJsonApplyConstructedArray2, ChartAxisDirection: ChartAxisDirection5, Default: Default2, Layers: Layers2, DEGREE: DEGREE2, BOOLEAN: BOOLEAN2, Validate: Validate7 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { Caption, Group: Group2, Path: Path4, Selection } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar { isNumberEqual: isNumberEqual7, normalizeAngle360: normalizeAngle3604, toRadians: toRadians3 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar RadiusAxisLabel = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.AxisLabel {\n  constructor() {\n    super(...arguments);\n    this.autoRotateAngle = 335;\n  }\n};\n__decorateClass([\n  Validate7(BOOLEAN2, { optional: true })\n], RadiusAxisLabel.prototype, \"autoRotate\", 2);\n__decorateClass([\n  Validate7(DEGREE2)\n], RadiusAxisLabel.prototype, \"autoRotateAngle\", 2);\nvar RadiusAxis = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.PolarAxis {\n  constructor(moduleCtx, scale) {\n    super(moduleCtx, scale);\n    this.positionAngle = 0;\n    this.gridPathGroup = this.gridGroup.appendChild(\n      new Group2({\n        name: `${this.id}-gridPaths`,\n        zIndex: Layers2.AXIS_GRID_ZINDEX\n      })\n    );\n    this.gridPathSelection = Selection.select(this.gridPathGroup, Path4);\n  }\n  get direction() {\n    return ChartAxisDirection5.Y;\n  }\n  assignCrossLineArrayConstructor(crossLines) {\n    assignJsonApplyConstructedArray2(crossLines, RadiusCrossLine);\n  }\n  getAxisTransform() {\n    const maxRadius = this.scale.range[0];\n    const { translation, positionAngle, innerRadiusRatio } = this;\n    const innerRadius = maxRadius * innerRadiusRatio;\n    const rotation = toRadians3(positionAngle);\n    return {\n      translationX: translation.x,\n      translationY: translation.y - maxRadius - innerRadius,\n      rotation,\n      rotationCenterX: 0,\n      rotationCenterY: maxRadius + innerRadius\n    };\n  }\n  updateSelections(lineData, data, params) {\n    super.updateSelections(lineData, data, params);\n    const {\n      gridLine: { enabled, style, width },\n      shape\n    } = this;\n    if (!style) {\n      return;\n    }\n    const ticks = this.prepareTickData(data);\n    const styleCount = style.length;\n    const setStyle = (node, index) => {\n      const { stroke, lineDash } = style[index % styleCount];\n      node.stroke = stroke;\n      node.strokeWidth = width;\n      node.lineDash = lineDash;\n      node.fill = void 0;\n    };\n    const [startAngle, endAngle] = this.gridRange ?? [0, 2 * Math.PI];\n    const isFullCircle = isNumberEqual7(endAngle - startAngle, 2 * Math.PI);\n    const drawCircleShape = (node, value) => {\n      const { path } = node;\n      path.clear(true);\n      const radius = this.getTickRadius(value);\n      if (isFullCircle) {\n        path.moveTo(radius, 0);\n        path.arc(0, 0, radius, 0, 2 * Math.PI);\n      } else {\n        path.moveTo(radius * Math.cos(startAngle), radius * Math.sin(startAngle));\n        path.arc(0, 0, radius, normalizeAngle3604(startAngle), normalizeAngle3604(endAngle));\n      }\n      if (isFullCircle) {\n        path.closePath();\n      }\n    };\n    const drawPolygonShape = (node, value) => {\n      const { path } = node;\n      const angles = this.gridAngles;\n      path.clear(true);\n      if (!angles || angles.length < 3) {\n        return;\n      }\n      const radius = this.getTickRadius(value);\n      angles.forEach((angle, idx) => {\n        const x = radius * Math.cos(angle);\n        const y = radius * Math.sin(angle);\n        if (idx === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n        angles.forEach((innerAngle, innerIdx) => {\n          const x2 = radius * Math.cos(innerAngle);\n          const y2 = radius * Math.sin(innerAngle);\n          if (innerIdx === 0) {\n            path.moveTo(x2, y2);\n          } else {\n            path.lineTo(x2, y2);\n          }\n        });\n        path.closePath();\n      });\n      path.closePath();\n    };\n    this.gridPathSelection.update(enabled ? ticks : []).each((node, value, index) => {\n      setStyle(node, index);\n      if (shape === \"circle\") {\n        drawCircleShape(node, value);\n      } else {\n        drawPolygonShape(node, value);\n      }\n    });\n  }\n  updateTitle() {\n    const identityFormatter = (params) => params.defaultValue;\n    const {\n      title,\n      _titleCaption,\n      range: requestedRange,\n      moduleCtx: { callbackCache }\n    } = this;\n    const { formatter = identityFormatter } = this.title ?? {};\n    if (!title) {\n      _titleCaption.enabled = false;\n      return;\n    }\n    _titleCaption.enabled = title.enabled;\n    _titleCaption.fontFamily = title.fontFamily;\n    _titleCaption.fontSize = title.fontSize;\n    _titleCaption.fontStyle = title.fontStyle;\n    _titleCaption.fontWeight = title.fontWeight;\n    _titleCaption.color = title.color;\n    _titleCaption.wrapping = title.wrapping;\n    let titleVisible = false;\n    const titleNode = _titleCaption.node;\n    if (title.enabled) {\n      titleVisible = true;\n      titleNode.rotation = Math.PI / 2;\n      titleNode.x = Math.floor((requestedRange[0] + requestedRange[1]) / 2);\n      titleNode.y = -Caption.SMALL_PADDING;\n      titleNode.textAlign = \"center\";\n      titleNode.textBaseline = \"bottom\";\n      titleNode.text = callbackCache.call(formatter, this.getTitleFormatterParams());\n    }\n    titleNode.visible = titleVisible;\n  }\n  updateCrossLines() {\n    this.crossLines?.forEach((crossLine) => {\n      if (crossLine instanceof RadiusCrossLine) {\n        const { shape, gridAngles, range: range2, innerRadiusRatio } = this;\n        const radius = range2[0];\n        crossLine.shape = shape;\n        crossLine.gridAngles = gridAngles;\n        crossLine.axisOuterRadius = radius;\n        crossLine.axisInnerRadius = radius * innerRadiusRatio;\n      }\n    });\n    super.updateCrossLines({ rotation: 0, parallelFlipRotation: 0, regularFlipRotation: 0 });\n  }\n  createLabel() {\n    return new RadiusAxisLabel();\n  }\n};\n__decorateClass([\n  Validate7(DEGREE2),\n  Default2(0)\n], RadiusAxis.prototype, \"positionAngle\", 2);\n\n// packages/ag-charts-enterprise/src/axes/radius-category/radiusCategoryAxis.ts\nvar { RATIO: RATIO3, ProxyPropertyOnWrite, Validate: Validate8 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { BandScale: BandScale2 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scale;\nvar RadiusCategoryAxis = class extends RadiusAxis {\n  constructor(moduleCtx) {\n    super(moduleCtx, new BandScale2());\n    this.shape = \"circle\";\n    this.groupPaddingInner = 0;\n    this.paddingInner = 0;\n    this.paddingOuter = 0;\n  }\n  prepareTickData(data) {\n    return data.slice().reverse();\n  }\n  getTickRadius(tickDatum) {\n    const { scale, innerRadiusRatio } = this;\n    const maxRadius = scale.range[0];\n    const minRadius = maxRadius * innerRadiusRatio;\n    if (scale instanceof BandScale2) {\n      const ticks = scale.ticks();\n      const index = ticks.length - 1 - ticks.indexOf(tickDatum.tickId);\n      return index === 0 ? minRadius : scale.inset + scale.step * (index - 0.5) + scale.bandwidth / 2;\n    } else {\n      const tickRange = (maxRadius - minRadius) / scale.domain.length;\n      return maxRadius - tickDatum.translationY + minRadius - tickRange / 2;\n    }\n  }\n};\nRadiusCategoryAxis.className = \"RadiusCategoryAxis\";\nRadiusCategoryAxis.type = \"radius-category\";\n__decorateClass([\n  Validate8(RATIO3)\n], RadiusCategoryAxis.prototype, \"groupPaddingInner\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"scale\", \"paddingInner\"),\n  Validate8(RATIO3)\n], RadiusCategoryAxis.prototype, \"paddingInner\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"scale\", \"paddingOuter\"),\n  Validate8(RATIO3)\n], RadiusCategoryAxis.prototype, \"paddingOuter\", 2);\n\n// packages/ag-charts-enterprise/src/axes/radius-category/radiusCategoryAxisModule.ts\nvar RadiusCategoryAxisModule = {\n  type: \"axis\",\n  optionsKey: \"axes[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"polar\"],\n  identifier: \"radius-category\",\n  instanceConstructor: RadiusCategoryAxis\n};\n\n// packages/ag-charts-enterprise/src/axes/radius-number/radiusNumberAxis.ts\n\nvar { AND: AND4, Default: Default3, GREATER_THAN: GREATER_THAN3, LESS_THAN: LESS_THAN2, NUMBER_OR_NAN: NUMBER_OR_NAN2, Validate: Validate9 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { LinearScale: LinearScale2 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scale;\nvar { normalisedExtentWithMetadata: normalisedExtentWithMetadata2 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar RadiusNumberAxis = class extends RadiusAxis {\n  constructor(moduleCtx) {\n    super(moduleCtx, new LinearScale2());\n    this.shape = \"polygon\";\n    this.min = NaN;\n    this.max = NaN;\n  }\n  prepareTickData(data) {\n    const { scale } = this;\n    const domainTop = scale.getDomain?.()[1];\n    return data.filter(({ tick }) => tick !== domainTop).sort((a, b) => b.tick - a.tick);\n  }\n  getTickRadius(tickDatum) {\n    const { scale } = this;\n    const maxRadius = scale.range[0];\n    const minRadius = maxRadius * this.innerRadiusRatio;\n    return maxRadius - tickDatum.translationY + minRadius;\n  }\n  normaliseDataDomain(d) {\n    const { min, max } = this;\n    const { extent: extent6, clipped } = normalisedExtentWithMetadata2(d, min, max);\n    return { domain: extent6, clipped };\n  }\n};\nRadiusNumberAxis.className = \"RadiusNumberAxis\";\nRadiusNumberAxis.type = \"radius-number\";\n__decorateClass([\n  Validate9(AND4(NUMBER_OR_NAN2, LESS_THAN2(\"max\"))),\n  Default3(NaN)\n], RadiusNumberAxis.prototype, \"min\", 2);\n__decorateClass([\n  Validate9(AND4(NUMBER_OR_NAN2, GREATER_THAN3(\"min\"))),\n  Default3(NaN)\n], RadiusNumberAxis.prototype, \"max\", 2);\n\n// packages/ag-charts-enterprise/src/axes/radius-number/radiusNumberAxisModule.ts\nvar RadiusNumberAxisModule = {\n  type: \"axis\",\n  optionsKey: \"axes[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"polar\"],\n  identifier: \"radius-number\",\n  instanceConstructor: RadiusNumberAxis\n};\n\n// packages/ag-charts-enterprise/src/features/animation/animation.ts\n\nvar { BOOLEAN: BOOLEAN3, POSITIVE_NUMBER: POSITIVE_NUMBER3, ObserveChanges, Validate: Validate10 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar Animation = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.enabled = true;\n    ctx.animationManager.skip(false);\n  }\n};\n__decorateClass([\n  ObserveChanges((target, newValue) => {\n    target.ctx.animationManager.skip(!newValue);\n  }),\n  Validate10(BOOLEAN3)\n], Animation.prototype, \"enabled\", 2);\n__decorateClass([\n  ObserveChanges((target, newValue) => {\n    target.ctx.animationManager.defaultDuration = newValue;\n  }),\n  Validate10(POSITIVE_NUMBER3, { optional: true })\n], Animation.prototype, \"duration\", 2);\n\n// packages/ag-charts-enterprise/src/features/animation/animationModule.ts\nvar AnimationModule = {\n  type: \"root\",\n  optionsKey: \"animation\",\n  packageType: \"enterprise\",\n  chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n  instanceConstructor: Animation,\n  themeTemplate: {\n    animation: {\n      enabled: true\n    }\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/annotations/annotationsModule.ts\n\n\n// packages/ag-charts-enterprise/src/features/annotations/annotations.ts\n\n\n// packages/ag-charts-enterprise/src/utils/position.ts\n\nvar { ChartAxisDirection: ChartAxisDirection6 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nfunction calculateAxisLabelPosition({\n  x,\n  y,\n  labelBBox,\n  bounds,\n  axisPosition,\n  axisDirection,\n  padding\n}) {\n  let coordinates;\n  if (axisDirection === ChartAxisDirection6.X) {\n    const alignmentShift = 4;\n    const xOffset = -labelBBox.width / 2;\n    const yOffset = axisPosition === \"bottom\" ? -alignmentShift : -labelBBox.height + alignmentShift;\n    const fixedY = axisPosition === \"bottom\" ? bounds.y + bounds.height + padding : bounds.y - padding;\n    coordinates = {\n      x: x + xOffset,\n      y: fixedY + yOffset\n    };\n  } else {\n    const alignmentShift = 8;\n    const yOffset = -labelBBox.height / 2;\n    const xOffset = axisPosition === \"right\" ? -alignmentShift : -labelBBox.width + alignmentShift;\n    const fixedX = axisPosition === \"right\" ? bounds.x + bounds.width + padding : bounds.x - padding;\n    coordinates = {\n      x: fixedX + xOffset,\n      y: y + yOffset\n    };\n  }\n  return coordinates;\n}\nfunction buildBounds(rect, axisPosition, padding) {\n  const bounds = rect.clone();\n  bounds.x += axisPosition === \"left\" ? -padding : 0;\n  bounds.y += axisPosition === \"top\" ? -padding : 0;\n  bounds.width += axisPosition === \"left\" || axisPosition === \"right\" ? padding : 0;\n  bounds.height += axisPosition === \"top\" || axisPosition === \"bottom\" ? padding : 0;\n  return bounds;\n}\n\n// packages/ag-charts-enterprise/src/features/color-picker/colorPicker.ts\n\n\n// packages/ag-charts-enterprise/src/features/color-picker/colorPickerStyles.css\nvar colorPickerStyles_default = `.ag-charts-color-picker{position:absolute;display:flex;flex-direction:column;width:190px;padding:8px;border:var(--ag-charts-toolbar-border);color:var(--ag-charts-toolbar-foreground-color);background:var(--ag-charts-toolbar-background-color);border-radius:4px;z-index:99999;--h:0;--s:0;--v:0;--a:0;--color:#000;--color-a:#000;--thumb-size:18px;--inner-width:172px;--track-height:12px;--palette-height:136px;--checker:url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"4\" height=\"4\"><rect x=\"0\" y=\"0\" width=\"4\" height=\"4\" fill=\"%23fff\"/><path d=\"M0 0H2V4H4V2H0Z\" fill=\"%23b2b2b2\"/></svg>')}.ag-charts-color-picker__palette{position:relative;width:100%;height:var(--palette-height);margin-bottom:8px;background:linear-gradient(to bottom,#0000,#000),linear-gradient(to right,#fff,#fff0) hsl(var(--h),100%,50%);border-radius:6px;box-shadow:inset 0 0 0 1px #0003}.ag-charts-color-picker__palette::after{content:'';position:absolute;display:block;top:calc(var(--thumb-size) * -0.5 + (1 - var(--v)) * 100%);left:calc(var(--thumb-size) * -0.5 + var(--s) * 100%);background:var(--color);width:var(--thumb-size);height:var(--thumb-size);border-radius:99px;box-shadow:var(--box-shadow);--box-shadow:inset 0 0 0 3px white,inset 0 0 1px 3px #0006,0 0 5px #00000038}.ag-charts-color-picker__palette:focus-visible::after{outline:var(--ag-charts-focus-border);box-shadow:var(--box-shadow),0 0 0 2px #fff8,var(--ag-charts-focus-border-shadow)}.ag-charts-color-picker__hue-input,\n.ag-charts-color-picker__alpha-input{-webkit-appearance:none;display:block;position:relative;padding:0;margin:0 calc(var(--inset) * -1);border:0;height:var(--thumb-size);width:auto;background:transparent;--inset:calc((var(--thumb-size) - var(--track-height)) / 2)}.ag-charts-color-picker__hue-input::-webkit-slider-thumb,\n.ag-charts-color-picker__alpha-input::-webkit-slider-thumb{-webkit-appearance:none;width:var(--thumb-size);height:var(--thumb-size);border-radius:99px;box-shadow:var(--box-shadow);--box-shadow:inset 0 0 0 3px white,inset 0 0 1px 3px #0006,0 0 5px #00000038;transform:translate3d(0,0,0)}.ag-charts-color-picker__hue-input::-webkit-slider-thumb{background:hsl(var(--h),100%,50%)}.ag-charts-color-picker__alpha-input::-webkit-slider-thumb{background:transparent}.ag-charts-color-picker__alpha-input--opaque::-webkit-slider-thumb{background:var(--color)}.ag-charts-color-picker__hue-input:focus-visible::-webkit-slider-thumb,\n.ag-charts-color-picker__alpha-input:focus-visible::-webkit-slider-thumb{outline:var(--ag-charts-focus-border);box-shadow:var(--box-shadow),var(--ag-charts-focus-border-shadow)}.ag-charts-color-picker__hue-input::before,\n.ag-charts-color-picker__alpha-input::before{position:absolute;content:'';display:block;top:calc(50% - var(--track-height) / 2);left:var(--inset);right:var(--inset);height:var(--track-height);border-radius:99px;box-shadow:inset 0 0 0 1px #0003}.ag-charts-color-picker__hue-input{margin-bottom:4px}.ag-charts-color-picker__hue-input::before{background:linear-gradient(to right,#f00,#f00 calc((100% - var(--track-height)) * 0 / 6 + var(--track-height) / 2),#ff0 calc((100% - var(--track-height)) * 1 / 6 + var(--track-height) / 2),#0f0 calc((100% - var(--track-height)) * 2 / 6 + var(--track-height) / 2),#0ff calc((100% - var(--track-height)) * 3 / 6 + var(--track-height) / 2),#00f calc((100% - var(--track-height)) * 4 / 6 + var(--track-height) / 2),#f0f calc((100% - var(--track-height)) * 5 / 6 + var(--track-height) / 2),#f00 calc((100% - var(--track-height)) * 6 / 6 + var(--track-height) / 2))}.ag-charts-color-picker__alpha-input{margin-bottom:7px}.ag-charts-color-picker__alpha-input::before{background:linear-gradient(to right,transparent,var(--color)),var(--checker) top left /4px 4px}.ag-charts-color-picker__color-field{display:flex;border:var(--ag-charts-border);background:var(--ag-charts-background-color);border-radius:4px;overflow:hidden}.ag-charts-color-picker__color-field:has(:focus-visible){border-color:var(--ag-charts-active-color);box-shadow:var(--ag-charts-focus-border-shadow)}.ag-charts-color-picker__color-label{width:16px;height:16px;margin:7px 0px 7px 7px;color:transparent;background:linear-gradient(to right,var(--color-a),var(--color-a)),var(--checker) top left /4px 4px;border-radius:2px;box-shadow:inset 0 0 0 1px #0003}.ag-charts-color-picker__color-input{flex:1;min-width:0;padding:7px 7px 7px 8px;border:0;margin:0;color:inherit;background:transparent;font-variant:tabular-nums}.ag-charts-color-picker__color-input:focus-visible{border:none;outline:none}`;\n\n// packages/ag-charts-enterprise/src/features/color-picker/colorPickerTemplate.html\nvar colorPickerTemplate_default = '<div class=\"ag-charts-color-picker\"><div class=\"ag-charts-color-picker__palette\" tabindex=\"0\"></div><input class=\"ag-charts-color-picker__hue-input\" tabindex=\"0\" type=\"range\" min=\"0\" max=\"360\" value=\"0\"> <input class=\"ag-charts-color-picker__alpha-input\" tabindex=\"0\" type=\"range\" min=\"0\" max=\"1\" value=\"1\" step=\"0.01\"> <label class=\"ag-charts-color-picker__color-field\"><span class=\"ag-charts-color-picker__color-label\">Color</span> <input class=\"ag-charts-color-picker__color-input\" tabindex=\"0\" value=\"#000\"></label></div>';\n\n// packages/ag-charts-enterprise/src/features/color-picker/colorPicker.ts\nvar { clamp, createElement } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { Color } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar moduleId = \"color-picker\";\nvar canvasOverlay = \"canvas-overlay\";\nvar getHsva = (input) => {\n  try {\n    const color = Color.fromString(input);\n    const [h, s, v] = color.toHSB();\n    return [h, s, v, color.a];\n  } catch {\n    return;\n  }\n};\nvar ColorPicker = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    ctx.domManager.addStyles(moduleId, colorPickerStyles_default);\n    this.element = ctx.domManager.addChild(canvasOverlay, moduleId);\n    this.destroyFns.push(() => ctx.domManager.removeChild(canvasOverlay, moduleId));\n  }\n  show(opts) {\n    let [h, s, v, a] = getHsva(opts.color ?? \"#f00\") ?? [0, 1, 0.5, 1];\n    const colorPickerContainer = createElement(\"div\");\n    colorPickerContainer.innerHTML = colorPickerTemplate_default;\n    this.element.replaceChildren(colorPickerContainer);\n    const colorPicker = colorPickerContainer.firstElementChild;\n    const paletteInput = colorPicker.querySelector(\".ag-charts-color-picker__palette\");\n    const hueInput = colorPicker.querySelector(\".ag-charts-color-picker__hue-input\");\n    const alphaInput = colorPicker.querySelector(\".ag-charts-color-picker__alpha-input\");\n    const colorInput = colorPicker.querySelector(\".ag-charts-color-picker__color-input\");\n    if (this.anchor) {\n      this.setAnchor(this.anchor, this.fallbackAnchor);\n    }\n    const update = () => {\n      const color = Color.fromHSB(h, s, v, a);\n      const colorString = color.toHexString();\n      colorPicker.style.setProperty(\"--h\", `${h}`);\n      colorPicker.style.setProperty(\"--s\", `${s}`);\n      colorPicker.style.setProperty(\"--v\", `${v}`);\n      colorPicker.style.setProperty(\"--a\", `${a}`);\n      colorPicker.style.setProperty(\"--color\", colorString.slice(0, 7));\n      colorPicker.style.setProperty(\"--color-a\", colorString);\n      hueInput.value = `${h}`;\n      alphaInput.value = `${a}`;\n      alphaInput.classList.toggle(\"ag-charts-color-picker__alpha-input--opaque\", a === 1);\n      if (document.activeElement !== colorInput) {\n        colorInput.value = colorString.toUpperCase();\n      }\n      opts.onChange?.(colorString);\n    };\n    update();\n    const beginPaletteInteraction = (e) => {\n      e.preventDefault();\n      const currentTarget = e.currentTarget;\n      currentTarget.focus();\n      const rect = currentTarget.getBoundingClientRect();\n      const mouseMove = ({ pageX, pageY }) => {\n        s = Math.min(Math.max((pageX - rect.left) / rect.width, 0), 1);\n        v = 1 - Math.min(Math.max((pageY - rect.top) / rect.height, 0), 1);\n        update();\n      };\n      mouseMove(e);\n      window.addEventListener(\"mousemove\", mouseMove);\n      window.addEventListener(\"mouseup\", () => window.removeEventListener(\"mousemove\", mouseMove), {\n        once: true\n      });\n    };\n    colorPicker.addEventListener(\"mousedown\", (e) => {\n      e.stopPropagation();\n    });\n    colorPicker.addEventListener(\"keydown\", (e) => {\n      e.stopPropagation();\n      switch (e.key) {\n        case \"Enter\":\n        case \"Escape\":\n          opts.onClose?.();\n          break;\n        default:\n          return;\n      }\n      e.preventDefault();\n    });\n    paletteInput.addEventListener(\"mousedown\", beginPaletteInteraction);\n    paletteInput.addEventListener(\"keydown\", (e) => {\n      if (e.key === \"ArrowLeft\") {\n        s = Math.min(Math.max(s - 0.01), 1);\n      } else if (e.key === \"ArrowRight\") {\n        s = Math.min(Math.max(s + 0.01), 1);\n      } else if (e.key === \"ArrowUp\") {\n        v = Math.min(Math.max(v + 0.01), 1);\n      } else if (e.key === \"ArrowDown\") {\n        v = Math.min(Math.max(v - 0.01), 1);\n      } else {\n        return;\n      }\n      e.preventDefault();\n      update();\n    });\n    hueInput.addEventListener(\"input\", (e) => {\n      h = e.currentTarget.valueAsNumber ?? 0;\n      update();\n    });\n    alphaInput.addEventListener(\"input\", (e) => {\n      a = e.currentTarget.valueAsNumber ?? 0;\n      update();\n    });\n    colorInput.addEventListener(\"input\", (e) => {\n      const hsva = getHsva(e.currentTarget.value);\n      if (hsva == null)\n        return;\n      [h, s, v, a] = hsva;\n      update();\n    });\n    colorInput.addEventListener(\"blur\", () => update());\n    colorInput.addEventListener(\"keydown\", (e) => {\n      if (e.key === \"Enter\") {\n        e.currentTarget.blur();\n        update();\n      }\n    });\n  }\n  setAnchor(anchor, fallbackAnchor) {\n    this.anchor = anchor;\n    this.fallbackAnchor = fallbackAnchor;\n    const colorPicker = this.element.firstElementChild?.firstElementChild;\n    if (!colorPicker)\n      return;\n    this.updatePosition(colorPicker, anchor.x, anchor.y);\n    this.repositionWithinBounds(colorPicker, anchor, fallbackAnchor);\n  }\n  hide() {\n    this.element.replaceChildren();\n  }\n  isChildElement(element) {\n    return this.ctx.domManager.isManagedChildDOMElement(element, canvasOverlay, moduleId);\n  }\n  updatePosition(colorPicker, x, y) {\n    colorPicker.style.setProperty(\"top\", \"unset\");\n    colorPicker.style.setProperty(\"bottom\", \"unset\");\n    colorPicker.style.setProperty(\"left\", `${x}px`);\n    colorPicker.style.setProperty(\"top\", `${y}px`);\n  }\n  repositionWithinBounds(colorPicker, anchor, fallbackAnchor) {\n    const canvasRect = this.ctx.domManager.getBoundingClientRect();\n    const { offsetWidth: width, offsetHeight: height } = colorPicker;\n    let x = clamp(0, anchor.x, canvasRect.width - width);\n    let y = clamp(0, anchor.y, canvasRect.height - height);\n    if (x !== anchor.x && fallbackAnchor?.x != null) {\n      x = clamp(0, fallbackAnchor.x - width, canvasRect.width - width);\n    }\n    if (y !== anchor.y && fallbackAnchor?.y != null) {\n      y = clamp(0, fallbackAnchor.y - height, canvasRect.height - height);\n    }\n    this.updatePosition(colorPicker, x, y);\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/annotations/annotationTypes.ts\n\nvar AnnotationType = /* @__PURE__ */ ((AnnotationType2) => {\n  AnnotationType2[\"Line\"] = \"line\";\n  AnnotationType2[\"DisjointChannel\"] = \"disjoint-channel\";\n  AnnotationType2[\"ParallelChannel\"] = \"parallel-channel\";\n  AnnotationType2[\"HorizontalLine\"] = \"horizontal-line\";\n  AnnotationType2[\"VerticalLine\"] = \"vertical-line\";\n  return AnnotationType2;\n})(AnnotationType || {});\nvar ANNOTATION_TYPES = Object.values(AnnotationType);\nvar ANNOTATION_BUTTONS = [\n  \"line\" /* Line */,\n  \"disjoint-channel\" /* DisjointChannel */,\n  \"parallel-channel\" /* ParallelChannel */,\n  \"horizontal-line\" /* HorizontalLine */,\n  \"vertical-line\" /* VerticalLine */\n];\nfunction stringToAnnotationType(value) {\n  switch (value) {\n    case \"line\":\n      return \"line\" /* Line */;\n    case \"horizontal-line\":\n      return \"horizontal-line\" /* HorizontalLine */;\n    case \"vertical-line\":\n      return \"vertical-line\" /* VerticalLine */;\n    case \"disjoint-channel\":\n      return \"disjoint-channel\" /* DisjointChannel */;\n    case \"parallel-channel\":\n      return \"parallel-channel\" /* ParallelChannel */;\n  }\n}\n\n// packages/ag-charts-enterprise/src/features/annotations/annotationUtils.ts\n\nvar { Logger } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nfunction validateDatumLine(context, datum, warningPrefix) {\n  let valid = true;\n  valid && (valid = validateDatumPoint(context, datum.start, warningPrefix && `${warningPrefix}[start] `));\n  valid && (valid = validateDatumPoint(context, datum.end, warningPrefix && `${warningPrefix}[end] `));\n  return valid;\n}\nfunction validateDatumValue(context, datum, warningPrefix) {\n  const axis = datum.direction === \"horizontal\" ? context.yAxis : context.xAxis;\n  const valid = validateDatumPointDirection(datum.value, axis);\n  if (!valid && warningPrefix) {\n    Logger.warnOnce(`${warningPrefix}is outside the axis domain, ignoring. - value: [${datum.value}]]`);\n  }\n  return valid;\n}\nfunction validateDatumPoint(context, point, warningPrefix) {\n  if (point.x == null || point.y == null) {\n    if (warningPrefix) {\n      Logger.warnOnce(`${warningPrefix}requires both an [x] and [y] property, ignoring.`);\n    }\n    return false;\n  }\n  const validX = validateDatumPointDirection(point.x, context.xAxis);\n  const validY = validateDatumPointDirection(point.y, context.yAxis);\n  if (!validX || !validY) {\n    let text = \"x & y domains\";\n    if (validX)\n      text = \"y domain\";\n    if (validY)\n      text = \"x domain\";\n    if (warningPrefix) {\n      Logger.warnOnce(`${warningPrefix}is outside the ${text}, ignoring. - x: [${point.x}], y: ${point.y}]`);\n    }\n    return false;\n  }\n  return true;\n}\nfunction validateDatumPointDirection(value, context) {\n  const domain = context.scaleDomain();\n  if (domain && context.continuous) {\n    return value >= domain[0] && value <= domain.at(-1);\n  }\n  return true;\n}\nfunction convertLine(datum, context) {\n  if (datum.start == null || datum.end == null)\n    return;\n  const start = convertPoint(datum.start, context);\n  const end = convertPoint(datum.end, context);\n  if (start == null || end == null)\n    return;\n  return { x1: start.x, y1: start.y, x2: end.x, y2: end.y };\n}\nfunction convertPoint(point, context) {\n  const x = convert(point.x, context.xAxis);\n  const y = convert(point.y, context.yAxis);\n  return { x, y };\n}\nfunction convert(p, context) {\n  if (p == null)\n    return 0;\n  const halfBandwidth = (context.scaleBandwidth() ?? 0) / 2;\n  return context.scaleConvert(p) + halfBandwidth;\n}\nfunction invertCoords(coords, context) {\n  const x = invert(coords.x, context.xAxis);\n  const y = invert(coords.y, context.yAxis);\n  return { x, y };\n}\nfunction invert(n, context) {\n  const halfBandwidth = (context.scaleBandwidth() ?? 0) / 2;\n  if (context.continuous) {\n    return context.scaleInvert(n - halfBandwidth);\n  }\n  return context.scaleInvertNearest(n - halfBandwidth);\n}\nfunction calculateAxisLabelPadding(axisLayout) {\n  return axisLayout.gridPadding + axisLayout.seriesAreaPadding + axisLayout.tickSize + axisLayout.label.padding;\n}\n\n// packages/ag-charts-enterprise/src/features/annotations/axisButton.ts\n\nvar { BaseModuleInstance, InteractionState, Validate: Validate11, BOOLEAN: BOOLEAN4, createElement: createElement2, REGIONS, ChartAxisDirection: ChartAxisDirection7 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar DEFAULT_ANNOTATION_AXIS_BUTTON_CLASS = `ag-charts-annotations__axis-button`;\nvar AxisButton = class extends BaseModuleInstance {\n  constructor(ctx, axisCtx, onButtonClick, seriesRect) {\n    super();\n    this.ctx = ctx;\n    this.axisCtx = axisCtx;\n    this.onButtonClick = onButtonClick;\n    this.seriesRect = seriesRect;\n    this.enabled = true;\n    this.snap = false;\n    this.padding = 0;\n    const { button, wrapper } = this.setup();\n    this.wrapper = wrapper;\n    this.button = button;\n    this.toggleVisibility(false);\n    this.updateButtonElement();\n    this.snap = axisCtx.scaleBandwidth() > 0;\n    const seriesRegion = this.ctx.regionManager.getRegion(REGIONS.SERIES);\n    const mouseMoveStates = InteractionState.Default | InteractionState.Annotations;\n    this.destroyFns.push(\n      seriesRegion.addListener(\"hover\", (event) => this.onMouseMove(event), mouseMoveStates),\n      seriesRegion.addListener(\"drag\", (event) => this.onMouseMove(event), mouseMoveStates),\n      seriesRegion.addListener(\"leave\", () => this.onLeave()),\n      () => this.destroyElements(),\n      () => this.wrapper.remove(),\n      () => this.button.remove()\n    );\n  }\n  update(seriesRect, padding) {\n    this.seriesRect = seriesRect;\n    this.padding = padding;\n  }\n  setup() {\n    const wrapper = this.ctx.domManager.addChild(\n      \"canvas-overlay\",\n      `${DEFAULT_ANNOTATION_AXIS_BUTTON_CLASS}-${this.axisCtx.axisId}`\n    );\n    wrapper.classList.add(`${DEFAULT_ANNOTATION_AXIS_BUTTON_CLASS}-wrapper`);\n    const button = createElement2(\"button\");\n    button.classList.add(DEFAULT_ANNOTATION_AXIS_BUTTON_CLASS);\n    wrapper.appendChild(button);\n    return {\n      wrapper,\n      button\n    };\n  }\n  destroyElements() {\n    this.ctx.domManager.removeChild(\"canvas-overlay\", DEFAULT_ANNOTATION_AXIS_BUTTON_CLASS);\n  }\n  onMouseMove(event) {\n    if (!this.enabled)\n      return;\n    this.toggleVisibility(true);\n    const buttonCoords = this.getButtonCoordinates({ x: event.offsetX, y: event.offsetY });\n    this.coords = this.getAxisCoordinates(buttonCoords);\n    this.updatePosition(buttonCoords);\n  }\n  onLeave() {\n    this.toggleVisibility(false);\n  }\n  getButtonCoordinates({ x, y }) {\n    const {\n      axisCtx: { direction, position },\n      seriesRect,\n      snap,\n      axisCtx,\n      padding\n    } = this;\n    const { clientWidth: buttonWidth, clientHeight: buttonHeight } = this.button;\n    const [minY, maxY] = [seriesRect.y, seriesRect.y + seriesRect.height];\n    const [minX, maxX] = [seriesRect.x, seriesRect.x + seriesRect.width];\n    if (snap) {\n      x = convert(invert(x - seriesRect.x, axisCtx), axisCtx) + seriesRect.x;\n      y = convert(invert(y - seriesRect.y, axisCtx), axisCtx) + seriesRect.y;\n    }\n    if (direction === ChartAxisDirection7.X) {\n      const crosshairLabelPadding = 5;\n      const offset = buttonHeight - Math.max(0, padding - crosshairLabelPadding);\n      x = x - buttonWidth / 2;\n      y = position === \"top\" ? minY - buttonHeight + offset : maxY - offset;\n    } else {\n      const crosshairLabelPadding = 9;\n      const offset = buttonWidth - Math.max(0, padding - crosshairLabelPadding);\n      x = position === \"left\" ? minX - buttonWidth + offset : maxX - offset;\n      y = y - buttonHeight / 2;\n    }\n    return { x, y };\n  }\n  getAxisCoordinates(coords) {\n    const { seriesRect } = this;\n    const { clientWidth: buttonWidth, clientHeight: buttonHeight } = this.button;\n    const x = coords.x - seriesRect.x + buttonWidth / 2;\n    const y = coords.y - seriesRect.y + buttonHeight / 2;\n    return {\n      x,\n      y\n    };\n  }\n  toggleVisibility(visible) {\n    const { button } = this;\n    if (button == null)\n      return;\n    const isVisible = this.enabled && visible;\n    this.toggleClass(\"-hidden\", !isVisible);\n  }\n  toggleClass(name, include) {\n    this.wrapper.classList.toggle(`${DEFAULT_ANNOTATION_AXIS_BUTTON_CLASS}-wrapper-${name}`, include);\n  }\n  updatePosition({ x, y }) {\n    this.wrapper.style.transform = `translate(${Math.round(x)}px, ${Math.round(y)}px)`;\n  }\n  updateButtonElement() {\n    const { button } = this;\n    button.onclick = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.makeAccessibleClickListener(button, () => this.onButtonClick(this.coords));\n    button.innerHTML = `<span class=\"ag-charts-icon-crossline-add-line ${DEFAULT_ANNOTATION_AXIS_BUTTON_CLASS}-icon\"></span>`;\n  }\n};\n__decorateClass([\n  Validate11(BOOLEAN4)\n], AxisButton.prototype, \"enabled\", 2);\n\n// packages/ag-charts-enterprise/src/features/annotations/axisButton.css\nvar axisButton_default = \".ag-charts-annotations__axis-button-wrapper{position:absolute;left:0px;top:0px;user-select:none;font:16px Verdana,sans-serif;overflow:hidden;white-space:nowrap;z-index:var(--ag-charts-layer-annotations);box-sizing:border-box}.ag-charts-annotations__axis-button-wrapper--hidden{display:none}.ag-charts-annotations__axis-button{cursor:pointer;padding:2px;border:none;border-radius:2px;line-height:16px;background-color:var(--ag-charts-axis-label-background-color);color:var(--ag-charts-axis-label-color)}.ag-charts-annotations__axis-button-icon{height:1.2em;width:1.2em}.ag-charts-annotations__axis-button:hover{opacity:0.8;color:var(--ag-charts-axis-label-color)}\";\n\n// packages/ag-charts-enterprise/src/features/annotations/cross-line/crossLineProperties.ts\n\n\n// packages/ag-charts-enterprise/src/features/annotations/annotationProperties.ts\n\nvar {\n  BOOLEAN: BOOLEAN5,\n  COLOR_STRING: COLOR_STRING2,\n  DATE,\n  LINE_DASH: LINE_DASH2,\n  NUMBER: NUMBER3,\n  RATIO: RATIO4,\n  STRING: STRING2,\n  OBJECT: OBJECT3,\n  FUNCTION,\n  TEXT_ALIGN,\n  FONT_STYLE: FONT_STYLE2,\n  FONT_WEIGHT: FONT_WEIGHT2,\n  POSITIVE_NUMBER: POSITIVE_NUMBER4,\n  OR: OR2,\n  UNION: UNION3,\n  BaseProperties,\n  Validate: Validate12\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar AnnotationPoint = class extends BaseProperties {\n};\n__decorateClass([\n  Validate12(OR2(STRING2, NUMBER3, DATE))\n], AnnotationPoint.prototype, \"x\", 2);\n__decorateClass([\n  Validate12(NUMBER3)\n], AnnotationPoint.prototype, \"y\", 2);\nvar ChannelAnnotationBackground = class extends Fill(BaseProperties) {\n};\nvar ChannelAnnotationMiddle = class extends Stroke(LineDash(Visible(BaseProperties))) {\n};\nvar AnnotationHandleProperties = class extends Stroke(LineDash(Fill(BaseProperties))) {\n};\nvar AnnotationAxisLabelProperties = class extends Stroke(LineDash(Fill(Label(BaseProperties)))) {\n  constructor() {\n    super(...arguments);\n    this.cornerRadius = 2;\n  }\n};\n__decorateClass([\n  Validate12(BOOLEAN5)\n], AnnotationAxisLabelProperties.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate12(POSITIVE_NUMBER4)\n], AnnotationAxisLabelProperties.prototype, \"cornerRadius\", 2);\nfunction Annotation(_type, Parent) {\n  class AnnotationProperties extends Lockable(Visible(Parent)) {\n    constructor() {\n      super(...arguments);\n      // A uuid is required, over the usual incrementing index, as annotations can be restored from external databases\n      this.id = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util.uuid();\n    }\n    isValidWithContext(_context, warningPrefix) {\n      return super.isValid(warningPrefix);\n    }\n  }\n  return AnnotationProperties;\n}\nfunction AnnotationLine(Parent) {\n  class AnnotationLinePoints extends Parent {\n    constructor() {\n      super(...arguments);\n      this.start = new AnnotationPoint();\n      this.end = new AnnotationPoint();\n    }\n  }\n  __decorateClass([\n    Validate12(OBJECT3)\n  ], AnnotationLinePoints.prototype, \"start\", 2);\n  __decorateClass([\n    Validate12(OBJECT3)\n  ], AnnotationLinePoints.prototype, \"end\", 2);\n  return AnnotationLinePoints;\n}\nfunction AnnotationCrossLine(Parent) {\n  class AnnotationCrossLineOptions extends Parent {\n  }\n  __decorateClass([\n    Validate12(OR2(STRING2, NUMBER3, DATE))\n  ], AnnotationCrossLineOptions.prototype, \"value\", 2);\n  return AnnotationCrossLineOptions;\n}\nfunction ChannelAnnotation(Parent) {\n  class ChannelAnnotationStyles extends Parent {\n    constructor() {\n      super(...arguments);\n      this.background = new ChannelAnnotationBackground();\n    }\n  }\n  __decorateClass([\n    Validate12(OBJECT3, { optional: true })\n  ], ChannelAnnotationStyles.prototype, \"background\", 2);\n  return ChannelAnnotationStyles;\n}\nfunction AnnotationHandle(Parent) {\n  class WithAnnotationHandle extends Parent {\n    constructor() {\n      super(...arguments);\n      this.handle = new AnnotationHandleProperties();\n    }\n  }\n  __decorateClass([\n    Validate12(OBJECT3, { optional: true })\n  ], WithAnnotationHandle.prototype, \"handle\", 2);\n  return WithAnnotationHandle;\n}\nfunction AnnotationAxisLabel(Parent) {\n  class WithAxisLabel extends Parent {\n    constructor() {\n      super(...arguments);\n      this.axisLabel = new AnnotationAxisLabelProperties();\n    }\n  }\n  __decorateClass([\n    Validate12(OBJECT3, { optional: true })\n  ], WithAxisLabel.prototype, \"axisLabel\", 2);\n  return WithAxisLabel;\n}\nfunction Cappable(Parent) {\n  class CappableOptions extends Parent {\n  }\n  __decorateClass([\n    Validate12(UNION3([\"arrow\", \"circle\"]), { optional: true })\n  ], CappableOptions.prototype, \"startCap\", 2);\n  __decorateClass([\n    Validate12(UNION3([\"arrow\", \"circle\"]), { optional: true })\n  ], CappableOptions.prototype, \"endCap\", 2);\n  return CappableOptions;\n}\nfunction Extendable(Parent) {\n  class ExtendableOptions extends Parent {\n  }\n  __decorateClass([\n    Validate12(BOOLEAN5, { optional: true })\n  ], ExtendableOptions.prototype, \"extendLeft\", 2);\n  __decorateClass([\n    Validate12(BOOLEAN5, { optional: true })\n  ], ExtendableOptions.prototype, \"extendRight\", 2);\n  return ExtendableOptions;\n}\nfunction Lockable(Parent) {\n  class LockableOptions extends Parent {\n  }\n  __decorateClass([\n    Validate12(BOOLEAN5, { optional: true })\n  ], LockableOptions.prototype, \"locked\", 2);\n  return LockableOptions;\n}\nfunction Visible(Parent) {\n  class VisibleOptions extends Parent {\n  }\n  __decorateClass([\n    Validate12(BOOLEAN5, { optional: true })\n  ], VisibleOptions.prototype, \"visible\", 2);\n  return VisibleOptions;\n}\nfunction Fill(Parent) {\n  class FillOptions extends Parent {\n  }\n  __decorateClass([\n    Validate12(COLOR_STRING2, { optional: true })\n  ], FillOptions.prototype, \"fill\", 2);\n  __decorateClass([\n    Validate12(RATIO4, { optional: true })\n  ], FillOptions.prototype, \"fillOpacity\", 2);\n  return FillOptions;\n}\nfunction Stroke(Parent) {\n  class StrokeOptions extends Parent {\n  }\n  __decorateClass([\n    Validate12(COLOR_STRING2, { optional: true })\n  ], StrokeOptions.prototype, \"stroke\", 2);\n  __decorateClass([\n    Validate12(RATIO4, { optional: true })\n  ], StrokeOptions.prototype, \"strokeOpacity\", 2);\n  __decorateClass([\n    Validate12(NUMBER3, { optional: true })\n  ], StrokeOptions.prototype, \"strokeWidth\", 2);\n  return StrokeOptions;\n}\nfunction Label(Parent) {\n  class LabelOptions extends Parent {\n    constructor() {\n      super(...arguments);\n      this.textAlign = \"center\";\n      this.fontSize = 12;\n      this.fontFamily = \"Verdana, sans-serif\";\n    }\n  }\n  __decorateClass([\n    Validate12(POSITIVE_NUMBER4, { optional: true })\n  ], LabelOptions.prototype, \"padding\", 2);\n  __decorateClass([\n    Validate12(TEXT_ALIGN, { optional: true })\n  ], LabelOptions.prototype, \"textAlign\", 2);\n  __decorateClass([\n    Validate12(FONT_STYLE2, { optional: true })\n  ], LabelOptions.prototype, \"fontStyle\", 2);\n  __decorateClass([\n    Validate12(FONT_WEIGHT2, { optional: true })\n  ], LabelOptions.prototype, \"fontWeight\", 2);\n  __decorateClass([\n    Validate12(POSITIVE_NUMBER4)\n  ], LabelOptions.prototype, \"fontSize\", 2);\n  __decorateClass([\n    Validate12(STRING2)\n  ], LabelOptions.prototype, \"fontFamily\", 2);\n  __decorateClass([\n    Validate12(COLOR_STRING2, { optional: true })\n  ], LabelOptions.prototype, \"color\", 2);\n  __decorateClass([\n    Validate12(FUNCTION, { optional: true })\n  ], LabelOptions.prototype, \"formatter\", 2);\n  return LabelOptions;\n}\nfunction LineDash(Parent) {\n  class LineDashOptions extends Parent {\n  }\n  __decorateClass([\n    Validate12(LINE_DASH2, { optional: true })\n  ], LineDashOptions.prototype, \"lineDash\", 2);\n  __decorateClass([\n    Validate12(NUMBER3, { optional: true })\n  ], LineDashOptions.prototype, \"lineDashOffset\", 2);\n  return LineDashOptions;\n}\n\n// packages/ag-charts-enterprise/src/features/annotations/cross-line/crossLineProperties.ts\nvar { STRING: STRING3, BaseProperties: BaseProperties2, Validate: Validate13, isObject } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar HorizontalLineAnnotation = class extends Annotation(\n  \"horizontal-line\" /* HorizontalLine */,\n  AnnotationCrossLine(AnnotationHandle(AnnotationAxisLabel(Cappable(Stroke(LineDash(BaseProperties2))))))\n) {\n  constructor() {\n    super(...arguments);\n    this.direction = \"horizontal\";\n    this.type = \"horizontal-line\" /* HorizontalLine */;\n  }\n  static is(value) {\n    return isObject(value) && value.type === \"horizontal-line\" /* HorizontalLine */;\n  }\n  isValidWithContext(context, warningPrefix) {\n    return super.isValid(warningPrefix) && validateDatumValue(context, this, warningPrefix);\n  }\n};\n__decorateClass([\n  Validate13(STRING3)\n], HorizontalLineAnnotation.prototype, \"type\", 2);\nvar VerticalLineAnnotation = class extends Annotation(\n  \"vertical-line\" /* VerticalLine */,\n  AnnotationCrossLine(AnnotationHandle(AnnotationAxisLabel(Cappable(Stroke(LineDash(BaseProperties2))))))\n) {\n  constructor() {\n    super(...arguments);\n    this.direction = \"vertical\";\n    this.type = \"vertical-line\" /* VerticalLine */;\n  }\n  static is(value) {\n    return isObject(value) && value.type === \"vertical-line\" /* VerticalLine */;\n  }\n  isValidWithContext(context, warningPrefix) {\n    return super.isValid(warningPrefix) && validateDatumValue(context, this, warningPrefix);\n  }\n};\n__decorateClass([\n  Validate13(STRING3)\n], VerticalLineAnnotation.prototype, \"type\", 2);\n\n// packages/ag-charts-enterprise/src/features/annotations/cross-line/crossLineScene.ts\n\n\n// packages/ag-charts-enterprise/src/features/annotations/scenes/annotation.ts\n\n\n// packages/ag-charts-enterprise/src/features/annotations/scenes/handle.ts\n\nvar _Handle = class _Handle extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Group {\n  constructor() {\n    super(...arguments);\n    this.active = false;\n    this.locked = false;\n    this.visible = false;\n  }\n  drag(target) {\n    const { handle, locked } = this;\n    if (locked) {\n      return { point: { x: handle.x, y: handle.y }, offset: { x: 0, y: 0 } };\n    }\n    return {\n      point: target,\n      offset: { x: target.x - handle.x, y: target.y - handle.y }\n    };\n  }\n  toggleActive(active) {\n    this.active = active;\n    if (!active) {\n      this.handle.strokeWidth = _Handle.INACTIVE_STROKE_WIDTH;\n    }\n  }\n  toggleHovered(hovered) {\n    this.glow.visible = !this.locked && hovered;\n    this.glow.dirtyPath = true;\n  }\n  toggleDragging(dragging) {\n    if (this.locked)\n      return;\n    this.handle.visible = !dragging;\n    this.glow.visible = this.glow.visible && !dragging;\n    this.handle.dirtyPath = true;\n    this.glow.dirtyPath = true;\n  }\n  toggleLocked(locked) {\n    this.locked = locked;\n  }\n  getCursor() {\n    return \"default\";\n  }\n  containsPoint(x, y) {\n    return this.handle.containsPoint(x, y);\n  }\n};\n_Handle.INACTIVE_STROKE_WIDTH = 1;\nvar Handle = _Handle;\nvar _InvariantHandle = class _InvariantHandle extends Handle {\n  constructor() {\n    super();\n    this.handle = new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Circle();\n    this.glow = new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Circle();\n    this.append([this.handle]);\n    this.handle.size = _InvariantHandle.HANDLE_SIZE;\n    this.handle.strokeWidth = Handle.INACTIVE_STROKE_WIDTH;\n    this.handle.zIndex = 2;\n  }\n  update(styles) {\n    this.handle.setProperties({ ...styles, strokeWidth: Handle.INACTIVE_STROKE_WIDTH });\n  }\n  drag(target) {\n    return { point: target, offset: { x: 0, y: 0 } };\n  }\n};\n_InvariantHandle.HANDLE_SIZE = 7;\n_InvariantHandle.GLOW_SIZE = 9;\nvar InvariantHandle = _InvariantHandle;\nvar _UnivariantHandle = class _UnivariantHandle extends Handle {\n  constructor() {\n    super();\n    this.handle = new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Rect();\n    this.glow = new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Rect();\n    this.gradient = \"horizontal\";\n    this.append([this.glow, this.handle]);\n    this.handle.cornerRadius = _UnivariantHandle.CORNER_RADIUS;\n    this.handle.width = _UnivariantHandle.HANDLE_SIZE;\n    this.handle.height = _UnivariantHandle.HANDLE_SIZE;\n    this.handle.strokeWidth = Handle.INACTIVE_STROKE_WIDTH;\n    this.handle.zIndex = 2;\n    this.glow.cornerRadius = _UnivariantHandle.CORNER_RADIUS;\n    this.glow.width = _UnivariantHandle.GLOW_SIZE;\n    this.glow.height = _UnivariantHandle.GLOW_SIZE;\n    this.glow.strokeWidth = 0;\n    this.glow.fillOpacity = 0.2;\n    this.glow.zIndex = 1;\n    this.glow.visible = false;\n  }\n  toggleLocked(locked) {\n    super.toggleLocked(locked);\n    if (locked) {\n      const offset = (_UnivariantHandle.HANDLE_SIZE - InvariantHandle.HANDLE_SIZE) / 2;\n      this.handle.cornerRadius = 1;\n      this.handle.fill = this.handle.stroke;\n      this.handle.strokeWidth = 0;\n      this.handle.x += offset;\n      this.handle.y += offset;\n      this.handle.width = InvariantHandle.HANDLE_SIZE;\n      this.handle.height = InvariantHandle.HANDLE_SIZE;\n      this.glow.width = InvariantHandle.GLOW_SIZE;\n      this.glow.height = InvariantHandle.GLOW_SIZE;\n    } else {\n      this.handle.cornerRadius = _UnivariantHandle.CORNER_RADIUS;\n      this.handle.width = _UnivariantHandle.HANDLE_SIZE;\n      this.handle.height = _UnivariantHandle.HANDLE_SIZE;\n      this.glow.width = _UnivariantHandle.GLOW_SIZE;\n      this.glow.height = _UnivariantHandle.GLOW_SIZE;\n      if (this.cachedStyles) {\n        this.handle.setProperties(this.cachedStyles);\n      }\n    }\n  }\n  update(styles) {\n    this.cachedStyles = { ...styles };\n    if (!this.active) {\n      delete styles.strokeWidth;\n    }\n    if (this.locked) {\n      delete styles.fill;\n      delete styles.strokeWidth;\n      const offset = (_UnivariantHandle.HANDLE_SIZE - InvariantHandle.HANDLE_SIZE) / 2;\n      styles.x -= offset;\n      styles.y -= offset;\n      this.cachedStyles.x -= offset;\n      this.cachedStyles.y -= offset;\n    }\n    this.handle.setProperties(styles);\n    this.glow.setProperties({\n      ...styles,\n      x: (styles.x ?? this.glow.x) - 2,\n      y: (styles.y ?? this.glow.y) - 2,\n      strokeWidth: 0,\n      fill: styles.stroke\n    });\n  }\n  drag(target) {\n    if (this.locked) {\n      return { point: target, offset: { x: 0, y: 0 } };\n    }\n    if (this.gradient === \"vertical\") {\n      return {\n        point: { x: target.x, y: this.handle.y },\n        offset: { x: target.x - this.handle.x, y: 0 }\n      };\n    }\n    return {\n      point: { x: this.handle.x, y: target.y },\n      offset: { x: 0, y: target.y - this.handle.y }\n    };\n  }\n  getCursor() {\n    if (this.locked)\n      return \"default\";\n    return this.gradient === \"vertical\" ? \"col-resize\" : \"row-resize\";\n  }\n};\n_UnivariantHandle.HANDLE_SIZE = 12;\n_UnivariantHandle.GLOW_SIZE = 16;\n_UnivariantHandle.CORNER_RADIUS = 4;\nvar UnivariantHandle = _UnivariantHandle;\nvar _DivariantHandle = class _DivariantHandle extends Handle {\n  constructor() {\n    super();\n    this.handle = new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Circle();\n    this.glow = new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Circle();\n    this.append([this.glow, this.handle]);\n    this.handle.size = _DivariantHandle.HANDLE_SIZE;\n    this.handle.strokeWidth = Handle.INACTIVE_STROKE_WIDTH;\n    this.handle.zIndex = 2;\n    this.glow.size = _DivariantHandle.GLOW_SIZE;\n    this.glow.strokeWidth = 0;\n    this.glow.fillOpacity = 0.2;\n    this.glow.zIndex = 1;\n    this.glow.visible = false;\n  }\n  toggleLocked(locked) {\n    super.toggleLocked(locked);\n    if (locked) {\n      this.handle.fill = this.handle.stroke;\n      this.handle.strokeWidth = 0;\n      this.handle.size = InvariantHandle.HANDLE_SIZE;\n      this.glow.size = InvariantHandle.GLOW_SIZE;\n    } else {\n      this.handle.size = _DivariantHandle.HANDLE_SIZE;\n      this.glow.size = _DivariantHandle.GLOW_SIZE;\n      if (this.cachedStyles) {\n        this.handle.setProperties(this.cachedStyles);\n      }\n    }\n  }\n  update(styles) {\n    this.cachedStyles = { ...styles };\n    if (!this.active) {\n      delete styles.strokeWidth;\n    }\n    if (this.locked) {\n      delete styles.fill;\n      delete styles.strokeWidth;\n    }\n    this.handle.setProperties(styles);\n    this.glow.setProperties({ ...styles, strokeWidth: 0, fill: styles.stroke });\n  }\n};\n_DivariantHandle.HANDLE_SIZE = 11;\n_DivariantHandle.GLOW_SIZE = 17;\nvar DivariantHandle = _DivariantHandle;\n\n// packages/ag-charts-enterprise/src/features/annotations/scenes/annotation.ts\nvar { isObject: isObject2 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar Annotation2 = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Group {\n  constructor() {\n    super(...arguments);\n    this.locked = false;\n  }\n  static isCheck(value, type) {\n    return isObject2(value) && Object.hasOwn(value, \"type\") && value.type === type;\n  }\n  getCachedBBoxWithoutHandles() {\n    return this.cachedBBoxWithoutHandles ?? ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.BBox.zero;\n  }\n  computeBBoxWithoutHandles() {\n    this.computeTransformMatrix();\n    return ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Group.computeBBox(this.children.filter((node) => !(node instanceof Handle)));\n  }\n  render(renderCtx) {\n    super.render(renderCtx);\n    this.cachedBBoxWithoutHandles = this.computeBBoxWithoutHandles();\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/annotations/scenes/axisLabel.ts\n\nvar { calculateLabelTranslation, ChartAxisDirection: ChartAxisDirection8 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar AxisLabel = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Group {\n  constructor() {\n    super({ name: \"AnnotationAxisLabelGroup\" });\n    this.label = new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Text({ zIndex: 1 });\n    this.rect = new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Rect();\n    const { label } = this;\n    label.fontSize = 12;\n    label.fontFamily = \"Verdana, sans-serif\";\n    label.fill = \"black\";\n    label.textBaseline = \"middle\";\n    label.textAlign = \"center\";\n    this.append([this.rect, this.label]);\n  }\n  update(opts) {\n    this.updateLabel(opts);\n    this.updateRect(opts);\n    this.updatePosition(opts);\n  }\n  updateLabel({ value, styles, context }) {\n    const { label } = this;\n    const { fontWeight, fontSize, fontStyle, fontFamily, textAlign, color = \"white\", formatter } = styles;\n    label.setProperties({ fontWeight, fontSize, fontStyle, fontFamily, textAlign, fill: color });\n    label.text = this.getFormattedValue(value, formatter ?? context.scaleValueFormatter());\n  }\n  updateRect({ styles }) {\n    const { rect } = this;\n    const { cornerRadius, fill, fillOpacity, stroke, strokeOpacity } = styles;\n    rect.setProperties({ cornerRadius, fill, fillOpacity, stroke, strokeOpacity });\n  }\n  updatePosition({ x, y, context, styles: { padding } }) {\n    const { label, rect } = this;\n    const labelBBox = label.computeBBox();\n    const horizontalPadding = 8;\n    const verticalPadding = 5;\n    labelBBox.grow(padding ?? horizontalPadding, \"horizontal\");\n    labelBBox.grow(padding ?? verticalPadding, \"vertical\");\n    const shift = context.direction === ChartAxisDirection8.X ? verticalPadding / 2 : horizontalPadding;\n    const { xTranslation, yTranslation } = calculateLabelTranslation({\n      yDirection: true,\n      padding: context.labelPadding - shift,\n      position: context.position ?? \"left\",\n      bbox: labelBBox\n    });\n    const translationX = x + xTranslation;\n    const translationY = y + yTranslation;\n    label.translationX = translationX;\n    label.translationY = translationY;\n    rect.x = translationX - labelBBox.width / 2;\n    rect.y = translationY - labelBBox.height / 2;\n    rect.height = labelBBox.height;\n    rect.width = labelBBox.width;\n  }\n  getFormattedValue(value, formatter) {\n    return formatter?.(value) ?? String(value);\n  }\n};\nAxisLabel.className = \"AxisLabel\";\n\n// packages/ag-charts-enterprise/src/features/annotations/scenes/shapes.ts\n\nvar { Vec2 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar CollidableLine = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Line {\n  constructor() {\n    super(...arguments);\n    this.growCollisionBox = 9;\n  }\n  updateCollisionBBox() {\n    const { growCollisionBox, strokeWidth, x1, y1, x2, y2 } = this;\n    let height = strokeWidth + growCollisionBox;\n    if (height % 2 === 0)\n      height += 1;\n    const topLeft = Vec2.from(x1, y1 - Math.floor(height / 2));\n    const bottomRight = Vec2.from(x2, y2);\n    const width = Vec2.distance(topLeft, bottomRight);\n    this.collisionBBox = new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.BBox(topLeft.x, topLeft.y, width, height);\n  }\n  isPointInPath(pointX, pointY) {\n    const { collisionBBox, x1, y1, x2, y2 } = this;\n    if (!collisionBBox)\n      return false;\n    const v1 = Vec2.from(x1, y1);\n    const v2 = Vec2.from(x2, y2);\n    const point = Vec2.sub(Vec2.from(pointX, pointY), v1);\n    const end = Vec2.sub(v2, v1);\n    const rotated = Vec2.rotate(point, Vec2.angle(point, end), v1);\n    return collisionBBox.containsPoint(rotated.x, rotated.y) ?? false;\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/annotations/cross-line/crossLineScene.ts\nvar { Vec2: Vec22 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar { ChartAxisDirection: ChartAxisDirection9 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar CrossLine = class extends Annotation2 {\n  constructor() {\n    super();\n    this.type = \"cross-line\";\n    this.line = new CollidableLine();\n    this.middle = new UnivariantHandle();\n    this.isHorizontal = false;\n    this.append([this.line, this.middle]);\n  }\n  static is(value) {\n    return Annotation2.isCheck(value, \"cross-line\");\n  }\n  update(datum, context) {\n    const { line, middle } = this;\n    const { locked, visible, lineDash, lineDashOffset, stroke, strokeWidth, strokeOpacity } = datum;\n    const { seriesRect } = context;\n    this.locked = locked ?? false;\n    this.seriesRect = seriesRect;\n    this.isHorizontal = HorizontalLineAnnotation.is(datum);\n    const axisContext = this.isHorizontal ? context.yAxis : context.xAxis;\n    const coords = this.convertCrossLine(datum, axisContext);\n    if (coords == null) {\n      this.visible = false;\n      return;\n    } else {\n      this.visible = visible ?? true;\n    }\n    const { x1, y1, x2, y2 } = coords;\n    line.setProperties({\n      x1,\n      y1,\n      x2,\n      y2,\n      lineDash,\n      lineDashOffset,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      fillOpacity: 0\n    });\n    line.updateCollisionBBox();\n    const handleStyles = {\n      fill: datum.handle.fill,\n      stroke: datum.handle.stroke ?? stroke,\n      strokeOpacity: datum.handle.strokeOpacity ?? strokeOpacity,\n      strokeWidth: datum.handle.strokeWidth ?? strokeWidth\n    };\n    const x = x1 + (x2 - x1) / 2;\n    const y = y1 + (y2 - y1) / 2;\n    const { width: handleWidth, height: handleHeight } = middle.handle;\n    middle.gradient = this.isHorizontal ? \"horizontal\" : \"vertical\";\n    middle.update({ ...handleStyles, x: x - handleWidth / 2, y: y - handleHeight / 2 });\n    middle.toggleLocked(this.locked);\n    this.updateAxisLabel(datum, axisContext, coords);\n  }\n  createAxisLabel(context) {\n    const axisLabel = new AxisLabel();\n    context.attachLabel(axisLabel);\n    return axisLabel;\n  }\n  updateAxisLabel(datum, axisContext, { x1, y1, x2, y2 }) {\n    if (!this.axisLabel) {\n      this.axisLabel = this.createAxisLabel(axisContext);\n    }\n    const { axisLabel, seriesRect } = this;\n    if (datum.axisLabel.enabled) {\n      axisLabel.visible = this.visible;\n      const [labelX, labelY] = axisContext.position === \"left\" || axisContext.position === \"top\" ? [x1, y1] : [x2, y2];\n      const labelPosition = axisContext.direction === ChartAxisDirection9.X ? labelX : labelY;\n      if (!axisContext.inRange(labelPosition)) {\n        axisLabel.visible = false;\n        return;\n      }\n      axisLabel.update({\n        x: labelX + (seriesRect?.x ?? 0),\n        y: labelY + (seriesRect?.y ?? 0),\n        value: datum.value,\n        styles: datum.axisLabel,\n        context: axisContext\n      });\n    } else {\n      axisLabel.visible = false;\n    }\n  }\n  toggleHandles(show) {\n    this.middle.visible = show;\n    this.middle.toggleHovered(this.activeHandle === \"middle\");\n  }\n  destroy() {\n    super.destroy();\n    this.axisLabel?.destroy();\n  }\n  toggleActive(active) {\n    this.toggleHandles(active);\n    this.middle.toggleActive(active);\n  }\n  dragStart(datum, target, context) {\n    const middle = HorizontalLineAnnotation.is(datum) ? { x: target.x, y: convert(datum.value, context.yAxis) } : { x: convert(datum.value, context.xAxis), y: target.y };\n    this.dragState = {\n      offset: target,\n      middle\n    };\n  }\n  drag(datum, target, context, onInvalid) {\n    const { activeHandle, dragState, locked } = this;\n    if (locked)\n      return;\n    let coords;\n    if (activeHandle) {\n      this[activeHandle].toggleDragging(true);\n      coords = this[activeHandle].drag(target).point;\n    } else if (dragState) {\n      coords = Vec22.add(dragState.middle, Vec22.sub(target, dragState.offset));\n    } else {\n      return;\n    }\n    const point = invertCoords(coords, context);\n    if (!validateDatumPoint(context, point)) {\n      onInvalid();\n      return;\n    }\n    const isHorizontal = HorizontalLineAnnotation.is(datum);\n    datum.set({ value: isHorizontal ? point.y : point.x });\n  }\n  stopDragging() {\n    this.middle.toggleDragging(false);\n  }\n  getCursor() {\n    if (this.activeHandle == null)\n      return \"pointer\";\n    return this[this.activeHandle].getCursor();\n  }\n  containsPoint(x, y) {\n    const { middle, seriesRect, line } = this;\n    this.activeHandle = void 0;\n    if (middle.containsPoint(x, y)) {\n      this.activeHandle = \"middle\";\n      return true;\n    }\n    x -= seriesRect?.x ?? 0;\n    y -= seriesRect?.y ?? 0;\n    return line.isPointInPath(x, y);\n  }\n  getAnchor() {\n    let bbox = this.getCachedBBoxWithoutHandles();\n    if (bbox.width === 0 && bbox.height === 0) {\n      bbox = this.computeBBoxWithoutHandles();\n    }\n    if (this.isHorizontal) {\n      return { x: bbox.x + bbox.width / 2, y: bbox.y };\n    }\n    return { x: bbox.x + bbox.width, y: bbox.y + bbox.height / 2, position: \"above\" };\n  }\n  convertCrossLine(datum, context) {\n    if (datum.value == null)\n      return;\n    let x1 = 0;\n    let x2 = 0;\n    let y1 = 0;\n    let y2 = 0;\n    const { bounds, scaleConvert, scaleBandwidth } = context;\n    const halfBandwidth = (scaleBandwidth() ?? 0) / 2;\n    if (HorizontalLineAnnotation.is(datum)) {\n      const scaledValue = scaleConvert(datum.value) + halfBandwidth;\n      x2 = bounds.width;\n      y1 = scaledValue;\n      y2 = scaledValue;\n    } else {\n      const scaledValue = scaleConvert(datum.value) + halfBandwidth;\n      x1 = scaledValue;\n      x2 = scaledValue;\n      y2 = bounds.height;\n    }\n    return { x1, y1, x2, y2 };\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/annotations/cross-line/crossLineState.ts\n\nvar CrossLineStateMachine = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.StateMachine {\n  constructor(direction, appendDatum, onExit) {\n    const onClick = ({ point }) => {\n      const isHorizontal = direction === \"horizontal\";\n      const datum = isHorizontal ? new HorizontalLineAnnotation() : new VerticalLineAnnotation();\n      datum.set({ value: isHorizontal ? point.y : point.x });\n      appendDatum(datum);\n    };\n    super(\"start\", {\n      start: {\n        click: {\n          target: \"__parent\",\n          action: onClick\n        },\n        cancel: \"__parent\",\n        onExit\n      }\n    });\n    this.debug = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util.Debug.create(true, \"annotations\");\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/annotations/disjoint-channel/disjointChannelProperties.ts\n\nvar { NUMBER: NUMBER4, STRING: STRING4, BaseProperties: BaseProperties3, Validate: Validate14, isObject: isObject3 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar DisjointChannelAnnotation = class extends Annotation(\n  \"disjoint-channel\" /* DisjointChannel */,\n  ChannelAnnotation(AnnotationLine(AnnotationHandle(Stroke(LineDash(BaseProperties3)))))\n) {\n  constructor() {\n    super(...arguments);\n    this.type = \"disjoint-channel\" /* DisjointChannel */;\n  }\n  static is(value) {\n    return isObject3(value) && value.type === \"disjoint-channel\" /* DisjointChannel */;\n  }\n  get bottom() {\n    const bottom = {\n      start: { x: this.start.x, y: this.start.y },\n      end: { x: this.end.x, y: this.end.y }\n    };\n    if (typeof bottom.start.y === \"number\" && typeof bottom.end.y === \"number\") {\n      bottom.start.y -= this.startHeight;\n      bottom.end.y -= this.endHeight;\n    } else {\n      ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util.Logger.warnOnce(`Annotation [${this.type}] can only be used with a numeric y-axis.`);\n    }\n    return bottom;\n  }\n  isValidWithContext(context, warningPrefix) {\n    return super.isValid(warningPrefix) && validateDatumLine(context, this, warningPrefix) && validateDatumLine(context, this.bottom, warningPrefix);\n  }\n};\n__decorateClass([\n  Validate14(STRING4)\n], DisjointChannelAnnotation.prototype, \"type\", 2);\n__decorateClass([\n  Validate14(NUMBER4)\n], DisjointChannelAnnotation.prototype, \"startHeight\", 2);\n__decorateClass([\n  Validate14(NUMBER4)\n], DisjointChannelAnnotation.prototype, \"endHeight\", 2);\n\n// packages/ag-charts-enterprise/src/features/annotations/disjoint-channel/disjointChannelScene.ts\n\n\n// packages/ag-charts-enterprise/src/features/annotations/scenes/channelScene.ts\n\n\n// packages/ag-charts-enterprise/src/features/annotations/scenes/linearScene.ts\n\nvar { Vec2: Vec23 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar LinearScene = class extends Annotation2 {\n  dragStart(datum, target, context) {\n    this.dragState = {\n      offset: target,\n      start: convertPoint(datum.start, context),\n      end: convertPoint(datum.end, context)\n    };\n  }\n  drag(datum, target, context, onInvalid) {\n    if (datum.locked)\n      return;\n    if (this.activeHandle) {\n      this.dragHandle(datum, target, context, onInvalid);\n    } else {\n      this.dragAll(datum, target, context);\n    }\n  }\n  dragAll(datum, target, context) {\n    const { dragState } = this;\n    if (!dragState)\n      return;\n    const { xAxis, yAxis } = context;\n    const topLeft = Vec23.add(dragState.start, Vec23.sub(target, dragState.offset));\n    const topRight = Vec23.add(dragState.end, Vec23.sub(target, dragState.offset));\n    const startPoint = invertCoords(topLeft, context);\n    const endPoint = invertCoords(topRight, context);\n    const within = (min, value, max) => value >= min && value <= max;\n    const coords = [topLeft, topRight].concat(...this.getOtherCoords(datum, topLeft, topRight, context));\n    if (coords.every((coord) => within(xAxis.bounds.x, coord.x, xAxis.bounds.x + xAxis.bounds.width))) {\n      datum.start.x = startPoint.x;\n      datum.end.x = endPoint.x;\n    }\n    if (coords.every((coord) => within(yAxis.bounds.y, coord.y, yAxis.bounds.y + yAxis.bounds.height))) {\n      datum.start.y = startPoint.y;\n      datum.end.y = endPoint.y;\n    }\n  }\n  getOtherCoords(_datum, _topLeft, _topRight, _context) {\n    return [];\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/annotations/scenes/channelScene.ts\nvar ChannelScene = class extends LinearScene {\n  constructor() {\n    super(...arguments);\n    this.handles = {};\n    this.topLine = new CollidableLine();\n    this.bottomLine = new CollidableLine();\n    this.background = new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Path({ zIndex: -1 });\n  }\n  update(datum, context) {\n    const { locked, visible } = datum;\n    this.locked = locked ?? false;\n    this.seriesRect = context.seriesRect;\n    const top = convertLine(datum, context);\n    const bottom = convertLine(datum.bottom, context);\n    if (top == null || bottom == null) {\n      this.visible = false;\n      return;\n    } else {\n      this.visible = visible ?? true;\n    }\n    this.updateLines(datum, top, bottom);\n    this.updateHandles(datum, top, bottom);\n    this.updateBackground(datum, top, bottom);\n    for (const handle of Object.values(this.handles)) {\n      handle.toggleLocked(this.locked);\n    }\n  }\n  toggleActive(active) {\n    this.toggleHandles(active);\n    for (const node of Object.values(this.handles)) {\n      node.toggleActive(active);\n    }\n  }\n  stopDragging() {\n    const { activeHandle, handles } = this;\n    if (activeHandle == null)\n      return;\n    handles[activeHandle].toggleDragging(false);\n  }\n  getAnchor() {\n    const bbox = this.getCachedBBoxWithoutHandles();\n    return { x: bbox.x + bbox.width / 2, y: bbox.y };\n  }\n  getCursor() {\n    if (this.activeHandle == null)\n      return \"pointer\";\n    return this.handles[this.activeHandle].getCursor();\n  }\n  containsPoint(x, y) {\n    const { handles, seriesRect, topLine, bottomLine } = this;\n    this.activeHandle = void 0;\n    for (const [handle, child] of Object.entries(handles)) {\n      if (child.containsPoint(x, y)) {\n        this.activeHandle = handle;\n        return true;\n      }\n    }\n    x -= seriesRect?.x ?? 0;\n    y -= seriesRect?.y ?? 0;\n    return topLine.containsPoint(x, y) || bottomLine.containsPoint(x, y);\n  }\n  updateBackground(datum, top, bottom) {\n    const { background } = this;\n    background.path.clear();\n    background.path.moveTo(top.x1, top.y1);\n    background.path.lineTo(top.x2, top.y2);\n    background.path.lineTo(bottom.x2, bottom.y2);\n    background.path.lineTo(bottom.x1, bottom.y1);\n    background.path.closePath();\n    background.checkPathDirty();\n    background.setProperties({\n      fill: datum.background.fill,\n      fillOpacity: datum.background.fillOpacity\n    });\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/annotations/disjoint-channel/disjointChannelScene.ts\nvar { Vec2: Vec24 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar DisjointChannel = class extends ChannelScene {\n  constructor() {\n    super();\n    this.type = \"disjoint-channel\";\n    this.handles = {\n      topLeft: new DivariantHandle(),\n      topRight: new DivariantHandle(),\n      bottomLeft: new DivariantHandle(),\n      bottomRight: new UnivariantHandle()\n    };\n    this.append([this.background, this.topLine, this.bottomLine, ...Object.values(this.handles)]);\n  }\n  static is(value) {\n    return Annotation2.isCheck(value, \"disjoint-channel\");\n  }\n  toggleHandles(show) {\n    if (typeof show === \"boolean\") {\n      show = {\n        topLeft: show,\n        topRight: show,\n        bottomLeft: show,\n        bottomRight: show\n      };\n    }\n    for (const [handle, node] of Object.entries(this.handles)) {\n      node.visible = show[handle] ?? true;\n      node.toggleHovered(this.activeHandle === handle);\n    }\n  }\n  toggleActive(active) {\n    this.toggleHandles(active);\n    for (const node of Object.values(this.handles)) {\n      node.toggleActive(active);\n    }\n  }\n  dragHandle(datum, target, context, onInvalid) {\n    const { activeHandle, handles } = this;\n    if (activeHandle == null)\n      return;\n    const { offset } = handles[activeHandle].drag(target);\n    handles[activeHandle].toggleDragging(true);\n    const invert2 = (coords) => invertCoords(coords, context);\n    const prev = datum.toJson();\n    switch (activeHandle) {\n      case \"topLeft\":\n      case \"bottomLeft\": {\n        const direction = activeHandle === \"topLeft\" ? 1 : -1;\n        const start = invert2({\n          x: handles.topLeft.handle.x + offset.x,\n          y: handles.topLeft.handle.y + offset.y * direction\n        });\n        const bottomStart = invert2({\n          x: handles.bottomLeft.handle.x + offset.x,\n          y: handles.bottomLeft.handle.y + offset.y * -direction\n        });\n        if (!start || !bottomStart || datum.start.y == null)\n          return;\n        const startHeight = datum.startHeight + (start.y - datum.start.y) * 2;\n        datum.start.x = start.x;\n        datum.start.y = start.y;\n        datum.startHeight = startHeight;\n        break;\n      }\n      case \"topRight\": {\n        const end = invert2({\n          x: handles.topRight.handle.x + offset.x,\n          y: handles.topRight.handle.y + offset.y\n        });\n        if (!end || datum.end.y == null)\n          return;\n        const endHeight = datum.endHeight + (end.y - datum.end.y) * 2;\n        datum.end.x = end.x;\n        datum.end.y = end.y;\n        datum.endHeight = endHeight;\n        break;\n      }\n      case \"bottomRight\": {\n        const bottomStart = invert2({\n          x: handles.bottomLeft.handle.x + offset.x,\n          y: handles.bottomLeft.handle.y + offset.y\n        });\n        const bottomEnd = invert2({\n          x: handles.bottomRight.handle.x + offset.x,\n          y: handles.bottomRight.handle.y + offset.y\n        });\n        if (!bottomStart || !bottomEnd || datum.start.y == null || datum.end.y == null)\n          return;\n        const endHeight = datum.end.y - bottomEnd.y;\n        const startHeight = datum.startHeight - (datum.endHeight - endHeight);\n        datum.startHeight = startHeight;\n        datum.endHeight = endHeight;\n      }\n    }\n    if (!datum.isValidWithContext(context)) {\n      datum.set(prev);\n      onInvalid();\n    }\n  }\n  getOtherCoords(datum, topLeft, topRight, context) {\n    const { dragState } = this;\n    if (!dragState)\n      return [];\n    const startHeight = convertPoint(datum.bottom.start, context).y - convertPoint(datum.start, context).y;\n    const endHeight = convertPoint(datum.bottom.end, context).y - convertPoint(datum.end, context).y;\n    const bottomLeft = Vec24.add(topLeft, Vec24.from(0, startHeight));\n    const bottomRight = Vec24.add(topRight, Vec24.from(0, endHeight));\n    return [bottomLeft, bottomRight];\n  }\n  updateLines(datum, top, bottom) {\n    const { topLine, bottomLine } = this;\n    const { lineDash, lineDashOffset, stroke, strokeOpacity, strokeWidth } = datum;\n    const lineStyles = { lineDash, lineDashOffset, stroke, strokeOpacity, strokeWidth };\n    topLine.setProperties({\n      x1: top.x1,\n      y1: top.y1,\n      x2: top.x2,\n      y2: top.y2,\n      ...lineStyles\n    });\n    bottomLine.setProperties({\n      x1: bottom.x1,\n      y1: bottom.y1,\n      x2: bottom.x2,\n      y2: bottom.y2,\n      ...lineStyles\n    });\n    topLine.updateCollisionBBox();\n    bottomLine.updateCollisionBBox();\n  }\n  updateHandles(datum, top, bottom) {\n    const {\n      handles: { topLeft, topRight, bottomLeft, bottomRight }\n    } = this;\n    const handleStyles = {\n      fill: datum.handle.fill,\n      stroke: datum.handle.stroke ?? datum.stroke,\n      strokeOpacity: datum.handle.strokeOpacity ?? datum.strokeOpacity,\n      strokeWidth: datum.handle.strokeWidth ?? datum.strokeWidth\n    };\n    topLeft.update({ ...handleStyles, x: top.x1, y: top.y1 });\n    topRight.update({ ...handleStyles, x: top.x2, y: top.y2 });\n    bottomLeft.update({ ...handleStyles, x: bottom.x1, y: bottom.y1 });\n    bottomRight.update({\n      ...handleStyles,\n      x: bottom.x2 - bottomRight.handle.width / 2,\n      y: bottom.y2 - bottomRight.handle.height / 2\n    });\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/annotations/disjoint-channel/disjointChannelState.ts\n\nvar DisjointChannelStateMachine = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.StateMachine {\n  constructor(appendDatum, validateDatumPoint2) {\n    const onStartClick = ({ point }) => {\n      const datum = new DisjointChannelAnnotation();\n      datum.set({ start: point, end: point, startHeight: 0, endHeight: 0 });\n      appendDatum(datum);\n    };\n    const onEndHover = ({ datum, node, point }) => {\n      datum?.set({ end: point });\n      node?.toggleHandles({ topRight: false, bottomLeft: false, bottomRight: false });\n    };\n    const onEndClick = ({ datum, point }) => {\n      datum?.set({ end: point });\n    };\n    const onHeightHover = ({ datum, node, point }) => {\n      if (datum.start.y == null || datum.end.y == null)\n        return;\n      const endHeight = datum.end.y - point.y;\n      const startHeight = (datum.start.y - datum.end.y) * 2 + endHeight;\n      const bottomStart = { x: datum.start.x, y: datum.start.y - startHeight };\n      const bottomEnd = { x: datum.end.x, y: point.y };\n      node.toggleHandles({ bottomLeft: false });\n      if (!validateDatumPoint2(bottomStart) || !validateDatumPoint2(bottomEnd)) {\n        return;\n      }\n      datum.set({ startHeight, endHeight });\n    };\n    const onHeightClick = ({ datum, node, point }) => {\n      if (!datum || !node || datum.start.y == null || datum.end.y == null)\n        return;\n      const endHeight = datum.end.y - point.y;\n      const startHeight = (datum.start.y - datum.end.y) * 2 + endHeight;\n      const bottomStart = { x: datum.start.x, y: datum.start.y - endHeight };\n      const bottomEnd = { x: datum.end.x, y: point.y };\n      node.toggleHandles(true);\n      if (validateDatumPoint2(bottomStart) && validateDatumPoint2(bottomEnd)) {\n        datum.set({ startHeight, endHeight });\n      }\n    };\n    super(\"start\", {\n      start: {\n        click: {\n          target: \"end\",\n          action: onStartClick\n        },\n        drag: {\n          target: \"end\",\n          action: onStartClick\n        },\n        cancel: \"__parent\"\n      },\n      end: {\n        hover: onEndHover,\n        click: {\n          target: \"height\",\n          action: onEndClick\n        },\n        drag: onEndHover,\n        cancel: \"__parent\"\n      },\n      height: {\n        hover: onHeightHover,\n        click: {\n          target: \"__parent\",\n          action: onHeightClick\n        },\n        cancel: \"__parent\"\n      }\n    });\n    this.debug = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util.Debug.create(true, \"annotations\");\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/annotations/line/lineProperties.ts\n\nvar { STRING: STRING5, BaseProperties: BaseProperties4, Validate: Validate15, isObject: isObject4 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar LineAnnotation = class extends Annotation(\n  \"line\" /* Line */,\n  AnnotationLine(AnnotationHandle(Cappable(Extendable(Stroke(LineDash(BaseProperties4))))))\n) {\n  constructor() {\n    super(...arguments);\n    this.type = \"line\" /* Line */;\n  }\n  static is(value) {\n    return isObject4(value) && value.type === \"line\" /* Line */;\n  }\n  isValidWithContext(context, warningPrefix) {\n    return super.isValid(warningPrefix) && validateDatumLine(context, this, warningPrefix);\n  }\n};\n__decorateClass([\n  Validate15(STRING5)\n], LineAnnotation.prototype, \"type\", 2);\n\n// packages/ag-charts-enterprise/src/features/annotations/line/lineScene.ts\n\nvar Line = class extends LinearScene {\n  constructor() {\n    super();\n    this.type = \"line\";\n    this.line = new CollidableLine();\n    this.start = new DivariantHandle();\n    this.end = new DivariantHandle();\n    this.append([this.line, this.start, this.end]);\n  }\n  static is(value) {\n    return Annotation2.isCheck(value, \"line\");\n  }\n  update(datum, context) {\n    const { line, start, end } = this;\n    const { locked, visible, lineDash, lineDashOffset, stroke, strokeWidth, strokeOpacity } = datum;\n    this.locked = locked ?? false;\n    this.seriesRect = context.seriesRect;\n    const coords = convertLine(datum, context);\n    if (coords == null) {\n      this.visible = false;\n      return;\n    } else {\n      this.visible = visible ?? true;\n    }\n    const { x1, y1, x2, y2 } = coords;\n    line.setProperties({\n      x1,\n      y1,\n      x2,\n      y2,\n      lineDash,\n      lineDashOffset,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      fillOpacity: 0\n    });\n    line.updateCollisionBBox();\n    const handleStyles = {\n      fill: datum.handle.fill,\n      stroke: datum.handle.stroke ?? stroke,\n      strokeOpacity: datum.handle.strokeOpacity ?? strokeOpacity,\n      strokeWidth: datum.handle.strokeWidth ?? strokeWidth\n    };\n    start.update({ ...handleStyles, x: x1, y: y1 });\n    end.update({ ...handleStyles, x: x2, y: y2 });\n    start.toggleLocked(this.locked);\n    end.toggleLocked(this.locked);\n  }\n  toggleHandles(show) {\n    if (typeof show === \"boolean\") {\n      show = { start: show, end: show };\n    }\n    this.start.visible = show.start ?? true;\n    this.end.visible = show.end ?? true;\n    this.start.toggleHovered(this.activeHandle === \"start\");\n    this.end.toggleHovered(this.activeHandle === \"end\");\n  }\n  toggleActive(active) {\n    this.toggleHandles(active);\n    this.start.toggleActive(active);\n    this.end.toggleActive(active);\n  }\n  dragHandle(datum, target, context, onInvalid) {\n    const { activeHandle } = this;\n    if (!activeHandle)\n      return;\n    this[activeHandle].toggleDragging(true);\n    const point = invertCoords(this[activeHandle].drag(target).point, context);\n    if (!validateDatumPoint(context, point)) {\n      onInvalid();\n      return;\n    }\n    datum[activeHandle].x = point.x;\n    datum[activeHandle].y = point.y;\n  }\n  stopDragging() {\n    this.start.toggleDragging(false);\n    this.end.toggleDragging(false);\n  }\n  getAnchor() {\n    const bbox = this.getCachedBBoxWithoutHandles();\n    return { x: bbox.x + bbox.width / 2, y: bbox.y };\n  }\n  getCursor() {\n    if (this.activeHandle == null)\n      return \"pointer\";\n    return \"default\";\n  }\n  containsPoint(x, y) {\n    const { start, end, seriesRect, line } = this;\n    this.activeHandle = void 0;\n    if (start.containsPoint(x, y)) {\n      this.activeHandle = \"start\";\n      return true;\n    }\n    if (end.containsPoint(x, y)) {\n      this.activeHandle = \"end\";\n      return true;\n    }\n    x -= seriesRect?.x ?? 0;\n    y -= seriesRect?.y ?? 0;\n    return line.isPointInPath(x, y);\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/annotations/line/lineState.ts\n\nvar LineStateMachine = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.StateMachine {\n  constructor(appendDatum) {\n    const onStartClick = ({ point }) => {\n      const datum = new LineAnnotation();\n      datum.set({ start: point, end: point });\n      appendDatum(datum);\n    };\n    const onEndHover = ({ datum, node, point }) => {\n      datum?.set({ end: point });\n      node?.toggleHandles({ end: false });\n    };\n    const onEndClick = ({ datum, node, point }) => {\n      datum?.set({ end: point });\n      node?.toggleHandles(true);\n    };\n    super(\"start\", {\n      start: {\n        click: {\n          target: \"end\",\n          action: onStartClick\n        },\n        drag: {\n          target: \"end\",\n          action: onStartClick\n        },\n        cancel: \"__parent\"\n      },\n      end: {\n        hover: onEndHover,\n        click: {\n          target: \"__parent\",\n          action: onEndClick\n        },\n        drag: onEndHover,\n        cancel: \"__parent\"\n      }\n    });\n    this.debug = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util.Debug.create(true, \"annotations\");\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/annotations/parallel-channel/parallelChannelProperties.ts\n\nvar { NUMBER: NUMBER5, STRING: STRING6, OBJECT: OBJECT4, BaseProperties: BaseProperties5, Validate: Validate16, isObject: isObject5 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar ParallelChannelAnnotation = class extends Annotation(\n  \"parallel-channel\" /* ParallelChannel */,\n  ChannelAnnotation(AnnotationLine(AnnotationHandle(Extendable(Stroke(LineDash(BaseProperties5))))))\n) {\n  constructor() {\n    super(...arguments);\n    this.type = \"parallel-channel\" /* ParallelChannel */;\n    this.middle = new ChannelAnnotationMiddle();\n  }\n  static is(value) {\n    return isObject5(value) && value.type === \"parallel-channel\" /* ParallelChannel */;\n  }\n  get bottom() {\n    const bottom = {\n      start: { x: this.start.x, y: this.start.y },\n      end: { x: this.end.x, y: this.end.y }\n    };\n    if (typeof bottom.start.y === \"number\" && typeof bottom.end.y === \"number\") {\n      bottom.start.y -= this.height;\n      bottom.end.y -= this.height;\n    } else {\n      ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util.Logger.warnOnce(`Annotation [${this.type}] can only be used with a numeric y-axis.`);\n    }\n    return bottom;\n  }\n  isValidWithContext(context, warningPrefix) {\n    return super.isValid(warningPrefix) && validateDatumLine(context, this, warningPrefix) && validateDatumLine(context, this.bottom, warningPrefix);\n  }\n};\n__decorateClass([\n  Validate16(STRING6)\n], ParallelChannelAnnotation.prototype, \"type\", 2);\n__decorateClass([\n  Validate16(NUMBER5)\n], ParallelChannelAnnotation.prototype, \"height\", 2);\n__decorateClass([\n  Validate16(OBJECT4, { optional: true })\n], ParallelChannelAnnotation.prototype, \"middle\", 2);\n\n// packages/ag-charts-enterprise/src/features/annotations/parallel-channel/parallelChannelScene.ts\n\nvar { Vec2: Vec25 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar ParallelChannel = class extends ChannelScene {\n  constructor() {\n    super();\n    this.type = \"parallel-channel\";\n    this.handles = {\n      topLeft: new DivariantHandle(),\n      topMiddle: new UnivariantHandle(),\n      topRight: new DivariantHandle(),\n      bottomLeft: new DivariantHandle(),\n      bottomMiddle: new UnivariantHandle(),\n      bottomRight: new DivariantHandle()\n    };\n    this.middleLine = new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Line();\n    this.append([this.background, this.topLine, this.middleLine, this.bottomLine, ...Object.values(this.handles)]);\n  }\n  static is(value) {\n    return Annotation2.isCheck(value, \"parallel-channel\");\n  }\n  toggleHandles(show) {\n    if (typeof show === \"boolean\") {\n      show = {\n        topLeft: show,\n        topMiddle: show,\n        topRight: show,\n        bottomLeft: show,\n        bottomMiddle: show,\n        bottomRight: show\n      };\n    }\n    for (const [handle, node] of Object.entries(this.handles)) {\n      node.visible = show[handle] ?? true;\n      node.toggleHovered(this.activeHandle === handle);\n    }\n  }\n  toggleActive(active) {\n    this.toggleHandles(active);\n    for (const node of Object.values(this.handles)) {\n      node.toggleActive(active);\n    }\n  }\n  dragHandle(datum, target, context, onInvalid) {\n    const { activeHandle, handles } = this;\n    if (activeHandle == null)\n      return;\n    const { offset } = handles[activeHandle].drag(target);\n    handles[activeHandle].toggleDragging(true);\n    const prev = datum.toJson();\n    let moves = [];\n    switch (activeHandle) {\n      case \"topLeft\":\n      case \"bottomLeft\":\n        moves = [\"topLeft\", \"bottomLeft\"];\n        break;\n      case \"topMiddle\":\n        moves = [\"topLeft\", \"topRight\"];\n        offset.y -= UnivariantHandle.HANDLE_SIZE / 2;\n        break;\n      case \"topRight\":\n      case \"bottomRight\":\n        moves = [\"topRight\", \"bottomRight\"];\n        break;\n      case \"bottomMiddle\":\n        moves = [\"bottomLeft\", \"bottomRight\"];\n        offset.y -= UnivariantHandle.HANDLE_SIZE / 2;\n        break;\n    }\n    const invertedMoves = moves.map((move) => invertCoords(Vec25.add(handles[move].handle, offset), context));\n    if (invertedMoves.some((invertedMove) => !validateDatumPoint(context, invertedMove))) {\n      onInvalid();\n      return;\n    }\n    if ((activeHandle === \"topMiddle\" || activeHandle === \"bottomMiddle\") && datum.start.y != null) {\n      const topLeft = invertCoords(Vec25.add(handles.topLeft.handle, offset), context);\n      if (validateDatumPoint(context, topLeft)) {\n        if (activeHandle === \"topMiddle\") {\n          datum.height += topLeft.y - datum.start.y;\n        } else {\n          datum.height -= topLeft.y - datum.start.y;\n        }\n      }\n    }\n    for (const [index, invertedMove] of invertedMoves.entries()) {\n      switch (moves[index]) {\n        case \"topLeft\":\n          datum.start.x = invertedMove.x;\n          datum.start.y = invertedMove.y;\n          break;\n        case \"topRight\":\n          datum.end.x = invertedMove.x;\n          datum.end.y = invertedMove.y;\n          break;\n      }\n    }\n    if (!datum.isValidWithContext(context)) {\n      datum.set(prev);\n      onInvalid();\n    }\n  }\n  getOtherCoords(datum, topLeft, topRight, context) {\n    const { dragState } = this;\n    if (!dragState)\n      return [];\n    const height = convertPoint(datum.bottom.start, context).y - convertPoint(datum.start, context).y;\n    const bottomLeft = Vec25.add(topLeft, Vec25.from(0, height));\n    const bottomRight = Vec25.add(topRight, Vec25.from(0, height));\n    return [bottomLeft, bottomRight];\n  }\n  updateLines(datum, top, bottom) {\n    const { topLine, middleLine, bottomLine } = this;\n    const { lineDash, lineDashOffset, stroke, strokeOpacity, strokeWidth } = datum;\n    const lineStyles = { lineDash, lineDashOffset, stroke, strokeOpacity, strokeWidth };\n    topLine.setProperties({\n      x1: top.x1,\n      y1: top.y1,\n      x2: top.x2,\n      y2: top.y2,\n      ...lineStyles\n    });\n    bottomLine.setProperties({\n      x1: bottom.x1,\n      y1: bottom.y1,\n      x2: bottom.x2,\n      y2: bottom.y2,\n      ...lineStyles\n    });\n    topLine.updateCollisionBBox();\n    bottomLine.updateCollisionBBox();\n    middleLine.setProperties({\n      x1: top.x1,\n      y1: bottom.y1 + (top.y1 - bottom.y1) / 2,\n      x2: top.x2,\n      y2: bottom.y2 + (top.y2 - bottom.y2) / 2,\n      lineDash: datum.middle.lineDash ?? lineDash,\n      lineDashOffset: datum.middle.lineDashOffset ?? lineDashOffset,\n      stroke: datum.middle.stroke ?? stroke,\n      strokeOpacity: datum.middle.strokeOpacity ?? strokeOpacity,\n      strokeWidth: datum.middle.strokeWidth ?? strokeWidth,\n      visible: datum.middle.visible ?? true\n    });\n  }\n  updateHandles(datum, top, bottom) {\n    const {\n      handles: { topLeft, topMiddle, topRight, bottomLeft, bottomMiddle, bottomRight }\n    } = this;\n    const handleStyles = {\n      fill: datum.handle.fill,\n      stroke: datum.handle.stroke ?? datum.stroke,\n      strokeOpacity: datum.handle.strokeOpacity ?? datum.strokeOpacity,\n      strokeWidth: datum.handle.strokeWidth ?? datum.strokeWidth\n    };\n    topLeft.update({ ...handleStyles, x: top.x1, y: top.y1 });\n    topRight.update({ ...handleStyles, x: top.x2, y: top.y2 });\n    bottomLeft.update({ ...handleStyles, x: bottom.x1, y: bottom.y1 });\n    bottomRight.update({ ...handleStyles, x: bottom.x2, y: bottom.y2 });\n    topMiddle.update({\n      ...handleStyles,\n      x: top.x1 + (top.x2 - top.x1) / 2 - topMiddle.handle.width / 2,\n      y: top.y1 + (top.y2 - top.y1) / 2 - topMiddle.handle.height / 2\n    });\n    bottomMiddle.update({\n      ...handleStyles,\n      x: bottom.x1 + (bottom.x2 - bottom.x1) / 2 - bottomMiddle.handle.width / 2,\n      y: bottom.y1 + (bottom.y2 - bottom.y1) / 2 - bottomMiddle.handle.height / 2\n    });\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/annotations/parallel-channel/parallelChannelState.ts\n\nvar ParallelChannelStateMachine = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.StateMachine {\n  constructor(appendDatum, validateDatumPoint2) {\n    const onStartClick = ({ point }) => {\n      const datum = new ParallelChannelAnnotation();\n      datum.set({ start: point, end: point, height: 0 });\n      appendDatum(datum);\n    };\n    const onEndHover = ({ datum, node, point }) => {\n      datum?.set({ end: point, height: 0 });\n      node?.toggleHandles({\n        topMiddle: false,\n        topRight: false,\n        bottomLeft: false,\n        bottomMiddle: false,\n        bottomRight: false\n      });\n    };\n    const onEndClick = ({ datum, node, point }) => {\n      datum?.set({ end: point });\n      node?.toggleHandles({ topMiddle: false, bottomMiddle: false });\n    };\n    const onHeightHover = ({ datum, node, point }) => {\n      if (datum.start.y == null || datum.end.y == null)\n        return;\n      const height = datum.end.y - point.y;\n      const bottomStartY = datum.start.y - height;\n      node.toggleHandles({ topMiddle: false, bottomMiddle: false });\n      if (!validateDatumPoint2({ x: datum.start.x, y: bottomStartY }) || !validateDatumPoint2({ x: datum.end.x, y: point.y })) {\n        return;\n      }\n      datum.set({ height });\n    };\n    const onHeightClick = ({ datum, node, point }) => {\n      if (!datum || !node || datum.start.y == null || datum.end.y == null)\n        return;\n      const height = datum.end.y - point.y;\n      const bottomStartY = datum.start.y - height;\n      node.toggleHandles(true);\n      if (validateDatumPoint2({ x: datum.start.x, y: bottomStartY }) && validateDatumPoint2({ x: datum.end.x, y: point.y })) {\n        datum.set({ height });\n      }\n    };\n    super(\"start\", {\n      start: {\n        click: {\n          target: \"end\",\n          action: onStartClick\n        },\n        drag: {\n          target: \"end\",\n          action: onStartClick\n        },\n        cancel: \"__parent\"\n      },\n      end: {\n        hover: onEndHover,\n        click: {\n          target: \"height\",\n          action: onEndClick\n        },\n        drag: onEndHover,\n        cancel: \"__parent\"\n      },\n      height: {\n        hover: onHeightHover,\n        click: {\n          target: \"__parent\",\n          action: onHeightClick\n        },\n        cancel: \"__parent\"\n      }\n    });\n    this.debug = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util.Debug.create(true, \"annotations\");\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/annotations/annotations.ts\nvar {\n  BOOLEAN: BOOLEAN6,\n  ChartUpdateType,\n  Cursor,\n  InteractionState: InteractionState2,\n  PropertiesArray,\n  StateMachine,\n  ToolbarManager,\n  Validate: Validate17,\n  REGIONS: REGIONS2,\n  UNION: UNION4,\n  ChartAxisDirection: ChartAxisDirection10\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { Vec2: Vec26 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar annotationDatums = {\n  [\"line\" /* Line */]: LineAnnotation,\n  [\"horizontal-line\" /* HorizontalLine */]: HorizontalLineAnnotation,\n  [\"vertical-line\" /* VerticalLine */]: VerticalLineAnnotation,\n  [\"parallel-channel\" /* ParallelChannel */]: ParallelChannelAnnotation,\n  [\"disjoint-channel\" /* DisjointChannel */]: DisjointChannelAnnotation\n};\nvar annotationScenes = {\n  [\"line\" /* Line */]: Line,\n  [\"horizontal-line\" /* HorizontalLine */]: CrossLine,\n  [\"vertical-line\" /* VerticalLine */]: CrossLine,\n  [\"disjoint-channel\" /* DisjointChannel */]: DisjointChannel,\n  [\"parallel-channel\" /* ParallelChannel */]: ParallelChannel\n};\nvar AnnotationsStateMachine = class extends StateMachine {\n  constructor(onEnterIdle, appendDatum, onExitCrossLine, validateChildStateDatumPoint) {\n    super(\"idle\", {\n      idle: {\n        onEnter: () => onEnterIdle(),\n        [\"line\" /* Line */]: new LineStateMachine((datum) => appendDatum(\"line\" /* Line */, datum)),\n        [\"horizontal-line\" /* HorizontalLine */]: new CrossLineStateMachine(\n          \"horizontal\",\n          (datum) => appendDatum(\"horizontal-line\" /* HorizontalLine */, datum),\n          onExitCrossLine\n        ),\n        [\"vertical-line\" /* VerticalLine */]: new CrossLineStateMachine(\n          \"vertical\",\n          (datum) => appendDatum(\"vertical-line\" /* VerticalLine */, datum),\n          onExitCrossLine\n        ),\n        [\"disjoint-channel\" /* DisjointChannel */]: new DisjointChannelStateMachine(\n          (datum) => appendDatum(\"disjoint-channel\" /* DisjointChannel */, datum),\n          validateChildStateDatumPoint\n        ),\n        [\"parallel-channel\" /* ParallelChannel */]: new ParallelChannelStateMachine(\n          (datum) => appendDatum(\"parallel-channel\" /* ParallelChannel */, datum),\n          validateChildStateDatumPoint\n        )\n      }\n    });\n    this.debug = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util.Debug.create(true, \"annotations\");\n  }\n};\nvar AXIS_TYPE = UNION4([\"x\", \"y\", \"xy\"], \"an axis type\");\nvar AxesButtons = class {\n  constructor() {\n    this.enabled = true;\n    this.axes = \"y\";\n  }\n};\n__decorateClass([\n  Validate17(BOOLEAN6)\n], AxesButtons.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate17(AXIS_TYPE, { optional: true })\n], AxesButtons.prototype, \"axes\", 2);\nvar Annotations = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    // TODO: When the 'restore-annotations' event is triggered from `ActionsOnSet.newValue()`, the module is still\n    // disabled when `onRestoreAnnotations()` is called, preventing the state from being restored. However,\n    // when `ObserveChanges()` is first called `target.enabled === false`, rather than `undefined`. So\n    // there is no way to detect if the module was actively disabled. This flag simulates a combined\n    // behaviour of both and is toggled when the module is actively disabled and enabled.\n    this.__hackWasDisabled = false;\n    this.enabled = true;\n    this.axesButtons = new AxesButtons();\n    this.annotationData = new PropertiesArray(this.createAnnotationDatum);\n    this.container = new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Group({ name: \"static-annotations\" });\n    this.annotations = new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Selection(\n      this.container,\n      this.createAnnotationScene.bind(this)\n    );\n    this.colorPicker = new ColorPicker(this.ctx);\n    this.state = new AnnotationsStateMachine(\n      () => {\n        ctx.cursorManager.updateCursor(\"annotations\");\n        ctx.interactionManager.popState(InteractionState2.Annotations);\n        ctx.toolbarManager.toggleGroup(\"annotations\", \"annotationOptions\", this.active != null);\n        ctx.tooltipManager.unsuppressTooltip(\"annotations\");\n        for (const annotationType of ANNOTATION_BUTTONS) {\n          ctx.toolbarManager.toggleButton(\"annotations\", annotationType, { active: false });\n        }\n        this.toggleAnnotationOptionsButtons();\n      },\n      this.appendDatum.bind(this),\n      () => {\n        this.active = this.annotationData.length - 1;\n      },\n      this.validateChildStateDatumPoint.bind(this)\n    );\n    const { All, Default: Default4, Annotations: AnnotationsState, ZoomDrag } = InteractionState2;\n    const seriesRegion = ctx.regionManager.getRegion(REGIONS2.SERIES);\n    const otherRegions = Object.values(REGIONS2).filter(\n      (region) => ![\n        REGIONS2.SERIES,\n        // TODO: Navigator wrongly enchroaches on the top of the chart, even if it is disabled. We\n        // have to ignore it to prevent it immediately calling `onCancel()` when the top-left\n        // annotations toolbar button is clicked.\n        REGIONS2.NAVIGATOR\n      ].includes(region)\n    ).map((region) => ctx.regionManager.getRegion(region));\n    ctx.domManager.addStyles(DEFAULT_ANNOTATION_AXIS_BUTTON_CLASS, axisButton_default);\n    this.destroyFns.push(\n      ctx.annotationManager.attachNode(this.container),\n      () => this.colorPicker.destroy(),\n      seriesRegion.addListener(\"hover\", (event) => this.onHover(event), All),\n      seriesRegion.addListener(\"click\", (event) => this.onClick(event), All),\n      seriesRegion.addListener(\"drag-start\", this.onDragStart.bind(this), Default4 | ZoomDrag | AnnotationsState),\n      seriesRegion.addListener(\"drag\", this.onDrag.bind(this), Default4 | ZoomDrag | AnnotationsState),\n      seriesRegion.addListener(\"drag-end\", this.onDragEnd.bind(this), All),\n      seriesRegion.addListener(\"cancel\", this.onCancel.bind(this), All),\n      seriesRegion.addListener(\"delete\", this.onDelete.bind(this), All),\n      ...otherRegions.map((region) => region.addListener(\"click\", this.onCancel.bind(this), All)),\n      ctx.annotationManager.addListener(\"restore-annotations\", this.onRestoreAnnotations.bind(this)),\n      ctx.toolbarManager.addListener(\"button-pressed\", this.onToolbarButtonPress.bind(this)),\n      ctx.toolbarManager.addListener(\"button-moved\", this.onToolbarButtonMoved.bind(this)),\n      ctx.toolbarManager.addListener(\"cancelled\", this.onToolbarCancelled.bind(this)),\n      ctx.layoutService.addListener(\"layout-complete\", this.onLayoutComplete.bind(this)),\n      () => ctx.domManager.removeStyles(DEFAULT_ANNOTATION_AXIS_BUTTON_CLASS)\n    );\n  }\n  createAnnotationScene(datum) {\n    return new annotationScenes[datum.type]();\n  }\n  createAnnotationDatum(params) {\n    if (params.type in annotationDatums) {\n      return new annotationDatums[params.type]().set(params);\n    }\n    throw new Error(\n      `AG Charts - Cannot set property of unknown type [${params.type}], expected one of [${Object.keys(annotationDatums)}], ignoring.`\n    );\n  }\n  appendDatum(type, datum) {\n    this.annotationData.push(datum);\n    const styles = this.ctx.annotationManager.getAnnotationTypeStyles(type);\n    if (styles)\n      datum.set(styles);\n    if (this.defaultColor) {\n      this.colorDatum(datum, this.defaultColor);\n    }\n  }\n  onRestoreAnnotations(event) {\n    if (!this.enabled)\n      return;\n    this.clear();\n    this.annotationData.set(event.annotations);\n    this.update();\n  }\n  onToolbarButtonPress(event) {\n    const {\n      state,\n      ctx: { interactionManager, toolbarManager, tooltipManager }\n    } = this;\n    if (ToolbarManager.isGroup(\"annotationOptions\", event)) {\n      this.onToolbarAnnotationOptionButtonPress(event);\n      return;\n    }\n    if (!ToolbarManager.isGroup(\"annotations\", event)) {\n      this.reset();\n      this.update();\n      return;\n    }\n    if (event.value === \"clear\") {\n      this.clear();\n      this.update();\n      return;\n    }\n    tooltipManager.suppressTooltip(\"annotations\");\n    const annotation = stringToAnnotationType(event.value);\n    if (!annotation) {\n      ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util.Logger.errorOnce(`Can not create unknown annotation type [${event.value}], ignoring.`);\n      this.update();\n      return;\n    }\n    if (!state.is(\"idle\")) {\n      this.cancel();\n    }\n    interactionManager.pushState(InteractionState2.Annotations);\n    for (const annotationType of ANNOTATION_BUTTONS) {\n      toolbarManager.toggleButton(\"annotations\", annotationType, { active: annotationType === event.value });\n    }\n    state.transition(annotation);\n    this.reset();\n    this.update();\n  }\n  onToolbarAnnotationOptionButtonPress(event) {\n    if (!ToolbarManager.isGroup(\"annotationOptions\", event))\n      return;\n    const { active, annotationData } = this;\n    if (active == null)\n      return;\n    switch (event.value) {\n      case \"line-color\":\n        this.colorPicker.show({\n          color: this.getTypedDatum(annotationData[active])?.stroke,\n          onChange: this.onColorPickerChange.bind(this),\n          onClose: this.onColorPickerClose.bind(this)\n        });\n        break;\n      case \"delete\":\n        annotationData.splice(active, 1);\n        this.reset();\n        break;\n      case \"lock\":\n        annotationData[active].locked = true;\n        this.toggleAnnotationOptionsButtons();\n        this.colorPicker.hide();\n        break;\n      case \"unlock\":\n        annotationData[active].locked = false;\n        this.toggleAnnotationOptionsButtons();\n        break;\n    }\n    this.update();\n  }\n  onToolbarButtonMoved(event) {\n    const { rect } = event;\n    const anchor = Vec26.add(rect, Vec26.from(0, rect.height + 4));\n    const fallback = { y: rect.y - 4 };\n    this.colorPicker.setAnchor(anchor, fallback);\n  }\n  onColorPickerChange(color) {\n    const { active, annotationData } = this;\n    if (active == null)\n      return;\n    this.colorDatum(annotationData[active], color);\n    this.defaultColor = color;\n    this.update();\n  }\n  onColorPickerClose() {\n    this.colorPicker.hide();\n  }\n  onToolbarCancelled(event) {\n    if (event.group !== \"annotations\")\n      return;\n    this.onCancel();\n    for (const annotationType of ANNOTATION_BUTTONS) {\n      this.ctx.toolbarManager.toggleButton(\"annotations\", annotationType, { active: false });\n    }\n  }\n  onLayoutComplete(event) {\n    const seriesRect = event.series.paddedRect;\n    this.seriesRect = seriesRect;\n    for (const axisLayout of event.axes ?? []) {\n      if (axisLayout.direction === ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.ChartAxisDirection.X) {\n        this.xAxis = this.getAxis(axisLayout, seriesRect, this.xAxis?.button);\n      } else {\n        this.yAxis = this.getAxis(axisLayout, seriesRect, this.yAxis?.button);\n      }\n    }\n    this.updateAnnotations();\n  }\n  getAxis(axisLayout, seriesRect, button) {\n    const axisCtx = this.ctx.axisManager.getAxisContext(axisLayout.direction)[0];\n    const { position: axisPosition = \"bottom\", direction } = axisCtx;\n    const padding = axisLayout.gridPadding + axisLayout.seriesAreaPadding;\n    const bounds = buildBounds(new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.BBox(0, 0, seriesRect.width, seriesRect.height), axisPosition, padding);\n    const lineDirection = axisCtx.direction === ChartAxisDirection10.X ? \"vertical\" : \"horizontal\";\n    const { axesButtons } = this;\n    const buttonEnabled = this.enabled && axesButtons.enabled && (axesButtons.axes === \"xy\" || axesButtons.axes === direction);\n    if (buttonEnabled) {\n      button ?? (button = new AxisButton(\n        this.ctx,\n        axisCtx,\n        (coords) => this.onAxisButtonClick(coords, lineDirection),\n        seriesRect\n      ));\n      const axisLabelPadding = calculateAxisLabelPadding(axisLayout);\n      button.update(seriesRect, axisLabelPadding);\n    } else {\n      button?.destroy();\n      button = void 0;\n    }\n    return { layout: axisLayout, context: axisCtx, bounds, button };\n  }\n  updateAnnotations() {\n    const {\n      active,\n      seriesRect,\n      annotationData,\n      annotations,\n      ctx: { annotationManager, toolbarManager }\n    } = this;\n    const context = this.getAnnotationContext();\n    if (!seriesRect || !context) {\n      return;\n    }\n    annotationManager.updateData(annotationData.toJson());\n    annotations.update(annotationData ?? [], void 0, (datum) => datum.id).each((node, datum, index) => {\n      if (!this.validateDatum(datum)) {\n        node.visible = false;\n        return;\n      }\n      if (LineAnnotation.is(datum) && Line.is(node)) {\n        node.update(datum, context);\n      }\n      if (DisjointChannelAnnotation.is(datum) && DisjointChannel.is(node)) {\n        node.update(datum, context);\n      }\n      if ((HorizontalLineAnnotation.is(datum) || VerticalLineAnnotation.is(datum)) && CrossLine.is(node)) {\n        node.update(datum, context);\n      }\n      if (ParallelChannelAnnotation.is(datum) && ParallelChannel.is(node)) {\n        node.update(datum, context);\n      }\n      if (active === index) {\n        toolbarManager.changeFloatingAnchor(\"annotationOptions\", node.getAnchor());\n      }\n    });\n  }\n  // Validation of the options beyond the scope of the @Validate decorator\n  validateDatum(datum) {\n    const context = this.getAnnotationContext();\n    return context ? datum.isValidWithContext(context, `Annotation [${datum.type}] `) : true;\n  }\n  validateChildStateDatumPoint(point) {\n    const context = this.getAnnotationContext();\n    const valid = context ? validateDatumPoint(context, point) : true;\n    if (!valid) {\n      this.ctx.cursorManager.updateCursor(\"annotations\", Cursor.NotAllowed);\n    }\n    return valid;\n  }\n  getAnnotationContext() {\n    const { seriesRect, xAxis, yAxis } = this;\n    if (!(seriesRect && xAxis && yAxis)) {\n      return;\n    }\n    return {\n      seriesRect,\n      xAxis: {\n        ...xAxis.context,\n        bounds: xAxis.bounds,\n        labelPadding: calculateAxisLabelPadding(xAxis.layout)\n      },\n      yAxis: {\n        ...yAxis.context,\n        bounds: yAxis.bounds,\n        labelPadding: calculateAxisLabelPadding(xAxis.layout)\n      }\n    };\n  }\n  onHover(event) {\n    if (this.state.is(\"idle\")) {\n      this.onHoverSelecting(event);\n    } else {\n      this.onHoverAdding(event);\n    }\n  }\n  onHoverSelecting(event) {\n    const {\n      active,\n      annotations,\n      ctx: { cursorManager }\n    } = this;\n    this.hovered = void 0;\n    annotations.each((annotation, _, index) => {\n      const contains = annotation.containsPoint(event.offsetX, event.offsetY);\n      if (contains)\n        this.hovered ?? (this.hovered = index);\n      annotation.toggleHandles(contains || active === index);\n    });\n    cursorManager.updateCursor(\n      \"annotations\",\n      this.hovered == null ? void 0 : annotations.nodes()[this.hovered].getCursor()\n    );\n  }\n  onHoverAdding(event) {\n    const {\n      annotationData,\n      annotations,\n      seriesRect,\n      state,\n      ctx: { cursorManager }\n    } = this;\n    const context = this.getAnnotationContext();\n    if (!context)\n      return;\n    const offset = Vec26.sub(Vec26.fromOffset(event), Vec26.required(seriesRect));\n    const point = invertCoords(offset, context);\n    const valid = validateDatumPoint(context, point);\n    cursorManager.updateCursor(\"annotations\", valid ? void 0 : Cursor.NotAllowed);\n    if (!valid || state.is(\"start\"))\n      return;\n    const datum = annotationData.at(-1);\n    this.active = annotationData.length - 1;\n    const node = annotations.nodes()[this.active];\n    if (!datum || !node)\n      return;\n    node.toggleActive(true);\n    const data = { datum, node, point };\n    this.state.transition(\"hover\", data);\n    this.update();\n  }\n  onClick(event) {\n    const { dragOffset, state } = this;\n    if (state.is(\"end\") && dragOffset && dragOffset.x === event.offsetX && dragOffset.y === event.offsetY) {\n      this.dragOffset = void 0;\n      return;\n    }\n    if (state.is(\"idle\")) {\n      this.onClickSelecting();\n    } else {\n      this.onClickAdding(event);\n    }\n  }\n  onAxisButtonClick(coords, direction) {\n    this.onCancel();\n    const context = this.getAnnotationContext();\n    if (!this.annotationData || !context)\n      return;\n    const {\n      state,\n      ctx: { toolbarManager, interactionManager }\n    } = this;\n    interactionManager.pushState(InteractionState2.Annotations);\n    const isHorizontal = direction === \"horizontal\";\n    state.transition(isHorizontal ? \"horizontal-line\" /* HorizontalLine */ : \"vertical-line\" /* VerticalLine */);\n    toolbarManager.toggleGroup(\"annotations\", \"annotationOptions\", false);\n    if (!coords) {\n      return;\n    }\n    const point = invertCoords(coords, context);\n    if (!validateDatumPoint(context, point)) {\n      return;\n    }\n    const data = { point };\n    state.transition(\"click\", data);\n    this.update();\n  }\n  onClickSelecting() {\n    const {\n      annotations,\n      colorPicker,\n      hovered,\n      ctx: { toolbarManager, tooltipManager }\n    } = this;\n    colorPicker.hide();\n    if (this.active != null) {\n      annotations.nodes()[this.active].toggleActive(false);\n    }\n    this.active = hovered;\n    toolbarManager.toggleGroup(\"annotations\", \"annotationOptions\", this.active != null);\n    if (this.active == null) {\n      tooltipManager.unsuppressTooltip(\"annotations\");\n    } else {\n      const node = annotations.nodes()[this.active];\n      node.toggleActive(true);\n      tooltipManager.suppressTooltip(\"annotations\");\n      this.toggleAnnotationOptionsButtons();\n    }\n    this.update();\n  }\n  onClickAdding(event) {\n    const {\n      active,\n      annotationData,\n      annotations,\n      seriesRect,\n      state,\n      ctx: { toolbarManager }\n    } = this;\n    toolbarManager.toggleGroup(\"annotations\", \"annotationOptions\", false);\n    const context = this.getAnnotationContext();\n    if (!context)\n      return;\n    const datum = annotationData.at(-1);\n    const offset = Vec26.sub(Vec26.fromOffset(event), Vec26.required(seriesRect));\n    const point = invertCoords(offset, context);\n    const node = active != null ? annotations.nodes()[active] : void 0;\n    if (!validateDatumPoint(context, point)) {\n      return;\n    }\n    const data = { datum, node, point };\n    state.transition(\"click\", data);\n    this.update();\n  }\n  onDragStart(event) {\n    const { annotationData, annotations, hovered, seriesRect } = this;\n    if (this.isOtherElement(event)) {\n      return;\n    }\n    const context = this.getAnnotationContext();\n    if (hovered == null || annotationData == null || !this.state.is(\"idle\") || context == null)\n      return;\n    const datum = annotationData[hovered];\n    const node = annotations.nodes()[hovered];\n    const offset = Vec26.sub(Vec26.fromOffset(event), Vec26.required(seriesRect));\n    if (Line.is(node)) {\n      node.dragStart(datum, offset, context);\n    }\n    if (CrossLine.is(node)) {\n      node.dragStart(datum, offset, context);\n    }\n    if (DisjointChannel.is(node)) {\n      node.dragStart(datum, offset, context);\n    }\n    if (ParallelChannel.is(node)) {\n      node.dragStart(datum, offset, context);\n    }\n  }\n  onDrag(event) {\n    const { state } = this;\n    if (this.isOtherElement(event)) {\n      return;\n    }\n    if (state.is(\"start\")) {\n      this.dragOffset = Vec26.fromOffset(event);\n    }\n    if (state.is(\"idle\")) {\n      this.onClickSelecting();\n      this.onDragAnnotation(event);\n    } else {\n      this.onDragAdding(event);\n    }\n  }\n  onDragAnnotation(event) {\n    const {\n      annotationData,\n      annotations,\n      hovered,\n      seriesRect,\n      ctx: { cursorManager, interactionManager }\n    } = this;\n    const context = this.getAnnotationContext();\n    if (hovered == null || annotationData == null || !this.state.is(\"idle\") || context == null)\n      return;\n    interactionManager.pushState(InteractionState2.Annotations);\n    const datum = annotationData[hovered];\n    const node = annotations.nodes()[hovered];\n    const offset = Vec26.sub(Vec26.fromOffset(event), Vec26.required(seriesRect));\n    cursorManager.updateCursor(\"annotations\");\n    const onDragInvalid = () => cursorManager.updateCursor(\"annotations\", Cursor.NotAllowed);\n    if (LineAnnotation.is(datum) && Line.is(node)) {\n      node.drag(datum, offset, context, onDragInvalid);\n    }\n    if ((HorizontalLineAnnotation.is(datum) || VerticalLineAnnotation.is(datum)) && CrossLine.is(node)) {\n      node.drag(datum, offset, context, onDragInvalid);\n    }\n    if (DisjointChannelAnnotation.is(datum) && DisjointChannel.is(node)) {\n      node.drag(datum, offset, context, onDragInvalid);\n    }\n    if (ParallelChannelAnnotation.is(datum) && ParallelChannel.is(node)) {\n      node.drag(datum, offset, context, onDragInvalid);\n    }\n    this.update();\n  }\n  onDragAdding(event) {\n    const {\n      active,\n      annotationData,\n      annotations,\n      seriesRect,\n      state,\n      ctx: { interactionManager }\n    } = this;\n    const context = this.getAnnotationContext();\n    if (annotationData == null || context == null)\n      return;\n    const datum = active != null ? annotationData[active] : void 0;\n    const node = active != null ? annotations.nodes()[active] : void 0;\n    const offset = Vec26.sub(Vec26.fromOffset(event), Vec26.required(seriesRect));\n    interactionManager.pushState(InteractionState2.Annotations);\n    const point = invertCoords(offset, context);\n    const data = { datum, node, point };\n    state.transition(\"drag\", data);\n    this.active = annotationData.length - 1;\n    this.update();\n  }\n  onDragEnd(_event) {\n    const {\n      active,\n      annotations,\n      ctx: { cursorManager, interactionManager }\n    } = this;\n    if (!this.state.is(\"idle\"))\n      return;\n    interactionManager.popState(InteractionState2.Annotations);\n    cursorManager.updateCursor(\"annotations\");\n    if (active == null)\n      return;\n    annotations.nodes()[active].stopDragging();\n    this.update();\n  }\n  onCancel() {\n    if (!this.state.is(\"idle\")) {\n      this.cancel();\n    }\n    this.reset();\n    this.update();\n  }\n  onDelete() {\n    const { active, annotationData, state } = this;\n    if (active == null)\n      return;\n    if (!state.is(\"idle\")) {\n      state.transition(\"cancel\");\n    }\n    annotationData.splice(active, 1);\n    this.reset();\n    this.update();\n  }\n  toggleAnnotationOptionsButtons() {\n    const {\n      active,\n      annotationData,\n      ctx: { toolbarManager }\n    } = this;\n    if (active == null)\n      return;\n    const locked = annotationData.at(active)?.locked ?? false;\n    toolbarManager.toggleButton(\"annotationOptions\", \"line-color\", { enabled: !locked });\n    toolbarManager.toggleButton(\"annotationOptions\", \"delete\", { enabled: !locked });\n    toolbarManager.toggleButton(\"annotationOptions\", \"lock\", { visible: !locked });\n    toolbarManager.toggleButton(\"annotationOptions\", \"unlock\", { visible: locked });\n  }\n  getTypedDatum(datum) {\n    if (LineAnnotation.is(datum) || HorizontalLineAnnotation.is(datum) || VerticalLineAnnotation.is(datum) || DisjointChannelAnnotation.is(datum) || ParallelChannelAnnotation.is(datum)) {\n      return datum;\n    }\n  }\n  colorDatum(datum, color) {\n    datum.stroke = color;\n    if (\"axisLabel\" in datum) {\n      datum.axisLabel.fill = color;\n      datum.axisLabel.stroke = color;\n    }\n    if (\"background\" in datum)\n      datum.background.fill = color;\n  }\n  isOtherElement({ targetElement }) {\n    const {\n      colorPicker,\n      ctx: { domManager }\n    } = this;\n    if (!targetElement)\n      return false;\n    return ToolbarManager.isChildElement(domManager, targetElement) || colorPicker.isChildElement(targetElement);\n  }\n  clear() {\n    this.annotationData.splice(0, this.annotationData.length);\n    this.reset();\n  }\n  reset() {\n    if (this.active != null) {\n      this.annotations.nodes().at(this.active)?.toggleActive(false);\n    }\n    this.hovered = void 0;\n    this.active = void 0;\n    this.ctx.toolbarManager.toggleGroup(\"annotations\", \"annotationOptions\", false);\n    this.colorPicker.hide();\n  }\n  cancel() {\n    const { active, annotationData, state } = this;\n    state.transition(\"cancel\");\n    if (active != null && annotationData) {\n      annotationData.splice(active, 1);\n    }\n  }\n  update() {\n    this.ctx.updateService.update(ChartUpdateType.PERFORM_LAYOUT, { skipAnimations: true });\n  }\n};\n__decorateClass([\n  ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.ObserveChanges((target, enabled) => {\n    const {\n      ctx: { annotationManager, stateManager, toolbarManager }\n    } = target;\n    toolbarManager.toggleGroup(\"annotations\", \"annotations\", Boolean(enabled));\n    if (target.__hackWasDisabled && enabled) {\n      stateManager.restoreState(annotationManager);\n      target.__hackWasDisabled = false;\n    } else if (enabled === false) {\n      target.__hackWasDisabled = true;\n      target.clear();\n    }\n  }),\n  Validate17(BOOLEAN6)\n], Annotations.prototype, \"enabled\", 2);\n\n// packages/ag-charts-enterprise/src/features/annotations/annotationsModule.ts\nvar AnnotationsModule = {\n  type: \"root\",\n  optionsKey: \"annotations\",\n  packageType: \"enterprise\",\n  chartTypes: [\"cartesian\"],\n  dependencies: [\"toolbar\"],\n  instanceConstructor: Annotations,\n  themeTemplate: {\n    annotations: {\n      line: {\n        stroke: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_ANNOTATION_STROKE,\n        strokeWidth: 2,\n        strokeOpacity: 1,\n        handle: {\n          fill: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_ANNOTATION_HANDLE_FILL\n        }\n      },\n      \"horizontal-line\": {\n        stroke: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_ANNOTATION_STROKE,\n        strokeWidth: 2,\n        strokeOpacity: 1,\n        handle: {\n          fill: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_ANNOTATION_HANDLE_FILL\n        },\n        axisLabel: {\n          enabled: true,\n          color: \"white\",\n          fill: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_ANNOTATION_STROKE,\n          fontSize: 12,\n          fontFamily: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_FONT_FAMILY\n        }\n      },\n      \"vertical-line\": {\n        stroke: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_ANNOTATION_STROKE,\n        strokeWidth: 2,\n        strokeOpacity: 1,\n        handle: {\n          fill: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_ANNOTATION_HANDLE_FILL\n        },\n        axisLabel: {\n          enabled: true,\n          color: \"white\",\n          fill: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_ANNOTATION_STROKE,\n          fontSize: 12,\n          fontFamily: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_FONT_FAMILY\n        }\n      },\n      \"disjoint-channel\": {\n        stroke: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_ANNOTATION_STROKE,\n        strokeWidth: 2,\n        strokeOpacity: 1,\n        background: {\n          fill: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_ANNOTATION_BACKGROUND_FILL,\n          fillOpacity: 0.2\n        },\n        handle: {\n          fill: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_ANNOTATION_HANDLE_FILL\n        }\n      },\n      \"parallel-channel\": {\n        stroke: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_ANNOTATION_STROKE,\n        strokeWidth: 2,\n        strokeOpacity: 1,\n        middle: {\n          lineDash: [6, 5],\n          strokeWidth: 1\n        },\n        background: {\n          fill: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_ANNOTATION_BACKGROUND_FILL,\n          fillOpacity: 0.2\n        },\n        handle: {\n          fill: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_ANNOTATION_HANDLE_FILL\n        }\n      }\n    }\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/background/background.ts\n\n\n// packages/ag-charts-enterprise/src/features/background/backgroundImage.ts\n\nvar { Image } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar {\n  BaseProperties: BaseProperties6,\n  ObserveChanges: ObserveChanges2,\n  ProxyProperty,\n  Validate: Validate18,\n  NUMBER: NUMBER6,\n  POSITIVE_NUMBER: POSITIVE_NUMBER5,\n  RATIO: RATIO5,\n  createElement: createElement3,\n  calculatePlacement\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar BackgroundImage = class extends BaseProperties6 {\n  constructor() {\n    super();\n    this.opacity = 1;\n    this.loadedSynchronously = true;\n    this.containerWidth = 0;\n    this.containerHeight = 0;\n    this.onLoad = void 0;\n    this.onImageLoad = () => {\n      if (this.loadedSynchronously) {\n        return;\n      }\n      this.node.visible = false;\n      this.performLayout(this.containerWidth, this.containerHeight);\n      this.onLoad?.();\n    };\n    this.imageElement = createElement3(\"img\");\n    this.imageElement.onload = this.onImageLoad;\n    this.node = new Image(this.imageElement);\n  }\n  get complete() {\n    return this.imageElement.width > 0 && this.imageElement.height > 0;\n  }\n  performLayout(containerWidth, containerHeight) {\n    this.containerWidth = containerWidth;\n    this.containerHeight = containerHeight;\n    this.node.setProperties(\n      this.complete ? {\n        visible: true,\n        opacity: this.opacity,\n        ...calculatePlacement(\n          this.imageElement.width,\n          this.imageElement.height,\n          this.containerWidth,\n          this.containerHeight,\n          this\n        )\n      } : { visible: false }\n    );\n  }\n};\n__decorateClass([\n  Validate18(NUMBER6, { optional: true })\n], BackgroundImage.prototype, \"top\", 2);\n__decorateClass([\n  Validate18(NUMBER6, { optional: true })\n], BackgroundImage.prototype, \"right\", 2);\n__decorateClass([\n  Validate18(NUMBER6, { optional: true })\n], BackgroundImage.prototype, \"bottom\", 2);\n__decorateClass([\n  Validate18(NUMBER6, { optional: true })\n], BackgroundImage.prototype, \"left\", 2);\n__decorateClass([\n  Validate18(POSITIVE_NUMBER5, { optional: true })\n], BackgroundImage.prototype, \"width\", 2);\n__decorateClass([\n  Validate18(POSITIVE_NUMBER5, { optional: true })\n], BackgroundImage.prototype, \"height\", 2);\n__decorateClass([\n  Validate18(RATIO5)\n], BackgroundImage.prototype, \"opacity\", 2);\n__decorateClass([\n  ProxyProperty(\"imageElement.src\"),\n  ObserveChanges2((target) => target.loadedSynchronously = target.complete)\n], BackgroundImage.prototype, \"url\", 2);\n\n// packages/ag-charts-enterprise/src/features/background/background.ts\nvar { ActionOnSet, OBJECT: OBJECT5, Validate: Validate19 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar Background = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.Background {\n  constructor(ctx) {\n    super(ctx);\n    this.ctx = ctx;\n    this.image = new BackgroundImage();\n  }\n  onLayoutComplete(event) {\n    super.onLayoutComplete(event);\n    if (this.image) {\n      const { width, height } = event.chart;\n      this.image.performLayout(width, height);\n    }\n  }\n  onImageLoad() {\n    this.ctx.updateService.update(ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.ChartUpdateType.SCENE_RENDER);\n  }\n};\n__decorateClass([\n  Validate19(OBJECT5, { optional: true }),\n  ActionOnSet({\n    newValue(image) {\n      this.node.appendChild(image.node);\n      image.onLoad = () => this.onImageLoad();\n    },\n    oldValue(image) {\n      this.node.removeChild(image.node);\n      image.onLoad = void 0;\n    }\n  })\n], Background.prototype, \"image\", 2);\n\n// packages/ag-charts-enterprise/src/features/background/backgroundModule.ts\nvar BackgroundModule = {\n  type: \"root\",\n  optionsKey: \"background\",\n  packageType: \"enterprise\",\n  chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n  instanceConstructor: Background\n};\n\n// packages/ag-charts-enterprise/src/features/context-menu/contextMenuModule.ts\n\n\n// packages/ag-charts-enterprise/src/features/context-menu/contextMenu.ts\n\n\n// packages/ag-charts-enterprise/src/features/context-menu/contextMenuStyles.css\nvar contextMenuStyles_default = \".ag-chart-context-menu{background:rgb(248,248,248);border:1px solid #babfc7;border-radius:5px;box-shadow:0 1px 4px 1px rgba(186,191,199,0.4);color:rgb(24,29,31);font:13px Verdana,sans-serif;transition:transform 0.1s ease;white-space:nowrap;z-index:var(--ag-charts-layer-context-menu)}.ag-chart-context-menu.ag-charts-dark-context-menu{color:white;background:#15181c}.ag-chart-context-menu__cover{position:fixed;left:0px;top:0px}.ag-chart-context-menu__menu{display:flex;flex-direction:column;padding:0.5em 0}.ag-chart-context-menu__menu:focus{outline:none}.ag-chart-context-menu__item{background:none;border:none;box-sizing:border-box;font:inherit;padding:0.5em 1em;text-align:left;-webkit-appearance:none;-moz-appearance:none}.ag-chart-context-menu__item.ag-charts-dark-context-menu{color:white}.ag-chart-context-menu__item:hover{background:rgb(33,150,243,0.1)}.ag-chart-context-menu__item:hover.ag-charts-dark-context-menu{background:rgb(33,150,243,0.1)}.ag-chart-context-menu__item:active{background:rgb(33,150,243,0.2)}.ag-chart-context-menu__item:active.ag-charts-dark-context-menu{background:rgb(33,150,243,0.1)}.ag-chart-context-menu__item[aria-disabled='true']{border:none;opacity:0.5;text-align:left}.ag-chart-context-menu__item[aria-disabled='true']:hover{background:inherit;cursor:inherit}.ag-chart-context-menu__divider{margin:5px 0;background:#babfc7;height:1px}.ag-chart-context-menu__divider.ag-charts-dark-context-menu{background:rgb(33,150,243,0.1)}\";\n\n// packages/ag-charts-enterprise/src/features/context-menu/contextMenuStyles.ts\nvar DEFAULT_CONTEXT_MENU_CLASS = \"ag-chart-context-menu\";\nvar DEFAULT_CONTEXT_MENU_DARK_CLASS = \"ag-charts-dark-context-menu\";\n\n// packages/ag-charts-enterprise/src/features/context-menu/contextMenu.ts\nvar { BOOLEAN: BOOLEAN7, Validate: Validate20, createElement: createElement4, initMenuKeyNav, makeAccessibleClickListener, ContextMenuRegistry } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar moduleId2 = \"context-menu\";\nfunction getChildrenOfType(parent, ctor) {\n  const { children } = parent ?? {};\n  if (!children)\n    return [];\n  const result = [];\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    if (child instanceof ctor) {\n      result.push(child);\n    }\n  }\n  return result;\n}\nvar ContextMenu = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.enabled = true;\n    this.darkTheme = false;\n    /**\n     * Extra menu actions with a label and callback.\n     */\n    this.extraActions = [];\n    /**\n     * Extra menu actions that only appear when clicking on a node.\n     */\n    this.extraNodeActions = [];\n    /**\n     * Extra menu actions that only appear when clicking on a legend item\n     */\n    this.extraLegendItemActions = [];\n    this.x = 0;\n    this.y = 0;\n    this.menuElementDestroyFns = [];\n    this.interactionManager = ctx.interactionManager;\n    this.registry = ctx.contextMenuRegistry;\n    this.scene = ctx.scene;\n    const { All } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.InteractionState;\n    this.destroyFns.push(ctx.regionManager.listenAll(\"click\", (_region) => this.onClick(), All));\n    this.groups = { default: [], extra: [], extraSeries: [], extraNode: [], extraLegendItem: [] };\n    this.element = ctx.domManager.addChild(\"canvas-overlay\", moduleId2);\n    this.element.classList.add(DEFAULT_CONTEXT_MENU_CLASS);\n    this.element.addEventListener(\"contextmenu\", (event) => event.preventDefault());\n    this.destroyFns.push(() => this.element.parentNode?.removeChild(this.element));\n    this.hide();\n    this.destroyFns.push(ctx.domManager.addListener(\"hidden\", () => this.hide()));\n    if (typeof MutationObserver !== \"undefined\") {\n      const observer = new MutationObserver(() => {\n        if (this.menuElement && this.element.contains(this.menuElement)) {\n          this.reposition();\n        }\n      });\n      observer.observe(this.element, { childList: true });\n      this.mutationObserver = observer;\n      this.destroyFns.push(() => observer.disconnect());\n    }\n    ctx.domManager.addStyles(moduleId2, contextMenuStyles_default);\n    this.registry.registerDefaultAction({\n      id: \"download\",\n      type: \"all\",\n      label: \"contextMenuDownload\",\n      action: () => {\n        const title = ctx.chartService.title;\n        let fileName = \"image\";\n        if (title?.enabled && title?.text !== void 0) {\n          fileName = title.text;\n        }\n        this.scene.download(fileName);\n      }\n    });\n    this.destroyFns.push(this.registry.addListener((e) => this.onContext(e)));\n  }\n  isShown() {\n    return this.menuElement !== void 0;\n  }\n  onClick() {\n    if (this.isShown()) {\n      this.hide();\n    }\n  }\n  onContext(event) {\n    if (!this.enabled)\n      return;\n    event.preventDefault();\n    this.showEvent = event.sourceEvent;\n    this.x = event.x;\n    this.y = event.y;\n    this.groups.default = this.registry.filterActions(event.type);\n    this.pickedNode = void 0;\n    this.pickedLegendItem = void 0;\n    this.groups.extra = this.extraActions.map(({ label, action }) => {\n      return { type: \"all\", label, action };\n    });\n    if (ContextMenuRegistry.check(\"series\", event)) {\n      this.pickedNode = event.context.pickedNode;\n      if (this.pickedNode) {\n        this.groups.extraNode = this.extraNodeActions.map(({ label, action }) => {\n          return { type: \"node\", label, action };\n        });\n      }\n    }\n    if (ContextMenuRegistry.check(\"legend\", event)) {\n      this.pickedLegendItem = event.context.legendItem;\n      if (this.pickedLegendItem) {\n        this.groups.extraLegendItem = this.extraLegendItemActions.map(({ label, action }) => {\n          return { type: \"legend\", label, action };\n        });\n      }\n    }\n    const { default: def, extra, extraNode, extraLegendItem } = this.groups;\n    const groupCount = [def, extra, extraNode, extraLegendItem].reduce((count, e) => {\n      return e.length + count;\n    }, 0);\n    if (groupCount === 0)\n      return;\n    this.lastFocus = this.getLastFocus(event);\n    this.show();\n  }\n  getLastFocus(event) {\n    if (event.sourceEvent.target instanceof HTMLElement && \"tabindex\" in event.sourceEvent.target.attributes) {\n      return event.sourceEvent.target;\n    }\n    return void 0;\n  }\n  show() {\n    this.interactionManager.pushState(ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.InteractionState.ContextMenu);\n    this.element.classList.toggle(DEFAULT_CONTEXT_MENU_DARK_CLASS, this.darkTheme);\n    const newMenuElement = this.renderMenu();\n    if (this.menuElement) {\n      this.element.replaceChild(newMenuElement, this.menuElement);\n      this.menuElementDestroyFns.forEach((d) => d());\n    } else {\n      this.element.appendChild(newMenuElement);\n    }\n    this.menuElement = newMenuElement;\n    this.element.style.display = \"block\";\n    const buttons2 = getChildrenOfType(newMenuElement, HTMLButtonElement);\n    this.menuElementDestroyFns = initMenuKeyNav({\n      menu: newMenuElement,\n      buttons: buttons2,\n      orientation: \"vertical\",\n      onEscape: () => this.hide()\n    });\n    newMenuElement.focus();\n  }\n  hide() {\n    this.interactionManager.popState(ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.InteractionState.ContextMenu);\n    if (this.menuElement) {\n      this.element.removeChild(this.menuElement);\n      this.menuElement = void 0;\n      this.menuElementDestroyFns.forEach((d) => d());\n      this.menuElementDestroyFns.length = 0;\n    }\n    this.element.style.display = \"none\";\n    this.lastFocus?.focus();\n    this.lastFocus = void 0;\n  }\n  renderMenu() {\n    const menuElement = createElement4(\"div\");\n    menuElement.classList.add(`${DEFAULT_CONTEXT_MENU_CLASS}__menu`);\n    menuElement.classList.toggle(DEFAULT_CONTEXT_MENU_DARK_CLASS, this.darkTheme);\n    menuElement.role = \"menu\";\n    this.appendMenuGroup(menuElement, this.groups.default, false);\n    this.appendMenuGroup(menuElement, this.groups.extra);\n    if (this.pickedNode) {\n      this.appendMenuGroup(menuElement, this.groups.extraNode);\n    }\n    if (this.pickedLegendItem) {\n      this.appendMenuGroup(menuElement, this.groups.extraLegendItem);\n    }\n    return menuElement;\n  }\n  appendMenuGroup(menuElement, group, divider = true) {\n    if (group.length === 0)\n      return;\n    if (divider)\n      menuElement.appendChild(this.createDividerElement());\n    group.forEach((i) => {\n      const item = this.renderItem(i);\n      if (item)\n        menuElement.appendChild(item);\n    });\n  }\n  renderItem(item) {\n    if (item && typeof item === \"object\" && item.constructor === Object) {\n      return this.createActionElement(item);\n    }\n  }\n  createDividerElement() {\n    const el = createElement4(\"div\");\n    el.classList.add(`${DEFAULT_CONTEXT_MENU_CLASS}__divider`);\n    el.classList.toggle(DEFAULT_CONTEXT_MENU_DARK_CLASS, this.darkTheme);\n    el.role = \"separator\";\n    return el;\n  }\n  createActionElement({ id, label, type, action }) {\n    const disabled = !!(id && this.registry.isDisabled(id));\n    return this.createButtonElement(type, label, action, disabled);\n  }\n  createButtonOnClick(type, callback) {\n    if (ContextMenuRegistry.checkCallback(\"legend\", type, callback)) {\n      return () => {\n        if (this.pickedLegendItem) {\n          const { seriesId, itemId, enabled } = this.pickedLegendItem;\n          callback({ type: \"contextmenu\", seriesId, itemId, enabled });\n          this.hide();\n        }\n      };\n    } else if (ContextMenuRegistry.checkCallback(\"node\", type, callback)) {\n      return () => {\n        const { pickedNode, showEvent } = this;\n        const event = pickedNode?.series.createNodeContextMenuActionEvent(showEvent, pickedNode);\n        if (event) {\n          callback(event);\n        } else {\n          ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util.Logger.error(\"series node not found\");\n        }\n        this.hide();\n      };\n    }\n    return () => {\n      callback({ type: \"contextMenuEvent\", event: this.showEvent });\n      this.hide();\n    };\n  }\n  createButtonElement(type, label, callback, disabled) {\n    const el = createElement4(\"button\");\n    el.classList.add(`${DEFAULT_CONTEXT_MENU_CLASS}__item`);\n    el.classList.toggle(DEFAULT_CONTEXT_MENU_DARK_CLASS, this.darkTheme);\n    el.ariaDisabled = disabled.toString();\n    el.textContent = this.ctx.localeManager.t(label);\n    el.role = \"menuitem\";\n    el.onclick = makeAccessibleClickListener(el, this.createButtonOnClick(type, callback));\n    return el;\n  }\n  reposition() {\n    let { x, y } = this;\n    this.element.style.top = \"unset\";\n    this.element.style.bottom = \"unset\";\n    const canvasRect = this.ctx.domManager.getBoundingClientRect();\n    const { offsetWidth: width, offsetHeight: height } = this.element;\n    x = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.clamp(0, x, canvasRect.width - width);\n    y = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.clamp(0, y, canvasRect.height - height);\n    this.element.style.left = `${x}px`;\n    this.element.style.top = `calc(${y}px - 0.5em)`;\n  }\n  destroy() {\n    super.destroy();\n    this.mutationObserver?.disconnect();\n    this.ctx.domManager.removeStyles(moduleId2);\n    this.ctx.domManager.removeChild(\"canvas-overlay\", moduleId2);\n  }\n};\n__decorateClass([\n  Validate20(BOOLEAN7)\n], ContextMenu.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate20(BOOLEAN7)\n], ContextMenu.prototype, \"darkTheme\", 2);\n\n// packages/ag-charts-enterprise/src/features/context-menu/contextMenuModule.ts\nvar ContextMenuModule = {\n  type: \"root\",\n  packageType: \"enterprise\",\n  chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n  optionsKey: \"contextMenu\",\n  instanceConstructor: ContextMenu,\n  themeTemplate: {\n    contextMenu: {\n      enabled: true,\n      darkTheme: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.IS_DARK_THEME\n    }\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/crosshair/crosshair.ts\n\n\n// packages/ag-charts-enterprise/src/features/crosshair/crosshairLabel.ts\n\n\n// packages/ag-charts-enterprise/src/features/crosshair/crosshairLabel.css\nvar crosshairLabel_default = \".ag-crosshair-label{position:absolute;left:0px;top:0px;user-select:none;pointer-events:none;font:12px Verdana,sans-serif;overflow:hidden;white-space:nowrap;z-index:var(--ag-charts-layer-crosshair);box-sizing:border-box}.ag-crosshair-label-content{padding:0 8px;border-radius:2px;line-height:20px;background-color:var(--ag-charts-axis-label-background-color);color:var(--ag-charts-axis-label-color)}.ag-crosshair-label-hidden{top:-10000px!important}\";\n\n// packages/ag-charts-enterprise/src/features/crosshair/crosshairLabel.ts\nvar { ActionOnSet: ActionOnSet2, BaseProperties: BaseProperties7, BOOLEAN: BOOLEAN8, FUNCTION: FUNCTION2, NUMBER: NUMBER7, STRING: STRING7, Validate: Validate21 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { setAttribute } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar DEFAULT_LABEL_CLASS = \"ag-crosshair-label\";\nvar CrosshairLabelProperties = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.ChangeDetectableProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.xOffset = 0;\n    this.yOffset = 0;\n    this.format = void 0;\n    this.renderer = void 0;\n  }\n};\n__decorateClass([\n  Validate21(BOOLEAN8)\n], CrosshairLabelProperties.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate21(STRING7, { optional: true })\n], CrosshairLabelProperties.prototype, \"className\", 2);\n__decorateClass([\n  Validate21(NUMBER7)\n], CrosshairLabelProperties.prototype, \"xOffset\", 2);\n__decorateClass([\n  Validate21(NUMBER7)\n], CrosshairLabelProperties.prototype, \"yOffset\", 2);\n__decorateClass([\n  Validate21(STRING7, { optional: true })\n], CrosshairLabelProperties.prototype, \"format\", 2);\n__decorateClass([\n  Validate21(FUNCTION2, { optional: true })\n], CrosshairLabelProperties.prototype, \"renderer\", 2);\nvar CrosshairLabel = class extends BaseProperties7 {\n  constructor(domManager) {\n    super();\n    this.domManager = domManager;\n    this.id = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util.createId(this);\n    this.enabled = true;\n    this.xOffset = 0;\n    this.yOffset = 0;\n    this.renderer = void 0;\n    this.element = domManager.addChild(\"canvas-overlay\", `crosshair-label-${this.id}`);\n    this.element.classList.add(DEFAULT_LABEL_CLASS);\n    setAttribute(this.element, \"aria-hidden\", true);\n    this.domManager.addStyles(\"crosshair-labels\", crosshairLabel_default);\n  }\n  show(meta) {\n    const { element } = this;\n    const left = meta.x + this.xOffset;\n    const top = meta.y + this.yOffset;\n    element.style.top = `${Math.round(top)}px`;\n    element.style.left = `${Math.round(left)}px`;\n    this.toggle(true);\n  }\n  setLabelHtml(html) {\n    if (html !== void 0) {\n      this.element.innerHTML = html;\n    }\n  }\n  computeBBox() {\n    const { element } = this;\n    return new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.BBox(element.clientLeft, element.clientTop, element.clientWidth, element.clientHeight);\n  }\n  toggle(visible) {\n    this.element.classList.toggle(`ag-crosshair-label-hidden`, !visible);\n  }\n  destroy() {\n    this.domManager.removeChild(\"canvas-overlay\", `crosshair-label-${this.id}`);\n  }\n  toLabelHtml(input, defaults) {\n    if (typeof input === \"string\") {\n      return input;\n    }\n    defaults = defaults ?? {};\n    const {\n      text = defaults.text ?? \"\",\n      color = defaults.color,\n      backgroundColor = defaults.backgroundColor,\n      opacity = defaults.opacity ?? 1\n    } = input;\n    const style = `opacity: ${opacity}; background-color: ${backgroundColor?.toLowerCase()}; color: ${color}`;\n    return `<div class=\"ag-crosshair-label-content\" style=\"${style}\">\n                    <span>${text}</span>\n                </div>`;\n  }\n};\n__decorateClass([\n  Validate21(BOOLEAN8)\n], CrosshairLabel.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate21(STRING7, { optional: true }),\n  ActionOnSet2({\n    changeValue(newValue, oldValue) {\n      if (newValue !== oldValue) {\n        if (oldValue) {\n          this.element.classList.remove(oldValue);\n        }\n        if (newValue) {\n          this.element.classList.add(newValue);\n        }\n      }\n    }\n  })\n], CrosshairLabel.prototype, \"className\", 2);\n__decorateClass([\n  Validate21(NUMBER7)\n], CrosshairLabel.prototype, \"xOffset\", 2);\n__decorateClass([\n  Validate21(NUMBER7)\n], CrosshairLabel.prototype, \"yOffset\", 2);\n__decorateClass([\n  Validate21(STRING7, { optional: true })\n], CrosshairLabel.prototype, \"format\", 2);\n__decorateClass([\n  Validate21(FUNCTION2, { optional: true })\n], CrosshairLabel.prototype, \"renderer\", 2);\n\n// packages/ag-charts-enterprise/src/features/crosshair/crosshair.ts\nvar { Group: Group3, Line: Line2, BBox } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar { createId: createId2 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar { POSITIVE_NUMBER: POSITIVE_NUMBER6, RATIO: RATIO6, BOOLEAN: BOOLEAN9, COLOR_STRING: COLOR_STRING3, LINE_DASH: LINE_DASH3, OBJECT: OBJECT6, InteractionState: InteractionState3, Validate: Validate22, Layers: Layers3 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar Crosshair = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.id = createId2(this);\n    this.enabled = false;\n    this.stroke = \"rgb(195, 195, 195)\";\n    this.lineDash = [6, 3];\n    this.lineDashOffset = 0;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.snap = true;\n    this.label = new CrosshairLabelProperties();\n    this.seriesRect = new BBox(0, 0, 0, 0);\n    this.hoverRect = new BBox(0, 0, 0, 0);\n    this.bounds = new BBox(0, 0, 0, 0);\n    this.visible = false;\n    this.crosshairGroup = new Group3({ layer: true, zIndex: Layers3.SERIES_CROSSHAIR_ZINDEX });\n    this.lineGroup = this.crosshairGroup.appendChild(\n      new Group3({\n        name: `${this.id}-crosshair-lines`,\n        zIndex: Layers3.SERIES_CROSSHAIR_ZINDEX\n      })\n    );\n    this.lineGroupSelection = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Selection.select(this.lineGroup, Line2, false);\n    this.activeHighlight = void 0;\n    this.axisCtx = ctx.parent;\n    this.crosshairGroup.visible = false;\n    this.labels = {};\n    const region = ctx.regionManager.getRegion(\"series\");\n    const mouseMoveStates = InteractionState3.Default | InteractionState3.Annotations;\n    this.destroyFns.push(\n      ctx.scene.attachNode(this.crosshairGroup),\n      region.addListener(\"hover\", (event) => this.onMouseMove(event), mouseMoveStates),\n      region.addListener(\"drag\", (event) => this.onMouseMove(event), mouseMoveStates),\n      region.addListener(\"leave\", () => this.onMouseOut(), mouseMoveStates),\n      ctx.highlightManager.addListener(\"highlight-change\", (event) => this.onHighlightChange(event)),\n      ctx.layoutService.addListener(\"layout-complete\", (event) => this.layout(event)),\n      () => Object.entries(this.labels).forEach(([_, label]) => label.destroy())\n    );\n  }\n  layout({ series: { rect, paddedRect, visible }, axes }) {\n    if (!(visible && axes && this.enabled)) {\n      this.visible = false;\n      return;\n    }\n    this.visible = true;\n    this.seriesRect = rect;\n    this.hoverRect = paddedRect;\n    const { position: axisPosition = \"left\", axisId } = this.axisCtx;\n    const axisLayout = axes.find((a) => a.id === axisId);\n    if (!axisLayout) {\n      return;\n    }\n    this.axisLayout = axisLayout;\n    const padding = axisLayout.gridPadding + axisLayout.seriesAreaPadding;\n    this.bounds = buildBounds(rect, axisPosition, padding);\n    const { crosshairGroup, bounds } = this;\n    crosshairGroup.translationX = Math.round(bounds.x);\n    crosshairGroup.translationY = Math.round(bounds.y);\n    const crosshairKeys = [\"pointer\", ...this.axisCtx.seriesKeyProperties()];\n    this.updateSelections(crosshairKeys);\n    this.updateLines();\n    this.updateLabels(crosshairKeys);\n  }\n  updateSelections(data) {\n    this.lineGroupSelection.update(\n      data,\n      (group) => group.append(new Line2()),\n      (key) => key\n    );\n  }\n  updateLabels(keys) {\n    const { labels, ctx } = this;\n    keys.forEach((key) => {\n      labels[key] ?? (labels[key] = new CrosshairLabel(ctx.domManager));\n      this.updateLabel(labels[key]);\n    });\n    this.labelFormatter = this.axisCtx.scaleValueFormatter(this.label.format);\n  }\n  updateLabel(label) {\n    const { enabled, className, xOffset, yOffset, format, renderer } = this.label;\n    label.enabled = enabled;\n    label.className = className;\n    label.xOffset = xOffset;\n    label.yOffset = yOffset;\n    label.format = format;\n    label.renderer = renderer;\n  }\n  updateLines() {\n    const { lineGroupSelection, bounds, stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset, axisLayout } = this;\n    if (!axisLayout) {\n      return;\n    }\n    const isVertical = this.isVertical();\n    lineGroupSelection.each((line) => {\n      line.stroke = stroke;\n      line.strokeWidth = strokeWidth;\n      line.strokeOpacity = strokeOpacity;\n      line.lineDash = lineDash;\n      line.lineDashOffset = lineDashOffset;\n      line.y1 = 0;\n      line.y2 = isVertical ? bounds.height : 0;\n      line.x1 = 0;\n      line.x2 = isVertical ? 0 : bounds.width;\n    });\n  }\n  isVertical() {\n    return this.axisCtx.direction === \"x\";\n  }\n  formatValue(val) {\n    const {\n      labelFormatter,\n      axisLayout,\n      ctx: { callbackCache }\n    } = this;\n    if (labelFormatter) {\n      const result = callbackCache.call(labelFormatter, val);\n      if (result !== void 0)\n        return result;\n    }\n    const isInteger = val % 1 === 0;\n    const fractionDigits = (axisLayout?.label.fractionDigits ?? 0) + (isInteger ? 0 : 1);\n    return typeof val === \"number\" ? val.toFixed(fractionDigits) : String(val);\n  }\n  onMouseMove(event) {\n    if (!this.enabled || this.snap) {\n      return;\n    }\n    const { crosshairGroup, hoverRect } = this;\n    const { offsetX, offsetY } = event;\n    if (this.visible && hoverRect.containsPoint(offsetX, offsetY)) {\n      crosshairGroup.visible = true;\n      const lineData = this.getData(event);\n      this.updatePositions(lineData);\n    } else {\n      this.hideCrosshairs();\n    }\n  }\n  onMouseOut() {\n    this.hideCrosshairs();\n  }\n  onHighlightChange(event) {\n    if (!this.enabled) {\n      return;\n    }\n    const { crosshairGroup, axisCtx } = this;\n    const { datum, series } = event.currentHighlight ?? {};\n    const hasCrosshair = datum && (series?.axes.x?.id === axisCtx.axisId || series?.axes.y?.id === axisCtx.axisId);\n    this.activeHighlight = hasCrosshair ? event.currentHighlight : void 0;\n    if (this.snap) {\n      if (!this.visible || !this.activeHighlight) {\n        this.hideCrosshairs();\n        return;\n      }\n      const activeHighlightData = this.getActiveHighlightData(this.activeHighlight);\n      this.updatePositions(activeHighlightData);\n      crosshairGroup.visible = true;\n    }\n  }\n  updatePositions(data) {\n    const { seriesRect, lineGroupSelection } = this;\n    lineGroupSelection.each((line, key) => {\n      const lineData = data[key];\n      if (!lineData) {\n        line.visible = false;\n        return;\n      }\n      line.visible = true;\n      const { value, position } = lineData;\n      let x = 0;\n      let y = 0;\n      if (this.isVertical()) {\n        x = position;\n        line.translationX = Math.round(x);\n      } else {\n        y = position;\n        line.translationY = Math.round(y);\n      }\n      if (this.label.enabled) {\n        this.showLabel(x + seriesRect.x, y + seriesRect.y, value, key);\n      } else {\n        this.hideLabel(key);\n      }\n    });\n  }\n  getData(event) {\n    const { seriesRect, axisCtx } = this;\n    const key = \"pointer\";\n    const { datum, xKey = \"\", yKey = \"\" } = this.activeHighlight ?? {};\n    const { offsetX, offsetY } = event;\n    const x = offsetX - seriesRect.x;\n    const y = offsetY - seriesRect.y;\n    const isVertical = this.isVertical();\n    const position = isVertical ? x : y;\n    return {\n      [key]: {\n        position,\n        value: axisCtx.continuous ? axisCtx.scaleInvert(position) : datum?.[isVertical ? xKey : yKey] ?? \"\"\n      }\n    };\n  }\n  getActiveHighlightData(activeHighlight) {\n    const { axisCtx } = this;\n    const { datum, series, xKey = \"\", aggregatedValue, cumulativeValue, midPoint } = activeHighlight;\n    const seriesKeyProperties = series.getKeyProperties(axisCtx.direction);\n    const halfBandwidth = axisCtx.scaleBandwidth() / 2;\n    const matchingAxisId = series.axes[axisCtx.direction]?.id === axisCtx.axisId;\n    const isYKey = seriesKeyProperties.indexOf(\"yKey\") > -1 && matchingAxisId;\n    const isXKey = seriesKeyProperties.indexOf(\"xKey\") > -1 && matchingAxisId;\n    if (isYKey && aggregatedValue !== void 0) {\n      return {\n        yKey: { value: aggregatedValue, position: axisCtx.scaleConvert(aggregatedValue) + halfBandwidth }\n      };\n    }\n    if (isYKey && cumulativeValue !== void 0) {\n      return {\n        yKey: { value: cumulativeValue, position: axisCtx.scaleConvert(cumulativeValue) + halfBandwidth }\n      };\n    }\n    if (isXKey) {\n      const position = (this.isVertical() ? midPoint?.x : midPoint?.y) ?? 0;\n      return {\n        xKey: {\n          value: axisCtx.continuous ? axisCtx.scaleInvert(position) : datum[xKey],\n          position\n        }\n      };\n    }\n    const activeHighlightData = {};\n    seriesKeyProperties.forEach((key) => {\n      const keyValue = series.properties[key];\n      const value = datum[keyValue];\n      const position = axisCtx.scaleConvert(value) + halfBandwidth;\n      activeHighlightData[key] = { value, position };\n    });\n    return activeHighlightData;\n  }\n  getLabelHtml(value, label) {\n    const {\n      label: { renderer: labelRenderer },\n      axisLayout: { label: { fractionDigits = 0 } = {} } = {}\n    } = this;\n    const defaults = {\n      text: this.formatValue(value)\n    };\n    if (labelRenderer) {\n      const params = {\n        value,\n        fractionDigits\n      };\n      return label.toLabelHtml(labelRenderer(params), defaults);\n    }\n    return label.toLabelHtml(defaults);\n  }\n  showLabel(x, y, value, key) {\n    const {\n      axisCtx: { position: axisPosition, direction: axisDirection },\n      bounds,\n      axisLayout\n    } = this;\n    if (!axisLayout) {\n      return;\n    }\n    const {\n      label: { padding: labelPadding },\n      tickSize\n    } = axisLayout;\n    const padding = labelPadding + tickSize;\n    const label = this.labels[key];\n    const html = this.getLabelHtml(value, label);\n    label.setLabelHtml(html);\n    const labelBBox = label.computeBBox();\n    const labelMeta = calculateAxisLabelPosition({\n      x,\n      y,\n      labelBBox,\n      bounds,\n      axisPosition,\n      axisDirection,\n      padding\n    });\n    label.show(labelMeta);\n  }\n  hideCrosshairs() {\n    this.crosshairGroup.visible = false;\n    for (const key in this.labels) {\n      this.hideLabel(key);\n    }\n  }\n  hideLabel(key) {\n    this.labels[key].toggle(false);\n  }\n};\n__decorateClass([\n  Validate22(BOOLEAN9)\n], Crosshair.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate22(COLOR_STRING3, { optional: true })\n], Crosshair.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate22(LINE_DASH3, { optional: true })\n], Crosshair.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate22(POSITIVE_NUMBER6)\n], Crosshair.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate22(POSITIVE_NUMBER6)\n], Crosshair.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate22(RATIO6)\n], Crosshair.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate22(BOOLEAN9)\n], Crosshair.prototype, \"snap\", 2);\n__decorateClass([\n  Validate22(OBJECT6)\n], Crosshair.prototype, \"label\", 2);\n\n// packages/ag-charts-enterprise/src/features/crosshair/crosshairTheme.ts\n\nvar AXIS_CROSSHAIR_THEME = {\n  crosshair: {\n    enabled: true,\n    snap: true,\n    stroke: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_MUTED_LABEL_COLOUR,\n    strokeWidth: 1,\n    strokeOpacity: 1,\n    lineDash: [5, 6],\n    lineDashOffset: 0,\n    label: {\n      enabled: true\n    }\n  },\n  category: {\n    crosshair: {\n      enabled: false,\n      snap: true,\n      stroke: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_MUTED_LABEL_COLOUR,\n      strokeWidth: 1,\n      strokeOpacity: 1,\n      lineDash: [5, 6],\n      lineDashOffset: 0,\n      label: {\n        enabled: true\n      }\n    }\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/crosshair/crosshairModule.ts\nvar CrosshairModule = {\n  type: \"axis-option\",\n  optionsKey: \"crosshair\",\n  packageType: \"enterprise\",\n  chartTypes: [\"cartesian\"],\n  axisTypes: [\"category\", \"ordinal-time\", \"number\", \"log\", \"time\"],\n  instanceConstructor: Crosshair,\n  themeTemplate: AXIS_CROSSHAIR_THEME\n};\n\n// packages/ag-charts-enterprise/src/features/data-source/dataSource.ts\n\nvar { BOOLEAN: BOOLEAN10, FUNCTION: FUNCTION3, ActionOnSet: ActionOnSet3, Validate: Validate23 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar DataSource = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.enabled = false;\n    this.getData = () => Promise.resolve();\n    this.dataService = ctx.dataService;\n  }\n  updateCallback(enabled, getData) {\n    if (!this.dataService)\n      return;\n    if (enabled && getData != null) {\n      this.dataService.updateCallback(getData);\n    } else {\n      this.dataService.clearCallback();\n    }\n  }\n};\n__decorateClass([\n  ActionOnSet3({\n    newValue(enabled) {\n      this.updateCallback(enabled, this.getData);\n    }\n  }),\n  Validate23(BOOLEAN10)\n], DataSource.prototype, \"enabled\", 2);\n__decorateClass([\n  ActionOnSet3({\n    newValue(getData) {\n      this.updateCallback(this.enabled, getData);\n    }\n  }),\n  Validate23(FUNCTION3)\n], DataSource.prototype, \"getData\", 2);\n__decorateClass([\n  ActionOnSet3({\n    newValue(requestThrottle) {\n      this.dataService.requestThrottle = requestThrottle;\n    }\n  })\n], DataSource.prototype, \"requestThrottle\", 2);\n__decorateClass([\n  ActionOnSet3({\n    newValue(updateThrottle) {\n      this.dataService.dispatchThrottle = updateThrottle;\n    }\n  })\n], DataSource.prototype, \"updateThrottle\", 2);\n__decorateClass([\n  ActionOnSet3({\n    newValue(updateDuringInteraction) {\n      this.dataService.dispatchOnlyLatest = !updateDuringInteraction;\n    }\n  })\n], DataSource.prototype, \"updateDuringInteraction\", 2);\n\n// packages/ag-charts-enterprise/src/features/data-source/dataSourceModule.ts\nvar DataSourceModule = {\n  type: \"root\",\n  optionsKey: \"dataSource\",\n  packageType: \"enterprise\",\n  chartTypes: [\"cartesian\", \"hierarchy\", \"polar\", \"topology\", \"flow-proportion\"],\n  instanceConstructor: DataSource,\n  themeTemplate: {\n    dataSource: { enabled: false }\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/error-bar/errorBarModule.ts\n\n\n// packages/ag-charts-enterprise/src/features/error-bar/errorBar.ts\n\n\n// packages/ag-charts-enterprise/src/features/error-bar/errorBarNode.ts\n\nvar { nearestSquaredInContainer, partialAssign, mergeDefaults } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { BBox: BBox2 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar HierarchicalBBox = class {\n  constructor(components) {\n    this.components = components;\n    this.union = BBox2.merge(components);\n  }\n  containsPoint(x, y) {\n    if (!this.union.containsPoint(x, y)) {\n      return false;\n    }\n    for (const bbox of this.components) {\n      if (bbox.containsPoint(x, y)) {\n        return true;\n      }\n    }\n    return false;\n  }\n};\nvar ErrorBarNode = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Group {\n  constructor() {\n    super();\n    this.capLength = NaN;\n    this._datum = void 0;\n    this.whiskerPath = new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Path();\n    this.capsPath = new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Path();\n    this.bboxes = new HierarchicalBBox([]);\n    this.append([this.whiskerPath, this.capsPath]);\n  }\n  get datum() {\n    return this._datum;\n  }\n  set datum(datum) {\n    this._datum = datum;\n  }\n  calculateCapLength(capsTheme, capDefaults) {\n    const { lengthRatio = 1, length } = capsTheme;\n    const { lengthRatioMultiplier, lengthMax } = capDefaults;\n    const desiredLength = length ?? lengthRatio * lengthRatioMultiplier;\n    return Math.min(desiredLength, lengthMax);\n  }\n  getItemStylerParams(options, style, highlighted) {\n    const { datum } = this;\n    if (datum == null || options.itemStyler == null)\n      return;\n    const { xLowerKey, xUpperKey, yLowerKey, yUpperKey } = options;\n    return {\n      ...style,\n      datum: datum.datum,\n      seriesId: datum.datum.seriesId,\n      xKey: datum.xKey,\n      yKey: datum.yKey,\n      xLowerKey,\n      xUpperKey,\n      yLowerKey,\n      yUpperKey,\n      highlighted\n    };\n  }\n  formatStyles(style, options, highlighted) {\n    let { cap: capsStyle, ...whiskerStyle } = style;\n    const params = this.getItemStylerParams(options, style, highlighted);\n    if (params != null && options.itemStyler != null) {\n      const result = options.itemStyler(params);\n      whiskerStyle = mergeDefaults(result, whiskerStyle);\n      capsStyle = mergeDefaults(result?.cap, result, capsStyle);\n    }\n    return { whiskerStyle, capsStyle };\n  }\n  applyStyling(target, source) {\n    partialAssign(\n      [\"visible\", \"stroke\", \"strokeWidth\", \"strokeOpacity\", \"lineDash\", \"lineDashOffset\"],\n      target,\n      source\n    );\n  }\n  update(style, formatters, highlighted) {\n    if (this.datum === void 0) {\n      return;\n    }\n    const { whiskerStyle, capsStyle } = this.formatStyles(style, formatters, highlighted);\n    const { xBar, yBar, capDefaults } = this.datum;\n    const whisker = this.whiskerPath;\n    this.applyStyling(whisker, whiskerStyle);\n    whisker.path.clear();\n    if (yBar !== void 0) {\n      whisker.path.moveTo(yBar.lowerPoint.x, yBar.lowerPoint.y);\n      whisker.path.lineTo(yBar.upperPoint.x, yBar.upperPoint.y);\n    }\n    if (xBar !== void 0) {\n      whisker.path.moveTo(xBar.lowerPoint.x, xBar.lowerPoint.y);\n      whisker.path.lineTo(xBar.upperPoint.x, xBar.upperPoint.y);\n    }\n    whisker.path.closePath();\n    whisker.markDirtyTransform();\n    this.capLength = this.calculateCapLength(capsStyle ?? {}, capDefaults);\n    const capOffset = this.capLength / 2;\n    const caps = this.capsPath;\n    this.applyStyling(caps, capsStyle);\n    caps.path.clear();\n    if (yBar !== void 0) {\n      caps.path.moveTo(yBar.lowerPoint.x - capOffset, yBar.lowerPoint.y);\n      caps.path.lineTo(yBar.lowerPoint.x + capOffset, yBar.lowerPoint.y);\n      caps.path.moveTo(yBar.upperPoint.x - capOffset, yBar.upperPoint.y);\n      caps.path.lineTo(yBar.upperPoint.x + capOffset, yBar.upperPoint.y);\n    }\n    if (xBar !== void 0) {\n      caps.path.moveTo(xBar.lowerPoint.x, xBar.lowerPoint.y - capOffset);\n      caps.path.lineTo(xBar.lowerPoint.x, xBar.lowerPoint.y + capOffset);\n      caps.path.moveTo(xBar.upperPoint.x, xBar.upperPoint.y - capOffset);\n      caps.path.lineTo(xBar.upperPoint.x, xBar.upperPoint.y + capOffset);\n    }\n    caps.path.closePath();\n    caps.markDirtyTransform();\n  }\n  updateBBoxes() {\n    const { capLength, whiskerPath: whisker, capsPath: caps } = this;\n    const { yBar, xBar } = this.datum ?? {};\n    const capOffset = capLength / 2;\n    const components = [];\n    if (yBar !== void 0) {\n      const whiskerHeight = yBar.lowerPoint.y - yBar.upperPoint.y;\n      components.push(\n        new BBox2(yBar.lowerPoint.x, yBar.upperPoint.y, whisker.strokeWidth, whiskerHeight),\n        new BBox2(yBar.lowerPoint.x - capOffset, yBar.lowerPoint.y, capLength, caps.strokeWidth),\n        new BBox2(yBar.upperPoint.x - capOffset, yBar.upperPoint.y, capLength, caps.strokeWidth)\n      );\n    }\n    if (xBar !== void 0) {\n      const whiskerWidth = xBar.upperPoint.x - xBar.lowerPoint.x;\n      components.push(\n        new BBox2(xBar.lowerPoint.x, xBar.upperPoint.y, whiskerWidth, whisker.strokeWidth),\n        new BBox2(xBar.lowerPoint.x, xBar.lowerPoint.y - capOffset, caps.strokeWidth, capLength),\n        new BBox2(xBar.upperPoint.x, xBar.upperPoint.y - capOffset, caps.strokeWidth, capLength)\n      );\n    }\n    this.bboxes.components = components;\n    this.bboxes.union = BBox2.merge(components);\n  }\n  containsPoint(x, y) {\n    return this.bboxes.containsPoint(x, y);\n  }\n  pickNode(x, y) {\n    return this.containsPoint(x, y) ? this : void 0;\n  }\n  nearestSquared(x, y, maxDistance) {\n    const { bboxes } = this;\n    if (bboxes.union.distanceSquared(x, y) > maxDistance) {\n      return { nearest: void 0, distanceSquared: Infinity };\n    }\n    const { distanceSquared } = BBox2.nearestBox(x, y, bboxes.components);\n    return { nearest: this, distanceSquared };\n  }\n};\nvar ErrorBarGroup = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Group {\n  get children() {\n    return super.children;\n  }\n  nearestSquared(x, y) {\n    const { nearest, distanceSquared } = nearestSquaredInContainer(x, y, this);\n    if (nearest !== void 0 && !isNaN(distanceSquared)) {\n      return { datum: nearest.datum, distanceSquared };\n    }\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/error-bar/errorBarProperties.ts\n\nvar {\n  BaseProperties: BaseProperties8,\n  Validate: Validate24,\n  BOOLEAN: BOOLEAN11,\n  COLOR_STRING: COLOR_STRING4,\n  FUNCTION: FUNCTION4,\n  LINE_DASH: LINE_DASH4,\n  NUMBER: NUMBER8,\n  OBJECT: OBJECT7,\n  POSITIVE_NUMBER: POSITIVE_NUMBER7,\n  RATIO: RATIO7,\n  STRING: STRING8\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar ErrorBarCap = class extends BaseProperties8 {\n};\n__decorateClass([\n  Validate24(BOOLEAN11, { optional: true })\n], ErrorBarCap.prototype, \"visible\", 2);\n__decorateClass([\n  Validate24(COLOR_STRING4, { optional: true })\n], ErrorBarCap.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate24(POSITIVE_NUMBER7, { optional: true })\n], ErrorBarCap.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate24(RATIO7, { optional: true })\n], ErrorBarCap.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate24(LINE_DASH4, { optional: true })\n], ErrorBarCap.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate24(POSITIVE_NUMBER7, { optional: true })\n], ErrorBarCap.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate24(NUMBER8, { optional: true })\n], ErrorBarCap.prototype, \"length\", 2);\n__decorateClass([\n  Validate24(RATIO7, { optional: true })\n], ErrorBarCap.prototype, \"lengthRatio\", 2);\nvar ErrorBarProperties = class extends BaseProperties8 {\n  constructor() {\n    super(...arguments);\n    this.visible = true;\n    this.stroke = \"black\";\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.cap = new ErrorBarCap();\n  }\n};\n__decorateClass([\n  Validate24(STRING8, { optional: true })\n], ErrorBarProperties.prototype, \"yLowerKey\", 2);\n__decorateClass([\n  Validate24(STRING8, { optional: true })\n], ErrorBarProperties.prototype, \"yLowerName\", 2);\n__decorateClass([\n  Validate24(STRING8, { optional: true })\n], ErrorBarProperties.prototype, \"yUpperKey\", 2);\n__decorateClass([\n  Validate24(STRING8, { optional: true })\n], ErrorBarProperties.prototype, \"yUpperName\", 2);\n__decorateClass([\n  Validate24(STRING8, { optional: true })\n], ErrorBarProperties.prototype, \"xLowerKey\", 2);\n__decorateClass([\n  Validate24(STRING8, { optional: true })\n], ErrorBarProperties.prototype, \"xLowerName\", 2);\n__decorateClass([\n  Validate24(STRING8, { optional: true })\n], ErrorBarProperties.prototype, \"xUpperKey\", 2);\n__decorateClass([\n  Validate24(STRING8, { optional: true })\n], ErrorBarProperties.prototype, \"xUpperName\", 2);\n__decorateClass([\n  Validate24(BOOLEAN11, { optional: true })\n], ErrorBarProperties.prototype, \"visible\", 2);\n__decorateClass([\n  Validate24(COLOR_STRING4, { optional: true })\n], ErrorBarProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate24(POSITIVE_NUMBER7, { optional: true })\n], ErrorBarProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate24(RATIO7, { optional: true })\n], ErrorBarProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate24(LINE_DASH4, { optional: true })\n], ErrorBarProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate24(POSITIVE_NUMBER7, { optional: true })\n], ErrorBarProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate24(FUNCTION4, { optional: true })\n], ErrorBarProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate24(OBJECT7)\n], ErrorBarProperties.prototype, \"cap\", 2);\n\n// packages/ag-charts-enterprise/src/features/error-bar/errorBar.ts\nvar {\n  fixNumericExtent,\n  groupAccumulativeValueProperty,\n  isDefined,\n  mergeDefaults: mergeDefaults2,\n  valueProperty,\n  ChartAxisDirection: ChartAxisDirection11\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nfunction toErrorBoundCartesianSeries(ctx) {\n  for (const supportedType of ag_charts_community__WEBPACK_IMPORTED_MODULE_0__.AgErrorBarSupportedSeriesTypes) {\n    if (supportedType === ctx.series.type) {\n      return ctx.series;\n    }\n  }\n  throw new Error(\n    `AG Charts - unsupported series type '${ctx.series.type}', error bars supported series types: ${ag_charts_community__WEBPACK_IMPORTED_MODULE_0__.AgErrorBarSupportedSeriesTypes.join(\", \")}`\n  );\n}\nvar ErrorBars = class _ErrorBars extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.properties = new ErrorBarProperties();\n    const series = toErrorBoundCartesianSeries(ctx);\n    const { annotationGroup, annotationSelections } = series;\n    this.cartesianSeries = series;\n    this.groupNode = new ErrorBarGroup({\n      name: `${annotationGroup.id}-errorBars`,\n      zIndex: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.Layers.SERIES_LAYER_ZINDEX,\n      zIndexSubOrder: series.getGroupZIndexSubOrder(\"annotation\")\n    });\n    annotationGroup.appendChild(this.groupNode);\n    this.selection = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Selection.select(this.groupNode, () => this.errorBarFactory());\n    annotationSelections.add(this.selection);\n    this.destroyFns.push(\n      series.addListener(\"data-processed\", (e) => this.onDataProcessed(e)),\n      series.addListener(\"data-update\", (e) => this.onDataUpdate(e)),\n      series.addListener(\"visibility-changed\", (e) => this.onToggleSeriesItem(e)),\n      ctx.highlightManager.addListener(\"highlight-change\", (event) => this.onHighlightChange(event)),\n      () => annotationGroup.removeChild(this.groupNode),\n      () => annotationSelections.delete(this.selection)\n    );\n  }\n  hasErrorBars() {\n    const { xLowerKey, xUpperKey, yLowerKey, yUpperKey } = this.properties;\n    return isDefined(xLowerKey) && isDefined(xUpperKey) || isDefined(yLowerKey) && isDefined(yUpperKey);\n  }\n  isStacked() {\n    const stackCount = this.cartesianSeries.seriesGrouping?.stackCount;\n    return stackCount == null ? false : stackCount > 0;\n  }\n  getUnstackPropertyDefinition(opts) {\n    const props = [];\n    const { xLowerKey, xUpperKey, yLowerKey, yUpperKey, xErrorsID, yErrorsID } = this.getMaybeFlippedKeys();\n    const { xScaleType, yScaleType } = opts;\n    if (yLowerKey != null && yUpperKey != null) {\n      props.push(\n        valueProperty(yLowerKey, yScaleType, { id: `${yErrorsID}-lower` }),\n        valueProperty(yUpperKey, yScaleType, { id: `${yErrorsID}-upper` })\n      );\n    }\n    if (xLowerKey != null && xUpperKey != null) {\n      props.push(\n        valueProperty(xLowerKey, xScaleType, { id: `${xErrorsID}-lower` }),\n        valueProperty(xUpperKey, xScaleType, { id: `${xErrorsID}-upper` })\n      );\n    }\n    return props;\n  }\n  getStackPropertyDefinition(opts) {\n    const props = [];\n    const { cartesianSeries } = this;\n    const { xLowerKey, xUpperKey, yLowerKey, yUpperKey, xErrorsID, yErrorsID } = this.getMaybeFlippedKeys();\n    const { xScaleType, yScaleType } = opts;\n    const groupIndex = cartesianSeries.seriesGrouping?.groupIndex ?? cartesianSeries.id;\n    const groupOpts = {\n      invalidValue: null,\n      missingValue: 0,\n      separateNegative: true,\n      ...cartesianSeries.visible ? {} : { forceValue: 0 }\n    };\n    const makeErrorProperty = (key, id, type, scaleType) => {\n      return groupAccumulativeValueProperty(\n        key,\n        \"normal\",\n        \"current\",\n        {\n          id: `${id}-${type}`,\n          groupId: `errorGroup-${groupIndex}-${type}`,\n          ...groupOpts\n        },\n        scaleType\n      );\n    };\n    const pushErrorProperties = (lowerKey, upperKey, id, scaleType) => {\n      props.push(\n        ...makeErrorProperty(lowerKey, id, \"lower\", scaleType),\n        ...makeErrorProperty(upperKey, id, \"upper\", scaleType)\n      );\n    };\n    if (yLowerKey != null && yUpperKey != null) {\n      pushErrorProperties(yLowerKey, yUpperKey, yErrorsID, yScaleType);\n    }\n    if (xLowerKey != null && xUpperKey != null) {\n      pushErrorProperties(xLowerKey, xUpperKey, xErrorsID, xScaleType);\n    }\n    return props;\n  }\n  getPropertyDefinitions(opts) {\n    if (this.isStacked()) {\n      return this.getStackPropertyDefinition(opts);\n    } else {\n      return this.getUnstackPropertyDefinition(opts);\n    }\n  }\n  onDataProcessed(event) {\n    this.dataModel = event.dataModel;\n    this.processedData = event.processedData;\n  }\n  getDomain(direction) {\n    const { xLowerKey, xUpperKey, xErrorsID, yLowerKey, yUpperKey, yErrorsID } = this.getMaybeFlippedKeys();\n    const hasAxisErrors = direction === ChartAxisDirection11.X ? isDefined(xLowerKey) && isDefined(xUpperKey) : isDefined(yLowerKey) && isDefined(yUpperKey);\n    if (hasAxisErrors) {\n      const { dataModel, processedData, cartesianSeries: series } = this;\n      if (dataModel != null && processedData != null) {\n        const axis = series.axes[direction];\n        const id = { x: xErrorsID, y: yErrorsID }[direction];\n        const lowerDomain = dataModel.getDomain(series, `${id}-lower`, \"value\", processedData);\n        const upperDomain = dataModel.getDomain(series, `${id}-upper`, \"value\", processedData);\n        const domain = [Math.min(...lowerDomain, ...upperDomain), Math.max(...lowerDomain, ...upperDomain)];\n        return fixNumericExtent(domain, axis);\n      }\n    }\n    return [];\n  }\n  onDataUpdate(event) {\n    this.dataModel = event.dataModel;\n    this.processedData = event.processedData;\n    if (isDefined(event.dataModel) && isDefined(event.processedData)) {\n      this.createNodeData();\n      this.update();\n    }\n  }\n  getNodeData() {\n    return this.cartesianSeries.contextNodeData?.nodeData;\n  }\n  createNodeData() {\n    const nodeData = this.getNodeData();\n    const xScale = this.cartesianSeries.axes[ChartAxisDirection11.X]?.scale;\n    const yScale = this.cartesianSeries.axes[ChartAxisDirection11.Y]?.scale;\n    if (!this.hasErrorBars() || !xScale || !yScale || !nodeData) {\n      return;\n    }\n    for (let i = 0; i < nodeData.length; i++) {\n      const { midPoint, xLower, xUpper, yLower, yUpper } = this.getDatum(nodeData, i);\n      if (midPoint != null) {\n        let xBar, yBar;\n        if (isDefined(xLower) && isDefined(xUpper)) {\n          xBar = {\n            lowerPoint: { x: this.convert(xScale, xLower), y: midPoint.y },\n            upperPoint: { x: this.convert(xScale, xUpper), y: midPoint.y }\n          };\n        }\n        if (isDefined(yLower) && isDefined(yUpper)) {\n          yBar = {\n            lowerPoint: { x: midPoint.x, y: this.convert(yScale, yLower) },\n            upperPoint: { x: midPoint.x, y: this.convert(yScale, yUpper) }\n          };\n        }\n        nodeData[i].xBar = xBar;\n        nodeData[i].yBar = yBar;\n      }\n    }\n  }\n  getMaybeFlippedKeys() {\n    let { xLowerKey, xUpperKey, yLowerKey, yUpperKey } = this.properties;\n    let [xErrorsID, yErrorsID] = [\"xValue-errors\", \"yValue-errors\"];\n    if (this.cartesianSeries.shouldFlipXY()) {\n      [xLowerKey, yLowerKey] = [yLowerKey, xLowerKey];\n      [xUpperKey, yUpperKey] = [yUpperKey, xUpperKey];\n      [xErrorsID, yErrorsID] = [yErrorsID, xErrorsID];\n    }\n    return { xLowerKey, xUpperKey, xErrorsID, yLowerKey, yUpperKey, yErrorsID };\n  }\n  static getDatumKey(datum, key, offset) {\n    if (key == null) {\n      return;\n    }\n    const value = datum.datum[key];\n    if (value == null) {\n      return;\n    }\n    if (typeof value !== \"number\") {\n      ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util.Logger.warnOnce(`Found [${key}] error value of type ${typeof value}. Expected number type`);\n      return;\n    }\n    return value + offset;\n  }\n  getDatum(nodeData, datumIndex) {\n    const { xLowerKey, xUpperKey, yLowerKey, yUpperKey } = this.getMaybeFlippedKeys();\n    const datum = nodeData[datumIndex];\n    const d = datum.cumulativeValue == null || !this.isStacked() ? 0 : datum.cumulativeValue - datum.yValue;\n    const [xOffset, yOffset] = this.cartesianSeries.shouldFlipXY() ? [d, 0] : [0, d];\n    return {\n      midPoint: datum.midPoint,\n      xLower: _ErrorBars.getDatumKey(datum, xLowerKey, xOffset),\n      xUpper: _ErrorBars.getDatumKey(datum, xUpperKey, xOffset),\n      yLower: _ErrorBars.getDatumKey(datum, yLowerKey, yOffset),\n      yUpper: _ErrorBars.getDatumKey(datum, yUpperKey, yOffset)\n    };\n  }\n  convert(scale, value) {\n    const offset = (scale.bandwidth ?? 0) / 2;\n    return scale.convert(value) + offset;\n  }\n  update() {\n    const nodeData = this.getNodeData();\n    if (nodeData != null) {\n      this.selection.update(nodeData);\n      this.selection.each((node, datum, i) => this.updateNode(node, datum, i));\n    }\n  }\n  updateNode(node, datum, _index) {\n    node.datum = datum;\n    node.update(this.getDefaultStyle(), this.properties, false);\n    node.updateBBoxes();\n  }\n  pickNodeExact(point) {\n    const { x, y } = this.groupNode.transformPoint(point.x, point.y);\n    const node = this.groupNode.pickNode(x, y);\n    if (node != null) {\n      return { datum: node.datum, distanceSquared: 0 };\n    }\n  }\n  pickNodeNearest(point) {\n    return this.groupNode.nearestSquared(point.x, point.y);\n  }\n  pickNodeMainAxisFirst(point) {\n    return this.groupNode.nearestSquared(point.x, point.y);\n  }\n  getTooltipParams() {\n    const {\n      xLowerKey,\n      xUpperKey,\n      yLowerKey,\n      yUpperKey,\n      xLowerName = xLowerKey,\n      xUpperName = xUpperKey,\n      yLowerName = yLowerKey,\n      yUpperName = yUpperKey\n    } = this.properties;\n    return { xLowerKey, xLowerName, xUpperKey, xUpperName, yLowerKey, yLowerName, yUpperKey, yUpperName };\n  }\n  onToggleSeriesItem(event) {\n    this.groupNode.visible = event.enabled;\n  }\n  makeStyle(baseStyle) {\n    return {\n      visible: baseStyle.visible,\n      lineDash: baseStyle.lineDash,\n      lineDashOffset: baseStyle.lineDashOffset,\n      stroke: baseStyle.stroke,\n      strokeWidth: baseStyle.strokeWidth,\n      strokeOpacity: baseStyle.strokeOpacity,\n      cap: mergeDefaults2(this.properties.cap, baseStyle)\n    };\n  }\n  getDefaultStyle() {\n    return this.makeStyle(this.getWhiskerProperties());\n  }\n  getHighlightStyle() {\n    return this.makeStyle(this.getWhiskerProperties());\n  }\n  restyleHighlightChange(highlightChange, style, highlighted) {\n    const nodeData = this.getNodeData();\n    if (nodeData == null)\n      return;\n    for (let i = 0; i < nodeData.length; i++) {\n      if (highlightChange === nodeData[i]) {\n        this.selection.nodes()[i].update(style, this.properties, highlighted);\n        break;\n      }\n    }\n  }\n  onHighlightChange(event) {\n    const { previousHighlight, currentHighlight } = event;\n    if (currentHighlight?.series === this.cartesianSeries) {\n      this.restyleHighlightChange(currentHighlight, this.getHighlightStyle(), true);\n    }\n    if (previousHighlight?.series === this.cartesianSeries) {\n      this.restyleHighlightChange(previousHighlight, this.getDefaultStyle(), false);\n    }\n    this.groupNode.opacity = this.cartesianSeries.getOpacity();\n  }\n  errorBarFactory() {\n    return new ErrorBarNode();\n  }\n  getWhiskerProperties() {\n    const { stroke, strokeWidth, visible, strokeOpacity, lineDash, lineDashOffset } = this.properties;\n    return { stroke, strokeWidth, visible, strokeOpacity, lineDash, lineDashOffset };\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/error-bar/errorBarTheme.ts\n\nvar ERROR_BARS_THEME = {\n  series: {\n    errorBar: {\n      visible: true,\n      stroke: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_LABEL_COLOUR,\n      strokeWidth: 1,\n      strokeOpacity: 1,\n      cap: {\n        length: void 0,\n        lengthRatio: void 0\n      }\n    }\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/error-bar/errorBarModule.ts\nvar ErrorBarsModule = {\n  type: \"series-option\",\n  identifier: \"error-bars\",\n  optionsKey: \"errorBar\",\n  packageType: \"enterprise\",\n  chartTypes: [\"cartesian\"],\n  seriesTypes: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__.AgErrorBarSupportedSeriesTypes,\n  instanceConstructor: ErrorBars,\n  themeTemplate: ERROR_BARS_THEME\n};\n\n// packages/ag-charts-enterprise/src/features/navigator/navigatorModule.ts\n\n\n// packages/ag-charts-enterprise/src/features/navigator/navigator.ts\n\n\n// packages/ag-charts-enterprise/src/features/navigator/miniChart.ts\n\nvar { Validate: Validate25, BOOLEAN: BOOLEAN12, POSITIVE_NUMBER: POSITIVE_NUMBER8, Layers: Layers4, ActionOnSet: ActionOnSet4, CategoryAxis, GroupedCategoryAxis } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { Padding, Logger: Logger2 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar { Text: Text4, Group: Group4, BBox: BBox3 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar MiniChartPadding = class {\n  constructor() {\n    this.top = 0;\n    this.bottom = 0;\n  }\n};\n__decorateClass([\n  Validate25(POSITIVE_NUMBER8)\n], MiniChartPadding.prototype, \"top\", 2);\n__decorateClass([\n  Validate25(POSITIVE_NUMBER8)\n], MiniChartPadding.prototype, \"bottom\", 2);\nvar MiniChart = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.enabled = false;\n    this.padding = new MiniChartPadding();\n    this.root = new Group4({ name: \"root\" });\n    this.seriesRoot = this.root.appendChild(\n      new Group4({ name: \"Series-root\", layer: true, zIndex: Layers4.SERIES_LAYER_ZINDEX })\n    );\n    this.axisGridGroup = this.root.appendChild(\n      new Group4({ name: \"Axes-Grids\", layer: true, zIndex: Layers4.AXIS_GRID_ZINDEX })\n    );\n    this.axisGroup = this.root.appendChild(\n      new Group4({ name: \"Axes-Grids\", layer: true, zIndex: Layers4.AXIS_GRID_ZINDEX })\n    );\n    this.data = [];\n    this._destroyed = false;\n    this.miniChartAnimationPhase = \"initial\";\n    this.axes = [];\n    this.series = [];\n  }\n  destroy() {\n    if (this._destroyed) {\n      return;\n    }\n    this.destroySeries(this.series);\n    this.axes.forEach((a) => a.destroy());\n    this.axes = [];\n    this._destroyed = true;\n  }\n  onSeriesChange(newValue, oldValue) {\n    const seriesToDestroy = oldValue?.filter((series) => !newValue.includes(series)) ?? [];\n    this.destroySeries(seriesToDestroy);\n    for (const series of newValue) {\n      if (oldValue?.includes(series))\n        continue;\n      if (series.rootGroup.parent == null) {\n        this.seriesRoot.appendChild(series.rootGroup);\n      }\n      const chart = this;\n      series.chart = {\n        get mode() {\n          return \"standalone\";\n        },\n        get isMiniChart() {\n          return true;\n        },\n        get seriesRect() {\n          return chart.seriesRect;\n        },\n        placeLabels() {\n          return /* @__PURE__ */ new Map();\n        }\n      };\n      series.resetAnimation(this.miniChartAnimationPhase === \"initial\" ? \"initial\" : \"disabled\");\n    }\n  }\n  destroySeries(allSeries) {\n    allSeries?.forEach((series) => {\n      series.destroy();\n      if (series.rootGroup != null) {\n        this.seriesRoot.removeChild(series.rootGroup);\n      }\n      series.chart = void 0;\n    });\n  }\n  assignSeriesToAxes() {\n    this.axes.forEach((axis) => {\n      axis.boundSeries = this.series.filter((s) => {\n        const seriesAxis = s.axes[axis.direction];\n        return seriesAxis === axis;\n      });\n    });\n  }\n  assignAxesToSeries() {\n    const directionToAxesMap = {};\n    this.axes.forEach((axis) => {\n      const direction = axis.direction;\n      const directionAxes = directionToAxesMap[direction] ?? (directionToAxesMap[direction] = []);\n      directionAxes.push(axis);\n    });\n    this.series.forEach((series) => {\n      series.directions.forEach((direction) => {\n        const directionAxes = directionToAxesMap[direction];\n        if (!directionAxes) {\n          Logger2.warnOnce(\n            `no available axis for direction [${direction}]; check series and axes configuration.`\n          );\n          return;\n        }\n        const seriesKeys = series.getKeys(direction);\n        const newAxis = this.findMatchingAxis(directionAxes, seriesKeys);\n        if (!newAxis) {\n          Logger2.warnOnce(\n            `no matching axis for direction [${direction}] and keys [${seriesKeys}]; check series and axes configuration.`\n          );\n          return;\n        }\n        series.axes[direction] = newAxis;\n      });\n    });\n  }\n  findMatchingAxis(directionAxes, directionKeys) {\n    for (const axis of directionAxes) {\n      if (!axis.keys.length) {\n        return axis;\n      }\n      if (!directionKeys) {\n        continue;\n      }\n      for (const directionKey of directionKeys) {\n        if (axis.keys.includes(directionKey)) {\n          return axis;\n        }\n      }\n    }\n  }\n  async updateData(opts) {\n    this.series.forEach((s) => s.setChartData(opts.data));\n    if (this.miniChartAnimationPhase === \"initial\") {\n      this.ctx.animationManager.onBatchStop(() => {\n        this.miniChartAnimationPhase = \"ready\";\n        this.series.forEach((s) => s.resetAnimation(\"disabled\"));\n      });\n    }\n  }\n  async processData(opts) {\n    if (this.series.some((s) => s.canHaveAxes)) {\n      this.assignAxesToSeries();\n      this.assignSeriesToAxes();\n    }\n    const seriesPromises = this.series.map((s) => s.processData(opts.dataController));\n    await Promise.all(seriesPromises);\n  }\n  computeAxisPadding() {\n    const padding = new Padding();\n    if (!this.enabled) {\n      return padding;\n    }\n    this.axes.forEach((axis) => {\n      const { position, thickness = 0, line, label } = axis;\n      if (position == null)\n        return;\n      let size;\n      if (thickness > 0) {\n        size = thickness;\n      } else {\n        size = (line.enabled ? line.width : 0) + (label.enabled ? (label.fontSize ?? 0) * Text4.defaultLineHeightRatio + label.padding : 0);\n      }\n      padding[position] = Math.ceil(size);\n    });\n    return padding;\n  }\n  async layout(width, height) {\n    const { padding } = this;\n    const animated = this.seriesRect != null;\n    const seriesRect = new BBox3(0, 0, width, height - (padding.top + padding.bottom));\n    this.seriesRect = seriesRect;\n    this.seriesRoot.translationY = padding.top;\n    this.seriesRoot.setClipRectInGroupCoordinateSpace(\n      this.seriesRoot.inverseTransformBBox(new BBox3(0, -padding.top, width, height))\n    );\n    const axisLeftRightRange = (axis) => {\n      if (axis instanceof CategoryAxis || axis instanceof GroupedCategoryAxis) {\n        return [0, seriesRect.height];\n      }\n      return [seriesRect.height, 0];\n    };\n    this.axes.forEach((axis) => {\n      const { position = \"left\" } = axis;\n      switch (position) {\n        case \"top\":\n        case \"bottom\":\n          axis.range = [0, seriesRect.width];\n          axis.gridLength = seriesRect.height;\n          break;\n        case \"right\":\n        case \"left\":\n          axis.range = axisLeftRightRange(axis);\n          axis.gridLength = seriesRect.width;\n          break;\n      }\n      switch (position) {\n        case \"top\":\n        case \"left\":\n          axis.translation.x = 0;\n          axis.translation.y = 0;\n          break;\n        case \"bottom\":\n          axis.translation.x = 0;\n          axis.translation.y = height;\n          break;\n        case \"right\":\n          axis.translation.x = width;\n          axis.translation.y = 0;\n          break;\n      }\n      axis.gridPadding = 0;\n      axis.calculateLayout();\n      axis.updatePosition();\n      axis.update(void 0, animated);\n    });\n    await Promise.all(this.series.map((series) => series.update({ seriesRect })));\n  }\n};\n__decorateClass([\n  Validate25(BOOLEAN12)\n], MiniChart.prototype, \"enabled\", 2);\n__decorateClass([\n  ActionOnSet4({\n    changeValue(newValue, oldValue = []) {\n      for (const axis of oldValue) {\n        if (newValue.includes(axis))\n          continue;\n        axis.detachAxis(this.axisGroup, this.axisGridGroup);\n        axis.destroy();\n      }\n      for (const axis of newValue) {\n        if (oldValue?.includes(axis))\n          continue;\n        axis.attachAxis(this.axisGroup, this.axisGridGroup);\n      }\n    }\n  })\n], MiniChart.prototype, \"axes\", 2);\n__decorateClass([\n  ActionOnSet4({\n    changeValue(newValue, oldValue) {\n      this.onSeriesChange(newValue, oldValue);\n    }\n  })\n], MiniChart.prototype, \"series\", 2);\n\n// packages/ag-charts-enterprise/src/features/navigator/navigator.ts\nvar { ObserveChanges: ObserveChanges3 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar Navigator = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.Navigator {\n  constructor(ctx) {\n    super(ctx);\n    this.miniChart = new MiniChart(ctx);\n  }\n  async updateData(opts) {\n    await this.miniChart.updateData(opts);\n  }\n  async processData(opts) {\n    await this.miniChart.processData(opts);\n  }\n  async performLayout(opts) {\n    const { shrinkRect } = await super.performLayout(opts);\n    if (this.enabled) {\n      const { top, bottom } = this.miniChart.computeAxisPadding();\n      shrinkRect.shrink(top + bottom, \"bottom\");\n      this.y -= bottom;\n    }\n    return { ...opts, shrinkRect };\n  }\n  async performCartesianLayout(opts) {\n    await super.performCartesianLayout(opts);\n    await this.miniChart.layout(this.width, this.height);\n  }\n};\n__decorateClass([\n  ObserveChanges3((target, value, oldValue) => {\n    target.updateBackground(oldValue?.root, value?.root);\n  })\n], Navigator.prototype, \"miniChart\", 2);\n\n// packages/ag-charts-enterprise/src/features/navigator/navigatorModule.ts\nvar NavigatorModule = {\n  type: \"root\",\n  optionsKey: \"navigator\",\n  packageType: \"enterprise\",\n  chartTypes: [\"cartesian\"],\n  instanceConstructor: Navigator,\n  themeTemplate: {\n    ...ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.NavigatorModule.themeTemplate,\n    navigator: {\n      ...ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.NavigatorModule.themeTemplate?.navigator,\n      miniChart: {\n        enabled: false,\n        label: {\n          color: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_LABEL_COLOUR,\n          fontStyle: void 0,\n          fontWeight: void 0,\n          fontSize: 10,\n          fontFamily: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_FONT_FAMILY,\n          formatter: void 0,\n          padding: 0\n        },\n        padding: {\n          top: 0,\n          bottom: 0\n        }\n      }\n    }\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/status-bar/statusBarModule.ts\n\n\n// packages/ag-charts-enterprise/src/features/status-bar/statusBar.ts\n\nvar { Validate: Validate26, OBJECT: OBJECT8, BOOLEAN: BOOLEAN13, STRING: STRING9, valueProperty: valueProperty2 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { Label: Label2, Text: Text5, Group: Group5 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar StatusBarLabel = class extends Label2 {\n};\nvar StatusBar = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.enabled = false;\n    this.openKey = void 0;\n    this.highKey = void 0;\n    this.lowKey = void 0;\n    this.closeKey = void 0;\n    this.volumeKey = void 0;\n    this.title = new StatusBarLabel();\n    this.positive = new StatusBarLabel();\n    this.negative = new StatusBarLabel();\n    this.layoutStyle = \"block\";\n    this.id = \"status-bar\";\n    this.data = void 0;\n    this.labelGroup = new Group5({ name: \"StatusBar\" });\n    this.labels = [\n      {\n        label: \"O\",\n        title: this.labelGroup.appendChild(new Text5()),\n        value: this.labelGroup.appendChild(new Text5()),\n        id: \"openValue\",\n        key: \"openKey\",\n        domain: void 0,\n        formatter: new Intl.NumberFormat(\"en-US\", {\n          minimumFractionDigits: 2,\n          maximumFractionDigits: 2\n        })\n      },\n      {\n        label: \"H\",\n        title: this.labelGroup.appendChild(new Text5()),\n        value: this.labelGroup.appendChild(new Text5()),\n        id: \"highValue\",\n        key: \"highKey\",\n        domain: void 0,\n        formatter: new Intl.NumberFormat(\"en-US\", {\n          minimumFractionDigits: 2,\n          maximumFractionDigits: 2\n        })\n      },\n      {\n        label: \"L\",\n        title: this.labelGroup.appendChild(new Text5()),\n        value: this.labelGroup.appendChild(new Text5()),\n        id: \"lowValue\",\n        key: \"lowKey\",\n        domain: void 0,\n        formatter: new Intl.NumberFormat(\"en-US\", {\n          minimumFractionDigits: 2,\n          maximumFractionDigits: 2\n        })\n      },\n      {\n        label: \"C\",\n        title: this.labelGroup.appendChild(new Text5()),\n        value: this.labelGroup.appendChild(new Text5()),\n        id: \"closeValue\",\n        key: \"closeKey\",\n        domain: void 0,\n        formatter: new Intl.NumberFormat(\"en-US\", {\n          minimumFractionDigits: 2,\n          maximumFractionDigits: 2\n        })\n      },\n      {\n        label: \"Vol\",\n        title: this.labelGroup.appendChild(new Text5()),\n        value: this.labelGroup.appendChild(new Text5()),\n        id: \"volumeValue\",\n        key: \"volumeKey\",\n        domain: void 0,\n        formatter: new Intl.NumberFormat(\"en-US\", {\n          notation: \"compact\",\n          minimumFractionDigits: 2,\n          maximumFractionDigits: 2\n        })\n      }\n    ];\n    this.highlightManager = ctx.highlightManager;\n    this.labelGroup.visible = false;\n    this.destroyFns.push(\n      ctx.scene.attachNode(this.labelGroup, \"titles\"),\n      ctx.layoutService.addListener(\"before-series\", (e) => this.startPerformLayout(e)),\n      ctx.highlightManager.addListener(\"highlight-change\", () => this.updateHighlight())\n    );\n  }\n  async processData(opts) {\n    if (!this.enabled)\n      return;\n    const props = [];\n    for (const label of this.labels) {\n      const { id, key } = label;\n      const datumKey = this[key];\n      if (datumKey == null) {\n        label.domain = void 0;\n      } else {\n        props.push(valueProperty2(datumKey, \"number\", { id }));\n      }\n    }\n    if (props.length === 0 || this.data == null)\n      return;\n    const { dataController } = opts;\n    const { processedData, dataModel } = await dataController.request(this.id, this.data, {\n      props\n    });\n    for (const label of this.labels) {\n      const { id, key } = label;\n      const datumKey = this[key];\n      if (datumKey != null) {\n        label.domain = dataModel.getDomain(this, id, \"value\", processedData);\n      }\n    }\n  }\n  startPerformLayout(opts) {\n    const { shrinkRect } = opts;\n    const innerSpacing = 4;\n    const outerSpacing = 12;\n    const spacingAbove = 0;\n    const spacingBelow = 8;\n    this.labelGroup.translationX = 0;\n    this.labelGroup.translationY = 0;\n    if (!this.enabled)\n      return { ...opts, shrinkRect };\n    this.labelGroup.translationY = shrinkRect.y + spacingAbove;\n    const maxFontSize = Math.max(this.title.fontSize, this.positive.fontSize, this.negative.fontSize);\n    const lineHeight = maxFontSize * Text5.defaultLineHeightRatio;\n    let left = 0;\n    let offsetTop = 0;\n    let textVAlign = \"alphabetic\";\n    if (this.layoutStyle === \"block\") {\n      shrinkRect.shrink(spacingAbove + lineHeight + spacingBelow, \"top\");\n      offsetTop = maxFontSize + (lineHeight - maxFontSize) / 2;\n    } else {\n      const { title } = opts.positions;\n      const { title: padding = 0 } = opts.padding;\n      left = (title?.x ?? 0) + (title?.width ?? 0) + (title ? outerSpacing : padding);\n      textVAlign = \"top\";\n      offsetTop = spacingAbove + padding;\n    }\n    for (const { label, title, value, domain, formatter } of this.labels) {\n      if (domain == null) {\n        title.visible = false;\n        value.visible = false;\n        continue;\n      }\n      const maxValueWidth = Math.max(\n        Text5.measureText(formatter.format(domain[0]), this.positive.getFont(), textVAlign, \"left\").width,\n        Text5.measureText(formatter.format(domain[1]), this.positive.getFont(), textVAlign, \"left\").width,\n        Text5.measureText(formatter.format(domain[0]), this.negative.getFont(), textVAlign, \"left\").width,\n        Text5.measureText(formatter.format(domain[1]), this.negative.getFont(), textVAlign, \"left\").width\n      );\n      title.visible = true;\n      value.visible = true;\n      const titleMetrics = Text5.measureText(label, this.title.getFont(), textVAlign, \"left\");\n      title.setFont(this.title);\n      title.fill = this.title.color;\n      title.text = label;\n      title.textBaseline = textVAlign;\n      title.translationY = offsetTop;\n      title.translationX = left;\n      left += titleMetrics.width + innerSpacing;\n      value.textBaseline = textVAlign;\n      value.translationY = offsetTop;\n      value.translationX = left;\n      left += maxValueWidth + outerSpacing;\n    }\n    return { ...opts, shrinkRect };\n  }\n  async performCartesianLayout(opts) {\n    this.labelGroup.translationX = opts.seriesRect.x;\n  }\n  updateHighlight() {\n    if (!this.enabled)\n      return;\n    const activeHighlight = this.highlightManager.getActiveHighlight();\n    if (activeHighlight == null) {\n      this.labelGroup.visible = false;\n      return;\n    }\n    this.labelGroup.visible = true;\n    const datum = activeHighlight.datum;\n    const label = activeHighlight.itemId === \"up\" ? this.positive : this.negative;\n    for (const { domain, value, key, formatter } of this.labels) {\n      if (domain == null)\n        continue;\n      const datumKey = this[key];\n      const datumValue = datumKey != null ? datum?.[datumKey] : void 0;\n      value.setFont(label);\n      value.fill = label.color;\n      value.text = typeof datumValue === \"number\" ? formatter.format(datumValue) : \"\";\n    }\n  }\n};\n__decorateClass([\n  Validate26(BOOLEAN13)\n], StatusBar.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate26(STRING9, { optional: true })\n], StatusBar.prototype, \"openKey\", 2);\n__decorateClass([\n  Validate26(STRING9, { optional: true })\n], StatusBar.prototype, \"highKey\", 2);\n__decorateClass([\n  Validate26(STRING9, { optional: true })\n], StatusBar.prototype, \"lowKey\", 2);\n__decorateClass([\n  Validate26(STRING9, { optional: true })\n], StatusBar.prototype, \"closeKey\", 2);\n__decorateClass([\n  Validate26(STRING9, { optional: true })\n], StatusBar.prototype, \"volumeKey\", 2);\n__decorateClass([\n  Validate26(OBJECT8)\n], StatusBar.prototype, \"title\", 2);\n__decorateClass([\n  Validate26(OBJECT8)\n], StatusBar.prototype, \"positive\", 2);\n__decorateClass([\n  Validate26(OBJECT8)\n], StatusBar.prototype, \"negative\", 2);\n__decorateClass([\n  Validate26(STRING9)\n], StatusBar.prototype, \"layoutStyle\", 2);\n\n// packages/ag-charts-enterprise/src/features/status-bar/statusBarModule.ts\nvar StatusBarModule = {\n  type: \"root\",\n  identifier: \"status-bar\",\n  optionsKey: \"statusBar\",\n  packageType: \"enterprise\",\n  chartTypes: [\"cartesian\"],\n  instanceConstructor: StatusBar,\n  themeTemplate: {\n    statusBar: {\n      enabled: false,\n      openKey: void 0,\n      highKey: void 0,\n      lowKey: void 0,\n      closeKey: void 0,\n      volumeKey: void 0,\n      layoutStyle: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_CAPTION_LAYOUT_STYLE,\n      title: {\n        color: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_LABEL_COLOUR\n      },\n      positive: {\n        color: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.PALETTE_UP_STROKE\n      },\n      negative: {\n        color: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.PALETTE_DOWN_STROKE\n      }\n    }\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/sync/chartSync.ts\n\nvar {\n  BOOLEAN: BOOLEAN14,\n  STRING: STRING10,\n  UNION: UNION5,\n  BaseProperties: BaseProperties9,\n  CartesianAxis,\n  ChartUpdateType: ChartUpdateType2,\n  arraysEqual,\n  isDate,\n  isDefined: isDefined2,\n  isFiniteNumber,\n  ObserveChanges: ObserveChanges4,\n  TooltipManager,\n  Validate: Validate27\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { Logger: Logger3 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar ChartSync = class extends BaseProperties9 {\n  constructor(moduleContext) {\n    super();\n    this.moduleContext = moduleContext;\n    this.enabled = false;\n    this.axes = \"x\";\n    this.nodeInteraction = true;\n    this.zoom = true;\n  }\n  updateChart(chart, updateType = ChartUpdateType2.UPDATE_DATA) {\n    chart.ctx.updateService.update(updateType, { skipSync: true });\n  }\n  updateSiblings(groupId) {\n    const { syncManager } = this.moduleContext;\n    const updateFn = async () => {\n      for (const chart of syncManager.getGroupSiblings(groupId)) {\n        await chart.waitForDataProcess(120);\n        this.updateChart(chart);\n      }\n    };\n    updateFn().catch((e) => {\n      Logger3.warnOnce(\"Error updating sibling chart\", e);\n    });\n  }\n  enabledZoomSync() {\n    const { syncManager, zoomManager } = this.moduleContext;\n    this.disableZoomSync = zoomManager.addListener(\"zoom-change\", () => {\n      for (const chart of syncManager.getGroupSiblings(this.groupId)) {\n        if (chart.modulesManager.getModule(\"sync\")?.zoom) {\n          chart.ctx.zoomManager.updateZoom(\"sync\", this.mergeZoom(chart));\n        }\n      }\n    });\n  }\n  enabledNodeInteractionSync() {\n    const { highlightManager, syncManager } = this.moduleContext;\n    this.disableNodeInteractionSync = highlightManager.addListener(\"highlight-change\", (event) => {\n      for (const chart of syncManager.getGroupSiblings(this.groupId)) {\n        if (!chart.modulesManager.getModule(\"sync\")?.nodeInteraction)\n          continue;\n        if (!event.currentHighlight?.datum) {\n          chart.ctx.highlightManager.updateHighlight(chart.id);\n          chart.ctx.tooltipManager.removeTooltip(chart.id);\n          continue;\n        }\n        for (const axis of chart.axes) {\n          const validDirection = this.axes === \"xy\" ? \"x\" : this.axes;\n          if (!CartesianAxis.is(axis) || axis.direction !== validDirection)\n            continue;\n          const matchingNodes = chart.series.map((series) => {\n            const seriesKeys = series.getKeys(axis.direction);\n            if (axis.keys.length && !axis.keys.some((key) => seriesKeys.includes(key)))\n              return;\n            const { nodeData } = series.contextNodeData;\n            if (!nodeData?.length)\n              return;\n            const valueKey = nodeData[0][`${axis.direction}Key`];\n            let eventValue = event.currentHighlight.datum[valueKey];\n            const valueIsDate = isDate(eventValue);\n            if (valueIsDate) {\n              eventValue = eventValue.getTime();\n            }\n            const nodeDatum = nodeData.find((datum) => {\n              const nodeValue = datum.datum[valueKey];\n              return valueIsDate ? nodeValue.getTime() === eventValue : nodeValue === eventValue;\n            });\n            return nodeDatum ? { series, nodeDatum } : null;\n          }).filter(isDefined2);\n          if (matchingNodes.length < 2 && matchingNodes[0]?.nodeDatum !== chart.ctx.highlightManager.getActiveHighlight()) {\n            const { series, nodeDatum } = matchingNodes[0] ?? {};\n            chart.ctx.highlightManager.updateHighlight(chart.id, nodeDatum);\n            if (nodeDatum) {\n              const offsetX = nodeDatum.midPoint?.x ?? nodeDatum.point?.x ?? 0;\n              const offsetY = nodeDatum.midPoint?.y ?? nodeDatum.point?.y ?? 0;\n              const tooltipMeta = TooltipManager.makeTooltipMeta(\n                { type: \"hover\", offsetX, offsetY },\n                nodeDatum\n              );\n              delete tooltipMeta.lastPointerEvent;\n              chart.ctx.tooltipManager.updateTooltip(\n                chart.id,\n                tooltipMeta,\n                series.getTooltipHtml(nodeDatum)\n              );\n            } else {\n              chart.ctx.tooltipManager.removeTooltip(chart.id);\n            }\n            this.updateChart(chart, ChartUpdateType2.SERIES_UPDATE);\n          }\n        }\n      }\n    });\n  }\n  syncAxes(stopPropagation = false) {\n    const { syncManager } = this.moduleContext;\n    const chart = syncManager.getChart();\n    const syncGroup = syncManager.getGroup(this.groupId);\n    const syncSeries = syncGroup.flatMap((c) => c.series);\n    const syncAxes = syncGroup[0].axes;\n    let hasUpdated = false;\n    chart.axes.forEach((axis) => {\n      if (!CartesianAxis.is(axis) || this.axes !== \"xy\" && this.axes !== axis.direction) {\n        axis.boundSeries = chart.series.filter((s) => s.axes[axis.direction] === axis);\n        return;\n      }\n      const { direction, min, max, nice, reverse } = axis;\n      for (const mainAxis of syncAxes) {\n        if (direction !== mainAxis.direction)\n          continue;\n        if (nice !== mainAxis.nice || reverse !== mainAxis.reverse || min !== mainAxis.min && (isFiniteNumber(min) || isFiniteNumber(mainAxis.min)) || max !== mainAxis.max && (isFiniteNumber(max) || isFiniteNumber(mainAxis.max))) {\n          Logger3.warnOnce(\n            \"To allow synchronization, ensure that all charts have matching min, max, nice, and reverse properties on the synchronized axes.\"\n          );\n          axis.boundSeries = chart.series.filter((s) => s.axes[axis.direction] === axis);\n          this.enabled = false;\n          return;\n        }\n      }\n      const boundSeries = syncSeries.filter((series) => {\n        if (series.visible) {\n          const seriesKeys = series.getKeys(axis.direction);\n          return axis.keys.length ? axis.keys.some((key) => seriesKeys.includes(key)) : true;\n        }\n      });\n      if (!arraysEqual(axis.boundSeries, boundSeries)) {\n        axis.boundSeries = boundSeries;\n        hasUpdated = true;\n      }\n    });\n    if (hasUpdated && !stopPropagation) {\n      this.updateSiblings(this.groupId);\n    }\n  }\n  mergeZoom(chart) {\n    const { zoomManager } = this.moduleContext;\n    if (this.axes === \"xy\") {\n      return zoomManager.getZoom();\n    }\n    const combinedZoom = chart.zoomManager.getZoom() ?? {};\n    combinedZoom[this.axes] = zoomManager.getZoom()?.[this.axes];\n    return combinedZoom;\n  }\n  onEnabledChange() {\n    const { syncManager } = this.moduleContext;\n    if (this.enabled) {\n      syncManager.subscribe(this.groupId);\n    } else {\n      syncManager.unsubscribe(this.groupId);\n    }\n    this.updateSiblings(this.groupId);\n    this.onNodeInteractionChange();\n    this.onZoomChange();\n  }\n  onGroupIdChange(newValue, oldValue) {\n    if (!this.enabled || newValue === oldValue)\n      return;\n    const { syncManager } = this.moduleContext;\n    syncManager.unsubscribe(oldValue);\n    syncManager.subscribe(newValue);\n    this.updateSiblings(oldValue);\n    this.updateSiblings(newValue);\n  }\n  onAxesChange() {\n    if (!this.enabled)\n      return;\n    const { syncManager } = this.moduleContext;\n    this.updateChart(syncManager.getChart());\n  }\n  onNodeInteractionChange() {\n    if (this.enabled && this.nodeInteraction) {\n      this.enabledNodeInteractionSync();\n    } else {\n      this.disableNodeInteractionSync?.();\n    }\n  }\n  onZoomChange() {\n    if (this.enabled && this.zoom) {\n      this.enabledZoomSync();\n    } else {\n      this.disableZoomSync?.();\n    }\n  }\n  destroy() {\n    const { syncManager } = this.moduleContext;\n    syncManager.unsubscribe(this.groupId);\n    this.updateSiblings(this.groupId);\n    this.disableZoomSync?.();\n  }\n};\nChartSync.className = \"Sync\";\n__decorateClass([\n  Validate27(BOOLEAN14),\n  ObserveChanges4((target) => target.onEnabledChange())\n], ChartSync.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate27(STRING10, { optional: true }),\n  ObserveChanges4((target, newValue, oldValue) => target.onGroupIdChange(newValue, oldValue))\n], ChartSync.prototype, \"groupId\", 2);\n__decorateClass([\n  Validate27(UNION5([\"x\", \"y\", \"xy\"], \"an axis\")),\n  ObserveChanges4((target) => target.onAxesChange())\n], ChartSync.prototype, \"axes\", 2);\n__decorateClass([\n  Validate27(BOOLEAN14),\n  ObserveChanges4((target) => target.onNodeInteractionChange())\n], ChartSync.prototype, \"nodeInteraction\", 2);\n__decorateClass([\n  Validate27(BOOLEAN14),\n  ObserveChanges4((target) => target.onZoomChange())\n], ChartSync.prototype, \"zoom\", 2);\n\n// packages/ag-charts-enterprise/src/features/sync/syncModule.ts\nvar SyncModule = {\n  type: \"root\",\n  optionsKey: \"sync\",\n  packageType: \"enterprise\",\n  chartTypes: [\"cartesian\"],\n  instanceConstructor: ChartSync,\n  themeTemplate: {\n    sync: { enabled: false }\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/zoom/zoom.ts\n\n\n// packages/ag-charts-enterprise/src/features/zoom/scenes/zoomRect.ts\n\nvar { COLOR_STRING: COLOR_STRING5, RATIO: RATIO8, Validate: Validate28 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar ZoomRect = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Rect {\n  constructor() {\n    super(...arguments);\n    this.fill = \"rgb(33, 150, 243)\";\n    this.fillOpacity = 0.2;\n  }\n};\nZoomRect.className = \"ZoomRect\";\n__decorateClass([\n  Validate28(COLOR_STRING5)\n], ZoomRect.prototype, \"fill\", 2);\n__decorateClass([\n  Validate28(RATIO8)\n], ZoomRect.prototype, \"fillOpacity\", 2);\n\n// packages/ag-charts-enterprise/src/features/zoom/zoomAxisDragger.ts\n\n\n// packages/ag-charts-enterprise/src/features/zoom/zoomUtils.ts\n\nvar { clamp: clamp2, isEqual, round } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar UNIT = { min: 0, max: 1 };\nvar DEFAULT_ANCHOR_POINT_X = \"end\";\nvar DEFAULT_ANCHOR_POINT_Y = \"middle\";\nvar constrain = (value, min = UNIT.min, max = UNIT.max) => clamp2(min, value, max);\nfunction unitZoomState() {\n  return { x: { ...UNIT }, y: { ...UNIT } };\n}\nfunction dx(zoom) {\n  return zoom.x.max - zoom.x.min;\n}\nfunction dy(zoom) {\n  return zoom.y.max - zoom.y.min;\n}\nfunction isZoomEqual(left, right, epsilon = 1e-10) {\n  return isEqual(left.x.min, right.x.min, epsilon) && isEqual(left.x.max, right.x.max, epsilon) && isEqual(left.y.min, right.y.min, epsilon) && isEqual(left.y.max, right.y.max, epsilon);\n}\nfunction isZoomLess(zoom, minRatioX, minRatioY) {\n  const isMinXZoom = round(dx(zoom), 10) <= minRatioX;\n  const isMinYZoom = round(dy(zoom), 10) <= minRatioY;\n  return isMinXZoom || isMinYZoom;\n}\nfunction definedZoomState(zoom) {\n  return {\n    x: { min: zoom?.x?.min ?? UNIT.min, max: zoom?.x?.max ?? UNIT.max },\n    y: { min: zoom?.y?.min ?? UNIT.min, max: zoom?.y?.max ?? UNIT.max }\n  };\n}\nfunction pointToRatio(bbox, x, y) {\n  if (!bbox)\n    return { x: 0, y: 0 };\n  const constrainedX = constrain(x - bbox.x, 0, bbox.x + bbox.width);\n  const constrainedY = constrain(y - bbox.y, 0, bbox.y + bbox.height);\n  const rx = 1 / bbox.width * constrainedX;\n  const ry = 1 - 1 / bbox.height * constrainedY;\n  return { x: constrain(rx), y: constrain(ry) };\n}\nfunction translateZoom(zoom, x, y) {\n  return {\n    x: { min: zoom.x.min + x, max: zoom.x.max + x },\n    y: { min: zoom.y.min + y, max: zoom.y.max + y }\n  };\n}\nfunction scaleZoom(zoom, sx, sy) {\n  return {\n    x: { min: zoom.x.min, max: zoom.x.min + dx(zoom) * sx },\n    y: { min: zoom.y.min, max: zoom.y.min + dy(zoom) * sy }\n  };\n}\nfunction scaleZoomCenter(zoom, sx, sy) {\n  const dx_ = dx(zoom);\n  const dy_ = dy(zoom);\n  const cx = zoom.x.min + dx_ / 2;\n  const cy = zoom.y.min + dy_ / 2;\n  return {\n    x: { min: cx - dx_ * sx / 2, max: cx + dx_ * sx / 2 },\n    y: { min: cy - dy_ * sy / 2, max: cy + dy_ * sy / 2 }\n  };\n}\nfunction scaleZoomAxisWithAnchor(newState, oldState, anchor, origin) {\n  const { min, max } = oldState;\n  const center = min + (max - min) / 2;\n  const diff8 = newState.max - newState.min;\n  switch (anchor) {\n    case \"start\":\n      return { min, max: oldState.min + diff8 };\n    case \"end\":\n      return { min: oldState.max - diff8, max };\n    case \"middle\":\n      return { min: center - diff8 / 2, max: center + diff8 / 2 };\n    case \"pointer\":\n      return scaleZoomAxisWithPoint(newState, oldState, origin ?? center);\n    default:\n      return { min, max };\n  }\n}\nfunction scaleZoomAxisWithPoint(newState, oldState, origin) {\n  const newDelta = newState.max - newState.min;\n  const oldDelta = oldState.max - oldState.min;\n  const scaledOrigin = origin * (1 - (oldDelta - newDelta));\n  const translation = origin - scaledOrigin;\n  const min = newState.min + translation;\n  const max = newState.max + translation;\n  return { min, max };\n}\nfunction multiplyZoom(zoom, nx, ny) {\n  return {\n    x: { min: zoom.x.min * nx, max: zoom.x.max * nx },\n    y: { min: zoom.y.min * ny, max: zoom.y.max * ny }\n  };\n}\nfunction constrainZoom(zoom) {\n  const after = unitZoomState();\n  after.x = constrainAxis(zoom.x);\n  after.y = constrainAxis(zoom.y);\n  return after;\n}\nfunction constrainAxis(axis) {\n  const size = axis.max - axis.min;\n  let min = axis.max > UNIT.max ? UNIT.max - size : axis.min;\n  let max = axis.min < UNIT.min ? size : axis.max;\n  min = Math.max(UNIT.min, min);\n  max = Math.min(UNIT.max, max);\n  return { min, max };\n}\nfunction constrainAxisWithOld({ min, max }, old, minRatio) {\n  if (max === old.max) {\n    min = max - minRatio;\n  } else if (min === old.min) {\n    max = min + minRatio;\n  } else {\n    const cx = old.min + (old.max - old.min) / 2;\n    min = cx - minRatio / 2;\n    max = cx + minRatio / 2;\n  }\n  return { min, max };\n}\n\n// packages/ag-charts-enterprise/src/features/zoom/zoomAxisDragger.ts\nvar ZoomAxisDragger = class {\n  update(event, direction, anchor, bbox, zoom, axisZoom) {\n    this.oldZoom ?? (this.oldZoom = definedZoomState(\n      direction === ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.ChartAxisDirection.X ? { ...zoom, x: axisZoom } : { ...zoom, y: axisZoom }\n    ));\n    this.updateCoords(event.offsetX, event.offsetY);\n    return this.updateZoom(direction, anchor, bbox);\n  }\n  stop() {\n    this.coords = void 0;\n    this.oldZoom = void 0;\n  }\n  updateCoords(x, y) {\n    if (this.coords) {\n      this.coords.x2 = x;\n      this.coords.y2 = y;\n    } else {\n      this.coords = { x1: x, y1: y, x2: x, y2: y };\n    }\n  }\n  updateZoom(direction, anchor, bbox) {\n    const { coords, oldZoom } = this;\n    let newZoom = definedZoomState(oldZoom);\n    if (!coords || !oldZoom) {\n      if (direction === ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.ChartAxisDirection.X)\n        return newZoom.x;\n      return newZoom.y;\n    }\n    const origin = pointToRatio(bbox, coords.x1, coords.y1);\n    const target = pointToRatio(bbox, coords.x2, coords.y2);\n    if (direction === ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.ChartAxisDirection.X) {\n      const scaleX = (target.x - origin.x) * dx(oldZoom);\n      newZoom.x.max += scaleX;\n      newZoom.x = scaleZoomAxisWithAnchor(newZoom.x, oldZoom.x, anchor, origin.x);\n      newZoom = constrainZoom(newZoom);\n      return newZoom.x;\n    }\n    const scaleY = (target.y - origin.y) * dy(oldZoom);\n    newZoom.y.max -= scaleY;\n    newZoom.y = scaleZoomAxisWithAnchor(newZoom.y, oldZoom.y, anchor, origin.y);\n    newZoom = constrainZoom(newZoom);\n    return newZoom.y;\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/zoom/zoomContextMenu.ts\nvar CONTEXT_ZOOM_ACTION_ID = \"zoom-action\";\nvar CONTEXT_PAN_ACTION_ID = \"pan-action\";\nvar ZoomContextMenu = class {\n  constructor(contextMenuRegistry, zoomManager, updateZoom) {\n    this.contextMenuRegistry = contextMenuRegistry;\n    this.zoomManager = zoomManager;\n    this.updateZoom = updateZoom;\n  }\n  registerActions(enabled, zoom, props) {\n    if (!enabled)\n      return;\n    const { contextMenuRegistry } = this;\n    contextMenuRegistry.registerDefaultAction({\n      id: CONTEXT_ZOOM_ACTION_ID,\n      type: \"series\",\n      label: \"contextMenuZoomToCursor\",\n      action: (params) => this.onZoomToHere(params, props)\n    });\n    contextMenuRegistry.registerDefaultAction({\n      id: CONTEXT_PAN_ACTION_ID,\n      type: \"series\",\n      label: \"contextMenuPanToCursor\",\n      action: (params) => this.onPanToHere(params, props)\n    });\n    this.toggleActions(zoom, props);\n  }\n  toggleActions(zoom, props) {\n    const { contextMenuRegistry } = this;\n    if (isZoomLess(zoom, props.minRatioX, props.minRatioY)) {\n      contextMenuRegistry.disableAction(CONTEXT_ZOOM_ACTION_ID);\n    } else {\n      contextMenuRegistry.enableAction(CONTEXT_ZOOM_ACTION_ID);\n    }\n    if (isZoomEqual(zoom, unitZoomState())) {\n      contextMenuRegistry.disableAction(CONTEXT_PAN_ACTION_ID);\n    } else {\n      contextMenuRegistry.enableAction(CONTEXT_PAN_ACTION_ID);\n    }\n  }\n  onZoomToHere({ event }, props) {\n    const { rect } = this;\n    const { enabled, isScalingX, isScalingY, minRatioX, minRatioY } = props;\n    if (!enabled || !rect || !event || !event.target || !(event instanceof MouseEvent))\n      return;\n    const zoom = definedZoomState(this.zoomManager.getZoom());\n    const origin = pointToRatio(rect, event.clientX, event.clientY);\n    const scaledOriginX = origin.x * dx(zoom);\n    const scaledOriginY = origin.y * dy(zoom);\n    const size = UNIT.max - UNIT.min;\n    const halfSize = size / 2;\n    let newZoom = {\n      x: { min: origin.x - halfSize, max: origin.x + halfSize },\n      y: { min: origin.y - halfSize, max: origin.y + halfSize }\n    };\n    newZoom = scaleZoomCenter(newZoom, isScalingX ? minRatioX : size, isScalingY ? minRatioY : size);\n    newZoom = translateZoom(newZoom, zoom.x.min - origin.x + scaledOriginX, zoom.y.min - origin.y + scaledOriginY);\n    this.updateZoom(constrainZoom(newZoom));\n  }\n  onPanToHere({ event }, props) {\n    const { rect } = this;\n    const { enabled } = props;\n    if (!enabled || !rect || !event || !event.target || !(event instanceof MouseEvent))\n      return;\n    const zoom = definedZoomState(this.zoomManager.getZoom());\n    const origin = pointToRatio(rect, event.clientX, event.clientY);\n    const scaleX = dx(zoom);\n    const scaleY = dy(zoom);\n    const scaledOriginX = origin.x * scaleX;\n    const scaledOriginY = origin.y * scaleY;\n    const halfSize = (UNIT.max - UNIT.min) / 2;\n    let newZoom = {\n      x: { min: origin.x - halfSize, max: origin.x + halfSize },\n      y: { min: origin.y - halfSize, max: origin.y + halfSize }\n    };\n    newZoom = scaleZoomCenter(newZoom, scaleX, scaleY);\n    newZoom = translateZoom(newZoom, zoom.x.min - origin.x + scaledOriginX, zoom.y.min - origin.y + scaledOriginY);\n    this.updateZoom(constrainZoom(newZoom));\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/zoom/zoomPanner.ts\n\nvar maxZoomCoords = 16;\nvar decelerationValues = {\n  off: 1,\n  short: 0.01,\n  long: 2e-3\n};\nvar ZoomPanner = class {\n  constructor() {\n    this.deceleration = 1;\n    this.zoomCoordsHistoryIndex = 0;\n    this.coordsHistory = [];\n  }\n  get decelerationValue() {\n    const { deceleration } = this;\n    return Math.max(\n      typeof deceleration === \"number\" ? deceleration : decelerationValues[deceleration] ?? 1,\n      1e-4\n    );\n  }\n  addListener(_type, fn) {\n    this.onUpdate = fn;\n    return () => {\n      this.onUpdate = void 0;\n    };\n  }\n  stopInteractions() {\n    if (this.inertiaHandle != null) {\n      cancelAnimationFrame(this.inertiaHandle);\n      this.inertiaHandle = void 0;\n    }\n  }\n  update(event) {\n    this.updateCoords(event.offsetX, event.offsetY);\n    const { x1 = 0, y1 = 0, x2 = 0, y2 = 0 } = this.coords ?? {};\n    this.onUpdate?.({\n      type: \"update\",\n      deltaX: x1 - x2,\n      deltaY: y1 - y2\n    });\n  }\n  start() {\n    this.coordsMonitorTimeout = setInterval(this.recordCurrentZoomCoords.bind(this), 16);\n  }\n  stop() {\n    const { coordsHistory } = this;\n    let deltaX = 0;\n    let deltaY = 0;\n    let deltaT = 0;\n    if (coordsHistory.length > 0) {\n      const arrayIndex = this.zoomCoordsHistoryIndex % maxZoomCoords;\n      let index1 = arrayIndex - 1;\n      if (index1 < 0)\n        index1 = coordsHistory.length - 1;\n      let index0 = arrayIndex;\n      if (index0 >= coordsHistory.length)\n        index0 = 0;\n      const coords1 = coordsHistory[index1];\n      const coords0 = coordsHistory[index0];\n      deltaX = coords1.x - coords0.x;\n      deltaY = coords1.y - coords0.y;\n      deltaT = coords1.t - coords0.t;\n    }\n    this.coords = void 0;\n    clearInterval(this.coordsMonitorTimeout);\n    this.coordsMonitorTimeout = void 0;\n    this.zoomCoordsHistoryIndex = 0;\n    this.coordsHistory.length = 0;\n    if (deltaT > 0 && this.decelerationValue < 1) {\n      const xVelocity = deltaX / deltaT;\n      const yVelocity = deltaY / deltaT;\n      const velocity = Math.hypot(xVelocity, yVelocity);\n      const angle = Math.atan2(yVelocity, xVelocity);\n      const t0 = performance.now();\n      this.inertiaHandle = requestAnimationFrame((t) => {\n        this.animateInertia(t, t, t0, velocity, angle);\n      });\n    }\n  }\n  recordCurrentZoomCoords() {\n    const { coords, coordsHistory, zoomCoordsHistoryIndex } = this;\n    if (!coords)\n      return;\n    const { x2: x, y2: y } = coords;\n    const t = Date.now();\n    coordsHistory[zoomCoordsHistoryIndex % maxZoomCoords] = { x, y, t };\n    this.zoomCoordsHistoryIndex += 1;\n  }\n  animateInertia(t, prevT, t0, velocity, angle) {\n    const friction = 1 - this.decelerationValue;\n    const maxS = -velocity / Math.log(friction);\n    const s0 = velocity * (friction ** (prevT - t0) - 1) / Math.log(friction);\n    const s1 = velocity * (friction ** (t - t0) - 1) / Math.log(friction);\n    this.onUpdate?.({\n      type: \"update\",\n      deltaX: -Math.cos(angle) * (s1 - s0),\n      deltaY: -Math.sin(angle) * (s1 - s0)\n    });\n    if (s1 >= maxS - 1)\n      return;\n    this.inertiaHandle = requestAnimationFrame((nextT) => {\n      this.animateInertia(nextT, t, t0, velocity, angle);\n    });\n  }\n  updateCoords(x, y) {\n    if (this.coords) {\n      this.coords = { x1: this.coords.x2, y1: this.coords.y2, x2: x, y2: y };\n    } else {\n      this.coords = { x1: x, y1: y, x2: x, y2: y };\n    }\n  }\n  translateZooms(bbox, currentZooms, deltaX, deltaY) {\n    const offset = pointToRatio(bbox, bbox.x + Math.abs(deltaX), bbox.y + bbox.height - Math.abs(deltaY));\n    const offsetX = Math.sign(deltaX) * offset.x;\n    const offsetY = -Math.sign(deltaY) * offset.y;\n    const newZooms = {};\n    for (const [axisId, { direction, zoom: currentZoom }] of Object.entries(currentZooms)) {\n      let zoom;\n      if (direction === ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.ChartAxisDirection.X) {\n        zoom = definedZoomState({ x: currentZoom });\n      } else {\n        zoom = definedZoomState({ y: currentZoom });\n      }\n      zoom = constrainZoom(translateZoom(zoom, offsetX * dx(zoom), offsetY * dy(zoom)));\n      if (direction === ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.ChartAxisDirection.X) {\n        newZooms[axisId] = { direction, zoom: zoom.x };\n      } else {\n        newZooms[axisId] = { direction, zoom: zoom.y };\n      }\n    }\n    return newZooms;\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/zoom/zoomRange.ts\n\nvar { AND: AND5, DATE: DATE2, NUMBER: NUMBER9, OR: OR3, ActionOnSet: ActionOnSet5, isFiniteNumber: isFiniteNumber2, isValidDate, Validate: Validate29 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar ZoomRange = class {\n  constructor(onChange) {\n    this.onChange = onChange;\n  }\n  getRange() {\n    return this.getRangeWithValues(this.start, this.end);\n  }\n  getInitialRange() {\n    return this.getRangeWithValues(this.initialStart, this.initialEnd);\n  }\n  extendToEnd(extent6) {\n    return this.extendWith((end) => Number(end) - extent6);\n  }\n  extendWith(fn) {\n    if (!this.domain)\n      return;\n    const [, end] = this.domain;\n    if (end == null)\n      return;\n    const start = fn(end);\n    const changed = this.start !== start || this.end !== end;\n    this.end = end;\n    this.start = start;\n    if (!changed)\n      this.onChange?.(this.getRange());\n  }\n  updateWith(fn) {\n    if (!this.domain)\n      return;\n    let [start, end] = this.domain;\n    [start, end] = fn(start, end);\n    const changed = this.start !== start || this.end !== end;\n    this.end = end;\n    this.start = start;\n    if (!changed)\n      this.onChange?.(this.getRange());\n  }\n  extendAll() {\n    if (!this.domain)\n      return;\n    const [start, end] = this.domain;\n    const changed = this.start !== start || this.end !== end;\n    this.start = start;\n    this.end = end;\n    if (!changed)\n      this.onChange?.(this.getRange());\n  }\n  updateAxis(axes) {\n    const validAxis = axes.find(({ domain }) => {\n      const isNumberAxis = !isFiniteNumber2(domain[0]) || !isFiniteNumber2(domain.at(-1));\n      const isDateAxis = !isValidDate(domain[0]) || !isValidDate(domain.at(-1));\n      return isNumberAxis || isDateAxis;\n    });\n    if (!validAxis)\n      return this.domain != null;\n    let validAxisDomain = validAxis.domain;\n    if (validAxisDomain != null) {\n      validAxisDomain = [validAxisDomain[0], validAxisDomain.at(-1)];\n      if (validAxisDomain[0] instanceof Date && validAxisDomain[1] instanceof Date) {\n        validAxisDomain = [validAxisDomain[0].getTime(), validAxisDomain[1].getTime()];\n      }\n    }\n    const changed = this.domain == null || !ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util.areArrayItemsStrictlyEqual(this.domain, validAxisDomain);\n    if (changed) {\n      this.domain = validAxisDomain;\n    }\n    return changed;\n  }\n  getRangeWithValues(start, end) {\n    let [d0, d1] = this.domain ?? [];\n    if (start == null && end == null || d0 == null || d1 == null)\n      return;\n    d0 = Number(d0);\n    d1 = Number(d1);\n    let min = 0;\n    let max = 1;\n    if (start != null)\n      min = (Number(start) - d0) / (d1 - d0);\n    if (end != null)\n      max = (Number(end) - d0) / (d1 - d0);\n    return { min, max };\n  }\n};\n__decorateClass([\n  ActionOnSet5({\n    changeValue(start) {\n      this.initialStart ?? (this.initialStart = start);\n      this.onChange?.(this.getRangeWithValues(start, this.end));\n    }\n  }),\n  Validate29(AND5(\n    OR3(DATE2, NUMBER9)\n    /* LESS_THAN('end') */\n  ), { optional: true })\n], ZoomRange.prototype, \"start\", 2);\n__decorateClass([\n  ActionOnSet5({\n    changeValue(end) {\n      this.initialEnd ?? (this.initialEnd = end);\n      this.onChange?.(this.getRangeWithValues(this.start, end));\n    }\n  }),\n  Validate29(AND5(\n    OR3(DATE2, NUMBER9)\n    /* GREATER_THAN('start') */\n  ), { optional: true })\n], ZoomRange.prototype, \"end\", 2);\n\n// packages/ag-charts-enterprise/src/features/zoom/zoomRatio.ts\n\nvar { AND: AND6, GREATER_THAN: GREATER_THAN4, LESS_THAN: LESS_THAN3, RATIO: RATIO9, ActionOnSet: ActionOnSet6, Validate: Validate30 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar ZoomRatio = class {\n  constructor(onChange) {\n    this.onChange = onChange;\n  }\n  getRatio() {\n    return this.getRatioWithValues(this.start, this.end);\n  }\n  getInitialRatio() {\n    return this.getRatioWithValues(this.initialStart, this.initialEnd);\n  }\n  getRatioWithValues(start, end) {\n    if (start == null && end == null)\n      return;\n    return {\n      min: start ?? UNIT.min,\n      max: end ?? UNIT.max\n    };\n  }\n};\n__decorateClass([\n  ActionOnSet6({\n    changeValue(start) {\n      this.initialStart ?? (this.initialStart = start);\n      this.onChange?.(this.getRatioWithValues(start, this.end));\n    }\n  }),\n  Validate30(AND6(RATIO9, LESS_THAN3(\"end\")), { optional: true })\n], ZoomRatio.prototype, \"start\", 2);\n__decorateClass([\n  ActionOnSet6({\n    changeValue(end) {\n      this.initialEnd ?? (this.initialEnd = end);\n      this.onChange?.(this.getRatioWithValues(this.start, end));\n    }\n  }),\n  Validate30(AND6(RATIO9, GREATER_THAN4(\"start\")), { optional: true })\n], ZoomRatio.prototype, \"end\", 2);\n\n// packages/ag-charts-enterprise/src/features/zoom/zoomScrollPanner.ts\n\nvar DELTA_SCALE = 200;\nvar ZoomScrollPanner = class {\n  update(event, step, bbox, zooms) {\n    const deltaX = event.deltaX * step * DELTA_SCALE;\n    return this.translateZooms(bbox, zooms, deltaX);\n  }\n  translateZooms(bbox, currentZooms, deltaX) {\n    const newZooms = {};\n    const offset = pointToRatio(bbox, bbox.x + Math.abs(deltaX), 0);\n    const offsetX = deltaX < 0 ? -offset.x : offset.x;\n    for (const [axisId, { direction, zoom: currentZoom }] of Object.entries(currentZooms)) {\n      if (direction !== ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.ChartAxisDirection.X)\n        continue;\n      let zoom = definedZoomState({ x: currentZoom });\n      zoom = constrainZoom(translateZoom(zoom, offsetX * dx(zoom), 0));\n      newZooms[axisId] = { direction, zoom: zoom.x };\n    }\n    return newZooms;\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/zoom/zoomScroller.ts\n\nvar ZoomScroller = class {\n  updateAxes(event, props, bbox, zooms) {\n    const sourceEvent = event.sourceEvent;\n    const newZooms = {};\n    const { anchorPointX, anchorPointY, isScalingX, isScalingY, scrollingStep } = props;\n    const origin = pointToRatio(\n      bbox,\n      sourceEvent.offsetX ?? sourceEvent.clientX,\n      sourceEvent.offsetY ?? sourceEvent.clientY\n    );\n    for (const [axisId, { direction, zoom }] of Object.entries(zooms)) {\n      if (zoom == null)\n        continue;\n      let newZoom = { ...zoom };\n      const delta3 = scrollingStep * event.deltaY * (zoom.max - zoom.min);\n      if (direction === ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.ChartAxisDirection.X && isScalingX) {\n        newZoom.max += delta3;\n        newZoom = scaleZoomAxisWithAnchor(newZoom, zoom, anchorPointX, origin.x);\n      } else if (direction === ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.ChartAxisDirection.Y && isScalingY) {\n        newZoom.max += delta3;\n        newZoom = scaleZoomAxisWithAnchor(newZoom, zoom, anchorPointY, origin.y);\n      } else {\n        continue;\n      }\n      newZooms[axisId] = { direction, zoom: constrainAxis(newZoom) };\n    }\n    return newZooms;\n  }\n  update(event, props, bbox, oldZoom) {\n    const sourceEvent = event.sourceEvent;\n    const { anchorPointX, anchorPointY, isScalingX, isScalingY, scrollingStep } = props;\n    const origin = pointToRatio(\n      bbox,\n      sourceEvent.offsetX ?? sourceEvent.clientX,\n      sourceEvent.offsetY ?? sourceEvent.clientY\n    );\n    const dir = event.deltaY;\n    let newZoom = definedZoomState(oldZoom);\n    newZoom.x.max += isScalingX ? scrollingStep * dir * dx(oldZoom) : 0;\n    newZoom.y.max += isScalingY ? scrollingStep * dir * dy(oldZoom) : 0;\n    if (isScalingX) {\n      newZoom.x = scaleZoomAxisWithAnchor(newZoom.x, oldZoom.x, anchorPointX, origin.x);\n    }\n    if (isScalingY) {\n      newZoom.y = scaleZoomAxisWithAnchor(newZoom.y, oldZoom.y, anchorPointY, origin.y);\n    }\n    newZoom = constrainZoom(newZoom);\n    return newZoom;\n  }\n  updateDelta(delta3, props, oldZoom) {\n    const { anchorPointX, anchorPointY, isScalingX, isScalingY, scrollingStep } = props;\n    let newZoom = definedZoomState(oldZoom);\n    newZoom.x.max += isScalingX ? scrollingStep * -delta3 * dx(oldZoom) : 0;\n    newZoom.y.max += isScalingY ? scrollingStep * -delta3 * dy(oldZoom) : 0;\n    if (isScalingX) {\n      newZoom.x = scaleZoomAxisWithAnchor(newZoom.x, oldZoom.x, anchorPointX);\n    }\n    if (isScalingY) {\n      newZoom.y = scaleZoomAxisWithAnchor(newZoom.y, oldZoom.y, anchorPointY);\n    }\n    newZoom = constrainZoom(newZoom);\n    return newZoom;\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/zoom/zoomSelector.ts\nvar ZoomSelector = class {\n  constructor(rect) {\n    this.rect = rect;\n    this.rect.visible = false;\n  }\n  update(event, props, bbox, currentZoom) {\n    this.rect.visible = true;\n    this.updateCoords(event.offsetX, event.offsetY, props, bbox, currentZoom);\n    this.updateRect(bbox);\n  }\n  stop(innerBBox, bbox, currentZoom) {\n    let zoom = definedZoomState();\n    if (!innerBBox || !bbox)\n      return zoom;\n    if (this.coords) {\n      zoom = this.createZoomFromCoords(bbox, currentZoom);\n    }\n    const multiplyX = bbox.width / innerBBox.width;\n    const multiplyY = bbox.height / innerBBox.height;\n    zoom = constrainZoom(multiplyZoom(zoom, multiplyX, multiplyY));\n    this.reset();\n    return zoom;\n  }\n  reset() {\n    this.coords = void 0;\n    this.rect.visible = false;\n  }\n  didUpdate() {\n    return this.rect.visible;\n  }\n  updateCoords(x, y, props, bbox, currentZoom) {\n    if (!this.coords) {\n      this.coords = { x1: x, y1: y, x2: x, y2: y };\n      return;\n    }\n    this.coords.x2 = x;\n    this.coords.y2 = y;\n    if (!bbox)\n      return;\n    const { isScalingX, isScalingY, minRatioX, minRatioY } = props;\n    const zoom = definedZoomState(currentZoom);\n    const normal = this.getNormalisedDimensions();\n    const aspectRatio = bbox.width / bbox.height;\n    const scaleX = zoom.x.max - zoom.x.min;\n    const scaleY = zoom.y.max - zoom.y.min;\n    const xRatio = minRatioX / scaleX;\n    const yRatio = minRatioY / scaleY;\n    if (normal.width / bbox.width < xRatio) {\n      if (this.coords.x2 < this.coords.x1) {\n        this.coords.x2 = this.coords.x1 - bbox.width * xRatio;\n      } else {\n        this.coords.x2 = this.coords.x1 + bbox.width * xRatio;\n      }\n    }\n    if (isScalingY && !isScalingX) {\n      if (normal.height / bbox.height < yRatio) {\n        if (this.coords.y2 < this.coords.y1) {\n          this.coords.y2 = this.coords.y1 - bbox.width * xRatio;\n        } else {\n          this.coords.y2 = this.coords.y1 + bbox.height * yRatio;\n        }\n      }\n    } else if (this.coords.y2 < this.coords.y1) {\n      this.coords.y2 = Math.min(\n        this.coords.y1 - normal.width / aspectRatio,\n        this.coords.y1 - bbox.height * yRatio\n      );\n    } else {\n      this.coords.y2 = Math.max(\n        this.coords.y1 + normal.width / aspectRatio,\n        this.coords.y1 + bbox.height * yRatio\n      );\n    }\n    if (!isScalingX) {\n      this.coords.x1 = bbox.x;\n      this.coords.x2 = bbox.x + bbox.width;\n    }\n    if (!isScalingY) {\n      this.coords.y1 = bbox.y;\n      this.coords.y2 = bbox.y + bbox.height;\n    }\n  }\n  updateRect(bbox) {\n    if (!bbox)\n      return;\n    const { rect } = this;\n    const normal = this.getNormalisedDimensions();\n    const { width, height } = normal;\n    let { x, y } = normal;\n    x = Math.max(x, bbox.x);\n    x -= Math.max(0, x + width - (bbox.x + bbox.width));\n    y = Math.max(y, bbox.y);\n    y -= Math.max(0, y + height - (bbox.y + bbox.height));\n    rect.x = x;\n    rect.y = y;\n    rect.width = width;\n    rect.height = height;\n  }\n  createZoomFromCoords(bbox, currentZoom) {\n    const oldZoom = definedZoomState(currentZoom);\n    const normal = this.getNormalisedDimensions();\n    const origin = pointToRatio(bbox, normal.x, normal.y + normal.height);\n    const xFactor = normal.width / bbox.width;\n    const yFactor = normal.height / bbox.height;\n    let newZoom = scaleZoom(oldZoom, xFactor, yFactor);\n    const translateX = origin.x * (oldZoom.x.max - oldZoom.x.min);\n    const translateY = origin.y * (oldZoom.y.max - oldZoom.y.min);\n    newZoom = translateZoom(newZoom, translateX, translateY);\n    newZoom = constrainZoom(newZoom);\n    return newZoom;\n  }\n  getNormalisedDimensions() {\n    const { x1 = 0, y1 = 0, x2 = 0, y2 = 0 } = this.coords ?? {};\n    const x = x1 <= x2 ? x1 : x2;\n    const y = y1 <= y2 ? y1 : y2;\n    const width = x1 <= x2 ? x2 - x1 : x1 - x2;\n    const height = y1 <= y2 ? y2 - y1 : y1 - y2;\n    return { x, y, width, height };\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/zoom/zoomToolbar.ts\n\nvar { ChartAxisDirection: ChartAxisDirection12, ToolbarManager: ToolbarManager2 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar ZoomToolbar = class {\n  constructor(toolbarManager, zoomManager, getResetZoom, updateZoom, updateAxisZoom) {\n    this.toolbarManager = toolbarManager;\n    this.zoomManager = zoomManager;\n    this.getResetZoom = getResetZoom;\n    this.updateZoom = updateZoom;\n    this.updateAxisZoom = updateAxisZoom;\n  }\n  toggle(enabled, zoom, props) {\n    this.toggleGroups(enabled);\n    if (enabled) {\n      this.toggleButtons(zoom, props);\n    }\n  }\n  toggleButtons(zoom, props) {\n    const { toolbarManager } = this;\n    const isMaxZoom = isZoomEqual(zoom, unitZoomState());\n    const isMinZoom = isZoomLess(zoom, props.minRatioX, props.minRatioY);\n    const isResetZoom = isZoomEqual(zoom, this.getResetZoom());\n    toolbarManager.toggleButton(\"zoom\", \"pan-start\", { enabled: zoom.x.min > UNIT.min });\n    toolbarManager.toggleButton(\"zoom\", \"pan-end\", { enabled: zoom.x.max < UNIT.max });\n    toolbarManager.toggleButton(\"zoom\", \"pan-left\", { enabled: zoom.x.min > UNIT.min });\n    toolbarManager.toggleButton(\"zoom\", \"pan-right\", { enabled: zoom.x.max < UNIT.max });\n    toolbarManager.toggleButton(\"zoom\", \"zoom-out\", { enabled: !isMaxZoom });\n    toolbarManager.toggleButton(\"zoom\", \"zoom-in\", { enabled: !isMinZoom });\n    toolbarManager.toggleButton(\"zoom\", \"reset\", { enabled: !isResetZoom });\n  }\n  onButtonPress(event, props) {\n    this.onButtonPressRanges(event, props);\n    this.onButtonPressZoom(event, props);\n  }\n  toggleGroups(enabled) {\n    this.toolbarManager?.toggleGroup(\"zoom\", \"ranges\", Boolean(enabled));\n    this.toolbarManager?.toggleGroup(\"zoom\", \"zoom\", Boolean(enabled));\n  }\n  onButtonPressRanges(event, props) {\n    if (!ToolbarManager2.isGroup(\"ranges\", event))\n      return;\n    const { rangeX } = props;\n    const time2 = event.value;\n    if (typeof time2 === \"number\") {\n      rangeX.extendToEnd(time2);\n    } else if (Array.isArray(time2)) {\n      rangeX.updateWith(() => time2);\n    } else if (typeof time2 === \"function\") {\n      rangeX.updateWith(time2);\n    }\n  }\n  onButtonPressZoom(event, props) {\n    if (!ToolbarManager2.isGroup(\"zoom\", event))\n      return;\n    if (props.independentAxes && event.value !== \"reset\") {\n      const axisZooms = this.zoomManager.getAxisZooms();\n      for (const [axisId, { direction, zoom }] of Object.entries(axisZooms)) {\n        if (zoom == null)\n          continue;\n        this.onButtonPressZoomAxis(event, props, axisId, direction, zoom);\n      }\n    } else {\n      this.onButtonPressZoomUnified(event, props);\n    }\n  }\n  onButtonPressZoomAxis(event, props, axisId, direction, zoom) {\n    if (!ToolbarManager2.isGroup(\"zoom\", event))\n      return;\n    const { anchorPointX, anchorPointY, isScalingX, isScalingY, scrollingStep } = props;\n    let newZoom = { ...zoom };\n    const delta3 = zoom.max - zoom.min;\n    switch (event.value) {\n      case \"pan-start\":\n        newZoom.max = delta3;\n        newZoom.min = 0;\n        break;\n      case \"pan-end\":\n        newZoom.min = newZoom.max - delta3;\n        newZoom.max = UNIT.max;\n        break;\n      case \"pan-left\":\n        newZoom.min -= delta3 * scrollingStep;\n        newZoom.max -= delta3 * scrollingStep;\n        break;\n      case \"pan-right\":\n        newZoom.min += delta3 * scrollingStep;\n        newZoom.max += delta3 * scrollingStep;\n        break;\n      case \"zoom-in\":\n      case \"zoom-out\": {\n        const isDirectionX = direction === ChartAxisDirection12.X;\n        const isScalingDirection = isDirectionX && isScalingX || !isDirectionX && isScalingY;\n        let scale = event.value === \"zoom-in\" ? 1 - scrollingStep : 1 + scrollingStep;\n        if (!isScalingDirection)\n          scale = 1;\n        const useAnchorPointX = anchorPointX === \"pointer\" ? DEFAULT_ANCHOR_POINT_X : anchorPointX;\n        const useAnchorPointY = anchorPointY === \"pointer\" ? DEFAULT_ANCHOR_POINT_Y : anchorPointY;\n        const useAnchorPoint = isDirectionX ? useAnchorPointX : useAnchorPointY;\n        newZoom.max = newZoom.min + (newZoom.max - newZoom.min) * scale;\n        newZoom = scaleZoomAxisWithAnchor(newZoom, zoom, useAnchorPoint);\n        break;\n      }\n    }\n    this.updateAxisZoom(axisId, direction, constrainAxis(newZoom));\n  }\n  onButtonPressZoomUnified(event, props) {\n    if (!ToolbarManager2.isGroup(\"zoom\", event))\n      return;\n    const { anchorPointX, anchorPointY, isScalingX, isScalingY, scrollingStep } = props;\n    const oldZoom = definedZoomState(this.zoomManager.getZoom());\n    let zoom = definedZoomState(oldZoom);\n    switch (event.value) {\n      case \"reset\":\n        zoom = this.getResetZoom();\n        break;\n      case \"pan-start\":\n        zoom.x.max = dx(zoom);\n        zoom.x.min = 0;\n        break;\n      case \"pan-end\":\n        zoom.x.min = UNIT.max - dx(zoom);\n        zoom.x.max = UNIT.max;\n        break;\n      case \"pan-left\":\n        zoom = translateZoom(zoom, -dx(zoom) * scrollingStep, 0);\n        break;\n      case \"pan-right\":\n        zoom = translateZoom(zoom, dx(zoom) * scrollingStep, 0);\n        break;\n      case \"zoom-in\":\n      case \"zoom-out\": {\n        const scale = event.value === \"zoom-in\" ? 1 - scrollingStep : 1 + scrollingStep;\n        const useAnchorPointX = anchorPointX === \"pointer\" ? DEFAULT_ANCHOR_POINT_X : anchorPointX;\n        const useAnchorPointY = anchorPointY === \"pointer\" ? DEFAULT_ANCHOR_POINT_Y : anchorPointY;\n        zoom = scaleZoom(zoom, isScalingX ? scale : 1, isScalingY ? scale : 1);\n        zoom.x = scaleZoomAxisWithAnchor(zoom.x, oldZoom.x, useAnchorPointX);\n        zoom.y = scaleZoomAxisWithAnchor(zoom.y, oldZoom.y, useAnchorPointY);\n        break;\n      }\n    }\n    this.updateZoom(constrainZoom(zoom));\n  }\n};\n\n// packages/ag-charts-enterprise/src/features/zoom/zoom.ts\nvar {\n  ARRAY: ARRAY2,\n  BOOLEAN: BOOLEAN15,\n  NUMBER: NUMBER10,\n  RATIO: RATIO10,\n  STRING: STRING11,\n  UNION: UNION6,\n  OR: OR4,\n  ActionOnSet: ActionOnSet7,\n  ChartAxisDirection: ChartAxisDirection13,\n  ChartUpdateType: ChartUpdateType3,\n  Validate: Validate31,\n  ProxyProperty: ProxyProperty2,\n  round: sharedRound,\n  REGIONS: REGIONS3\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar round2 = (value) => sharedRound(value, 10);\nvar ANCHOR_POINT = UNION6([\"pointer\", \"start\", \"middle\", \"end\"], \"an anchor cord\");\nvar CURSOR_ID = \"zoom-cursor\";\nvar TOOLTIP_ID = \"zoom-tooltip\";\nvar ZoomButtonsProperties = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.BaseProperties {\n  constructor(onChange) {\n    super();\n    this.onChange = onChange;\n    this.enabled = false;\n    this.position = \"floating-bottom\";\n    this.size = \"small\";\n    this.align = \"center\";\n  }\n};\n__decorateClass([\n  ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.ObserveChanges((target) => {\n    target.onChange();\n  }),\n  Validate31(BOOLEAN15)\n], ZoomButtonsProperties.prototype, \"enabled\", 2);\n__decorateClass([\n  ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.ObserveChanges((target) => {\n    target.onChange();\n  }),\n  Validate31(ARRAY2, { optional: true })\n], ZoomButtonsProperties.prototype, \"buttons\", 2);\n__decorateClass([\n  Validate31(STRING11)\n], ZoomButtonsProperties.prototype, \"position\", 2);\n__decorateClass([\n  Validate31(STRING11)\n], ZoomButtonsProperties.prototype, \"size\", 2);\n__decorateClass([\n  Validate31(STRING11)\n], ZoomButtonsProperties.prototype, \"align\", 2);\nvar Zoom = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.enabled = false;\n    this.enableAxisDragging = true;\n    this.buttons = new ZoomButtonsProperties(() => this.onZoomButtonsChange(this.enabled));\n    this.enableDoubleClickToReset = true;\n    this.enablePanning = true;\n    this.enableScrolling = true;\n    this.enableSelecting = false;\n    this.panKey = \"alt\";\n    this.axes = \"x\";\n    this.scrollingStep = (UNIT.max - UNIT.min) / 10;\n    this.minVisibleItemsX = 2;\n    this.minVisibleItemsY = 2;\n    this.anchorPointX = DEFAULT_ANCHOR_POINT_X;\n    this.anchorPointY = DEFAULT_ANCHOR_POINT_Y;\n    this.rangeX = new ZoomRange(this.onRangeChange.bind(this, ChartAxisDirection13.X));\n    this.rangeY = new ZoomRange(this.onRangeChange.bind(this, ChartAxisDirection13.Y));\n    this.ratioX = new ZoomRatio(this.onRatioChange.bind(this, ChartAxisDirection13.X));\n    this.ratioY = new ZoomRatio(this.onRatioChange.bind(this, ChartAxisDirection13.Y));\n    // Zoom methods\n    this.axisDragger = new ZoomAxisDragger();\n    this.panner = new ZoomPanner();\n    this.scroller = new ZoomScroller();\n    this.scrollPanner = new ZoomScrollPanner();\n    this.deceleration = \"short\";\n    // State\n    this.dragState = 0 /* None */;\n    this.minRatioX = 0;\n    this.minRatioY = 0;\n    const selectionRect = new ZoomRect();\n    this.selector = new ZoomSelector(selectionRect);\n    this.contextMenu = new ZoomContextMenu(ctx.contextMenuRegistry, ctx.zoomManager, this.updateZoom.bind(this));\n    this.toolbar = new ZoomToolbar(\n      ctx.toolbarManager,\n      ctx.zoomManager,\n      this.getResetZoom.bind(this),\n      this.updateZoom.bind(this),\n      this.updateAxisZoom.bind(this)\n    );\n    const { Default: Default4, ZoomDrag, Animation: Animation2 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.InteractionState;\n    const draggableState = Default4 | Animation2 | ZoomDrag;\n    const clickableState = Default4 | Animation2;\n    const region = ctx.regionManager.getRegion(REGIONS3.SERIES);\n    const horizontalAxesRegion = ctx.regionManager.getRegion(REGIONS3.HORIZONTAL_AXES);\n    const verticalAxesRegion = ctx.regionManager.getRegion(REGIONS3.VERTICAL_AXES);\n    const dragStartEventType = \"drag-start\";\n    this.destroyFns.push(\n      ctx.scene.attachNode(selectionRect),\n      ctx.regionManager.listenAll(\"dblclick\", (event) => this.onDoubleClick(event), clickableState),\n      ctx.regionManager.listenAll(\"nav-zoom\", (event) => this.onNavZoom(event)),\n      region.addListener(\"drag\", (event) => this.onDrag(event), draggableState),\n      region.addListener(dragStartEventType, (event) => this.onDragStart(event), draggableState),\n      region.addListener(\"drag-end\", (event) => this.onDragEnd(event), draggableState),\n      verticalAxesRegion.addListener(\"drag\", (event) => this.onDrag(event), draggableState),\n      verticalAxesRegion.addListener(dragStartEventType, (event) => this.onDragStart(event), draggableState),\n      verticalAxesRegion.addListener(\"drag-end\", (event) => this.onDragEnd(event), draggableState),\n      verticalAxesRegion.addListener(\"leave\", () => this.onAxisLeave(), clickableState),\n      horizontalAxesRegion.addListener(\"drag\", (event) => this.onDrag(event), draggableState),\n      horizontalAxesRegion.addListener(dragStartEventType, (event) => this.onDragStart(event), draggableState),\n      horizontalAxesRegion.addListener(\"drag-end\", (event) => this.onDragEnd(event), draggableState),\n      horizontalAxesRegion.addListener(\"leave\", () => this.onAxisLeave(), clickableState),\n      region.addListener(\"wheel\", (event) => this.onWheel(event), clickableState),\n      ctx.chartEventManager.addListener(\"axis-hover\", (event) => this.onAxisHover(event)),\n      ctx.gestureDetector.addListener(\"pinch-move\", (event) => this.onPinchMove(event)),\n      ctx.toolbarManager.addListener(\n        \"button-pressed\",\n        (event) => this.toolbar.onButtonPress(event, this.getModuleProperties())\n      ),\n      ctx.layoutService.addListener(\"layout-complete\", (event) => this.onLayoutComplete(event)),\n      ctx.updateService.addListener(\"update-complete\", (event) => this.onUpdateComplete(event)),\n      ctx.zoomManager.addListener(\"zoom-change\", (event) => this.onZoomChange(event)),\n      ctx.zoomManager.addListener(\"zoom-pan-start\", (event) => this.onZoomPanStart(event)),\n      this.panner.addListener(\"update\", (event) => this.onPanUpdate(event))\n    );\n  }\n  onEnabledChange(enabled) {\n    if (!this.contextMenu || !this.toolbar)\n      return;\n    const zoom = this.getZoom();\n    const props = this.getModuleProperties({ enabled });\n    this.contextMenu.registerActions(enabled, zoom, props);\n    this.onZoomButtonsChange(enabled);\n    this.toolbar.toggle(enabled, zoom, props);\n  }\n  onZoomButtonsChange(zoomEnabled) {\n    if (!this.buttons)\n      return;\n    const buttonsJson = this.buttons.toJson();\n    buttonsJson.enabled && (buttonsJson.enabled = zoomEnabled);\n    this.ctx.toolbarManager.proxyGroupOptions(\"zoom\", \"zoom\", buttonsJson);\n  }\n  onRangeChange(direction, rangeZoom) {\n    if (!rangeZoom)\n      return;\n    const zoom = this.getZoom();\n    zoom[direction] = rangeZoom;\n    this.updateZoom(constrainZoom(zoom));\n  }\n  onRatioChange(direction, ratioZoom) {\n    if (!ratioZoom)\n      return;\n    let x = this.ratioX.getRatio();\n    let y = this.ratioY.getRatio();\n    if (direction === ChartAxisDirection13.X) {\n      x = ratioZoom;\n    } else {\n      y = ratioZoom;\n    }\n    const newZoom = constrainZoom(definedZoomState({ x, y }));\n    this.updateZoom(newZoom);\n  }\n  onDoubleClick(event) {\n    const { enabled, enableDoubleClickToReset, hoveredAxis, paddedRect } = this;\n    if (!enabled || !enableDoubleClickToReset)\n      return;\n    const { x, y } = this.getResetZoom();\n    if (hoveredAxis) {\n      const { id, direction } = hoveredAxis;\n      const axisZoom = direction === ChartAxisDirection13.X ? x : y;\n      this.updateAxisZoom(id, direction, axisZoom);\n    } else if (paddedRect?.containsPoint(event.offsetX, event.offsetY) && !event.preventZoomDblClick) {\n      this.updateZoom({ x, y });\n    }\n  }\n  onDragStart(event) {\n    const {\n      enabled,\n      enableAxisDragging,\n      enablePanning,\n      enableSelecting,\n      hoveredAxis,\n      paddedRect,\n      ctx: { cursorManager, zoomManager }\n    } = this;\n    if (!enabled || !paddedRect)\n      return;\n    this.panner.stopInteractions();\n    let newDragState = 0 /* None */;\n    if (enableAxisDragging && hoveredAxis) {\n      newDragState = 1 /* Axis */;\n    } else if (paddedRect.containsPoint(event.offsetX, event.offsetY)) {\n      const panKeyPressed = this.isPanningKeyPressed(event.sourceEvent);\n      if (enablePanning && (!enableSelecting || panKeyPressed)) {\n        cursorManager.updateCursor(CURSOR_ID, \"grabbing\");\n        newDragState = 2 /* Pan */;\n        this.panner.start();\n      } else if (enableSelecting) {\n        const fullyZoomedIn = this.isMinZoom(this.getZoom());\n        if (!fullyZoomedIn && !panKeyPressed) {\n          newDragState = 3 /* Select */;\n        }\n      }\n    }\n    if ((this.dragState = newDragState) !== 0 /* None */) {\n      zoomManager.fireZoomPanStartEvent(\"zoom\");\n    }\n  }\n  onDrag(event) {\n    const {\n      anchorPointX,\n      anchorPointY,\n      axisDragger,\n      dragState,\n      enabled,\n      paddedRect,\n      panner,\n      selector,\n      seriesRect,\n      hoveredAxis,\n      ctx: { interactionManager, tooltipManager, updateService, zoomManager }\n    } = this;\n    if (!enabled || !paddedRect || !seriesRect)\n      return;\n    interactionManager.pushState(ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.InteractionState.ZoomDrag);\n    const zoom = this.getZoom();\n    switch (dragState) {\n      case 1 /* Axis */:\n        if (!hoveredAxis)\n          break;\n        const { id: axisId, direction } = hoveredAxis;\n        const anchor = direction === ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.ChartAxisDirection.X ? anchorPointX : anchorPointY;\n        const axisZoom = zoomManager.getAxisZoom(axisId);\n        const newZoom = axisDragger.update(event, direction, anchor, seriesRect, zoom, axisZoom);\n        this.updateAxisZoom(axisId, direction, newZoom);\n        break;\n      case 2 /* Pan */:\n        panner.update(event);\n        break;\n      case 3 /* Select */:\n        selector.update(event, this.getModuleProperties(), paddedRect, zoom);\n        break;\n      case 0 /* None */:\n        return;\n    }\n    tooltipManager.updateTooltip(TOOLTIP_ID);\n    updateService.update(ChartUpdateType3.PERFORM_LAYOUT, { skipAnimations: true });\n  }\n  onDragEnd(_event) {\n    const {\n      axisDragger,\n      dragState,\n      enabled,\n      panner,\n      selector,\n      ctx: { cursorManager, interactionManager, tooltipManager }\n    } = this;\n    interactionManager.popState(ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.InteractionState.ZoomDrag);\n    if (!enabled || dragState === 0 /* None */)\n      return;\n    switch (dragState) {\n      case 1 /* Axis */:\n        axisDragger.stop();\n        break;\n      case 2 /* Pan */:\n        panner.stop();\n        break;\n      case 3 /* Select */:\n        if (!selector.didUpdate())\n          break;\n        const zoom = this.getZoom();\n        if (this.isMinZoom(zoom))\n          break;\n        const newZoom = selector.stop(this.seriesRect, this.paddedRect, zoom);\n        this.updateZoom(newZoom);\n        break;\n    }\n    this.dragState = 0 /* None */;\n    cursorManager.updateCursor(CURSOR_ID);\n    tooltipManager.removeTooltip(TOOLTIP_ID);\n  }\n  onNavZoom(event) {\n    const { enabled, enableScrolling, scroller } = this;\n    if (!enabled || !enableScrolling)\n      return;\n    event.preventDefault();\n    this.updateZoom(scroller.updateDelta(event.delta, this.getModuleProperties(), this.getZoom()));\n  }\n  onWheel(event) {\n    const { enabled, enableAxisDragging, enablePanning, enableScrolling, hoveredAxis, paddedRect } = this;\n    if (!enabled || !enableScrolling || !paddedRect)\n      return;\n    const isSeriesScrolling = paddedRect.containsPoint(event.offsetX, event.offsetY);\n    const isAxisScrolling = enableAxisDragging && hoveredAxis != null;\n    const sourceEvent = event.sourceEvent;\n    const { deltaX, deltaY } = sourceEvent;\n    const isHorizontalScrolling = deltaX != null && deltaY != null && Math.abs(deltaX) > Math.abs(deltaY);\n    if (enablePanning && isHorizontalScrolling) {\n      this.onWheelPanning(event);\n    } else if (isSeriesScrolling || isAxisScrolling) {\n      this.onWheelScrolling(event);\n    }\n  }\n  onWheelPanning(event) {\n    const {\n      scrollingStep,\n      scrollPanner,\n      seriesRect,\n      ctx: { zoomManager }\n    } = this;\n    if (!seriesRect)\n      return;\n    event.preventDefault();\n    const newZooms = scrollPanner.update(event, scrollingStep, seriesRect, zoomManager.getAxisZooms());\n    for (const [axisId, { direction, zoom }] of Object.entries(newZooms)) {\n      this.updateAxisZoom(axisId, direction, zoom);\n    }\n  }\n  onWheelScrolling(event) {\n    const {\n      enableAxisDragging,\n      enableIndependentAxes,\n      hoveredAxis,\n      scroller,\n      seriesRect,\n      ctx: { zoomManager }\n    } = this;\n    if (!seriesRect)\n      return;\n    event.preventDefault();\n    const isAxisScrolling = enableAxisDragging && hoveredAxis != null;\n    let isScalingX = this.isScalingX();\n    let isScalingY = this.isScalingY();\n    if (isAxisScrolling) {\n      isScalingX = hoveredAxis.direction === ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.ChartAxisDirection.X;\n      isScalingY = !isScalingX;\n    }\n    const props = this.getModuleProperties({ isScalingX, isScalingY });\n    if (enableIndependentAxes === true) {\n      const newZooms = scroller.updateAxes(event, props, seriesRect, zoomManager.getAxisZooms());\n      for (const [axisId, { direction, zoom }] of Object.entries(newZooms)) {\n        if (isAxisScrolling && hoveredAxis.id !== axisId)\n          continue;\n        this.updateAxisZoom(axisId, direction, zoom);\n      }\n    } else {\n      const newZoom = scroller.update(event, props, seriesRect, this.getZoom());\n      this.updateZoom(newZoom);\n    }\n  }\n  onAxisLeave() {\n    const {\n      enabled,\n      ctx: { cursorManager }\n    } = this;\n    if (!enabled)\n      return;\n    this.hoveredAxis = void 0;\n    cursorManager.updateCursor(CURSOR_ID);\n  }\n  onAxisHover(event) {\n    const {\n      enabled,\n      enableAxisDragging,\n      ctx: { cursorManager }\n    } = this;\n    if (!enabled)\n      return;\n    this.hoveredAxis = {\n      id: event.axisId,\n      direction: event.direction\n    };\n    if (enableAxisDragging) {\n      cursorManager.updateCursor(CURSOR_ID, event.direction === ChartAxisDirection13.X ? \"ew-resize\" : \"ns-resize\");\n    }\n  }\n  onPinchMove(event) {\n    const { enabled, enableScrolling, paddedRect, seriesRect } = this;\n    if (!enabled || !enableScrolling || !paddedRect || !seriesRect)\n      return;\n    const oldZoom = this.getZoom();\n    const newZoom = this.getZoom();\n    const delta3 = event.deltaDistance * -0.01;\n    const origin = pointToRatio(seriesRect, event.origin.x, event.origin.y);\n    if (this.isScalingX()) {\n      newZoom.x.max += delta3 * dx(oldZoom);\n      newZoom.x = scaleZoomAxisWithPoint(newZoom.x, oldZoom.x, origin.x);\n    }\n    if (this.isScalingY()) {\n      newZoom.y.max += delta3 * (oldZoom.y.max - oldZoom.y.min);\n      newZoom.y = scaleZoomAxisWithPoint(newZoom.y, oldZoom.y, origin.y);\n    }\n    this.updateZoom(constrainZoom(newZoom));\n    event.preventDefault();\n  }\n  onLayoutComplete(event) {\n    const { enabled, rangeX, rangeY } = this;\n    if (!enabled)\n      return;\n    const {\n      series: { rect, paddedRect, shouldFlipXY },\n      axes\n    } = event;\n    this.seriesRect = rect;\n    this.paddedRect = paddedRect;\n    this.contextMenu.rect = paddedRect;\n    this.shouldFlipXY = shouldFlipXY;\n    if (!axes)\n      return;\n    const [axesX, axesY] = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util.bifurcate((axis) => axis.direction === ChartAxisDirection13.X, axes);\n    const rangeXAxisChanged = rangeX.updateAxis(axesX);\n    const rangeYAxisChanged = rangeY.updateAxis(axesY);\n    if (!rangeXAxisChanged && !rangeYAxisChanged)\n      return;\n    const newZoom = {};\n    newZoom.x = rangeX.getRange();\n    newZoom.y = rangeY.getRange();\n    if (newZoom.x != null || newZoom.y != null) {\n      this.updateZoom(constrainZoom(definedZoomState(newZoom)));\n    }\n  }\n  onUpdateComplete({ minRect, minVisibleRect }) {\n    const { enabled, minVisibleItemsX, minVisibleItemsY, paddedRect, shouldFlipXY } = this;\n    if (!enabled || !paddedRect || !minRect || !minVisibleRect)\n      return;\n    const zoom = this.getZoom();\n    const minVisibleItemsWidth = shouldFlipXY ? minVisibleItemsY : minVisibleItemsX;\n    const minVisibleItemsHeight = shouldFlipXY ? minVisibleItemsX : minVisibleItemsY;\n    const widthRatio = minVisibleRect.width * minVisibleItemsWidth / paddedRect.width;\n    const heightRatio = minVisibleRect.height * minVisibleItemsHeight / paddedRect.height;\n    const ratioX = round2(widthRatio * dx(zoom));\n    const ratioY = round2(heightRatio * dy(zoom));\n    if (this.isScalingX()) {\n      this.minRatioX = Math.min(1, ratioX);\n    }\n    if (this.isScalingY()) {\n      this.minRatioY = Math.min(1, ratioY);\n    }\n    this.minRatioX || (this.minRatioX = this.minRatioY || 0);\n    this.minRatioY || (this.minRatioY = this.minRatioX || 0);\n  }\n  onZoomChange(event) {\n    if (event.callerId !== \"zoom\") {\n      this.panner.stopInteractions();\n    }\n    const zoom = this.getZoom();\n    const props = this.getModuleProperties();\n    this.contextMenu.toggleActions(zoom, props);\n    this.toolbar.toggleButtons(zoom, props);\n  }\n  onZoomPanStart(event) {\n    if (event.callerId === \"zoom\") {\n      this.panner.stopInteractions();\n    }\n  }\n  onPanUpdate(event) {\n    const {\n      panner,\n      seriesRect,\n      ctx: { tooltipManager, updateService, zoomManager }\n    } = this;\n    if (!seriesRect)\n      return;\n    const newZooms = panner.translateZooms(seriesRect, zoomManager.getAxisZooms(), event.deltaX, event.deltaY);\n    for (const [axisId, { direction, zoom }] of Object.entries(newZooms)) {\n      this.updateAxisZoom(axisId, direction, zoom);\n    }\n    tooltipManager.updateTooltip(TOOLTIP_ID);\n    updateService.update(ChartUpdateType3.PERFORM_LAYOUT, { skipAnimations: true });\n  }\n  isPanningKeyPressed(event) {\n    switch (this.panKey) {\n      case \"alt\":\n        return event.altKey;\n      case \"ctrl\":\n        return event.ctrlKey;\n      case \"shift\":\n        return event.shiftKey;\n      case \"meta\":\n        return event.metaKey;\n    }\n  }\n  isScalingX() {\n    if (this.axes === \"xy\")\n      return true;\n    return this.shouldFlipXY ? this.axes === \"y\" : this.axes === \"x\";\n  }\n  isScalingY() {\n    if (this.axes === \"xy\")\n      return true;\n    return this.shouldFlipXY ? this.axes === \"x\" : this.axes === \"y\";\n  }\n  getAnchorPointX() {\n    return this.shouldFlipXY ? this.anchorPointY : this.anchorPointX;\n  }\n  getAnchorPointY() {\n    return this.shouldFlipXY ? this.anchorPointX : this.anchorPointY;\n  }\n  isMinZoom(zoom) {\n    return isZoomLess(zoom, this.minRatioX, this.minRatioY);\n  }\n  updateZoom(zoom) {\n    const {\n      minRatioX,\n      minRatioY,\n      ctx: { zoomManager }\n    } = this;\n    const dx_ = dx(zoom);\n    const dy_ = dy(zoom);\n    const oldZoom = this.getZoom();\n    const zoomedInTooFarX = dx_ <= dx(oldZoom) && dx_ < minRatioX;\n    const zoomedInTooFarY = dy_ <= dy(oldZoom) && dy_ < minRatioY;\n    if (zoomedInTooFarX) {\n      zoom.x = constrainAxisWithOld(zoom.x, oldZoom.x, minRatioX);\n    }\n    if (zoomedInTooFarY) {\n      zoom.y = constrainAxisWithOld(zoom.y, oldZoom.y, minRatioY);\n    }\n    zoomManager.updateZoom(\"zoom\", zoom);\n  }\n  updateAxisZoom(axisId, direction, axisZoom) {\n    const {\n      enableIndependentAxes,\n      minRatioX,\n      minRatioY,\n      ctx: { zoomManager }\n    } = this;\n    if (!axisZoom)\n      return;\n    const zoom = this.getZoom();\n    if (enableIndependentAxes !== true) {\n      zoom[direction] = axisZoom;\n      this.updateZoom(zoom);\n      return;\n    }\n    const deltaAxis = axisZoom.max - axisZoom.min;\n    const deltaOld = zoom[direction].max - zoom[direction].min;\n    const minRatio = direction === ChartAxisDirection13.X ? minRatioX : minRatioY;\n    if (deltaAxis <= deltaOld && deltaAxis < minRatio) {\n      return;\n    }\n    zoomManager.updateAxisZoom(\"zoom\", axisId, axisZoom);\n  }\n  getZoom() {\n    return definedZoomState(this.ctx.zoomManager.getZoom());\n  }\n  getResetZoom() {\n    const x = this.rangeX.getInitialRange() ?? this.ratioX.getInitialRatio() ?? UNIT;\n    const y = this.rangeY.getInitialRange() ?? this.ratioY.getInitialRatio() ?? UNIT;\n    return { x, y };\n  }\n  getModuleProperties(overrides) {\n    return {\n      anchorPointX: overrides?.anchorPointX ?? this.getAnchorPointX(),\n      anchorPointY: overrides?.anchorPointY ?? this.getAnchorPointY(),\n      enabled: overrides?.enabled ?? this.enabled,\n      independentAxes: overrides?.independentAxes ?? this.enableIndependentAxes === true,\n      isScalingX: overrides?.isScalingX ?? this.isScalingX(),\n      isScalingY: overrides?.isScalingY ?? this.isScalingY(),\n      minRatioX: overrides?.minRatioX ?? this.minRatioX,\n      minRatioY: overrides?.minRatioY ?? this.minRatioY,\n      rangeX: overrides?.rangeX ?? this.rangeX,\n      scrollingStep: overrides?.scrollingStep ?? this.scrollingStep\n    };\n  }\n};\n__decorateClass([\n  ActionOnSet7({\n    newValue(enabled) {\n      this.onEnabledChange(enabled);\n    }\n  }),\n  Validate31(BOOLEAN15)\n], Zoom.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate31(BOOLEAN15)\n], Zoom.prototype, \"enableAxisDragging\", 2);\n__decorateClass([\n  Validate31(BOOLEAN15)\n], Zoom.prototype, \"enableDoubleClickToReset\", 2);\n__decorateClass([\n  Validate31(BOOLEAN15, { optional: true })\n], Zoom.prototype, \"enableIndependentAxes\", 2);\n__decorateClass([\n  Validate31(BOOLEAN15)\n], Zoom.prototype, \"enablePanning\", 2);\n__decorateClass([\n  Validate31(BOOLEAN15)\n], Zoom.prototype, \"enableScrolling\", 2);\n__decorateClass([\n  Validate31(BOOLEAN15)\n], Zoom.prototype, \"enableSelecting\", 2);\n__decorateClass([\n  Validate31(UNION6([\"alt\", \"ctrl\", \"meta\", \"shift\"], \"a pan key\"))\n], Zoom.prototype, \"panKey\", 2);\n__decorateClass([\n  Validate31(UNION6([\"x\", \"y\", \"xy\"], \"an axis\"))\n], Zoom.prototype, \"axes\", 2);\n__decorateClass([\n  Validate31(RATIO10)\n], Zoom.prototype, \"scrollingStep\", 2);\n__decorateClass([\n  Validate31(NUMBER10.restrict({ min: 1 }))\n], Zoom.prototype, \"minVisibleItemsX\", 2);\n__decorateClass([\n  Validate31(NUMBER10.restrict({ min: 1 }))\n], Zoom.prototype, \"minVisibleItemsY\", 2);\n__decorateClass([\n  Validate31(ANCHOR_POINT)\n], Zoom.prototype, \"anchorPointX\", 2);\n__decorateClass([\n  Validate31(ANCHOR_POINT)\n], Zoom.prototype, \"anchorPointY\", 2);\n__decorateClass([\n  ProxyProperty2(\"panner.deceleration\"),\n  Validate31(OR4(RATIO10, UNION6([\"off\", \"short\", \"long\"], \"a deceleration\")))\n], Zoom.prototype, \"deceleration\", 2);\n\n// packages/ag-charts-enterprise/src/features/zoom/zoomModule.ts\nvar buttons = {\n  enabled: true,\n  buttons: [\n    {\n      icon: \"zoom-out\",\n      tooltip: \"toolbarZoomZoomOut\",\n      value: \"zoom-out\",\n      section: \"scale\"\n    },\n    {\n      icon: \"zoom-in\",\n      tooltip: \"toolbarZoomZoomIn\",\n      value: \"zoom-in\",\n      section: \"scale\"\n    },\n    {\n      icon: \"pan-left\",\n      tooltip: \"toolbarZoomPanLeft\",\n      value: \"pan-left\",\n      section: \"pan\"\n    },\n    {\n      icon: \"pan-right\",\n      tooltip: \"toolbarZoomPanRight\",\n      value: \"pan-right\",\n      section: \"pan\"\n    },\n    {\n      icon: \"reset\",\n      tooltip: \"toolbarZoomReset\",\n      value: \"reset\",\n      section: \"reset\"\n    }\n  ]\n};\nvar ZoomModule = {\n  type: \"root\",\n  optionsKey: \"zoom\",\n  packageType: \"enterprise\",\n  chartTypes: [\"cartesian\", \"topology\"],\n  dependencies: [\"toolbar\"],\n  instanceConstructor: Zoom,\n  themeTemplate: {\n    zoom: {\n      anchorPointX: \"end\",\n      anchorPointY: \"middle\",\n      axes: \"x\",\n      buttons,\n      enabled: false,\n      enableAxisDragging: true,\n      enableDoubleClickToReset: true,\n      enablePanning: true,\n      enableScrolling: true,\n      enableSelecting: false,\n      deceleration: \"short\",\n      minVisibleItemsX: 2,\n      minVisibleItemsY: 2,\n      panKey: \"alt\",\n      scrollingStep: 0.1\n    }\n  }\n};\n\n// packages/ag-charts-enterprise/src/gradient-legend/gradientLegendModule.ts\n\n\n// packages/ag-charts-enterprise/src/gradient-legend/gradientLegend.ts\n\nvar { BOOLEAN: BOOLEAN16, OBJECT: OBJECT9, Layers: Layers5, POSITION, Validate: Validate32, POSITIVE_NUMBER: POSITIVE_NUMBER9, ProxyProperty: ProxyProperty3 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { BBox: BBox4, Group: Group6, Rect, LinearGradientFill, Triangle } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar { createId: createId3 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar GradientBar = class {\n  constructor() {\n    this.thickness = 16;\n    this.preferredLength = 100;\n  }\n};\n__decorateClass([\n  Validate32(POSITIVE_NUMBER9)\n], GradientBar.prototype, \"thickness\", 2);\n__decorateClass([\n  Validate32(POSITIVE_NUMBER9)\n], GradientBar.prototype, \"preferredLength\", 2);\nvar GradientLegendAxis = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.CartesianAxis {\n  constructor(ctx) {\n    super(ctx, new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scale.LinearScale(), { respondsToZoom: false });\n    this.colorDomain = [];\n    this.nice = false;\n    this.line.enabled = false;\n  }\n  calculateDomain() {\n    this.setDomain(this.colorDomain);\n  }\n  getTickSize() {\n    return 0;\n  }\n};\nvar GradientLegendScale = class {\n  constructor(axis) {\n    this.axis = axis;\n  }\n};\n__decorateClass([\n  Validate32(OBJECT9),\n  ProxyProperty3(\"axis.label\")\n], GradientLegendScale.prototype, \"label\", 2);\n__decorateClass([\n  Validate32(OBJECT9),\n  ProxyProperty3(\"axis.interval\")\n], GradientLegendScale.prototype, \"interval\", 2);\n__decorateClass([\n  ProxyProperty3(\"axis.seriesAreaPadding\")\n], GradientLegendScale.prototype, \"padding\", 2);\nvar GradientLegend = class {\n  constructor(ctx) {\n    this.ctx = ctx;\n    this.id = createId3(this);\n    this.group = new Group6({ name: \"legend\", layer: true, zIndex: Layers5.LEGEND_ZINDEX });\n    this.gradient = new GradientBar();\n    this.destroyFns = [];\n    this.enabled = false;\n    this.position = \"bottom\";\n    this.reverseOrder = void 0;\n    // Placeholder\n    this.pagination = void 0;\n    this.spacing = 20;\n    this.data = [];\n    this.listeners = {};\n    this.latestGradientBox = void 0;\n    this.layoutService = ctx.layoutService;\n    this.destroyFns.push(this.layoutService.addListener(\"start-layout\", (e) => this.update(e)));\n    this.highlightManager = ctx.highlightManager;\n    this.destroyFns.push(this.highlightManager.addListener(\"highlight-change\", () => this.onChartHoverChange()));\n    this.gradientRect = new Rect();\n    this.gradientFill = new LinearGradientFill();\n    this.gradientFill.mask = this.gradientRect;\n    this.group.append(this.gradientFill);\n    this.arrow = new Triangle();\n    this.group.append(this.arrow);\n    this.axisGridGroup = new Group6({ name: \"legend-axis-grid-group\" });\n    this.group.append(this.axisGridGroup);\n    this.axisGroup = new Group6({ name: \"legend-axis-group\" });\n    this.group.append(this.axisGroup);\n    this.axis = new GradientLegendAxis(ctx);\n    this.axis.attachAxis(this.axisGroup, this.axisGridGroup);\n    this.scale = new GradientLegendScale(this.axis);\n    this.destroyFns.push(() => this.detachLegend());\n  }\n  getOrientation() {\n    switch (this.position) {\n      case \"right\":\n      case \"left\":\n        return \"vertical\";\n      case \"bottom\":\n      case \"top\":\n        return \"horizontal\";\n    }\n  }\n  destroy() {\n    this.destroyFns.forEach((f) => f());\n  }\n  attachLegend(scene) {\n    scene.appendChild(this.group);\n  }\n  detachLegend() {\n    this.group.parent?.removeChild(this.group);\n  }\n  update(ctx) {\n    const { shrinkRect } = ctx;\n    const data = this.data[0];\n    if (!this.enabled || !data || !data.enabled) {\n      this.group.visible = false;\n      return { ...ctx, shrinkRect: shrinkRect.clone() };\n    }\n    const { colorRange } = this.normalizeColorArrays(data);\n    const gradientBox = this.updateGradientRect(shrinkRect, colorRange);\n    const axisBox = this.updateAxis(data, gradientBox);\n    const { newShrinkRect, translateX, translateY } = this.getMeasurements(shrinkRect, gradientBox, axisBox);\n    this.updateArrow(gradientBox);\n    this.group.visible = true;\n    this.group.translationX = translateX;\n    this.group.translationY = translateY;\n    this.latestGradientBox = gradientBox;\n    return { ...ctx, shrinkRect: newShrinkRect };\n  }\n  normalizeColorArrays(data) {\n    let colorDomain = data.colorDomain.slice();\n    const colorRange = data.colorRange.slice();\n    if (colorDomain.length === colorRange.length) {\n      return { colorDomain, colorRange };\n    }\n    if (colorDomain.length > colorRange.length) {\n      colorRange.splice(colorDomain.length);\n    }\n    const count = colorRange.length;\n    colorDomain = colorRange.map((_, i) => {\n      const [d0, d1] = colorDomain;\n      if (i === 0)\n        return d0;\n      if (i === count - 1)\n        return d1;\n      return d0 + (d1 - d0) * i / (count - 1);\n    });\n    return { colorDomain, colorRange };\n  }\n  updateGradientRect(shrinkRect, colorRange) {\n    const { reverseOrder, gradientFill, gradientRect } = this;\n    const { preferredLength: gradientLength, thickness } = this.gradient;\n    const gradientBox = new BBox4(0, 0, 0, 0);\n    const vertical = this.getOrientation() === \"vertical\";\n    if (vertical) {\n      const maxHeight = shrinkRect.height;\n      const preferredHeight = gradientLength;\n      gradientBox.x = 0;\n      gradientBox.y = 0;\n      gradientBox.width = thickness;\n      gradientBox.height = Math.min(maxHeight, preferredHeight);\n    } else {\n      const maxWidth = shrinkRect.width;\n      const preferredWidth = gradientLength;\n      gradientBox.x = 0;\n      gradientBox.y = 0;\n      gradientBox.width = Math.min(maxWidth, preferredWidth);\n      gradientBox.height = thickness;\n    }\n    gradientFill.stops = colorRange;\n    if (vertical) {\n      gradientFill.direction = reverseOrder ? \"to-bottom\" : \"to-top\";\n    } else {\n      gradientFill.direction = reverseOrder ? \"to-left\" : \"to-right\";\n    }\n    gradientRect.x = gradientBox.x;\n    gradientRect.y = gradientBox.y;\n    gradientRect.width = gradientBox.width;\n    gradientRect.height = gradientBox.height;\n    return gradientBox;\n  }\n  updateAxis(data, gradientBox) {\n    const { reverseOrder, axis } = this;\n    const vertical = this.getOrientation() === \"vertical\";\n    const positiveAxis = reverseOrder !== vertical;\n    axis.position = vertical ? \"right\" : \"bottom\";\n    axis.colorDomain = positiveAxis ? data.colorDomain.slice().reverse() : data.colorDomain;\n    axis.calculateDomain();\n    axis.range = vertical ? [0, gradientBox.height] : [0, gradientBox.width];\n    axis.gridLength = 0;\n    axis.translation.x = gradientBox.x + (vertical ? gradientBox.width : 0);\n    axis.translation.y = gradientBox.y + (vertical ? 0 : gradientBox.height);\n    const axisBox = axis.calculateLayout().bbox;\n    axis.update();\n    return axisBox;\n  }\n  updateArrow(gradientBox) {\n    const {\n      arrow,\n      axis: { label, scale }\n    } = this;\n    const highlighted = this.highlightManager.getActiveHighlight();\n    const colorValue = highlighted?.colorValue;\n    if (highlighted == null || colorValue == null) {\n      arrow.visible = false;\n      return;\n    }\n    const vertical = this.getOrientation() === \"vertical\";\n    const size = label.fontSize ?? 0;\n    const t = scale.convert(colorValue);\n    let x;\n    let y;\n    let rotation;\n    if (vertical) {\n      x = gradientBox.x - size / 2;\n      y = gradientBox.y + t;\n      rotation = Math.PI / 2;\n    } else {\n      x = gradientBox.x + t;\n      y = gradientBox.y - size / 2;\n      rotation = Math.PI;\n    }\n    arrow.fill = label.color;\n    arrow.size = size;\n    arrow.translationX = x;\n    arrow.translationY = y;\n    arrow.rotation = rotation;\n    arrow.visible = true;\n  }\n  getMeasurements(shrinkRect, gradientBox, axisBox) {\n    let width;\n    let height;\n    const vertical = this.getOrientation() === \"vertical\";\n    if (vertical) {\n      width = gradientBox.width + axisBox.width;\n      height = gradientBox.height;\n    } else {\n      width = gradientBox.width;\n      height = gradientBox.height + axisBox.height;\n    }\n    const { spacing } = this;\n    const newShrinkRect = shrinkRect.clone();\n    let left;\n    let top;\n    if (this.position === \"left\") {\n      left = shrinkRect.x;\n      top = shrinkRect.y + shrinkRect.height / 2 - height / 2;\n      newShrinkRect.shrink(width + spacing, \"left\");\n    } else if (this.position === \"right\") {\n      left = shrinkRect.x + shrinkRect.width - width;\n      top = shrinkRect.y + shrinkRect.height / 2 - height / 2;\n      newShrinkRect.shrink(width + spacing, \"right\");\n    } else if (this.position === \"top\") {\n      left = shrinkRect.x + shrinkRect.width / 2 - width / 2;\n      top = shrinkRect.y;\n      newShrinkRect.shrink(height + spacing, \"top\");\n    } else {\n      left = shrinkRect.x + shrinkRect.width / 2 - width / 2;\n      top = shrinkRect.y + shrinkRect.height - height;\n      newShrinkRect.shrink(height + spacing, \"bottom\");\n    }\n    return {\n      translateX: left,\n      translateY: top,\n      gradientBox,\n      newShrinkRect\n    };\n  }\n  computeBBox() {\n    return this.group.computeBBox();\n  }\n  onChartHoverChange() {\n    if (this.enabled && this.latestGradientBox != null) {\n      this.updateArrow(this.latestGradientBox);\n    }\n  }\n};\nGradientLegend.className = \"GradientLegend\";\n__decorateClass([\n  Validate32(BOOLEAN16)\n], GradientLegend.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate32(POSITION)\n], GradientLegend.prototype, \"position\", 2);\n__decorateClass([\n  Validate32(BOOLEAN16, { optional: true })\n], GradientLegend.prototype, \"reverseOrder\", 2);\n__decorateClass([\n  Validate32(POSITIVE_NUMBER9)\n], GradientLegend.prototype, \"spacing\", 2);\n\n// packages/ag-charts-enterprise/src/gradient-legend/gradientLegendModule.ts\nvar GradientLegendModule = {\n  type: \"legend\",\n  optionsKey: \"gradientLegend\",\n  packageType: \"enterprise\",\n  chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n  identifier: \"gradient\",\n  instanceConstructor: GradientLegend,\n  themeTemplate: {\n    enabled: false,\n    position: \"bottom\",\n    spacing: 20,\n    scale: {\n      padding: 8,\n      label: {\n        color: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_LABEL_COLOUR,\n        fontStyle: void 0,\n        fontWeight: void 0,\n        fontSize: 12,\n        fontFamily: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_FONT_FAMILY,\n        formatter: void 0\n      },\n      interval: {\n        minSpacing: 1\n      }\n    },\n    gradient: {\n      preferredLength: 100,\n      thickness: 16\n    },\n    reverseOrder: false\n  }\n};\n\n// packages/ag-charts-enterprise/src/license/md5.ts\nvar MD5 = class {\n  constructor() {\n    this.ieCompatibility = false;\n  }\n  init() {\n    this.ieCompatibility = this.md5(\"hello\") != \"5d41402abc4b2a76b9719d911017c592\";\n  }\n  md5cycle(x, k) {\n    let a = x[0], b = x[1], c = x[2], d = x[3];\n    a = this.ff(a, b, c, d, k[0], 7, -680876936);\n    d = this.ff(d, a, b, c, k[1], 12, -389564586);\n    c = this.ff(c, d, a, b, k[2], 17, 606105819);\n    b = this.ff(b, c, d, a, k[3], 22, -1044525330);\n    a = this.ff(a, b, c, d, k[4], 7, -176418897);\n    d = this.ff(d, a, b, c, k[5], 12, 1200080426);\n    c = this.ff(c, d, a, b, k[6], 17, -1473231341);\n    b = this.ff(b, c, d, a, k[7], 22, -45705983);\n    a = this.ff(a, b, c, d, k[8], 7, 1770035416);\n    d = this.ff(d, a, b, c, k[9], 12, -1958414417);\n    c = this.ff(c, d, a, b, k[10], 17, -42063);\n    b = this.ff(b, c, d, a, k[11], 22, -1990404162);\n    a = this.ff(a, b, c, d, k[12], 7, 1804603682);\n    d = this.ff(d, a, b, c, k[13], 12, -40341101);\n    c = this.ff(c, d, a, b, k[14], 17, -1502002290);\n    b = this.ff(b, c, d, a, k[15], 22, 1236535329);\n    a = this.gg(a, b, c, d, k[1], 5, -165796510);\n    d = this.gg(d, a, b, c, k[6], 9, -1069501632);\n    c = this.gg(c, d, a, b, k[11], 14, 643717713);\n    b = this.gg(b, c, d, a, k[0], 20, -373897302);\n    a = this.gg(a, b, c, d, k[5], 5, -701558691);\n    d = this.gg(d, a, b, c, k[10], 9, 38016083);\n    c = this.gg(c, d, a, b, k[15], 14, -660478335);\n    b = this.gg(b, c, d, a, k[4], 20, -405537848);\n    a = this.gg(a, b, c, d, k[9], 5, 568446438);\n    d = this.gg(d, a, b, c, k[14], 9, -1019803690);\n    c = this.gg(c, d, a, b, k[3], 14, -187363961);\n    b = this.gg(b, c, d, a, k[8], 20, 1163531501);\n    a = this.gg(a, b, c, d, k[13], 5, -1444681467);\n    d = this.gg(d, a, b, c, k[2], 9, -51403784);\n    c = this.gg(c, d, a, b, k[7], 14, 1735328473);\n    b = this.gg(b, c, d, a, k[12], 20, -1926607734);\n    a = this.hh(a, b, c, d, k[5], 4, -378558);\n    d = this.hh(d, a, b, c, k[8], 11, -2022574463);\n    c = this.hh(c, d, a, b, k[11], 16, 1839030562);\n    b = this.hh(b, c, d, a, k[14], 23, -35309556);\n    a = this.hh(a, b, c, d, k[1], 4, -1530992060);\n    d = this.hh(d, a, b, c, k[4], 11, 1272893353);\n    c = this.hh(c, d, a, b, k[7], 16, -155497632);\n    b = this.hh(b, c, d, a, k[10], 23, -1094730640);\n    a = this.hh(a, b, c, d, k[13], 4, 681279174);\n    d = this.hh(d, a, b, c, k[0], 11, -358537222);\n    c = this.hh(c, d, a, b, k[3], 16, -722521979);\n    b = this.hh(b, c, d, a, k[6], 23, 76029189);\n    a = this.hh(a, b, c, d, k[9], 4, -640364487);\n    d = this.hh(d, a, b, c, k[12], 11, -421815835);\n    c = this.hh(c, d, a, b, k[15], 16, 530742520);\n    b = this.hh(b, c, d, a, k[2], 23, -995338651);\n    a = this.ii(a, b, c, d, k[0], 6, -198630844);\n    d = this.ii(d, a, b, c, k[7], 10, 1126891415);\n    c = this.ii(c, d, a, b, k[14], 15, -1416354905);\n    b = this.ii(b, c, d, a, k[5], 21, -57434055);\n    a = this.ii(a, b, c, d, k[12], 6, 1700485571);\n    d = this.ii(d, a, b, c, k[3], 10, -1894986606);\n    c = this.ii(c, d, a, b, k[10], 15, -1051523);\n    b = this.ii(b, c, d, a, k[1], 21, -2054922799);\n    a = this.ii(a, b, c, d, k[8], 6, 1873313359);\n    d = this.ii(d, a, b, c, k[15], 10, -30611744);\n    c = this.ii(c, d, a, b, k[6], 15, -1560198380);\n    b = this.ii(b, c, d, a, k[13], 21, 1309151649);\n    a = this.ii(a, b, c, d, k[4], 6, -145523070);\n    d = this.ii(d, a, b, c, k[11], 10, -1120210379);\n    c = this.ii(c, d, a, b, k[2], 15, 718787259);\n    b = this.ii(b, c, d, a, k[9], 21, -343485551);\n    x[0] = this.add32(a, x[0]);\n    x[1] = this.add32(b, x[1]);\n    x[2] = this.add32(c, x[2]);\n    x[3] = this.add32(d, x[3]);\n  }\n  cmn(q, a, b, x, s, t) {\n    a = this.add32(this.add32(a, q), this.add32(x, t));\n    return this.add32(a << s | a >>> 32 - s, b);\n  }\n  ff(a, b, c, d, x, s, t) {\n    return this.cmn(b & c | ~b & d, a, b, x, s, t);\n  }\n  gg(a, b, c, d, x, s, t) {\n    return this.cmn(b & d | c & ~d, a, b, x, s, t);\n  }\n  hh(a, b, c, d, x, s, t) {\n    return this.cmn(b ^ c ^ d, a, b, x, s, t);\n  }\n  ii(a, b, c, d, x, s, t) {\n    return this.cmn(c ^ (b | ~d), a, b, x, s, t);\n  }\n  md51(s) {\n    const n = s.length;\n    const state = [1732584193, -271733879, -1732584194, 271733878];\n    let i;\n    for (i = 64; i <= s.length; i += 64) {\n      this.md5cycle(state, this.md5blk(s.substring(i - 64, i)));\n    }\n    s = s.substring(i - 64);\n    const tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    for (i = 0; i < s.length; i++) {\n      tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);\n    }\n    tail[i >> 2] |= 128 << (i % 4 << 3);\n    if (i > 55) {\n      this.md5cycle(state, tail);\n      for (i = 0; i < 16; i++) {\n        tail[i] = 0;\n      }\n    }\n    tail[14] = n * 8;\n    this.md5cycle(state, tail);\n    return state;\n  }\n  /* there needs to be support for Unicode here, * unless we pretend that we can redefine the MD-5\n   * algorithm for multi-byte characters (perhaps by adding every four 16-bit characters and\n   * shortening the sum to 32 bits). Otherwise I suthis.ggest performing MD-5 as if every character\n   * was two bytes--e.g., 0040 0025 = @%--but then how will an ordinary MD-5 sum be matched?\n   * There is no way to standardize text to something like UTF-8 before transformation; speed cost is\n   * utterly prohibitive. The JavaScript standard itself needs to look at this: it should start\n   * providing access to strings as preformed UTF-8 8-bit unsigned value arrays.\n   */\n  md5blk(s) {\n    const md5blks = [];\n    for (let i = 0; i < 64; i += 4) {\n      md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n    }\n    return md5blks;\n  }\n  rhex(n) {\n    const hex_chr = \"0123456789abcdef\".split(\"\");\n    let s = \"\", j = 0;\n    for (; j < 4; j++) {\n      s += hex_chr[n >> j * 8 + 4 & 15] + hex_chr[n >> j * 8 & 15];\n    }\n    return s;\n  }\n  hex(x) {\n    for (let i = 0; i < x.length; i++) {\n      x[i] = this.rhex(x[i]);\n    }\n    return x.join(\"\");\n  }\n  md5(s) {\n    return this.hex(this.md51(s));\n  }\n  add32(a, b) {\n    return this.ieCompatibility ? this.add32Compat(a, b) : this.add32Std(a, b);\n  }\n  /* this function is much faster, so if possible we use it. Some IEs are the only ones I know of that\n   need the idiotic second function, generated by an if clause.  */\n  add32Std(a, b) {\n    return a + b & 4294967295;\n  }\n  add32Compat(x, y) {\n    const lsw = (x & 65535) + (y & 65535), msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n    return msw << 16 | lsw & 65535;\n  }\n};\n\n// packages/ag-charts-enterprise/src/license/licenseManager.ts\nfunction missingOrEmpty(value) {\n  return value == null || value.length === 0;\n}\nvar LICENSE_TYPES = {\n  \"01\": \"GRID\",\n  \"02\": \"CHARTS\",\n  \"0102\": \"BOTH\"\n};\nvar _LicenseManager = class _LicenseManager {\n  constructor(document2) {\n    this.gridContext = false;\n    this.watermarkMessage = void 0;\n    this.totalMessageLength = 124;\n    this.document = document2;\n    this.md5 = new MD5();\n    this.md5.init();\n  }\n  validateLicense() {\n    const licenseDetails = this.getLicenseDetails(this.licenseKey, this.gridContext);\n    const currentLicenseName = `AG ${licenseDetails.currentLicenseType === \"BOTH\" ? \"Grid and \" : \"\"}Charts Enterprise`;\n    const suppliedLicenseName = licenseDetails.suppliedLicenseType === void 0 ? \"\" : `AG ${licenseDetails.suppliedLicenseType === \"BOTH\" ? \"Grid and AG Charts\" : licenseDetails.suppliedLicenseType === \"GRID\" ? \"Grid\" : \"Charts\"} Enterprise`;\n    if (licenseDetails.missing) {\n      if (!this.isWebsiteUrl() || this.isForceWatermark()) {\n        this.outputMissingLicenseKey(currentLicenseName);\n      }\n    } else if (licenseDetails.expired) {\n      const gridReleaseDate = _LicenseManager.getChartsReleaseDate();\n      const formattedReleaseDate = _LicenseManager.formatDate(gridReleaseDate);\n      this.outputExpiredKey(licenseDetails.expiry, formattedReleaseDate, suppliedLicenseName);\n    } else if (!licenseDetails.valid) {\n      this.outputInvalidLicenseKey(\n        !!licenseDetails.incorrectLicenseType,\n        currentLicenseName,\n        suppliedLicenseName\n      );\n    } else if (licenseDetails.isTrial && licenseDetails.trialExpired) {\n      this.outputExpiredTrialKey(licenseDetails.expiry, currentLicenseName, suppliedLicenseName);\n    }\n  }\n  static extractExpiry(license) {\n    const restrictionHashed = license.substring(license.lastIndexOf(\"_\") + 1, license.length);\n    return new Date(parseInt(_LicenseManager.decode(restrictionHashed), 10));\n  }\n  static extractLicenseComponents(licenseKey) {\n    let cleanedLicenseKey = licenseKey.replace(/[\\u200B-\\u200D\\uFEFF]/g, \"\");\n    cleanedLicenseKey = cleanedLicenseKey.replace(/\\r?\\n|\\r/g, \"\");\n    if (licenseKey.length <= 32) {\n      return { md5: null, license: licenseKey, version: null, isTrial: null };\n    }\n    const hashStart = cleanedLicenseKey.length - 32;\n    const md5 = cleanedLicenseKey.substring(hashStart);\n    const license = cleanedLicenseKey.substring(0, hashStart);\n    const [version, isTrial, type] = _LicenseManager.extractBracketedInformation(cleanedLicenseKey);\n    return { md5, license, version, isTrial, type };\n  }\n  getLicenseDetails(licenseKey, gridContext = false) {\n    const currentLicenseType = \"CHARTS\";\n    if (missingOrEmpty(licenseKey)) {\n      return {\n        licenseKey,\n        valid: false,\n        missing: true,\n        currentLicenseType\n      };\n    }\n    const chartsReleaseDate = _LicenseManager.getChartsReleaseDate();\n    const { md5, license, version, isTrial, type } = _LicenseManager.extractLicenseComponents(licenseKey);\n    let valid = md5 === this.md5.md5(license) && licenseKey.indexOf(\"For_Trialing_ag-Grid_Only\") === -1;\n    let trialExpired = void 0;\n    let expired = void 0;\n    let expiry = null;\n    let incorrectLicenseType = false;\n    let suppliedLicenseType = void 0;\n    function handleTrial() {\n      const now = /* @__PURE__ */ new Date();\n      trialExpired = expiry < now;\n      expired = void 0;\n    }\n    if (valid) {\n      expiry = _LicenseManager.extractExpiry(license);\n      valid = !isNaN(expiry.getTime());\n      if (valid) {\n        expired = chartsReleaseDate > expiry;\n        switch (version) {\n          case \"legacy\":\n          case \"2\": {\n            valid = false;\n            break;\n          }\n          case \"3\": {\n            if (missingOrEmpty(type)) {\n              valid = false;\n            } else {\n              suppliedLicenseType = type;\n              if (type !== LICENSE_TYPES[\"02\"] && type !== LICENSE_TYPES[\"0102\"]) {\n                valid = false;\n                incorrectLicenseType = true;\n              } else if (isTrial) {\n                handleTrial();\n              }\n            }\n          }\n        }\n      }\n    }\n    if (!valid) {\n      return {\n        licenseKey,\n        valid,\n        incorrectLicenseType,\n        currentLicenseType,\n        suppliedLicenseType\n      };\n    }\n    return {\n      licenseKey,\n      valid,\n      expiry: _LicenseManager.formatDate(expiry),\n      expired,\n      version,\n      isTrial,\n      trialExpired,\n      invalidLicenseTypeForCombo: gridContext ? suppliedLicenseType !== \"BOTH\" : void 0,\n      incorrectLicenseType,\n      currentLicenseType,\n      suppliedLicenseType\n    };\n  }\n  isDisplayWatermark() {\n    return this.isForceWatermark() || !this.isLocalhost() && !this.isWebsiteUrl() && !missingOrEmpty(this.watermarkMessage);\n  }\n  getWatermarkMessage() {\n    return this.watermarkMessage || \"\";\n  }\n  getHostname() {\n    if (!this.document) {\n      return \"localhost\";\n    }\n    const win = this.document.defaultView || window;\n    if (!win) {\n      return \"localhost\";\n    }\n    const loc = win.location;\n    const { hostname = \"\" } = loc;\n    return hostname;\n  }\n  isForceWatermark() {\n    if (!this.document) {\n      return false;\n    }\n    const win = this.document?.defaultView ?? typeof window != \"undefined\" ? window : void 0;\n    if (!win) {\n      return false;\n    }\n    const { pathname } = win.location;\n    return pathname ? pathname.indexOf(\"forceWatermark\") !== -1 : false;\n  }\n  isWebsiteUrl() {\n    const hostname = this.getHostname();\n    return hostname.match(/^((?:[\\w-]+\\.)?ag-grid\\.com)$/) !== null;\n  }\n  isLocalhost() {\n    const hostname = this.getHostname();\n    return hostname.match(/^(?:127\\.0\\.0\\.1|localhost)$/) !== null;\n  }\n  static formatDate(date) {\n    const monthNames = [\n      \"January\",\n      \"February\",\n      \"March\",\n      \"April\",\n      \"May\",\n      \"June\",\n      \"July\",\n      \"August\",\n      \"September\",\n      \"October\",\n      \"November\",\n      \"December\"\n    ];\n    const day = date.getDate();\n    const monthIndex = date.getMonth();\n    const year = date.getFullYear();\n    return day + \" \" + monthNames[monthIndex] + \" \" + year;\n  }\n  static getChartsReleaseDate() {\n    return new Date(parseInt(_LicenseManager.decode(_LicenseManager.RELEASE_INFORMATION), 10));\n  }\n  static decode(input) {\n    const keystr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n    let t = \"\";\n    let n, r, i;\n    let s, o, u, a;\n    let f = 0;\n    const e = input.replace(/[^A-Za-z0-9+/=]/g, \"\");\n    while (f < e.length) {\n      s = keystr.indexOf(e.charAt(f++));\n      o = keystr.indexOf(e.charAt(f++));\n      u = keystr.indexOf(e.charAt(f++));\n      a = keystr.indexOf(e.charAt(f++));\n      n = s << 2 | o >> 4;\n      r = (o & 15) << 4 | u >> 2;\n      i = (u & 3) << 6 | a;\n      t = t + String.fromCharCode(n);\n      if (u != 64) {\n        t = t + String.fromCharCode(r);\n      }\n      if (a != 64) {\n        t = t + String.fromCharCode(i);\n      }\n    }\n    t = _LicenseManager.utf8_decode(t);\n    return t;\n  }\n  static utf8_decode(input) {\n    input = input.replace(/rn/g, \"n\");\n    let t = \"\";\n    for (let n = 0; n < input.length; n++) {\n      const r = input.charCodeAt(n);\n      if (r < 128) {\n        t += String.fromCharCode(r);\n      } else if (r > 127 && r < 2048) {\n        t += String.fromCharCode(r >> 6 | 192);\n        t += String.fromCharCode(r & 63 | 128);\n      } else {\n        t += String.fromCharCode(r >> 12 | 224);\n        t += String.fromCharCode(r >> 6 & 63 | 128);\n        t += String.fromCharCode(r & 63 | 128);\n      }\n    }\n    return t;\n  }\n  setLicenseKey(licenseKey, gridContext = false) {\n    this.gridContext = gridContext;\n    this.licenseKey = licenseKey;\n  }\n  static extractBracketedInformation(licenseKey) {\n    if (!licenseKey.includes(\"[\")) {\n      return [\"legacy\", false, void 0];\n    }\n    const matches = licenseKey.match(/\\[(.*?)\\]/g).map((match) => match.replace(\"[\", \"\").replace(\"]\", \"\"));\n    if (!matches || matches.length === 0) {\n      return [\"legacy\", false, void 0];\n    }\n    const isTrial = matches.filter((match) => match === \"TRIAL\").length === 1;\n    const rawVersion = matches.filter((match) => match.indexOf(\"v\") === 0)[0];\n    const version = rawVersion ? rawVersion.replace(\"v\", \"\") : \"legacy\";\n    const type = LICENSE_TYPES[matches.filter((match) => LICENSE_TYPES[match])[0]];\n    return [version, isTrial, type];\n  }\n  centerPadAndOutput(input) {\n    const paddingRequired = this.totalMessageLength - input.length;\n    console.error(input.padStart(paddingRequired / 2 + input.length, \"*\").padEnd(this.totalMessageLength, \"*\"));\n  }\n  padAndOutput(input, padding = \"*\", terminateWithPadding = \"\") {\n    console.error(\n      input.padEnd(this.totalMessageLength - terminateWithPadding.length, padding) + terminateWithPadding\n    );\n  }\n  outputInvalidLicenseKey(incorrectLicenseType, currentLicenseName, suppliedLicenseName) {\n    if (!this.gridContext) {\n      if (incorrectLicenseType) {\n        this.centerPadAndOutput(\"\");\n        this.centerPadAndOutput(` ${currentLicenseName} License `);\n        this.centerPadAndOutput(\" Incompatible License Key \");\n        this.padAndOutput(\n          `* Your license key is for ${suppliedLicenseName} only and does not cover you for ${currentLicenseName}.`,\n          \" \",\n          \"*\"\n        );\n        this.padAndOutput(\"* Please contact info@ag-grid.com to obtain a combined license key.\", \" \", \"*\");\n        this.centerPadAndOutput(\"\");\n        this.centerPadAndOutput(\"\");\n      } else {\n        this.centerPadAndOutput(\"\");\n        this.centerPadAndOutput(` ${currentLicenseName} License `);\n        this.centerPadAndOutput(\" Invalid License Key \");\n        this.padAndOutput(\n          `* Your license key is not valid - please contact info@ag-grid.com to obtain a valid license.`,\n          \" \",\n          \"*\"\n        );\n        this.centerPadAndOutput(\"\");\n        this.centerPadAndOutput(\"\");\n      }\n    }\n    this.watermarkMessage = \"Invalid License\";\n  }\n  outputExpiredTrialKey(formattedExpiryDate, currentLicenseName, suppliedLicenseName) {\n    if (!this.gridContext) {\n      this.centerPadAndOutput(\"\");\n      this.centerPadAndOutput(` ${currentLicenseName} License `);\n      this.centerPadAndOutput(\" Trial Period Expired. \");\n      this.padAndOutput(\n        `* Your trial only license for ${suppliedLicenseName} expired on ${formattedExpiryDate}.`,\n        \" \",\n        \"*\"\n      );\n      this.padAndOutput(\"* Please email info@ag-grid.com to purchase a license.\", \" \", \"*\");\n      this.centerPadAndOutput(\"\");\n      this.centerPadAndOutput(\"\");\n    }\n    this.watermarkMessage = \"Trial Period Expired\";\n  }\n  outputMissingLicenseKey(currentLicenseName) {\n    if (!this.gridContext) {\n      this.centerPadAndOutput(\"\");\n      this.centerPadAndOutput(` ${currentLicenseName} License `);\n      this.centerPadAndOutput(\" License Key Not Found \");\n      this.padAndOutput(`* All ${currentLicenseName} features are unlocked for trial.`, \" \", \"*\");\n      this.padAndOutput(\n        \"* If you want to hide the watermark please email info@ag-grid.com for a trial license key.\",\n        \" \",\n        \"*\"\n      );\n      this.centerPadAndOutput(\"\");\n      this.centerPadAndOutput(\"\");\n    }\n    this.watermarkMessage = \"For Trial Use Only\";\n  }\n  outputExpiredKey(formattedExpiryDate, formattedReleaseDate, currentLicenseName) {\n    if (!this.gridContext) {\n      this.centerPadAndOutput(\"\");\n      this.centerPadAndOutput(` ${currentLicenseName} License `);\n      this.centerPadAndOutput(\" Incompatible Software Version \");\n      this.padAndOutput(\n        `* Your license key works with versions of ${currentLicenseName} released before ${formattedExpiryDate}.`,\n        \" \",\n        \"*\"\n      );\n      this.padAndOutput(`* The version you are trying to use was released on ${formattedReleaseDate}.`, \" \", \"*\");\n      this.padAndOutput(\"* Please contact info@ag-grid.com to renew your license key.\", \" \", \"*\");\n      this.centerPadAndOutput(\"\");\n      this.centerPadAndOutput(\"\");\n    }\n    this.watermarkMessage = \"License Expired\";\n  }\n};\n_LicenseManager.RELEASE_INFORMATION = \"MTcyMDAyMjAyNTIyOQ==\";\nvar LicenseManager = _LicenseManager;\n\n// packages/ag-charts-enterprise/src/license/watermark.ts\n\n\n// packages/ag-charts-enterprise/src/license/watermark.css\nvar watermark_default = \".ag-watermark{position:absolute;bottom:20px;right:25px;font-weight:bold;font-family:Impact,sans-serif;font-size:19px;opacity:0.7;animation:1s ease-out 3s ag-watermark-fadeout;color:#9b9b9b;pointer-events:none;&::before{content:'';display:block;height:40px;width:170px;background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU4IiBoZWlnaHQ9IjQwIiB2aWV3Qm94PSIwIDAgMjU4IDQwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cGF0aCBkPSJNMjUuNzc5IDI4LjY1N0gxMy4zNTlMMTEuMTczIDM0LjAxMkg1LjY3Mjk3TDE3LjE4MiA3LjA1OTk5SDIxLjk1M0wzMy40NjIgMzQuMDEySDI3Ljk2MkwyNS43NzYgMjguNjU3SDI1Ljc3OVpNMjQuMDY4IDI0LjM5N0wxOS41ODggMTMuNDM0TDE1LjEwNyAyNC4zOTdIMjQuMDY4Wk02Mi4wOTIgMTguODIzSDQ5LjgxN1YyMy4wODZINTYuNzc1QzU2LjU1NSAyNS4yMjIgNTUuNzU1IDI2LjkyNyA1NC4zNzIgMjguMjAyQzUyLjk4OSAyOS40NzYgNTEuMTY2IDMwLjExNSA0OC45MDkgMzAuMTE1QzQ3LjYyMiAzMC4xMTUgNDYuNDUgMjkuODg1IDQ1LjM5MyAyOS40MjNDNDQuMzU4MyAyOC45NzgxIDQzLjQzMjYgMjguMzEzOCA0Mi42OCAyNy40NzZDNDEuOTI3IDI2LjYzOSA0MS4zNDQgMjUuNjMxIDQwLjkzMSAyNC40NTNDNDAuNTE5IDIzLjI3NSA0MC4zMTEgMjEuOTcgNDAuMzExIDIwLjUzN0M0MC4zMTEgMTkuMTA1IDQwLjUxNiAxNy44IDQwLjkzMSAxNi42MjFDNDEuMzQ0IDE1LjQ0MyA0MS45MjcgMTQuNDM2IDQyLjY4IDEzLjU5OEM0My40Mzc2IDEyLjc1NzcgNDQuMzY5NiAxMi4wOTMyIDQ1LjQxMSAxMS42NTFDNDYuNDc4IDExLjE4OSA0Ny42NTYgMTAuOTYgNDguOTQ2IDEwLjk2QzUxLjYxMiAxMC45NiA1My42MzcgMTEuNjAyIDU1LjAyIDEyLjg4NUw1OC4zIDkuNjA0OTlDNTUuODE3IDcuNjY5OTkgNTIuNjc2IDYuNjk5OTkgNDguODcyIDYuNjk5OTlDNDYuNzYgNi42OTk5OSA0NC44NTMgNy4wMzQ5OSA0My4xNTQgNy43MDA5OUM0MS40NTUgOC4zNjc5OSAzOS45OTggOS4zMDM5OSAzOC43ODMgMTAuNTA0QzM3LjU2NyAxMS43MDcgMzYuNjM0IDEzLjE1OCAzNS45NzcgMTQuODU3QzM1LjMxOSAxNi41NTYgMzQuOTk0IDE4LjQ1MSAzNC45OTQgMjAuNTRDMzQuOTk0IDIyLjYzIDM1LjMyOSAyNC40OTQgMzUuOTk1IDI2LjIwNUMzNi42NjIgMjcuOTE2IDM3LjYwNSAyOS4zNzQgMzguODE3IDMwLjU3N0M0MC4wMzIgMzEuNzggNDEuNDg2IDMyLjcxMyA0My4xODggMzMuMzgzQzQ0Ljg4OCAzNC4wNDkgNDYuNzgyIDM0LjM4NCA0OC44NzIgMzQuMzg0QzUwLjk2MSAzNC4zODQgNTIuNzUgMzQuMDQ5IDU0LjM5IDMzLjM4M0M1Ni4wMzEgMzIuNzE2IDU3LjQyNiAzMS43OCA1OC41NzkgMzAuNTc3QzU5LjczMyAyOS4zNzQgNjAuNjE5IDI3LjkxNiA2MS4yMzkgMjYuMjA1QzYxLjg2IDI0LjQ5NCA2Mi4xNyAyMi42MDUgNjIuMTcgMjAuNTRDNjIuMTY5NiAxOS45Njg4IDYyLjE0NDUgMTkuMzk4IDYyLjA5NSAxOC44MjlMNjIuMDkyIDE4LjgyM1pNMTUxLjgxIDE2Ljk4MUMxNTMuNDEgMTQuNjA5IDE1Ny40MTkgMTQuMzU4IDE1OS4wMjIgMTQuMzU4VjE4LjkxQzE1Ni45NTcgMTguOTEgMTU0Ljk4NSAxOC45OTYgMTUzLjc1NyAxOS44OTJDMTUyLjUyOSAyMC43OTIgMTUxLjkxOSAyMS45ODIgMTUxLjkxOSAyMy40NjRWMzMuOTlIMTQ2Ljk2NFYxNC4zNThIMTUxLjczNkwxNTEuODEgMTYuOTgxWk0xNDMuMDExIDE0LjM2MVYzNC4wMzFIMTM4LjI0TDEzOC4xMzEgMzEuMDQ1QzEzNy40NjYgMzIuMDc2IDEzNi41NTEgMzIuOTIxOSAxMzUuNDcxIDMzLjUwNEMxMzQuMzc2IDM0LjA5OSAxMzMuMDY4IDM0LjM5NiAxMzEuNTM2IDM0LjM5NkMxMzAuMiAzNC4zOTYgMTI4Ljk2MyAzNC4xNTIgMTI3LjgyMiAzMy42NjhDMTI2LjcgMzMuMTk2NCAxMjUuNjg5IDMyLjQ5NSAxMjQuODU1IDMxLjYwOUMxMjQuMDE4IDMwLjcyMiAxMjMuMzU0IDI5LjY2MiAxMjIuODcxIDI4LjQyMkMxMjIuMzg0IDI3LjE4NSAxMjIuMTQyIDI1LjgxMSAxMjIuMTQyIDI0LjMwNEMxMjIuMTQyIDIyLjc5OCAxMjIuMzg0IDIxLjM3OCAxMjIuODcxIDIwLjExNkMxMjMuMzU3IDE4Ljg1NCAxMjQuMDE4IDE3Ljc3MiAxMjQuODU1IDE2Ljg3M0MxMjUuNjg4IDE1Ljk3NjQgMTI2LjY5OCAxNS4yNjM2IDEyNy44MjIgMTQuNzhDMTI4Ljk2MyAxNC4yODEgMTMwLjIwMyAxNC4wMzMgMTMxLjUzNiAxNC4wMzNDMTMzLjA0MyAxNC4wMzMgMTM0LjMzIDE0LjMxOCAxMzUuMzk3IDE0Ljg4OEMxMzYuNDYyIDE1LjQ1ODkgMTM3LjM3NSAxNi4yNzggMTM4LjA1NyAxNy4yNzZWMTQuMzYxSDE0My4wMTFaTTEzMi42MzEgMzAuMTMzQzEzNC4yNTYgMzAuMTMzIDEzNS41NjcgMjkuNTk0IDEzNi41NjUgMjguNTEyQzEzNy41NjEgMjcuNDMgMTM4LjA2IDI1Ljk5MSAxMzguMDYgMjQuMTk2QzEzOC4wNiAyMi40MDEgMTM3LjU2MSAyMC45OSAxMzYuNTY1IDE5Ljg5OUMxMzUuNTcgMTguODA3IDEzNC4yNTkgMTguMjU4IDEzMi42MzEgMTguMjU4QzEzMS4wMDMgMTguMjU4IDEyOS43MjkgMTguODA0IDEyOC43MzQgMTkuODk5QzEyNy43MzggMjAuOTkzIDEyNy4yMzkgMjIuNDM4IDEyNy4yMzkgMjQuMjMzQzEyNy4yMzkgMjYuMDI4IDEyNy43MzUgMjcuNDMzIDEyOC43MzQgMjguNTE1QzEyOS43MjkgMjkuNTk0IDEzMS4wMjggMzAuMTM2IDEzMi42MzEgMzAuMTM2VjMwLjEzM1pNOTMuNjk4IDI3Ljg3NkM5My41Nzk1IDI4LjAwMjUgOTMuNDU2NCAyOC4xMjQ2IDkzLjMyOSAyOC4yNDJDOTEuOTQ3IDI5LjUxNiA5MC4xMjMgMzAuMTU1IDg3Ljg2NiAzMC4xNTVDODYuNTggMzAuMTU1IDg1LjQwOCAyOS45MjYgODQuMzUgMjkuNDY0QzgzLjMxNTUgMjkuMDE4OSA4Mi4zODk4IDI4LjM1NDYgODEuNjM3IDI3LjUxN0M4MC44ODQgMjYuNjc5IDgwLjMwMSAyNS42NzIgNzkuODg5IDI0LjQ5NEM3OS40NzYgMjMuMzE1IDc5LjI2OSAyMi4wMSA3OS4yNjkgMjAuNTc4Qzc5LjI2OSAxOS4xNDUgNzkuNDczIDE3Ljg0IDc5Ljg4OSAxNi42NjJDODAuMzAxIDE1LjQ4NCA4MC44ODQgMTQuNDc2IDgxLjYzNyAxMy42MzlDODIuMzk0OSAxMi43OTg3IDgzLjMyNzMgMTIuMTM0MiA4NC4zNjkgMTEuNjkyQzg1LjQzNiAxMS4yMyA4Ni42MTQgMTEgODcuOTAzIDExQzkwLjU3IDExIDkyLjU5NSAxMS42NDIgOTMuOTc3IDEyLjkyNkw5Ny4yNTggOS42NDQ5OUM5NC43NzQgNy43MTA5OSA5MS42MzMgNi43Mzk5OSA4Ny44MjkgNi43Mzk5OUM4NS43MTggNi43Mzk5OSA4My44MTEgNy4wNzQ5OSA4Mi4xMTIgNy43NDE5OUM4MC40MTMgOC40MDc5OSA3OC45NTYgOS4zNDQ5OSA3Ny43NCAxMC41NDVDNzYuNTI1IDExLjc0NyA3NS41OTIgMTMuMTk5IDc0LjkzNCAxNC44OThDNzQuMjc3IDE2LjU5NyA3My45NTEgMTguNDkxIDczLjk1MSAyMC41ODFDNzMuOTUxIDIyLjY3IDc0LjI4NiAyNC41MzQgNzQuOTUzIDI2LjI0NUM3NS42MTkgMjcuOTU3IDc2LjU2MiAyOS40MTQgNzcuNzc0IDMwLjYxN0M3OC45OSAzMS44MiA4MC40NDQgMzIuNzUzIDgyLjE0NiAzMy40MjNDODMuODQ1IDM0LjA5IDg1LjczOSAzNC40MjQgODcuODI5IDM0LjQyNEM4OS45MTkgMzQuNDI0IDkxLjcwOCAzNC4wOSA5My4zNDggMzMuNDIzQzk0LjcxOCAzMi44NjUgOTUuOTE4IDMyLjEyMSA5Ni45NDggMzEuMTkxQzk3LjE0OSAzMS4wMDggOTcuMzQ4IDMwLjgxNSA5Ny41MzcgMzAuNjJMOTMuNzAxIDI3Ljg4NUw5My42OTggMjcuODc2Wk0xMTAuODAyIDE0LjAxNUMxMDkuMTk5IDE0LjAxNSAxMDYuODM2IDE0LjQ3MSAxMDUuNjExIDE2LjE1OEwxMDUuNTM3IDYuMDE1OTlIMTAwLjc2NVYzMy45MzlIMTA1LjcyVjIyLjY0MUMxMDUuNzcxIDIxLjQ2MDcgMTA2LjI4OCAyMC4zNDg4IDEwNy4xNTcgMTkuNTQ4OUMxMDguMDI3IDE4Ljc0OTEgMTA5LjE3OCAxOC4zMjY2IDExMC4zNTggMTguMzc0QzExMy4zOTcgMTguMzc0IDExNC4yNjggMjEuMTU5IDExNC4yNjggMjIuNjQxVjMzLjkzOUgxMTkuMjIzVjIxLjA1OUMxMTkuMjIzIDIxLjA1OSAxMTkuMTQyIDE0LjAxNSAxMTAuODAyIDE0LjAxNVpNMTczLjc2MyAxNC4zNThIMTY5Ljk5OVY4LjcxNDk5SDE2NS4wNDhWMTQuMzU4SDE2MS4yODRWMTguOTE2SDE2NS4wNDhWMzQuMDAzSDE2OS45OTlWMTguOTE2SDE3My43NjNWMTQuMzU4Wk0xOTAuNzg3IDI1LjI2MkMxOTAuMTI5IDI0LjUwMTQgMTg5LjMwNyAyMy44OTk0IDE4OC4zODQgMjMuNTAxQzE4Ny40ODggMjMuMTE3IDE4Ni4zMzEgMjIuNzMyIDE4NC45NDggMjIuMzY0QzE4NC4xNjUgMjIuMTQzOSAxODMuMzkgMjEuODk3OCAxODIuNjIzIDIxLjYyNkMxODIuMTYzIDIxLjQ2MjEgMTgxLjc0MSAyMS4yMDY2IDE4MS4zODMgMjAuODc1QzE4MS4yMzUgMjAuNzQyMSAxODEuMTE4IDIwLjU3ODkgMTgxLjAzOSAyMC4zOTY0QzE4MC45NjEgMjAuMjE0IDE4MC45MjIgMjAuMDE2NiAxODAuOTI3IDE5LjgxOEMxODAuOTI3IDE5LjI3MiAxODEuMTU2IDE4Ljg0NCAxODEuNjI1IDE4LjUxQzE4Mi4xMjEgMTguMTU2IDE4Mi44NjIgMTcuOTc2IDE4My44MjYgMTcuOTc2QzE4NC43OSAxNy45NzYgMTg1LjU4NyAxOC4yMDkgMTg2LjE0OCAxOC42NjhDMTg2LjcwNiAxOS4xMjQgMTg3LjAwNyAxOS43MjUgMTg3LjA3MiAyMC41TDE4Ny4wOTQgMjAuNzgySDE5MS42MzNMMTkxLjYxNyAyMC40NkMxOTEuNTIxIDE4LjQ4NSAxOTAuNzcxIDE2LjkgMTg5LjM4NSAxNS43NUMxODguMDEyIDE0LjYxMiAxODYuMTg1IDE0LjAzMyAxODMuOTYyIDE0LjAzM0MxODIuNDc3IDE0LjAzMyAxODEuMTQxIDE0LjI4NyAxNzkuOTk0IDE0Ljc4NkMxNzguODMxIDE1LjI5MSAxNzcuOTI2IDE1Ljk5NSAxNzcuMjk2IDE2Ljg4MkMxNzYuNjczIDE3Ljc0NTUgMTc2LjMzOCAxOC43ODQgMTc2LjM0MSAxOS44NDlDMTc2LjM0MSAyMS4xNjcgMTc2LjY5OCAyMi4yNDkgMTc3LjM5OSAyMy4wNjRDMTc4LjA2IDIzLjg0MzIgMTc4Ljg5OCAyNC40NTM0IDE3OS44NDIgMjQuODQ0QzE4MC43NDQgMjUuMjE2IDE4MS45MjggMjUuNjA3IDE4My4zNjEgMjZDMTg0LjgwNiAyNi40MSAxODUuODcyIDI2Ljc4NSAxODYuNTMgMjcuMTIzQzE4Ny4xIDI3LjQxNCAxODcuMzc5IDI3Ljg0NSAxODcuMzc5IDI4LjQ0NEMxODcuMzc5IDI5LjA0MiAxODcuMTIyIDI5LjQ2NyAxODYuNTk1IDI5LjgzOUMxODYuMDQzIDMwLjIyNiAxODUuMjM3IDMwLjQyNSAxODQuMjAxIDMwLjQyNUMxODMuMTY2IDMwLjQyNSAxODIuMzk0IDMwLjE3NCAxODEuNzQ5IDI5LjY3NEMxODEuMTEzIDI5LjE4MSAxODAuNzcyIDI4LjU4OSAxODAuNzEgMjcuODY0TDE4MC42ODUgMjcuNTgySDE3Ni4wMTNMMTc2LjAyNSAyNy45MDFDMTc2LjA2NyAyOS4wOTU1IDE3Ni40NzIgMzAuMjQ4NyAxNzcuMTg4IDMxLjIwNkMxNzcuOTA3IDMyLjE4IDE3OC44OTMgMzIuOTU4IDE4MC4xMTggMzMuNTE5QzE4MS4zMzYgMzQuMDc3IDE4Mi43MzIgMzQuMzYyIDE4NC4yNjYgMzQuMzYyQzE4NS44MDEgMzQuMzYyIDE4Ny4xMDkgMzQuMTA4IDE4OC4yMzggMzMuNjA5QzE4OS4zNzYgMzMuMTA0IDE5MC4yNzIgMzIuMzk0IDE5MC45MDEgMzEuNDk0QzE5MS41MzQgMzAuNTkyIDE5MS44NTMgMjkuNTU0IDE5MS44NTMgMjguNDAzQzE5MS44MjggMjcuMTEgMTkxLjQ2NiAyNi4wNTMgMTkwLjc3NyAyNS4yNjJIMTkwLjc4N1oiIGZpbGw9IiM5QjlCOUIiLz4KPHBhdGggZD0iTTI0MS45ODIgMjUuNjU4MlYxNy43MTE3SDIyOC40NDFMMjIwLjQ5NCAyNS42NTgySDI0MS45ODJaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNTcuMjM5IDUuOTUwODFIMjQwLjI2NUwyMzIuMjU1IDEzLjg5NzNIMjU3LjIzOVY1Ljk1MDgxWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjEyLjYxMSAzMy42MDQ4TDIxNi42OCAyOS41MzYxSDIzMC40MTJWMzcuNDgyN0gyMTIuNjExVjMzLjYwNDhaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yMTUuNTk5IDIxLjc4MDNIMjI0LjM3MkwyMzIuMzgyIDEzLjgzMzdIMjE1LjU5OVYyMS43ODAzWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjA2IDMzLjYwNDdIMjEyLjYxMUwyMjAuNDk0IDI1LjY1ODJIMjA2VjMzLjYwNDdaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNDAuMjY1IDUuOTUwODFMMjM2LjE5NyAxMC4wMTk0SDIxMC4yNTlWMi4wNzI4OEgyNDAuMjY1VjUuOTUwODFaIiBmaWxsPSIjOUI5QjlCIi8+Cjwvc3ZnPgo=);background-repeat:no-repeat;background-size:170px 40px}> span{padding-left:0.7rem}}@keyframes ag-watermark-fadeout{from{opacity:0.5}to{opacity:0}}\";\n\n// packages/ag-charts-enterprise/src/license/watermark.ts\nvar { createElement: createElement5 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nfunction injectWatermark(domManager, text) {\n  domManager.addStyles(\"watermark\", watermark_default);\n  const element = domManager.addChild(\"canvas-overlay\", \"watermark\");\n  const textElement = createElement5(\"span\");\n  textElement.innerText = text;\n  element.addEventListener(\"animationend\", () => {\n    domManager.removeChild(\"canvas-overlay\", \"watermark\");\n    domManager.removeStyles(\"watermark\");\n  });\n  element.classList.add(\"ag-watermark\");\n  element.appendChild(textElement);\n}\n\n// packages/ag-charts-enterprise/src/series/box-plot/boxPlotModule.ts\n\n\n// packages/ag-charts-enterprise/src/series/box-plot/boxPlotSeries.ts\n\n\n// packages/ag-charts-enterprise/src/series/box-plot/blotPlotUtil.ts\nfunction prepareBoxPlotFromTo(isVertical) {\n  const from = isVertical ? { scalingX: 1, scalingY: 0 } : { scalingX: 0, scalingY: 1 };\n  const to = { scalingX: 1, scalingY: 1 };\n  return { from, to };\n}\nfunction resetBoxPlotSelectionsScalingCenterFn(isVertical) {\n  return (_node, datum) => {\n    if (isVertical) {\n      return { scalingCenterY: datum.scaledValues.medianValue };\n    }\n    return { scalingCenterX: datum.scaledValues.medianValue };\n  };\n}\n\n// packages/ag-charts-enterprise/src/series/box-plot/boxPlotGroup.ts\n\nvar { Group: Group7, Rect: Rect2, Line: Line3, BBox: BBox5, Selection: Selection2 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar { Logger: Logger4 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar BoxPlotGroup = class extends Group7 {\n  constructor() {\n    super();\n    this.append([\n      new Rect2({ tag: 0 /* Box */ }),\n      new Rect2({ tag: 0 /* Box */ }),\n      new Rect2({ tag: 2 /* Outline */ }),\n      new Rect2({ tag: 1 /* Median */ }),\n      new Line3({ tag: 3 /* Whisker */ }),\n      new Line3({ tag: 3 /* Whisker */ }),\n      new Line3({ tag: 4 /* Cap */ }),\n      new Line3({ tag: 4 /* Cap */ })\n    ]);\n  }\n  updateDatumStyles(datum, activeStyles, isVertical, isReversedValueAxis) {\n    const {\n      bandwidth,\n      scaledValues: { xValue: axisValue, medianValue }\n    } = datum;\n    let { minValue, q1Value, q3Value, maxValue } = datum.scaledValues;\n    if (isVertical && !isReversedValueAxis || !isVertical && isReversedValueAxis) {\n      [maxValue, q3Value, q1Value, minValue] = [minValue, q1Value, q3Value, maxValue];\n    }\n    const position = (x, y, width, height) => isVertical ? { y: x, x: y, width: height, height: width } : { x, y, width, height };\n    const hPosition = (x1, x2, y) => isVertical ? { y1: x1, y2: x2, x: y } : { x1, x2, y };\n    const vPosition = (x, y1, y2) => isVertical ? { x1: y1, x2: y2, y: x } : { x, y1, y2 };\n    const bbox = (x, y, width, height) => {\n      ({ x, y, width, height } = position(x, y, width, height));\n      return new BBox5(x, y, width, height);\n    };\n    const {\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      cornerRadius,\n      cap,\n      whisker: whiskerStyles\n    } = activeStyles;\n    const selection = Selection2.select(this, Rect2);\n    const boxes = selection.selectByTag(0 /* Box */);\n    const [outline] = selection.selectByTag(2 /* Outline */);\n    const [median] = selection.selectByTag(1 /* Median */);\n    const whiskers = selection.selectByTag(3 /* Whisker */);\n    const caps = selection.selectByTag(4 /* Cap */);\n    if (whiskerStyles.strokeWidth > bandwidth) {\n      whiskerStyles.strokeWidth = bandwidth;\n    }\n    const boxesPosition = position(q1Value, axisValue, q3Value - q1Value, bandwidth);\n    outline.setProperties(boxesPosition);\n    boxes[0].setProperties(boxesPosition);\n    boxes[0].setProperties({\n      cornerRadius,\n      clipBBox: bbox(q1Value, axisValue, Math.round(medianValue - q1Value + strokeWidth / 2), bandwidth)\n    });\n    boxes[1].setProperties(boxesPosition);\n    boxes[1].setProperties({\n      cornerRadius,\n      clipBBox: bbox(\n        Math.round(medianValue - strokeWidth / 2),\n        axisValue,\n        Math.floor(q3Value - medianValue + strokeWidth / 2),\n        bandwidth\n      )\n    });\n    const medianStart = Math.max(Math.round(medianValue - strokeWidth / 2), q1Value + strokeWidth);\n    const medianEnd = Math.min(Math.round(medianValue + strokeWidth / 2), q3Value - strokeWidth);\n    median.setProperties(boxesPosition);\n    median.setProperties({\n      visible: medianStart < medianEnd,\n      cornerRadius,\n      clipBBox: bbox(\n        medianStart,\n        axisValue + strokeWidth,\n        medianEnd - medianStart,\n        Math.max(0, bandwidth - strokeWidth * 2)\n      )\n    });\n    const capStart = Math.floor(axisValue + bandwidth * (1 - cap.lengthRatio) / 2);\n    const capEnd = Math.ceil(axisValue + bandwidth * (1 + cap.lengthRatio) / 2);\n    caps[0].setProperties(vPosition(minValue, capStart, capEnd));\n    caps[1].setProperties(vPosition(maxValue, capStart, capEnd));\n    whiskers[0].setProperties(\n      hPosition(\n        Math.round(minValue + whiskerStyles.strokeWidth / 2),\n        q1Value,\n        Math.floor(axisValue + bandwidth / 2)\n      )\n    );\n    whiskers[1].setProperties(\n      hPosition(\n        q3Value,\n        Math.round(maxValue - whiskerStyles.strokeWidth / 2),\n        Math.floor(axisValue + bandwidth / 2)\n      )\n    );\n    for (const element of boxes) {\n      element.setProperties({ fill, fillOpacity, strokeWidth: strokeWidth * 2, strokeOpacity: 0 });\n    }\n    median.setProperties({ fill: stroke, fillOpacity: strokeOpacity, strokeWidth: 0 });\n    for (const element of [...whiskers, ...caps]) {\n      element.setProperties(whiskerStyles);\n    }\n    outline.setProperties({\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      cornerRadius,\n      fillOpacity: 0\n    });\n  }\n  distanceSquared(x, y) {\n    const nodes = Selection2.selectByClass(this, Rect2, Line3);\n    return ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.nearestSquared(x, y, nodes).distanceSquared;\n  }\n  get midPoint() {\n    const datum = this.datum;\n    if (datum.midPoint === void 0) {\n      Logger4.error(\"BoxPlotGroup.datum.midPoint is undefined\");\n      return { x: NaN, y: NaN };\n    }\n    return datum.midPoint;\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/box-plot/boxPlotSeriesProperties.ts\n\nvar {\n  BaseProperties: BaseProperties10,\n  AbstractBarSeriesProperties,\n  SeriesTooltip,\n  Validate: Validate33,\n  COLOR_STRING: COLOR_STRING6,\n  FUNCTION: FUNCTION5,\n  LINE_DASH: LINE_DASH5,\n  OBJECT: OBJECT10,\n  POSITIVE_NUMBER: POSITIVE_NUMBER10,\n  RATIO: RATIO11,\n  STRING: STRING12,\n  mergeDefaults: mergeDefaults3\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar BoxPlotSeriesCap = class extends BaseProperties10 {\n  constructor() {\n    super(...arguments);\n    this.lengthRatio = 0.5;\n  }\n};\n__decorateClass([\n  Validate33(RATIO11)\n], BoxPlotSeriesCap.prototype, \"lengthRatio\", 2);\nvar BoxPlotSeriesWhisker = class extends BaseProperties10 {\n};\n__decorateClass([\n  Validate33(COLOR_STRING6, { optional: true })\n], BoxPlotSeriesWhisker.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate33(POSITIVE_NUMBER10)\n], BoxPlotSeriesWhisker.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate33(RATIO11)\n], BoxPlotSeriesWhisker.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate33(LINE_DASH5, { optional: true })\n], BoxPlotSeriesWhisker.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate33(POSITIVE_NUMBER10)\n], BoxPlotSeriesWhisker.prototype, \"lineDashOffset\", 2);\nvar BoxPlotSeriesProperties = class extends AbstractBarSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fill = \"#c16068\";\n    this.fillOpacity = 1;\n    this.stroke = \"#333\";\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.cap = new BoxPlotSeriesCap();\n    this.whisker = new BoxPlotSeriesWhisker();\n    this.tooltip = new SeriesTooltip();\n    // Internal: Set by paletteFactory.\n    this.backgroundFill = \"white\";\n  }\n  toJson() {\n    const { stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this;\n    const properties = super.toJson();\n    properties.whisker = mergeDefaults3(properties.whisker, {\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset\n    });\n    return properties;\n  }\n};\n__decorateClass([\n  Validate33(STRING12)\n], BoxPlotSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate33(STRING12)\n], BoxPlotSeriesProperties.prototype, \"minKey\", 2);\n__decorateClass([\n  Validate33(STRING12)\n], BoxPlotSeriesProperties.prototype, \"q1Key\", 2);\n__decorateClass([\n  Validate33(STRING12)\n], BoxPlotSeriesProperties.prototype, \"medianKey\", 2);\n__decorateClass([\n  Validate33(STRING12)\n], BoxPlotSeriesProperties.prototype, \"q3Key\", 2);\n__decorateClass([\n  Validate33(STRING12)\n], BoxPlotSeriesProperties.prototype, \"maxKey\", 2);\n__decorateClass([\n  Validate33(STRING12, { optional: true })\n], BoxPlotSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate33(STRING12, { optional: true })\n], BoxPlotSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate33(STRING12, { optional: true })\n], BoxPlotSeriesProperties.prototype, \"minName\", 2);\n__decorateClass([\n  Validate33(STRING12, { optional: true })\n], BoxPlotSeriesProperties.prototype, \"q1Name\", 2);\n__decorateClass([\n  Validate33(STRING12, { optional: true })\n], BoxPlotSeriesProperties.prototype, \"medianName\", 2);\n__decorateClass([\n  Validate33(STRING12, { optional: true })\n], BoxPlotSeriesProperties.prototype, \"q3Name\", 2);\n__decorateClass([\n  Validate33(STRING12, { optional: true })\n], BoxPlotSeriesProperties.prototype, \"maxName\", 2);\n__decorateClass([\n  Validate33(COLOR_STRING6, { optional: true })\n], BoxPlotSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate33(RATIO11)\n], BoxPlotSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate33(COLOR_STRING6)\n], BoxPlotSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate33(POSITIVE_NUMBER10)\n], BoxPlotSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate33(RATIO11)\n], BoxPlotSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate33(LINE_DASH5)\n], BoxPlotSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate33(POSITIVE_NUMBER10)\n], BoxPlotSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate33(POSITIVE_NUMBER10)\n], BoxPlotSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate33(FUNCTION5, { optional: true })\n], BoxPlotSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate33(OBJECT10)\n], BoxPlotSeriesProperties.prototype, \"cap\", 2);\n__decorateClass([\n  Validate33(OBJECT10)\n], BoxPlotSeriesProperties.prototype, \"whisker\", 2);\n__decorateClass([\n  Validate33(OBJECT10)\n], BoxPlotSeriesProperties.prototype, \"tooltip\", 2);\n__decorateClass([\n  Validate33(COLOR_STRING6)\n], BoxPlotSeriesProperties.prototype, \"backgroundFill\", 2);\n\n// packages/ag-charts-enterprise/src/series/box-plot/boxPlotSeries.ts\nvar {\n  extent,\n  extractDecoratedProperties,\n  fixNumericExtent: fixNumericExtent2,\n  keyProperty,\n  mergeDefaults: mergeDefaults4,\n  SeriesNodePickMode,\n  SMALLEST_KEY_INTERVAL,\n  valueProperty: valueProperty3,\n  diff,\n  animationValidation,\n  convertValuesToScaleByDefs,\n  isFiniteNumber: isFiniteNumber3,\n  computeBarFocusBounds\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { motion } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar { ContinuousScale } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scale;\nvar { Color: Color2 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar BoxPlotSeriesNodeEvent = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.xKey = series.properties.xKey;\n    this.minKey = series.properties.minKey;\n    this.q1Key = series.properties.q1Key;\n    this.medianKey = series.properties.medianKey;\n    this.q3Key = series.properties.q3Key;\n    this.maxKey = series.properties.maxKey;\n  }\n};\nvar BoxPlotSeries = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.AbstractBarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [SeriesNodePickMode.NEAREST_NODE, SeriesNodePickMode.EXACT_SHAPE_MATCH],\n      directionKeys: {\n        x: [\"xKey\"],\n        y: [\"medianKey\", \"q1Key\", \"q3Key\", \"minKey\", \"maxKey\"]\n      },\n      directionNames: {\n        x: [\"xName\"],\n        y: [\"medianName\", \"q1Name\", \"q3Name\", \"minName\", \"maxName\"]\n      },\n      pathsPerSeries: 1,\n      hasHighlightedLabels: true\n    });\n    this.properties = new BoxPlotSeriesProperties();\n    this.NodeEvent = BoxPlotSeriesNodeEvent;\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid() || !this.visible)\n      return;\n    const { xKey, minKey, q1Key, medianKey, q3Key, maxKey } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const xScale = this.getCategoryAxis()?.scale;\n    const yScale = this.getValueAxis()?.scale;\n    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const extraProps = [];\n    if (animationEnabled && this.processedData) {\n      extraProps.push(diff(this.processedData));\n    }\n    if (animationEnabled) {\n      extraProps.push(animationValidation());\n    }\n    const { processedData } = await this.requestDataModel(dataController, this.data, {\n      props: [\n        keyProperty(xKey, xScaleType, { id: `xValue` }),\n        valueProperty3(minKey, yScaleType, { id: `minValue` }),\n        valueProperty3(q1Key, yScaleType, { id: `q1Value` }),\n        valueProperty3(medianKey, yScaleType, { id: `medianValue` }),\n        valueProperty3(q3Key, yScaleType, { id: `q3Value` }),\n        valueProperty3(maxKey, yScaleType, { id: `maxValue` }),\n        ...isContinuousX ? [SMALLEST_KEY_INTERVAL] : [],\n        ...extraProps\n      ]\n    });\n    this.smallestDataInterval = processedData.reduced?.smallestKeyInterval;\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel, smallestDataInterval } = this;\n    if (!(processedData && dataModel))\n      return [];\n    if (direction === this.getBarDirection()) {\n      const minValues = dataModel.getDomain(this, `minValue`, \"value\", processedData);\n      const maxValues = dataModel.getDomain(this, `maxValue`, \"value\", processedData);\n      return fixNumericExtent2([Math.min(...minValues), Math.max(...maxValues)], this.getValueAxis());\n    }\n    const { index, def } = dataModel.resolveProcessedDataDefById(this, `xValue`);\n    const keys = processedData.domain.keys[index];\n    if (def.type === \"key\" && def.valueType === \"category\") {\n      return keys;\n    }\n    const categoryAxis = this.getCategoryAxis();\n    const keysExtent = extent(keys) ?? [NaN, NaN];\n    const scalePadding = isFiniteNumber3(smallestDataInterval) ? smallestDataInterval * 0.5 : 0;\n    const d0 = keysExtent[0] + -scalePadding;\n    const d1 = keysExtent[1] + scalePadding;\n    return fixNumericExtent2([d0, d1], categoryAxis);\n  }\n  async createNodeData() {\n    const { visible, dataModel } = this;\n    const xAxis = this.getCategoryAxis();\n    const yAxis = this.getValueAxis();\n    if (!(dataModel && xAxis && yAxis)) {\n      return;\n    }\n    const { xKey, fill, fillOpacity, stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cap, whisker } = this.properties;\n    const nodeData = [];\n    const defs = dataModel.resolveProcessedDataDefsByIds(this, [\n      \"xValue\",\n      \"minValue\",\n      \"q1Value\",\n      `medianValue`,\n      `q3Value`,\n      `maxValue`\n    ]);\n    const { barWidth, groupIndex } = this.updateGroupScale(xAxis);\n    const barOffset = ContinuousScale.is(xAxis.scale) ? barWidth * -0.5 : 0;\n    const { groupScale, processedData } = this;\n    const isVertical = this.isVertical();\n    const context = {\n      itemId: xKey,\n      nodeData,\n      labelData: [],\n      scales: this.calculateScaling(),\n      visible: this.visible\n    };\n    if (!visible)\n      return context;\n    processedData?.data.forEach(({ datum, keys, values }) => {\n      const { xValue, minValue, q1Value, medianValue, q3Value, maxValue } = dataModel.resolveProcessedDataDefsValues(defs, { keys, values });\n      if ([minValue, q1Value, medianValue, q3Value, maxValue].some((value) => typeof value !== \"number\") || minValue > q1Value || q1Value > medianValue || medianValue > q3Value || q3Value > maxValue) {\n        return;\n      }\n      const scaledValues = convertValuesToScaleByDefs({\n        defs,\n        values: {\n          xValue,\n          minValue,\n          q1Value,\n          medianValue,\n          q3Value,\n          maxValue\n        },\n        xAxis,\n        yAxis\n      });\n      scaledValues.xValue += Math.round(groupScale.convert(String(groupIndex))) + barOffset;\n      const bandwidth = Math.round(barWidth);\n      const height = Math.abs(scaledValues.q3Value - scaledValues.q1Value);\n      const midX = scaledValues.xValue + bandwidth / 2;\n      const midY = Math.min(scaledValues.q3Value, scaledValues.q1Value) + height / 2;\n      const midPoint = {\n        x: isVertical ? midX : midY,\n        y: isVertical ? midY : midX\n      };\n      let focusRect;\n      if (isVertical) {\n        focusRect = {\n          x: midPoint.x - bandwidth / 2,\n          y: scaledValues.minValue,\n          width: bandwidth,\n          height: scaledValues.maxValue - scaledValues.minValue\n        };\n      } else {\n        focusRect = {\n          x: scaledValues.minValue,\n          y: midPoint.y - bandwidth / 2,\n          width: scaledValues.maxValue - scaledValues.minValue,\n          height: bandwidth\n        };\n      }\n      nodeData.push({\n        series: this,\n        itemId: xValue,\n        datum,\n        xKey,\n        bandwidth,\n        scaledValues,\n        cap,\n        whisker,\n        fill,\n        fillOpacity,\n        stroke,\n        strokeWidth,\n        strokeOpacity,\n        lineDash,\n        lineDashOffset,\n        midPoint,\n        focusRect\n      });\n    });\n    return context;\n  }\n  getLegendData(legendType) {\n    const { id, data } = this;\n    const {\n      xKey,\n      yName,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      showInLegend,\n      legendItemName,\n      visible\n    } = this.properties;\n    if (!showInLegend || !data?.length || !xKey || legendType !== \"category\") {\n      return [];\n    }\n    return [\n      {\n        legendType: \"category\",\n        id,\n        itemId: id,\n        seriesId: id,\n        enabled: visible,\n        label: {\n          text: legendItemName ?? yName ?? id\n        },\n        symbols: [{ marker: { fill, fillOpacity, stroke, strokeOpacity, strokeWidth } }],\n        legendItemName\n      }\n    ];\n  }\n  getTooltipHtml(nodeDatum) {\n    const {\n      xKey,\n      minKey,\n      q1Key,\n      medianKey,\n      q3Key,\n      maxKey,\n      xName,\n      yName,\n      minName,\n      q1Name,\n      medianName,\n      q3Name,\n      maxName,\n      tooltip,\n      fill\n    } = this.properties;\n    const { datum, itemId } = nodeDatum;\n    const xAxis = this.getCategoryAxis();\n    const yAxis = this.getValueAxis();\n    if (!xAxis || !yAxis || !this.properties.isValid())\n      return ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.EMPTY_TOOLTIP_CONTENT;\n    const title = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util.sanitizeHtml(yName);\n    const contentData = [\n      [xKey, xName, xAxis],\n      [minKey, minName, yAxis],\n      [q1Key, q1Name, yAxis],\n      [medianKey, medianName, yAxis],\n      [q3Key, q3Name, yAxis],\n      [maxKey, maxName, yAxis]\n    ];\n    const content = contentData.map(([key, name, axis]) => ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util.sanitizeHtml(`${name ?? key}: ${axis.formatDatum(datum[key])}`)).join(title ? \"<br/>\" : \", \");\n    const { fill: formatFill } = this.getFormattedStyles(nodeDatum);\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: fill },\n      {\n        seriesId: this.id,\n        itemId,\n        datum,\n        fill,\n        xKey,\n        minKey,\n        q1Key,\n        medianKey,\n        q3Key,\n        maxKey,\n        xName,\n        minName,\n        q1Name,\n        medianName,\n        q3Name,\n        maxName,\n        yName,\n        title,\n        color: fill ?? formatFill\n      }\n    );\n  }\n  animateEmptyUpdateReady({\n    datumSelection\n  }) {\n    const isVertical = this.isVertical();\n    const { from, to } = prepareBoxPlotFromTo(isVertical);\n    motion.resetMotion([datumSelection], resetBoxPlotSelectionsScalingCenterFn(isVertical));\n    motion.staticFromToMotion(this.id, \"datums\", this.ctx.animationManager, [datumSelection], from, to, {\n      phase: \"initial\"\n    });\n  }\n  isLabelEnabled() {\n    return false;\n  }\n  async updateDatumSelection(opts) {\n    const data = opts.nodeData ?? [];\n    return opts.datumSelection.update(data);\n  }\n  async updateDatumNodes({\n    datumSelection,\n    isHighlight: highlighted\n  }) {\n    const isVertical = this.isVertical();\n    const isReversedValueAxis = this.getValueAxis()?.isReversed();\n    datumSelection.each((boxPlotGroup, nodeDatum) => {\n      let activeStyles = this.getFormattedStyles(nodeDatum, highlighted);\n      if (highlighted) {\n        activeStyles = mergeDefaults4(this.properties.highlightStyle.item, activeStyles);\n      }\n      const { stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = activeStyles;\n      activeStyles.whisker = mergeDefaults4(activeStyles.whisker, {\n        stroke,\n        strokeWidth,\n        strokeOpacity,\n        lineDash,\n        lineDashOffset\n      });\n      boxPlotGroup.updateDatumStyles(\n        nodeDatum,\n        activeStyles,\n        isVertical,\n        isReversedValueAxis\n      );\n    });\n  }\n  async updateLabelNodes(_opts) {\n  }\n  async updateLabelSelection(opts) {\n    const { labelData, labelSelection } = opts;\n    return labelSelection.update(labelData);\n  }\n  nodeFactory() {\n    return new BoxPlotGroup();\n  }\n  getFormattedStyles(nodeDatum, highlighted = false) {\n    const {\n      id: seriesId,\n      ctx: { callbackCache },\n      properties\n    } = this;\n    const { xKey, minKey, q1Key, medianKey, q3Key, maxKey, itemStyler, backgroundFill, cornerRadius } = properties;\n    const { datum, stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cap, whisker } = nodeDatum;\n    let fill;\n    let fillOpacity;\n    const useFakeFill = true;\n    if (useFakeFill) {\n      fill = nodeDatum.fill;\n      fillOpacity = properties.fillOpacity;\n    } else {\n      try {\n        fill = Color2.mix(\n          Color2.fromString(backgroundFill),\n          Color2.fromString(nodeDatum.fill),\n          properties.fillOpacity\n        ).toString();\n      } catch {\n        fill = nodeDatum.fill;\n      }\n      fillOpacity = void 0;\n    }\n    const activeStyles = {\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      cornerRadius,\n      cap: extractDecoratedProperties(cap),\n      whisker: extractDecoratedProperties(whisker)\n    };\n    if (itemStyler) {\n      const formatStyles = callbackCache.call(itemStyler, {\n        datum,\n        seriesId,\n        highlighted,\n        ...activeStyles,\n        xKey,\n        minKey,\n        q1Key,\n        medianKey,\n        q3Key,\n        maxKey\n      });\n      if (formatStyles) {\n        return mergeDefaults4(formatStyles, activeStyles);\n      }\n    }\n    return activeStyles;\n  }\n  computeFocusBounds({ datumIndex, seriesRect }) {\n    return computeBarFocusBounds(\n      this.contextNodeData?.nodeData[datumIndex].focusRect,\n      this.contentGroup,\n      seriesRect\n    );\n  }\n};\nBoxPlotSeries.className = \"BoxPlotSeries\";\nBoxPlotSeries.type = \"box-plot\";\n\n// packages/ag-charts-enterprise/src/series/box-plot/boxPlotThemes.ts\n\nvar BOX_PLOT_SERIES_THEME = {\n  series: {\n    direction: \"vertical\",\n    // @todo(AG-11876) Use fillOpacity to match area, range area, radar area, chord, and sankey series\n    // fillOpacity: 0.3,\n    strokeWidth: 2\n  },\n  axes: {\n    [ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.CARTESIAN_AXIS_TYPE.NUMBER]: {\n      crosshair: {\n        snap: false\n      }\n    },\n    [ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.CARTESIAN_AXIS_TYPE.CATEGORY]: {\n      groupPaddingInner: 0.2,\n      crosshair: {\n        enabled: false,\n        snap: false\n      }\n    }\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/box-plot/boxPlotModule.ts\nvar { Color: Color3 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar BoxPlotModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"box-plot\",\n  instanceConstructor: BoxPlotSeries,\n  tooltipDefaults: { range: \"exact\" },\n  defaultAxes: [\n    {\n      type: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.CARTESIAN_AXIS_TYPE.NUMBER,\n      position: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POSITION.LEFT\n    },\n    {\n      type: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.CARTESIAN_AXIS_TYPE.CATEGORY,\n      position: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POSITION.BOTTOM\n    }\n  ],\n  themeTemplate: BOX_PLOT_SERIES_THEME,\n  groupable: true,\n  paletteFactory: ({ takeColors, themeTemplateParameters }) => {\n    const themeBackgroundColor = themeTemplateParameters.get(ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_BACKGROUND_COLOUR);\n    const backgroundFill = (Array.isArray(themeBackgroundColor) ? themeBackgroundColor[0] : themeBackgroundColor) ?? \"white\";\n    const {\n      fills: [fill],\n      strokes: [stroke]\n    } = takeColors(1);\n    let fakeFill;\n    try {\n      fakeFill = Color3.mix(Color3.fromString(backgroundFill), Color3.fromString(fill), 0.3).toString();\n    } catch {\n      fakeFill = fill;\n    }\n    return {\n      fill: fakeFill,\n      stroke,\n      backgroundFill\n    };\n  },\n  swapDefaultAxesCondition: ({ direction }) => direction === \"horizontal\"\n};\n\n// packages/ag-charts-enterprise/src/series/bullet/bulletModule.ts\n\n\n// packages/ag-charts-enterprise/src/series/bullet/bulletSeries.ts\n\n\n// packages/ag-charts-enterprise/src/series/bullet/bulletSeriesProperties.ts\n\nvar {\n  AbstractBarSeriesProperties: AbstractBarSeriesProperties2,\n  BaseProperties: BaseProperties11,\n  PropertiesArray: PropertiesArray2,\n  SeriesTooltip: SeriesTooltip2,\n  Validate: Validate34,\n  ARRAY: ARRAY3,\n  COLOR_STRING: COLOR_STRING7,\n  LINE_DASH: LINE_DASH6,\n  OBJECT: OBJECT11,\n  POSITIVE_NUMBER: POSITIVE_NUMBER11,\n  RATIO: RATIO12,\n  STRING: STRING13\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar TargetStyle = class extends BaseProperties11 {\n  constructor() {\n    super(...arguments);\n    this.fill = \"black\";\n    this.fillOpacity = 1;\n    this.stroke = \"black\";\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.lengthRatio = 0.75;\n  }\n};\n__decorateClass([\n  Validate34(COLOR_STRING7)\n], TargetStyle.prototype, \"fill\", 2);\n__decorateClass([\n  Validate34(RATIO12)\n], TargetStyle.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate34(COLOR_STRING7)\n], TargetStyle.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate34(POSITIVE_NUMBER11)\n], TargetStyle.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate34(RATIO12)\n], TargetStyle.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate34(LINE_DASH6)\n], TargetStyle.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate34(POSITIVE_NUMBER11)\n], TargetStyle.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate34(RATIO12)\n], TargetStyle.prototype, \"lengthRatio\", 2);\nvar BulletScale = class extends BaseProperties11 {\n};\n__decorateClass([\n  Validate34(POSITIVE_NUMBER11, { optional: true })\n], BulletScale.prototype, \"max\", 2);\nvar BulletColorRange = class extends BaseProperties11 {\n  constructor() {\n    super(...arguments);\n    this.color = \"lightgrey\";\n  }\n};\n__decorateClass([\n  Validate34(COLOR_STRING7)\n], BulletColorRange.prototype, \"color\", 2);\n__decorateClass([\n  Validate34(POSITIVE_NUMBER11, { optional: true })\n], BulletColorRange.prototype, \"stop\", 2);\nvar BulletSeriesProperties = class extends AbstractBarSeriesProperties2 {\n  constructor() {\n    super(...arguments);\n    this.fill = \"black\";\n    this.fillOpacity = 1;\n    this.stroke = \"black\";\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.widthRatio = 0.5;\n    this.colorRanges = new PropertiesArray2(BulletColorRange);\n    this.target = new TargetStyle();\n    this.scale = new BulletScale();\n    this.tooltip = new SeriesTooltip2();\n    // Internal: Set by paletteFactory.\n    this.backgroundFill = \"white\";\n  }\n};\n__decorateClass([\n  Validate34(STRING13)\n], BulletSeriesProperties.prototype, \"valueKey\", 2);\n__decorateClass([\n  Validate34(STRING13, { optional: true })\n], BulletSeriesProperties.prototype, \"valueName\", 2);\n__decorateClass([\n  Validate34(STRING13, { optional: true })\n], BulletSeriesProperties.prototype, \"targetKey\", 2);\n__decorateClass([\n  Validate34(STRING13, { optional: true })\n], BulletSeriesProperties.prototype, \"targetName\", 2);\n__decorateClass([\n  Validate34(COLOR_STRING7)\n], BulletSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate34(RATIO12)\n], BulletSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate34(COLOR_STRING7)\n], BulletSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate34(POSITIVE_NUMBER11)\n], BulletSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate34(RATIO12)\n], BulletSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate34(LINE_DASH6)\n], BulletSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate34(POSITIVE_NUMBER11)\n], BulletSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate34(RATIO12)\n], BulletSeriesProperties.prototype, \"widthRatio\", 2);\n__decorateClass([\n  Validate34(ARRAY3.restrict({ minLength: 0 }))\n], BulletSeriesProperties.prototype, \"colorRanges\", 2);\n__decorateClass([\n  Validate34(OBJECT11)\n], BulletSeriesProperties.prototype, \"target\", 2);\n__decorateClass([\n  Validate34(OBJECT11)\n], BulletSeriesProperties.prototype, \"scale\", 2);\n__decorateClass([\n  Validate34(OBJECT11)\n], BulletSeriesProperties.prototype, \"tooltip\", 2);\n__decorateClass([\n  Validate34(COLOR_STRING7)\n], BulletSeriesProperties.prototype, \"backgroundFill\", 2);\n\n// packages/ag-charts-enterprise/src/series/bullet/bulletSeries.ts\nvar {\n  animationValidation: animationValidation2,\n  collapsedStartingBarPosition,\n  diff: diff2,\n  keyProperty: keyProperty2,\n  partialAssign: partialAssign2,\n  prepareBarAnimationFunctions,\n  resetBarSelectionsFn,\n  seriesLabelFadeInAnimation,\n  valueProperty: valueProperty4,\n  createDatumId,\n  computeBarFocusBounds: computeBarFocusBounds2\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { fromToMotion } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.motion;\nvar { sanitizeHtml, Color: Color4 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar STYLING_KEYS = [\n  \"fill\",\n  \"fillOpacity\",\n  \"stroke\",\n  \"strokeWidth\",\n  \"strokeOpacity\",\n  \"lineDash\",\n  \"lineDashOffset\"\n];\nvar BulletSeries = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.AbstractBarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: { y: [\"targetKey\", \"valueKey\"] },\n      directionNames: { y: [\"targetName\", \"valueName\"] },\n      pickModes: [\n        ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.SeriesNodePickMode.NEAREST_NODE,\n        ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.SeriesNodePickMode.EXACT_SHAPE_MATCH\n      ],\n      hasHighlightedLabels: true,\n      animationResetFns: {\n        datum: resetBarSelectionsFn\n      }\n    });\n    this.properties = new BulletSeriesProperties();\n    this.normalizedColorRanges = [];\n    this.colorRangesGroup = new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Group({ name: `${this.id}-colorRanges` });\n    this.colorRangesSelection = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Selection.select(this.colorRangesGroup, ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Rect, false);\n    this.rootGroup.append(this.colorRangesGroup);\n    this.targetLinesSelection = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Selection.select(this.annotationGroup, ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Line, false);\n  }\n  destroy() {\n    this.rootGroup.removeChild(this.colorRangesGroup);\n    super.destroy();\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid() || !this.data || !this.visible)\n      return;\n    const { valueKey, targetKey } = this.properties;\n    const xScale = this.getCategoryAxis()?.scale;\n    const yScale = this.getValueAxis()?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const extraProps = [];\n    if (targetKey !== void 0) {\n      extraProps.push(valueProperty4(targetKey, yScaleType, { id: \"target\" }));\n    }\n    if (!this.ctx.animationManager.isSkipped()) {\n      if (this.processedData !== void 0) {\n        extraProps.push(diff2(this.processedData));\n      }\n      extraProps.push(animationValidation2());\n    }\n    await this.requestDataModel(dataController, this.data.slice(0, 1), {\n      props: [\n        keyProperty2(valueKey, xScaleType, { id: \"xValue\" }),\n        valueProperty4(valueKey, yScaleType, { id: \"value\" }),\n        ...extraProps\n      ],\n      groupByKeys: true\n    });\n    this.animationState.transition(\"updateData\");\n  }\n  getBandScalePadding() {\n    return { inner: 0, outer: 0 };\n  }\n  getMaxValue() {\n    return Math.max(...this.getValueAxis()?.dataDomain.domain ?? [0]);\n  }\n  getSeriesDomain(direction) {\n    const { dataModel, processedData } = this;\n    if (!dataModel || !processedData) {\n      return [];\n    }\n    const { valueKey, targetKey, valueName, scale } = this.properties;\n    if (direction === this.getCategoryDirection()) {\n      return [valueName ?? valueKey];\n    }\n    if (direction == this.getValueAxis()?.direction) {\n      const valueDomain = dataModel.getDomain(this, \"value\", \"value\", processedData);\n      const targetDomain = targetKey === void 0 ? [] : dataModel.getDomain(this, \"target\", \"value\", processedData);\n      return [0, scale.max ?? Math.max(...valueDomain, ...targetDomain)];\n    }\n    throw new Error(`unknown direction ${direction}`);\n  }\n  getKeys(direction) {\n    if (direction === this.getBarDirection()) {\n      return [this.properties.valueKey];\n    }\n    return super.getKeys(direction);\n  }\n  async createNodeData() {\n    const { dataModel, processedData } = this;\n    const {\n      valueKey,\n      targetKey,\n      widthRatio,\n      target: { lengthRatio }\n    } = this.properties;\n    const xScale = this.getCategoryAxis()?.scale;\n    const yScale = this.getValueAxis()?.scale;\n    if (!valueKey || !dataModel || !processedData || !xScale || !yScale)\n      return;\n    if (widthRatio === void 0 || lengthRatio === void 0)\n      return;\n    const multiplier = xScale.bandwidth ?? NaN;\n    const maxValue = this.getMaxValue();\n    const valueIndex = dataModel.resolveProcessedDataIndexById(this, \"value\");\n    const targetIndex = targetKey === void 0 ? NaN : dataModel.resolveProcessedDataIndexById(this, \"target\");\n    const context = {\n      itemId: valueKey,\n      nodeData: [],\n      labelData: [],\n      scales: this.calculateScaling(),\n      visible: this.visible\n    };\n    if (!this.visible)\n      return context;\n    for (const { datum, values } of processedData.data) {\n      if (!Array.isArray(datum) || datum.length < 1) {\n        continue;\n      }\n      if (values[0][valueIndex] < 0) {\n        ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util.Logger.warnOnce(\"negative values are not supported, clipping to 0.\");\n      }\n      const xValue = this.properties.valueName ?? this.properties.valueKey;\n      const yValue = Math.min(maxValue, Math.max(0, values[0][valueIndex]));\n      const y = yScale.convert(yValue);\n      const barWidth = widthRatio * multiplier;\n      const bottomY = yScale.convert(0);\n      const barAlongX = this.getBarDirection() === ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.ChartAxisDirection.X;\n      const rect = {\n        x: multiplier * (1 - widthRatio) / 2,\n        y: Math.min(y, bottomY),\n        width: barWidth,\n        height: Math.abs(bottomY - y)\n      };\n      if (barAlongX) {\n        [rect.x, rect.y, rect.width, rect.height] = [rect.y, rect.x, rect.height, rect.width];\n      }\n      let target;\n      if (values[0][targetIndex] < 0) {\n        ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util.Logger.warnOnce(\"negative targets are not supported, ignoring.\");\n      }\n      if (this.properties.targetKey && values[0][targetIndex] >= 0) {\n        const targetLineLength = lengthRatio * multiplier;\n        const targetValue = Math.min(maxValue, values[0][targetIndex]);\n        if (!isNaN(targetValue) && targetValue !== void 0) {\n          const convertedY = yScale.convert(targetValue);\n          let x1 = multiplier * (1 - lengthRatio) / 2;\n          let x2 = x1 + targetLineLength;\n          let [y1, y2] = [convertedY, convertedY];\n          if (barAlongX) {\n            [x1, x2, y1, y2] = [y1, y2, x1, x2];\n          }\n          target = { value: targetValue, x1, x2, y1, y2 };\n        }\n      }\n      const nodeData = {\n        series: this,\n        datum: datum[0],\n        xKey: valueKey,\n        xValue,\n        yKey: valueKey,\n        yValue,\n        cumulativeValue: yValue,\n        target,\n        ...rect,\n        midPoint: { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 },\n        opacity: 1\n      };\n      context.nodeData.push(nodeData);\n    }\n    const sortedRanges = [...this.getColorRanges()].sort((a, b) => (a.stop ?? maxValue) - (b.stop ?? maxValue));\n    let start = 0;\n    this.normalizedColorRanges = sortedRanges.map((item) => {\n      const stop = Math.min(maxValue, item.stop ?? Infinity);\n      const result = { color: item.color, start, stop };\n      start = stop;\n      return result;\n    });\n    return context;\n  }\n  getColorRanges() {\n    const { colorRanges, fill, backgroundFill } = this.properties;\n    if (colorRanges !== void 0 && colorRanges.length > 0) {\n      return colorRanges;\n    }\n    const defaultColorRange = new BulletColorRange();\n    try {\n      defaultColorRange.color = Color4.mix(\n        Color4.fromString(fill),\n        Color4.fromString(backgroundFill),\n        0.7\n      ).toString();\n    } catch {\n      defaultColorRange.color = fill;\n    }\n    return [defaultColorRange];\n  }\n  getLegendData(_legendType) {\n    return [];\n  }\n  getTooltipHtml(nodeDatum) {\n    const { valueKey, valueName, targetKey, targetName } = this.properties;\n    const axis = this.getValueAxis();\n    const { yValue: valueValue, target: { value: targetValue } = { value: void 0 }, datum, itemId } = nodeDatum;\n    if (valueKey === void 0 || valueValue === void 0 || axis === void 0) {\n      return ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.EMPTY_TOOLTIP_CONTENT;\n    }\n    const makeLine = (key, name, value) => {\n      const nameString = sanitizeHtml(name ?? key);\n      const valueString = sanitizeHtml(axis.formatDatum(value));\n      return `<b>${nameString}</b>: ${valueString}`;\n    };\n    const title = void 0;\n    const content = targetKey === void 0 || targetValue === void 0 ? makeLine(valueKey, valueName, valueValue) : `${makeLine(valueKey, valueName, valueValue)}<br/>${makeLine(targetKey, targetName, targetValue)}`;\n    return this.properties.tooltip.toTooltipHtml(\n      { title, content, backgroundColor: this.properties.fill },\n      { datum, itemId, title, seriesId: this.id, valueKey, valueName, targetKey, targetName, color: void 0 }\n    );\n  }\n  isLabelEnabled() {\n    return false;\n  }\n  nodeFactory() {\n    return new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Rect();\n  }\n  async updateDatumSelection(opts) {\n    this.targetLinesSelection.update(opts.nodeData, void 0, void 0);\n    return opts.datumSelection.update(opts.nodeData, void 0, void 0);\n  }\n  async updateDatumNodes(opts) {\n    for (const { node } of opts.datumSelection) {\n      const style = this.properties;\n      partialAssign2(STYLING_KEYS, node, style);\n    }\n    for (const { node, datum } of this.targetLinesSelection) {\n      if (datum.target === void 0) {\n        node.visible = false;\n      } else {\n        const style = this.properties.target;\n        partialAssign2([\"x1\", \"x2\", \"y1\", \"y2\"], node, datum.target);\n        partialAssign2(STYLING_KEYS, node, style);\n      }\n    }\n  }\n  async updateColorRanges() {\n    const valAxis = this.getValueAxis();\n    const catAxis = this.getCategoryAxis();\n    if (!valAxis || !catAxis)\n      return;\n    const [min, max] = [0, Math.max(...catAxis.scale.range)];\n    const computeRect = this.getBarDirection() === ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.ChartAxisDirection.Y ? (rect, colorRange) => {\n      rect.x = min;\n      rect.y = valAxis.scale.convert(colorRange.stop);\n      rect.height = valAxis.scale.convert(colorRange.start) - rect.y;\n      rect.width = max;\n    } : (rect, colorRange) => {\n      rect.x = valAxis.scale.convert(colorRange.start);\n      rect.y = min;\n      rect.height = max;\n      rect.width = valAxis.scale.convert(colorRange.stop) - rect.x;\n    };\n    this.colorRangesSelection.update(this.normalizedColorRanges);\n    for (const { node, datum } of this.colorRangesSelection) {\n      computeRect(node, datum);\n      node.fill = datum.color;\n    }\n  }\n  async updateNodes(highlightedItems, seriesHighlighted, anySeriesItemEnabled) {\n    await super.updateNodes(highlightedItems, seriesHighlighted, anySeriesItemEnabled);\n    await this.updateColorRanges();\n  }\n  async updateLabelSelection(opts) {\n    return opts.labelSelection;\n  }\n  async updateLabelNodes(_opts) {\n  }\n  animateEmptyUpdateReady(data) {\n    const { datumSelection, annotationSelections } = data;\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, \"normal\"));\n    fromToMotion(this.id, \"nodes\", this.ctx.animationManager, [datumSelection], fns);\n    seriesLabelFadeInAnimation(this, \"annotations\", this.ctx.animationManager, ...annotationSelections);\n  }\n  animateWaitingUpdateReady(data) {\n    const { datumSelection, annotationSelections } = data;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    const dataDiff = this.processedData?.reduced?.diff;\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, \"normal\"));\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      this.ctx.animationManager,\n      [datumSelection],\n      fns,\n      (_, datum) => createDatumId(datum.xValue),\n      dataDiff\n    );\n    const hasMotion = dataDiff?.changed ?? true;\n    if (hasMotion) {\n      seriesLabelFadeInAnimation(this, \"annotations\", this.ctx.animationManager, ...annotationSelections);\n    }\n  }\n  computeFocusBounds({ datumIndex, seriesRect }) {\n    return computeBarFocusBounds2(this.contextNodeData?.nodeData[datumIndex], this.contentGroup, seriesRect);\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/bullet/bulletThemes.ts\n\nvar BULLET_SERIES_THEME = {\n  series: {\n    direction: \"vertical\",\n    strokeWidth: 0,\n    strokeOpacity: 1,\n    fillOpacity: 1,\n    widthRatio: 0.5,\n    target: {\n      strokeWidth: 3,\n      strokeOpacity: 1,\n      lengthRatio: 0.75\n    }\n  },\n  axes: {\n    [ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.CARTESIAN_AXIS_TYPE.NUMBER]: {\n      nice: false,\n      crosshair: {\n        enabled: false\n      }\n    }\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/bullet/bulletModule.ts\nvar BulletModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"bullet\",\n  solo: true,\n  instanceConstructor: BulletSeries,\n  tooltipDefaults: { range: \"exact\" },\n  defaultAxes: [\n    {\n      type: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.CARTESIAN_AXIS_TYPE.NUMBER,\n      position: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POSITION.LEFT\n    },\n    {\n      type: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.CARTESIAN_AXIS_TYPE.CATEGORY,\n      position: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POSITION.BOTTOM\n    }\n  ],\n  themeTemplate: BULLET_SERIES_THEME,\n  swapDefaultAxesCondition: (series) => series?.direction === \"horizontal\",\n  paletteFactory: ({ takeColors, colorsCount, themeTemplateParameters }) => {\n    const {\n      fills: [fill],\n      strokes: [stroke]\n    } = takeColors(colorsCount);\n    const themeBackgroundColor = themeTemplateParameters.get(ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_BACKGROUND_COLOUR);\n    const backgroundFill = (Array.isArray(themeBackgroundColor) ? themeBackgroundColor[0] : themeBackgroundColor) ?? \"white\";\n    const targetStroke = themeTemplateParameters.get(ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_CROSS_LINES_COLOUR);\n    return {\n      fill,\n      stroke,\n      target: { stroke: targetStroke },\n      backgroundFill\n    };\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/candlestick/candlestickModule.ts\n\n\n// packages/ag-charts-enterprise/src/series/candlestick/candlestickSeries.ts\n\n\n// packages/ag-charts-enterprise/src/series/ohlc/ohlcSeriesBase.ts\n\n\n// packages/ag-charts-enterprise/src/series/candlestick/candlestickUtil.ts\n\nvar { computeBarFocusBounds: computeBarFocusBounds3, NODE_UPDATE_STATE_TO_PHASE_MAPPING } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nfunction resetCandlestickSelectionsFn(_node, datum) {\n  return getCoordinates(datum);\n}\nfunction prepareCandlestickAnimationFunctions(initial) {\n  const fromFn = (candlestickGroup, datum, status) => {\n    const phase = initial ? \"initial\" : NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];\n    if (status === \"unknown\" || status === \"added\" && datum != null) {\n      const { x, y, yLow, yHigh, width, height } = getCoordinates(datum);\n      let collapsedY = datum.itemId === \"up\" ? yLow : yHigh;\n      if (status === \"unknown\") {\n        collapsedY = y + height / 2;\n      }\n      return {\n        x,\n        y: collapsedY,\n        yBottom: collapsedY,\n        yHigh: collapsedY,\n        yLow: collapsedY,\n        width,\n        height: 0,\n        phase\n      };\n    }\n    return {\n      x: candlestickGroup.x,\n      y: candlestickGroup.y,\n      yBottom: candlestickGroup.yBottom,\n      yHigh: candlestickGroup.yHigh,\n      yLow: candlestickGroup.yLow,\n      width: candlestickGroup.width,\n      height: candlestickGroup.height,\n      phase\n    };\n  };\n  const toFn = (_, datum, status) => {\n    if (status === \"removed\") {\n      const { x, yLow, yHigh, width } = getCoordinates(datum);\n      const collapsedY = datum.itemId === \"up\" ? yLow : yHigh;\n      return { x, y: collapsedY, yBottom: collapsedY, yHigh: collapsedY, yLow: collapsedY, width, height: 0 };\n    }\n    return getCoordinates(datum);\n  };\n  return { toFn, fromFn };\n}\nfunction getCoordinates(datum) {\n  const {\n    bandwidth,\n    scaledValues: { xValue: x, openValue, closeValue, highValue, lowValue }\n  } = datum;\n  const y = Math.min(openValue, closeValue);\n  const yBottom = isNaN(openValue) ? closeValue : Math.max(openValue, closeValue);\n  const yHigh = Math.min(highValue, lowValue);\n  const yLow = Math.max(highValue, lowValue);\n  return {\n    x,\n    y,\n    yBottom,\n    yHigh,\n    yLow,\n    width: bandwidth,\n    height: Math.max(yBottom - y, 1e-3)\n    // This is to differentiate between animation setting height 0 and data values resulting in height 0\n  };\n}\nfunction computeCandleFocusBounds(series, opts) {\n  const candleDatum = series.getNodeData()?.at(opts.datumIndex);\n  const datum = !candleDatum ? void 0 : {\n    x: candleDatum.scaledValues.xValue,\n    y: candleDatum.scaledValues.highValue,\n    width: candleDatum.bandwidth,\n    height: candleDatum.scaledValues.lowValue - candleDatum.scaledValues.highValue\n  };\n  return computeBarFocusBounds3(datum, series.contentGroup, opts.seriesRect);\n}\n\n// packages/ag-charts-enterprise/src/series/ohlc/ohlcSeriesBase.ts\nvar { motion: motion2 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar {\n  extent: extent2,\n  fixNumericExtent: fixNumericExtent3,\n  keyProperty: keyProperty3,\n  SeriesNodePickMode: SeriesNodePickMode2,\n  SMALLEST_KEY_INTERVAL: SMALLEST_KEY_INTERVAL2,\n  valueProperty: valueProperty5,\n  diff: diff3,\n  animationValidation: animationValidation3,\n  convertValuesToScaleByDefs: convertValuesToScaleByDefs2,\n  isFiniteNumber: isFiniteNumber4\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { sanitizeHtml: sanitizeHtml2, Logger: Logger5 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar { ContinuousScale: ContinuousScale2 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scale;\nvar CandlestickSeriesNodeEvent = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.xKey = series.properties.xKey;\n    this.openKey = series.properties.openKey;\n    this.closeKey = series.properties.closeKey;\n    this.highKey = series.properties.highKey;\n    this.lowKey = series.properties.lowKey;\n  }\n};\nvar OhlcSeriesBase = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.AbstractBarSeries {\n  constructor(moduleCtx, datumAnimationResetFnc) {\n    super({\n      moduleCtx,\n      pickModes: [SeriesNodePickMode2.NEAREST_BY_MAIN_AXIS_FIRST, SeriesNodePickMode2.EXACT_SHAPE_MATCH],\n      directionKeys: {\n        x: [\"xKey\"],\n        y: [\"lowKey\", \"highKey\", \"openKey\", \"closeKey\"]\n      },\n      directionNames: {\n        x: [\"xName\"],\n        y: [\"lowName\", \"highName\", \"openName\", \"closeName\"]\n      },\n      pathsPerSeries: 1,\n      datumSelectionGarbageCollection: false,\n      animationAlwaysUpdateSelections: true,\n      animationResetFns: {\n        datum: datumAnimationResetFnc\n      }\n    });\n    this.NodeEvent = CandlestickSeriesNodeEvent;\n  }\n  animateEmptyUpdateReady({\n    datumSelection\n  }) {\n    const animationFns = prepareCandlestickAnimationFunctions(true);\n    motion2.fromToMotion(this.id, \"datums\", this.ctx.animationManager, [datumSelection], animationFns);\n  }\n  animateWaitingUpdateReady({\n    datumSelection\n  }) {\n    const { processedData } = this;\n    const difference = processedData?.reduced?.diff;\n    const animationFns = prepareCandlestickAnimationFunctions(false);\n    motion2.fromToMotion(\n      this.id,\n      \"datums\",\n      this.ctx.animationManager,\n      [datumSelection],\n      animationFns,\n      (_, datum) => String(datum.xValue),\n      difference\n    );\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid() || !this.visible)\n      return;\n    const { xKey, openKey, closeKey, highKey, lowKey } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const xScale = this.getCategoryAxis()?.scale;\n    const yScale = this.getValueAxis()?.scale;\n    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const extraProps = [];\n    if (animationEnabled) {\n      if (this.processedData) {\n        extraProps.push(diff3(this.processedData));\n      }\n      extraProps.push(animationValidation3());\n    }\n    if (openKey) {\n      extraProps.push(\n        valueProperty5(openKey, yScaleType, {\n          id: `openValue`,\n          invalidValue: void 0,\n          missingValue: void 0\n        })\n      );\n    }\n    const { processedData } = await this.requestDataModel(dataController, this.data, {\n      props: [\n        keyProperty3(xKey, xScaleType, { id: `xValue` }),\n        valueProperty5(closeKey, yScaleType, { id: `closeValue` }),\n        valueProperty5(highKey, yScaleType, { id: `highValue` }),\n        valueProperty5(lowKey, yScaleType, { id: `lowValue` }),\n        ...isContinuousX ? [SMALLEST_KEY_INTERVAL2] : [],\n        ...extraProps\n      ]\n    });\n    this.smallestDataInterval = processedData.reduced?.smallestKeyInterval;\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel, smallestDataInterval } = this;\n    if (!(processedData && dataModel))\n      return [];\n    const { openKey } = this.properties;\n    if (direction === this.getBarDirection()) {\n      const lowValues = dataModel.getDomain(this, `lowValue`, \"value\", processedData);\n      const highValues = dataModel.getDomain(this, `highValue`, \"value\", processedData);\n      const openValues = openKey ? dataModel.getDomain(this, `openValue`, \"value\", processedData) : [];\n      const closeValues = dataModel.getDomain(this, `closeValue`, \"value\", processedData);\n      return fixNumericExtent3(\n        [\n          Math.min(...lowValues, ...highValues, ...openValues, ...closeValues),\n          Math.max(...highValues, ...lowValues, ...openValues, ...closeValues)\n        ],\n        this.getValueAxis()\n      );\n    }\n    const { index, def } = dataModel.resolveProcessedDataDefById(this, `xValue`);\n    const keys = processedData.domain.keys[index];\n    if (def.type === \"key\" && def.valueType === \"category\") {\n      return keys;\n    }\n    const categoryAxis = this.getCategoryAxis();\n    const keysExtent = extent2(keys) ?? [NaN, NaN];\n    const scalePadding = isFiniteNumber4(smallestDataInterval) ? smallestDataInterval : 0;\n    const d0 = keysExtent[0] + -scalePadding;\n    const d1 = keysExtent[1] + scalePadding;\n    return fixNumericExtent3([d0, d1], categoryAxis);\n  }\n  createBaseNodeData() {\n    const { visible, dataModel } = this;\n    const xAxis = this.getCategoryAxis();\n    const yAxis = this.getValueAxis();\n    if (!(dataModel && xAxis && yAxis)) {\n      return;\n    }\n    const nodeData = [];\n    const { xKey, highKey, lowKey } = this.properties;\n    const defs = dataModel.resolveProcessedDataDefsByIds(this, [\n      \"xValue\",\n      \"openValue\",\n      \"closeValue\",\n      \"highValue\",\n      \"lowValue\"\n    ]);\n    const { barWidth, groupIndex } = this.updateGroupScale(xAxis);\n    const barOffset = ContinuousScale2.is(xAxis.scale) ? barWidth * -0.5 : 0;\n    const { groupScale, processedData } = this;\n    const context = {\n      itemId: xKey,\n      nodeData,\n      labelData: [],\n      scales: this.calculateScaling(),\n      visible: this.visible\n    };\n    if (!visible)\n      return context;\n    processedData?.data.forEach(({ datum, keys, values }) => {\n      const { xValue, openValue, closeValue, highValue, lowValue } = dataModel.resolveProcessedDataDefsValues(\n        defs,\n        { keys, values }\n      );\n      const validLowValue = lowValue != null && lowValue <= openValue && lowValue <= closeValue;\n      const validHighValue = highValue != null && highValue >= openValue && highValue >= closeValue;\n      if (!validLowValue) {\n        Logger5.warnOnce(\n          `invalid low value for key [${lowKey}] in data element, low value cannot be higher than datum open or close values`\n        );\n        return;\n      }\n      if (!validHighValue) {\n        Logger5.warnOnce(\n          `invalid high value for key [${highKey}] in data element, high value cannot be lower than datum open or close values.`\n        );\n        return;\n      }\n      const scaledValues = convertValuesToScaleByDefs2({\n        defs,\n        values: {\n          xValue,\n          openValue,\n          closeValue,\n          highValue,\n          lowValue\n        },\n        xAxis,\n        yAxis\n      });\n      scaledValues.xValue += Math.round(groupScale.convert(String(groupIndex))) + barOffset;\n      const isRising = closeValue > openValue;\n      const itemId = this.getSeriesItemType(isRising);\n      const [y, yBottom] = isRising ? [scaledValues.openValue, scaledValues.closeValue] : [scaledValues.closeValue, scaledValues.openValue];\n      const height = yBottom - y;\n      const midPoint = {\n        x: scaledValues.xValue + Math.round(barWidth) / 2,\n        y: y + height / 2\n      };\n      nodeData.push({\n        series: this,\n        itemId,\n        datum,\n        xKey,\n        xValue,\n        openValue,\n        closeValue,\n        highValue,\n        lowValue,\n        // CRT-340 Use atleast 1px width to prevent nothing being drawn.\n        bandwidth: barWidth >= 1 ? barWidth : groupScale.rawBandwidth,\n        scaledValues,\n        midPoint,\n        aggregatedValue: closeValue\n      });\n    });\n    return context;\n  }\n  getSeriesItemType(isRising) {\n    return isRising ? \"up\" : \"down\";\n  }\n  getItemConfig(seriesItemType) {\n    return this.properties.item[seriesItemType];\n  }\n  getLegendData(legendType) {\n    const { id, data } = this;\n    const {\n      xKey,\n      yName,\n      item: { up, down },\n      showInLegend,\n      legendItemName,\n      visible\n    } = this.properties;\n    if (!showInLegend || !data?.length || !xKey || legendType !== \"category\") {\n      return [];\n    }\n    return [\n      {\n        legendType: \"category\",\n        id,\n        itemId: id,\n        seriesId: id,\n        enabled: visible,\n        label: {\n          text: legendItemName ?? yName ?? id\n        },\n        symbols: [\n          {\n            marker: {\n              fill: up.fill ?? up.stroke,\n              fillOpacity: up.fillOpacity ?? 1,\n              stroke: up.stroke,\n              strokeWidth: up.strokeWidth ?? 1,\n              strokeOpacity: up.strokeOpacity ?? 1,\n              padding: 0\n            }\n          },\n          {\n            marker: {\n              fill: down.fill ?? down.stroke,\n              fillOpacity: down.fillOpacity ?? 1,\n              stroke: down.stroke,\n              strokeWidth: down.strokeWidth ?? 1,\n              strokeOpacity: down.strokeOpacity ?? 1\n            }\n          }\n        ],\n        legendItemName\n      }\n    ];\n  }\n  getTooltipHtml(nodeDatum) {\n    const {\n      xKey,\n      openKey,\n      closeKey,\n      highKey,\n      lowKey,\n      xName,\n      yName,\n      openName,\n      closeName,\n      highName,\n      lowName,\n      tooltip\n    } = this.properties;\n    const { datum, itemId } = nodeDatum;\n    const xAxis = this.getCategoryAxis();\n    const yAxis = this.getValueAxis();\n    if (!xAxis || !yAxis || !this.properties.isValid())\n      return ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.EMPTY_TOOLTIP_CONTENT;\n    const capitalise = (text) => text.charAt(0).toUpperCase() + text.substring(1);\n    const title = sanitizeHtml2(yName);\n    const contentData = [\n      [xKey, xName, xAxis],\n      [openKey, openName, yAxis],\n      [highKey, highName, yAxis],\n      [lowKey, lowName, yAxis],\n      [closeKey, closeName, yAxis]\n    ];\n    const content = contentData.map(([key, name, axis]) => sanitizeHtml2(`${name ?? capitalise(key)}: ${axis.formatDatum(datum[key])}`)).join(\"<br/>\");\n    const styles = this.getFormattedStyles(nodeDatum);\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: styles.stroke },\n      {\n        seriesId: this.id,\n        highlighted: false,\n        datum,\n        ...styles,\n        xKey,\n        openKey,\n        closeKey,\n        highKey,\n        lowKey,\n        xName,\n        yName,\n        openName,\n        closeName,\n        highName,\n        lowName,\n        title,\n        color: styles.fill,\n        fill: styles.fill,\n        itemId\n      }\n    );\n  }\n  isVertical() {\n    return true;\n  }\n  isLabelEnabled() {\n    return false;\n  }\n  async updateDatumSelection(opts) {\n    const data = opts.nodeData ?? [];\n    return opts.datumSelection.update(data);\n  }\n  async updateDatumNodes({\n    datumSelection,\n    isHighlight: highlighted\n  }) {\n    datumSelection.each((group, nodeDatum) => {\n      const activeStyles = this.getActiveStyles(nodeDatum, highlighted);\n      group.updateDatumStyles(nodeDatum, activeStyles);\n    });\n  }\n  async updateLabelNodes(_opts) {\n  }\n  async updateLabelSelection(opts) {\n    const { labelData, labelSelection } = opts;\n    return labelSelection.update(labelData);\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/candlestick/candlestickGroup.ts\n\nvar { SceneChangeDetection, BBox: BBox6, RedrawType } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar CandlestickBaseGroup = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Group {\n  constructor() {\n    super(...arguments);\n    this.x = 0;\n    this.y = 0;\n    this.yBottom = 0;\n    this.yHigh = 0;\n    this.yLow = 0;\n    this.width = 0;\n    this.height = 0;\n  }\n  distanceSquared(x, y) {\n    const nodes = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Selection.selectByClass(this, ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Rect, ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Line);\n    return ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.nearestSquared(x, y, nodes).distanceSquared;\n  }\n  get midPoint() {\n    const datum = this.datum;\n    if (datum.midPoint === void 0) {\n      ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util.Logger.error(\"CandlestickBaseGroup.datum.midPoint is undefined\");\n      return { x: NaN, y: NaN };\n    }\n    return datum.midPoint;\n  }\n  render(renderCtx) {\n    this.updateCoordinates();\n    super.render(renderCtx);\n  }\n};\n__decorateClass([\n  SceneChangeDetection({ redraw: RedrawType.MAJOR })\n], CandlestickBaseGroup.prototype, \"x\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: RedrawType.MAJOR })\n], CandlestickBaseGroup.prototype, \"y\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: RedrawType.MAJOR })\n], CandlestickBaseGroup.prototype, \"yBottom\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: RedrawType.MAJOR })\n], CandlestickBaseGroup.prototype, \"yHigh\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: RedrawType.MAJOR })\n], CandlestickBaseGroup.prototype, \"yLow\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: RedrawType.MAJOR })\n], CandlestickBaseGroup.prototype, \"width\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: RedrawType.MAJOR })\n], CandlestickBaseGroup.prototype, \"height\", 2);\nvar CandlestickGroup = class extends CandlestickBaseGroup {\n  constructor() {\n    super();\n    this.append([\n      new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Rect({ tag: 0 /* Body */ }),\n      new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Line({ tag: 1 /* LowWick */ }),\n      new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Line({ tag: 2 /* HighWick */ })\n    ]);\n  }\n  updateCoordinates() {\n    const { x, y, yBottom, yHigh, yLow, width, height } = this;\n    const selection = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Selection.select(this, ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Rect);\n    const [body] = selection.selectByTag(0 /* Body */);\n    const [lowWick] = selection.selectByTag(1 /* LowWick */);\n    const [highWick] = selection.selectByTag(2 /* HighWick */);\n    if (width === 0 || height === 0) {\n      body.visible = false;\n      lowWick.visible = false;\n      highWick.visible = false;\n      return;\n    }\n    body.visible = true;\n    lowWick.visible = true;\n    highWick.visible = true;\n    body.setProperties({\n      x,\n      y,\n      width,\n      height,\n      crisp: true,\n      clipBBox: new BBox6(x, y, width, height)\n    });\n    const halfWidth = width / 2;\n    lowWick.setProperties({\n      y1: Math.round(yLow + lowWick.strokeWidth / 2),\n      y2: yBottom,\n      x: x + halfWidth\n    });\n    highWick.setProperties({\n      y1: Math.round(yHigh + highWick.strokeWidth / 2),\n      y2: y,\n      x: x + halfWidth\n    });\n  }\n  updateDatumStyles(datum, activeStyles) {\n    const { bandwidth } = datum;\n    const {\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      wick: wickStyles = {},\n      cornerRadius\n    } = activeStyles;\n    wickStyles.strokeWidth ?? (wickStyles.strokeWidth = 1);\n    const selection = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Selection.select(this, ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Rect);\n    const [body] = selection.selectByTag(0 /* Body */);\n    const [lowWick] = selection.selectByTag(1 /* LowWick */);\n    const [highWick] = selection.selectByTag(2 /* HighWick */);\n    if (wickStyles.strokeWidth > bandwidth) {\n      wickStyles.strokeWidth = bandwidth;\n    }\n    body.setProperties({\n      fill,\n      fillOpacity,\n      strokeWidth,\n      strokeOpacity,\n      stroke,\n      lineDash,\n      lineDashOffset,\n      cornerRadius\n    });\n    lowWick.setProperties(wickStyles);\n    highWick.setProperties(wickStyles);\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/candlestick/candlestickSeriesProperties.ts\n\nvar {\n  BaseProperties: BaseProperties12,\n  AbstractBarSeriesProperties: AbstractBarSeriesProperties3,\n  SeriesTooltip: SeriesTooltip3,\n  Validate: Validate35,\n  COLOR_STRING: COLOR_STRING8,\n  FUNCTION: FUNCTION6,\n  LINE_DASH: LINE_DASH7,\n  OBJECT: OBJECT12,\n  POSITIVE_NUMBER: POSITIVE_NUMBER12,\n  RATIO: RATIO13,\n  STRING: STRING14\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar CandlestickSeriesWick = class extends BaseProperties12 {\n};\n__decorateClass([\n  Validate35(COLOR_STRING8, { optional: true })\n], CandlestickSeriesWick.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate35(POSITIVE_NUMBER12)\n], CandlestickSeriesWick.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate35(RATIO13)\n], CandlestickSeriesWick.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate35(LINE_DASH7, { optional: true })\n], CandlestickSeriesWick.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate35(POSITIVE_NUMBER12)\n], CandlestickSeriesWick.prototype, \"lineDashOffset\", 2);\nvar CandlestickSeriesItem = class extends BaseProperties12 {\n  constructor() {\n    super(...arguments);\n    this.fill = \"#c16068\";\n    this.fillOpacity = 1;\n    this.stroke = \"#333\";\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.wick = new CandlestickSeriesWick();\n  }\n};\n__decorateClass([\n  Validate35(COLOR_STRING8, { optional: true })\n], CandlestickSeriesItem.prototype, \"fill\", 2);\n__decorateClass([\n  Validate35(RATIO13)\n], CandlestickSeriesItem.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate35(COLOR_STRING8)\n], CandlestickSeriesItem.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate35(POSITIVE_NUMBER12)\n], CandlestickSeriesItem.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate35(RATIO13)\n], CandlestickSeriesItem.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate35(LINE_DASH7)\n], CandlestickSeriesItem.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate35(POSITIVE_NUMBER12)\n], CandlestickSeriesItem.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate35(POSITIVE_NUMBER12)\n], CandlestickSeriesItem.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate35(OBJECT12)\n], CandlestickSeriesItem.prototype, \"wick\", 2);\nvar CandlestickSeriesItems = class extends BaseProperties12 {\n  constructor() {\n    super(...arguments);\n    this.up = new CandlestickSeriesItem();\n    this.down = new CandlestickSeriesItem();\n  }\n};\n__decorateClass([\n  Validate35(OBJECT12)\n], CandlestickSeriesItems.prototype, \"up\", 2);\n__decorateClass([\n  Validate35(OBJECT12)\n], CandlestickSeriesItems.prototype, \"down\", 2);\nvar CandlestickSeriesProperties = class extends AbstractBarSeriesProperties3 {\n  constructor() {\n    super(...arguments);\n    this.tooltip = new SeriesTooltip3();\n    this.item = new CandlestickSeriesItems();\n  }\n};\n__decorateClass([\n  Validate35(STRING14)\n], CandlestickSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate35(STRING14)\n], CandlestickSeriesProperties.prototype, \"openKey\", 2);\n__decorateClass([\n  Validate35(STRING14)\n], CandlestickSeriesProperties.prototype, \"closeKey\", 2);\n__decorateClass([\n  Validate35(STRING14)\n], CandlestickSeriesProperties.prototype, \"highKey\", 2);\n__decorateClass([\n  Validate35(STRING14)\n], CandlestickSeriesProperties.prototype, \"lowKey\", 2);\n__decorateClass([\n  Validate35(STRING14, { optional: true })\n], CandlestickSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate35(STRING14, { optional: true })\n], CandlestickSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate35(STRING14, { optional: true })\n], CandlestickSeriesProperties.prototype, \"openName\", 2);\n__decorateClass([\n  Validate35(STRING14, { optional: true })\n], CandlestickSeriesProperties.prototype, \"closeName\", 2);\n__decorateClass([\n  Validate35(STRING14, { optional: true })\n], CandlestickSeriesProperties.prototype, \"highName\", 2);\n__decorateClass([\n  Validate35(STRING14, { optional: true })\n], CandlestickSeriesProperties.prototype, \"lowName\", 2);\n__decorateClass([\n  Validate35(OBJECT12)\n], CandlestickSeriesProperties.prototype, \"tooltip\", 2);\n__decorateClass([\n  Validate35(OBJECT12)\n], CandlestickSeriesProperties.prototype, \"item\", 2);\n__decorateClass([\n  Validate35(FUNCTION6, { optional: true })\n], CandlestickSeriesProperties.prototype, \"itemStyler\", 2);\n\n// packages/ag-charts-enterprise/src/series/candlestick/candlestickSeries.ts\nvar { extractDecoratedProperties: extractDecoratedProperties2, mergeDefaults: mergeDefaults5 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar CandlestickSeries = class extends OhlcSeriesBase {\n  constructor(moduleCtx) {\n    super(moduleCtx, resetCandlestickSelectionsFn);\n    this.properties = new CandlestickSeriesProperties();\n  }\n  async createNodeData() {\n    const baseNodeData = this.createBaseNodeData();\n    if (!baseNodeData) {\n      return;\n    }\n    const nodeData = baseNodeData.nodeData.map((datum) => {\n      const {\n        fill,\n        fillOpacity,\n        stroke,\n        strokeWidth,\n        strokeOpacity,\n        lineDash,\n        lineDashOffset,\n        wick,\n        cornerRadius\n      } = this.getItemConfig(datum.itemId);\n      return {\n        ...datum,\n        fill,\n        fillOpacity,\n        stroke,\n        strokeWidth,\n        strokeOpacity,\n        lineDash,\n        lineDashOffset,\n        wick,\n        cornerRadius\n      };\n    });\n    return { ...baseNodeData, nodeData };\n  }\n  getFormattedStyles(nodeDatum, highlighted = false) {\n    const {\n      id: seriesId,\n      ctx: { callbackCache }\n    } = this;\n    const { xKey, openKey, closeKey, highKey, lowKey, itemStyler } = this.properties;\n    const { fill, fillOpacity, stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this.getItemConfig(\n      nodeDatum.itemId\n    );\n    if (itemStyler) {\n      const formatStyles = callbackCache.call(itemStyler, {\n        datum: nodeDatum.datum,\n        itemId: nodeDatum.itemId,\n        seriesId,\n        highlighted,\n        xKey,\n        openKey,\n        closeKey,\n        highKey,\n        lowKey,\n        fill,\n        fillOpacity,\n        stroke,\n        strokeWidth,\n        strokeOpacity,\n        lineDash,\n        lineDashOffset\n      });\n      if (formatStyles) {\n        return mergeDefaults5(formatStyles, this.getSeriesStyles(nodeDatum));\n      }\n    }\n    return this.getSeriesStyles(nodeDatum);\n  }\n  nodeFactory() {\n    return new CandlestickGroup();\n  }\n  getSeriesStyles(nodeDatum) {\n    const { fill, fillOpacity, stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset, wick, cornerRadius } = nodeDatum;\n    return {\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      wick: extractDecoratedProperties2(wick),\n      cornerRadius\n    };\n  }\n  getActiveStyles(nodeDatum, highlighted) {\n    let activeStyles = this.getFormattedStyles(nodeDatum, highlighted);\n    if (highlighted) {\n      activeStyles = mergeDefaults5(this.properties.highlightStyle.item, activeStyles);\n    }\n    const { stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = activeStyles;\n    activeStyles.wick = mergeDefaults5(activeStyles.wick, {\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset\n    });\n    return activeStyles;\n  }\n  computeFocusBounds(opts) {\n    return computeCandleFocusBounds(this, opts);\n  }\n};\nCandlestickSeries.className = \"CandleStickSeries\";\nCandlestickSeries.type = \"candlestick\";\n\n// packages/ag-charts-enterprise/src/series/candlestick/candlestickThemes.ts\n\nvar CANDLESTICK_SERIES_THEME = {\n  series: {\n    highlightStyle: {\n      item: { strokeWidth: 3 }\n    }\n  },\n  animation: { enabled: false },\n  axes: {\n    [ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.CARTESIAN_AXIS_TYPE.NUMBER]: {\n      crosshair: {\n        snap: false\n      }\n    },\n    [ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.CARTESIAN_AXIS_TYPE.ORDINAL_TIME]: {\n      groupPaddingInner: 0,\n      crosshair: {\n        enabled: true\n      }\n    }\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/candlestick/candlestickModule.ts\nvar CandlestickModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"candlestick\",\n  instanceConstructor: CandlestickSeries,\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.CARTESIAN_AXIS_TYPE.NUMBER,\n      position: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POSITION.LEFT\n    },\n    {\n      type: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.CARTESIAN_AXIS_TYPE.ORDINAL_TIME,\n      position: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POSITION.BOTTOM\n    }\n  ],\n  themeTemplate: CANDLESTICK_SERIES_THEME,\n  groupable: false,\n  paletteFactory: ({ takeColors, colorsCount, userPalette, palette }) => {\n    if (userPalette === \"user-indexed\") {\n      const { fills, strokes } = takeColors(colorsCount);\n      return {\n        item: {\n          up: {\n            fill: \"transparent\",\n            stroke: strokes[0]\n          },\n          down: {\n            fill: fills[0],\n            stroke: strokes[0]\n          }\n        }\n      };\n    }\n    return {\n      item: {\n        up: palette.up,\n        down: palette.down\n      }\n    };\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/chord/chordModule.ts\n\n\n// packages/ag-charts-enterprise/src/series/chord/chordSeries.ts\n\n\n// packages/ag-charts-enterprise/src/series/flow-proportion/flowProportionSeries.ts\n\n\n// packages/ag-charts-enterprise/src/series/flow-proportion/flowProportionUtil.ts\n\nvar { Logger: Logger6 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nfunction computeNodeGraph(nodes, links, includeCircularReferences) {\n  if (!includeCircularReferences) {\n    links = removeCircularLinks(links);\n  }\n  const nodeGraph = /* @__PURE__ */ new Map();\n  for (const datum of nodes) {\n    nodeGraph.set(datum.id, {\n      datum,\n      linksBefore: [],\n      linksAfter: [],\n      maxPathLengthBefore: -1,\n      maxPathLengthAfter: -1\n    });\n  }\n  let maxPathLength = 0;\n  nodeGraph.forEach((node, id) => {\n    maxPathLength = Math.max(\n      maxPathLength,\n      computePathLength(nodeGraph, links, node, id, -1, []) + computePathLength(nodeGraph, links, node, id, 1, []) + 1\n    );\n  });\n  return { links, nodeGraph, maxPathLength };\n}\nfunction findCircularLinks(links, link, into, stack) {\n  const stackIndex = stack.indexOf(link);\n  if (stackIndex !== -1) {\n    for (let i = stackIndex; i < stack.length; i += 1) {\n      into.add(stack[i]);\n    }\n    return;\n  }\n  stack.push(link);\n  const { toNode } = link;\n  for (const next of links) {\n    if (next.fromNode === toNode) {\n      findCircularLinks(links, next, into, stack);\n    }\n  }\n  stack.pop();\n}\nfunction removeCircularLinks(links) {\n  const circularLinks = /* @__PURE__ */ new Set();\n  for (const link of links) {\n    findCircularLinks(links, link, circularLinks, []);\n  }\n  if (circularLinks.size !== 0) {\n    Logger6.warnOnce(\"Some links formed circular references. These will be removed from the output.\");\n  }\n  return circularLinks.size === 0 ? links : links.filter((link) => !circularLinks.has(link));\n}\nfunction computePathLength(nodeGraph, links, node, id, direction, stack) {\n  if (stack.includes(id)) {\n    return Infinity;\n  }\n  let maxPathLength = direction === -1 ? node.maxPathLengthBefore : node.maxPathLengthAfter;\n  if (maxPathLength === -1) {\n    maxPathLength = 0;\n    const connectedLinks = direction === -1 ? node.linksBefore : node.linksAfter;\n    for (const link of links) {\n      const { fromNode, toNode } = link;\n      const linkId = direction === -1 ? toNode.id : fromNode.id;\n      const nextNodeId = direction === -1 ? fromNode.id : toNode.id;\n      const nextNode = id === linkId ? nodeGraph.get(nextNodeId) : void 0;\n      if (nextNode == null)\n        continue;\n      connectedLinks.push({ node: nextNode, link });\n      stack?.push(id);\n      maxPathLength = Math.max(\n        maxPathLength,\n        computePathLength(nodeGraph, links, nextNode, nextNodeId, direction, stack) + 1\n      );\n      stack?.pop();\n    }\n    if (direction === -1) {\n      node.maxPathLengthBefore = maxPathLength;\n    } else {\n      node.maxPathLengthAfter = maxPathLength;\n    }\n  }\n  return maxPathLength;\n}\n\n// packages/ag-charts-enterprise/src/series/flow-proportion/flowProportionSeries.ts\nvar { DataModelSeries, DataController, Validate: Validate36, ARRAY: ARRAY4, keyProperty: keyProperty4, valueProperty: valueProperty6 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { Selection: Selection3, Group: Group8, Text: Text6 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar FlowProportionSeries = class extends DataModelSeries {\n  constructor() {\n    super(...arguments);\n    this._chartNodes = void 0;\n    this.nodeCount = 0;\n    this.linkCount = 0;\n    this.nodesDataController = new DataController(\"standalone\");\n    this.nodesDataModel = void 0;\n    this.nodesProcessedData = void 0;\n    this.processedNodes = /* @__PURE__ */ new Map();\n    this.linkGroup = this.contentGroup.appendChild(new Group8({ name: \"linkGroup\" }));\n    this.nodeGroup = this.contentGroup.appendChild(new Group8({ name: \"nodeGroup\" }));\n    this.focusLinkGroup = this.highlightNode.appendChild(new Group8({ name: \"linkGroup\" }));\n    this.focusNodeGroup = this.highlightNode.appendChild(new Group8({ name: \"nodeGroup\" }));\n    this.highlightLinkGroup = this.highlightNode.appendChild(new Group8({ name: \"linkGroup\" }));\n    this.highlightNodeGroup = this.highlightNode.appendChild(new Group8({ name: \"nodeGroup\" }));\n    this.labelSelection = Selection3.select(this.labelGroup, Text6);\n    this.linkSelection = Selection3.select(\n      this.linkGroup,\n      () => this.linkFactory()\n    );\n    this.nodeSelection = Selection3.select(\n      this.nodeGroup,\n      () => this.nodeFactory()\n    );\n    this.focusLinkSelection = Selection3.select(\n      this.focusLinkGroup,\n      () => this.linkFactory()\n    );\n    this.focusNodeSelection = Selection3.select(\n      this.focusNodeGroup,\n      () => this.nodeFactory()\n    );\n    this.highlightLinkSelection = Selection3.select(\n      this.highlightLinkGroup,\n      () => this.linkFactory()\n    );\n    this.highlightNodeSelection = Selection3.select(\n      this.highlightNodeGroup,\n      () => this.nodeFactory()\n    );\n  }\n  get nodes() {\n    return this.properties.nodes ?? this._chartNodes;\n  }\n  setChartNodes(nodes) {\n    this._chartNodes = nodes;\n    if (this.nodes === nodes) {\n      this.nodeDataRefresh = true;\n    }\n  }\n  getNodeData() {\n    return this.contextNodeData?.nodeData;\n  }\n  async processData(dataController) {\n    const { nodesDataController, data, nodes } = this;\n    if (data == null || !this.properties.isValid()) {\n      return;\n    }\n    const { fromKey, toKey, sizeKey, idKey, labelKey } = this.properties;\n    const nodesDataModelPromise = nodes != null ? nodesDataController.request(this.id, nodes, {\n      props: [\n        keyProperty4(idKey, void 0, { id: \"idValue\", includeProperty: false }),\n        ...labelKey != null ? [valueProperty6(labelKey, void 0, { id: \"labelValue\", includeProperty: false })] : []\n      ],\n      groupByKeys: true\n    }) : null;\n    const linksDataModelPromise = this.requestDataModel(dataController, data, {\n      props: [\n        valueProperty6(fromKey, void 0, { id: \"fromValue\", includeProperty: false }),\n        valueProperty6(toKey, void 0, { id: \"toValue\", includeProperty: false }),\n        ...sizeKey != null ? [valueProperty6(sizeKey, void 0, { id: \"sizeValue\", includeProperty: false, missingValue: 0 })] : []\n      ],\n      groupByKeys: false\n    });\n    if (nodes != null) {\n      nodesDataController.execute();\n    }\n    const [nodesDataModel, linksDataModel] = await Promise.all([nodesDataModelPromise, linksDataModelPromise]);\n    this.nodesDataModel = nodesDataModel?.dataModel;\n    this.nodesProcessedData = nodesDataModel?.processedData;\n    const { fills, strokes } = this.properties;\n    const processedNodes = /* @__PURE__ */ new Map();\n    if (nodesDataModel == null) {\n      const fromIdIdx = linksDataModel.dataModel.resolveProcessedDataIndexById(this, \"fromValue\");\n      const toIdIdx = linksDataModel.dataModel.resolveProcessedDataIndexById(this, \"toValue\");\n      const createImplicitNode = (id) => {\n        const index = processedNodes.size;\n        const label = id;\n        const fill = fills[index % fills.length];\n        const stroke = strokes[index % strokes.length];\n        return {\n          series: this,\n          itemId: void 0,\n          datum: {},\n          // Must be a referential object for tooltips\n          type: 1 /* Node */,\n          index,\n          id,\n          label,\n          fill,\n          stroke\n        };\n      };\n      linksDataModel.processedData.data.forEach(({ values }) => {\n        const fromId = values[fromIdIdx];\n        const toId = values[toIdIdx];\n        if (fromId == null || toId == null)\n          return;\n        if (!processedNodes.has(fromId)) {\n          processedNodes.set(fromId, createImplicitNode(fromId));\n        }\n        if (!processedNodes.has(toId)) {\n          processedNodes.set(toId, createImplicitNode(toId));\n        }\n      });\n    } else {\n      const nodeIdIdx = nodesDataModel.dataModel.resolveProcessedDataIndexById(this, \"idValue\");\n      const labelIdx = labelKey != null ? nodesDataModel.dataModel.resolveProcessedDataIndexById(this, \"labelValue\") : void 0;\n      nodesDataModel.processedData.data.forEach(({ datum, keys, values }, index) => {\n        const value = values[0];\n        const id = keys[nodeIdIdx];\n        const label = labelIdx != null ? value[labelIdx] : void 0;\n        const fill = fills[index % fills.length];\n        const stroke = strokes[index % strokes.length];\n        processedNodes.set(id, {\n          series: this,\n          itemId: void 0,\n          datum,\n          type: 1 /* Node */,\n          index,\n          id,\n          label,\n          fill,\n          stroke\n        });\n      });\n    }\n    this.processedNodes = processedNodes;\n  }\n  getNodeGraph(createNode, createLink, { includeCircularReferences }) {\n    const { dataModel: linksDataModel, processedData: linksProcessedData } = this;\n    if (linksDataModel == null || linksProcessedData == null) {\n      const { links: links2, nodeGraph: nodeGraph2, maxPathLength: maxPathLength2 } = computeNodeGraph(\n        (/* @__PURE__ */ new Map()).values(),\n        [],\n        includeCircularReferences\n      );\n      this.nodeCount = 0;\n      this.linkCount = 0;\n      return { nodeGraph: nodeGraph2, links: links2, maxPathLength: maxPathLength2 };\n    }\n    const { sizeKey } = this.properties;\n    const fromIdIdx = linksDataModel.resolveProcessedDataIndexById(this, \"fromValue\");\n    const toIdIdx = linksDataModel.resolveProcessedDataIndexById(this, \"toValue\");\n    const sizeIdx = sizeKey != null ? linksDataModel.resolveProcessedDataIndexById(this, \"sizeValue\") : void 0;\n    const nodesById = /* @__PURE__ */ new Map();\n    this.processedNodes.forEach((datum) => {\n      const node = createNode(datum);\n      nodesById.set(datum.id, node);\n    });\n    const baseLinks = [];\n    linksProcessedData.data.forEach(({ datum, values }, index) => {\n      const fromId = values[fromIdIdx];\n      const toId = values[toIdIdx];\n      const size = sizeIdx != null ? values[sizeIdx] : 1;\n      const fromNode = nodesById.get(fromId);\n      const toNode = nodesById.get(toId);\n      if (size <= 0 || fromNode == null || toNode == null)\n        return;\n      const link = createLink({\n        series: this,\n        itemId: void 0,\n        datum,\n        type: 0 /* Link */,\n        index,\n        fromNode,\n        toNode,\n        size\n      });\n      baseLinks.push(link);\n    });\n    const { links, nodeGraph, maxPathLength } = computeNodeGraph(\n      nodesById.values(),\n      baseLinks,\n      includeCircularReferences\n    );\n    this.nodeCount = nodeGraph.size;\n    this.linkCount = links.length;\n    return { nodeGraph, links, maxPathLength };\n  }\n  async updateSelections() {\n    if (this.nodeDataRefresh) {\n      this.contextNodeData = await this.createNodeData();\n      this.nodeDataRefresh = false;\n    }\n  }\n  async update(opts) {\n    const { seriesRect } = opts;\n    const newNodeDataDependencies = {\n      seriesRectWidth: seriesRect?.width ?? 0,\n      seriesRectHeight: seriesRect?.height ?? 0\n    };\n    if (this._nodeDataDependencies == null || this._nodeDataDependencies.seriesRectWidth !== newNodeDataDependencies.seriesRectWidth || this._nodeDataDependencies.seriesRectHeight !== newNodeDataDependencies.seriesRectHeight) {\n      this._nodeDataDependencies = newNodeDataDependencies;\n    }\n    await this.updateSelections();\n    const nodeData = this.contextNodeData?.nodeData ?? [];\n    const labelData = this.contextNodeData?.labelData ?? [];\n    let highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();\n    if (highlightedDatum?.series === this && highlightedDatum.type == null) {\n      const { itemId } = highlightedDatum;\n      highlightedDatum = itemId != null ? nodeData.find((node) => node.type === 1 /* Node */ && node.id === itemId) : void 0;\n    } else if (highlightedDatum?.series !== this) {\n      highlightedDatum = void 0;\n    }\n    this.contentGroup.visible = this.visible;\n    this.contentGroup.opacity = highlightedDatum != null ? this.properties.highlightStyle.series.dimOpacity ?? 1 : 1;\n    this.labelSelection = await this.updateLabelSelection({ labelData, labelSelection: this.labelSelection });\n    await this.updateLabelNodes({ labelSelection: this.labelSelection });\n    this.linkSelection = await this.updateLinkSelection({\n      nodeData: nodeData.filter((d) => d.type === 0 /* Link */),\n      datumSelection: this.linkSelection\n    });\n    await this.updateLinkNodes({ datumSelection: this.linkSelection, isHighlight: false });\n    this.nodeSelection = await this.updateNodeSelection({\n      nodeData: nodeData.filter((d) => d.type === 1 /* Node */),\n      datumSelection: this.nodeSelection\n    });\n    await this.updateNodeNodes({ datumSelection: this.nodeSelection, isHighlight: false });\n    let focusLinkSelection;\n    let focusNodeSelection;\n    let highlightLinkSelection;\n    let highlightNodeSelection;\n    if (highlightedDatum?.type === 1 /* Node */) {\n      focusLinkSelection = nodeData.filter((node) => {\n        return node.type === 0 /* Link */ && (node.toNode === highlightedDatum || node.fromNode === highlightedDatum);\n      });\n      focusNodeSelection = focusLinkSelection.map((link) => {\n        return link.fromNode === highlightedDatum ? link.toNode : link.fromNode;\n      });\n      focusNodeSelection.push(highlightedDatum);\n      highlightLinkSelection = [];\n      highlightNodeSelection = [highlightedDatum];\n    } else if (highlightedDatum?.type === 0 /* Link */) {\n      focusLinkSelection = [highlightedDatum];\n      focusNodeSelection = [highlightedDatum.fromNode, highlightedDatum.toNode];\n      highlightLinkSelection = [highlightedDatum];\n      highlightNodeSelection = [];\n    } else {\n      focusLinkSelection = [];\n      focusNodeSelection = [];\n      highlightLinkSelection = [];\n      highlightNodeSelection = [];\n    }\n    this.focusLinkSelection = await this.updateLinkSelection({\n      nodeData: focusLinkSelection,\n      datumSelection: this.focusLinkSelection\n    });\n    await this.updateLinkNodes({ datumSelection: this.focusLinkSelection, isHighlight: false });\n    this.focusNodeSelection = await this.updateNodeSelection({\n      nodeData: focusNodeSelection,\n      datumSelection: this.focusNodeSelection\n    });\n    await this.updateNodeNodes({ datumSelection: this.focusNodeSelection, isHighlight: false });\n    this.highlightLinkSelection = await this.updateLinkSelection({\n      nodeData: highlightLinkSelection,\n      datumSelection: this.highlightLinkSelection\n    });\n    await this.updateLinkNodes({ datumSelection: this.highlightLinkSelection, isHighlight: true });\n    this.highlightNodeSelection = await this.updateNodeSelection({\n      nodeData: highlightNodeSelection,\n      datumSelection: this.highlightNodeSelection\n    });\n    await this.updateNodeNodes({ datumSelection: this.highlightNodeSelection, isHighlight: true });\n  }\n  resetAnimation(_chartAnimationPhase) {\n  }\n  getSeriesDomain(_direction) {\n    return [];\n  }\n  getLegendData(legendType) {\n    if (legendType !== \"category\")\n      return [];\n    return Array.from(\n      this.processedNodes.values(),\n      ({ id, label, fill, stroke }) => ({\n        legendType: \"category\",\n        id: this.id,\n        itemId: id,\n        seriesId: this.id,\n        enabled: true,\n        label: { text: label ?? id },\n        symbols: [\n          {\n            marker: {\n              fill,\n              fillOpacity: 1,\n              stroke,\n              strokeWidth: 0,\n              strokeOpacity: 1\n            }\n          }\n        ]\n      })\n    );\n  }\n  pickNodeClosestDatum({ x, y }) {\n    let minDistanceSquared = Infinity;\n    let minDatum;\n    this.linkSelection.each((node, datum) => {\n      const distanceSquared = node.containsPoint(x, y) ? 0 : Infinity;\n      if (distanceSquared < minDistanceSquared) {\n        minDistanceSquared = distanceSquared;\n        minDatum = datum;\n      }\n    });\n    this.nodeSelection.each((node, datum) => {\n      const distanceSquared = node.distanceSquared(x, y);\n      if (distanceSquared < minDistanceSquared) {\n        minDistanceSquared = distanceSquared;\n        minDatum = datum;\n      }\n    });\n    return minDatum != null ? { datum: minDatum, distance: Math.sqrt(minDistanceSquared) } : void 0;\n  }\n  getDatumAriaText(datum, description) {\n    if (datum.type === 0 /* Link */) {\n      return this.ctx.localeManager.t(\"ariaAnnounceFlowProportionLink\", {\n        index: datum.index + 1,\n        count: this.linkCount,\n        from: datum.fromNode.id,\n        to: datum.toNode.id,\n        size: datum.size,\n        sizeName: this.properties.sizeName ?? this.properties.sizeKey\n      });\n    } else if (datum.type === 1 /* Node */) {\n      return this.ctx.localeManager.t(\"ariaAnnounceFlowProportionNode\", {\n        index: datum.index + 1,\n        count: this.nodeCount,\n        description\n      });\n    }\n  }\n};\n__decorateClass([\n  Validate36(ARRAY4, { optional: true, property: \"nodes\" })\n], FlowProportionSeries.prototype, \"_chartNodes\", 2);\n\n// packages/ag-charts-enterprise/src/series/chord/chordLink.ts\n\nvar { Path: Path5, ScenePathChangeDetection } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar ChordLink = class extends Path5 {\n  constructor() {\n    super(...arguments);\n    this.centerX = 0;\n    this.centerY = 0;\n    this.radius = 0;\n    this.startAngle1 = 0;\n    this.endAngle1 = 0;\n    this.startAngle2 = 0;\n    this.endAngle2 = 0;\n    this.tension = 1;\n  }\n  tensionedCurveTo(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y) {\n    const { path, tension } = this;\n    const scale = 1 - tension;\n    path.cubicCurveTo(\n      (cp1x - cp0x) * scale + cp0x,\n      (cp1y - cp0y) * scale + cp0y,\n      (cp2x - cp3x) * scale + cp3x,\n      (cp2y - cp3y) * scale + cp3y,\n      cp3x,\n      cp3y\n    );\n  }\n  updatePath() {\n    const { path, centerX, centerY, radius } = this;\n    let { startAngle1, endAngle1, startAngle2, endAngle2 } = this;\n    if (startAngle1 > startAngle2) {\n      [startAngle1, startAngle2] = [startAngle2, startAngle1];\n      [endAngle1, endAngle2] = [endAngle2, endAngle1];\n    }\n    path.clear();\n    const startX = centerX + radius * Math.cos(startAngle1);\n    const startY = centerY + radius * Math.sin(startAngle1);\n    path.moveTo(startX, startY);\n    this.tensionedCurveTo(\n      startX,\n      startY,\n      centerX,\n      centerY,\n      centerX,\n      centerY,\n      centerX + radius * Math.cos(endAngle2),\n      centerY + radius * Math.sin(endAngle2)\n    );\n    path.arc(centerX, centerY, radius, endAngle2, startAngle2, true);\n    this.tensionedCurveTo(\n      centerX + radius * Math.cos(startAngle2),\n      centerY + radius * Math.sin(startAngle2),\n      centerX,\n      centerY,\n      centerX,\n      centerY,\n      centerX + radius * Math.cos(endAngle1),\n      centerY + radius * Math.sin(endAngle1)\n    );\n    path.arc(centerX, centerY, radius, endAngle1, startAngle1, true);\n    path.closePath();\n  }\n};\n__decorateClass([\n  ScenePathChangeDetection()\n], ChordLink.prototype, \"centerX\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], ChordLink.prototype, \"centerY\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], ChordLink.prototype, \"radius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], ChordLink.prototype, \"startAngle1\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], ChordLink.prototype, \"endAngle1\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], ChordLink.prototype, \"startAngle2\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], ChordLink.prototype, \"endAngle2\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], ChordLink.prototype, \"tension\", 2);\n\n// packages/ag-charts-enterprise/src/series/chord/chordSeriesProperties.ts\n\nvar {\n  BaseProperties: BaseProperties13,\n  SeriesTooltip: SeriesTooltip4,\n  SeriesProperties,\n  ARRAY: ARRAY5,\n  COLOR_STRING: COLOR_STRING9,\n  COLOR_STRING_ARRAY,\n  FUNCTION: FUNCTION7,\n  LINE_DASH: LINE_DASH8,\n  OBJECT: OBJECT13,\n  POSITIVE_NUMBER: POSITIVE_NUMBER13,\n  RATIO: RATIO14,\n  STRING: STRING15,\n  Validate: Validate37\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { Label: Label3 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar ChordSeriesLabelProperties = class extends Label3 {\n  constructor() {\n    super(...arguments);\n    this.spacing = 1;\n    this.maxWidth = 1;\n  }\n};\n__decorateClass([\n  Validate37(POSITIVE_NUMBER13)\n], ChordSeriesLabelProperties.prototype, \"spacing\", 2);\n__decorateClass([\n  Validate37(POSITIVE_NUMBER13)\n], ChordSeriesLabelProperties.prototype, \"maxWidth\", 2);\nvar ChordSeriesLinkProperties = class extends BaseProperties13 {\n  constructor() {\n    super(...arguments);\n    this.fill = void 0;\n    this.fillOpacity = 1;\n    this.stroke = void 0;\n    this.strokeOpacity = 1;\n    this.strokeWidth = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.tension = 0;\n  }\n};\n__decorateClass([\n  Validate37(COLOR_STRING9, { optional: true })\n], ChordSeriesLinkProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate37(RATIO14)\n], ChordSeriesLinkProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate37(COLOR_STRING9, { optional: true })\n], ChordSeriesLinkProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate37(RATIO14)\n], ChordSeriesLinkProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate37(POSITIVE_NUMBER13)\n], ChordSeriesLinkProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate37(LINE_DASH8)\n], ChordSeriesLinkProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate37(POSITIVE_NUMBER13)\n], ChordSeriesLinkProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate37(RATIO14)\n], ChordSeriesLinkProperties.prototype, \"tension\", 2);\n__decorateClass([\n  Validate37(FUNCTION7, { optional: true })\n], ChordSeriesLinkProperties.prototype, \"itemStyler\", 2);\nvar ChordSeriesNodeProperties = class extends BaseProperties13 {\n  constructor() {\n    super(...arguments);\n    this.spacing = 1;\n    this.width = 1;\n    this.fill = void 0;\n    this.fillOpacity = 1;\n    this.stroke = void 0;\n    this.strokeOpacity = 1;\n    this.strokeWidth = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n  }\n};\n__decorateClass([\n  Validate37(POSITIVE_NUMBER13)\n], ChordSeriesNodeProperties.prototype, \"spacing\", 2);\n__decorateClass([\n  Validate37(POSITIVE_NUMBER13)\n], ChordSeriesNodeProperties.prototype, \"width\", 2);\n__decorateClass([\n  Validate37(COLOR_STRING9, { optional: true })\n], ChordSeriesNodeProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate37(RATIO14)\n], ChordSeriesNodeProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate37(COLOR_STRING9, { optional: true })\n], ChordSeriesNodeProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate37(RATIO14)\n], ChordSeriesNodeProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate37(POSITIVE_NUMBER13)\n], ChordSeriesNodeProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate37(LINE_DASH8)\n], ChordSeriesNodeProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate37(POSITIVE_NUMBER13)\n], ChordSeriesNodeProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate37(FUNCTION7, { optional: true })\n], ChordSeriesNodeProperties.prototype, \"itemStyler\", 2);\nvar ChordSeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.idKey = \"\";\n    this.idName = void 0;\n    this.labelKey = void 0;\n    this.labelName = void 0;\n    this.sizeKey = void 0;\n    this.sizeName = void 0;\n    this.nodes = void 0;\n    this.fills = [];\n    this.strokes = [];\n    this.label = new ChordSeriesLabelProperties();\n    this.link = new ChordSeriesLinkProperties();\n    this.node = new ChordSeriesNodeProperties();\n    this.tooltip = new SeriesTooltip4();\n  }\n};\n__decorateClass([\n  Validate37(STRING15)\n], ChordSeriesProperties.prototype, \"fromKey\", 2);\n__decorateClass([\n  Validate37(STRING15)\n], ChordSeriesProperties.prototype, \"toKey\", 2);\n__decorateClass([\n  Validate37(STRING15)\n], ChordSeriesProperties.prototype, \"idKey\", 2);\n__decorateClass([\n  Validate37(STRING15, { optional: true })\n], ChordSeriesProperties.prototype, \"idName\", 2);\n__decorateClass([\n  Validate37(STRING15, { optional: true })\n], ChordSeriesProperties.prototype, \"labelKey\", 2);\n__decorateClass([\n  Validate37(STRING15, { optional: true })\n], ChordSeriesProperties.prototype, \"labelName\", 2);\n__decorateClass([\n  Validate37(STRING15, { optional: true })\n], ChordSeriesProperties.prototype, \"sizeKey\", 2);\n__decorateClass([\n  Validate37(STRING15, { optional: true })\n], ChordSeriesProperties.prototype, \"sizeName\", 2);\n__decorateClass([\n  Validate37(ARRAY5, { optional: true })\n], ChordSeriesProperties.prototype, \"nodes\", 2);\n__decorateClass([\n  Validate37(COLOR_STRING_ARRAY)\n], ChordSeriesProperties.prototype, \"fills\", 2);\n__decorateClass([\n  Validate37(COLOR_STRING_ARRAY)\n], ChordSeriesProperties.prototype, \"strokes\", 2);\n__decorateClass([\n  Validate37(OBJECT13)\n], ChordSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate37(OBJECT13)\n], ChordSeriesProperties.prototype, \"link\", 2);\n__decorateClass([\n  Validate37(OBJECT13)\n], ChordSeriesProperties.prototype, \"node\", 2);\n__decorateClass([\n  Validate37(OBJECT13)\n], ChordSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-enterprise/src/series/chord/chordSeries.ts\nvar { SeriesNodePickMode: SeriesNodePickMode3, createDatumId: createDatumId2, EMPTY_TOOLTIP_CONTENT } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { angleBetween: angleBetween3, normalizeAngle360: normalizeAngle3605, isBetweenAngles, sanitizeHtml: sanitizeHtml3, Logger: Logger7 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar { Sector: Sector3, Text: Text7 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar nodeMidAngle = (node) => node.startAngle + angleBetween3(node.startAngle, node.endAngle) / 2;\nvar ChordSeries = class extends FlowProportionSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      contentGroupVirtual: false,\n      pickModes: [SeriesNodePickMode3.NEAREST_NODE, SeriesNodePickMode3.EXACT_SHAPE_MATCH]\n    });\n    this.properties = new ChordSeriesProperties();\n  }\n  isLabelEnabled() {\n    return (this.properties.labelKey != null || this.nodes == null) && this.properties.label.enabled;\n  }\n  linkFactory() {\n    return new ChordLink();\n  }\n  nodeFactory() {\n    return new Sector3();\n  }\n  async createNodeData() {\n    const {\n      id: seriesId,\n      _nodeDataDependencies: { seriesRectWidth, seriesRectHeight } = { seriesRectWidth: 0, seriesRectHeight: 0 }\n    } = this;\n    const {\n      fromKey,\n      toKey,\n      sizeKey,\n      label: { spacing: labelSpacing, maxWidth: labelMaxWidth, fontSize },\n      node: { width: nodeWidth, spacing: nodeSpacing }\n    } = this.properties;\n    const centerX = seriesRectWidth / 2;\n    const centerY = seriesRectHeight / 2;\n    let labelData = [];\n    const defaultLabelFormatter = (v) => String(v);\n    const { nodeGraph, links } = this.getNodeGraph(\n      (node) => {\n        const label = this.getLabelText(\n          this.properties.label,\n          {\n            datum: node.datum,\n            value: node.label,\n            fromKey,\n            toKey,\n            sizeKey\n          },\n          defaultLabelFormatter\n        );\n        return {\n          ...node,\n          label,\n          size: 0,\n          centerX,\n          centerY,\n          innerRadius: NaN,\n          outerRadius: NaN,\n          startAngle: NaN,\n          endAngle: NaN\n        };\n      },\n      (link) => ({\n        ...link,\n        centerX,\n        centerY,\n        radius: NaN,\n        startAngle1: NaN,\n        endAngle1: NaN,\n        startAngle2: NaN,\n        endAngle2: NaN\n      }),\n      { includeCircularReferences: true }\n    );\n    let totalSize = 0;\n    nodeGraph.forEach(({ datum: node, linksBefore, linksAfter }, id) => {\n      const size = linksBefore.reduce((acc, { link }) => acc + link.size, 0) + linksAfter.reduce((acc, { link }) => acc + link.size, 0);\n      if (size === 0) {\n        nodeGraph.delete(id);\n      } else {\n        node.size = size;\n        totalSize += node.size;\n      }\n    });\n    let labelInset = 0;\n    if (this.isLabelEnabled()) {\n      const canvasFont = this.properties.label.getFont();\n      let maxMeasuredLabelWidth = 0;\n      nodeGraph.forEach(({ datum: node }) => {\n        const { id, label } = node;\n        if (label == null)\n          return;\n        const text = Text7.wrap(label, labelMaxWidth, Infinity, this.properties.label, \"never\", \"ellipsis\");\n        const { width } = Text7.measureText(text, canvasFont, \"middle\", \"left\");\n        maxMeasuredLabelWidth = Math.max(width, maxMeasuredLabelWidth);\n        labelData.push({\n          id,\n          text,\n          centerX,\n          centerY,\n          angle: NaN,\n          radius: NaN\n        });\n      });\n      labelInset = maxMeasuredLabelWidth + labelSpacing;\n    }\n    const nodeCount = nodeGraph.size;\n    let radius = Math.min(seriesRectWidth, seriesRectHeight) / 2 - nodeWidth - labelInset;\n    let spacingSweep = nodeSpacing / radius;\n    if (labelInset !== 0 && (nodeCount * spacingSweep >= 1.5 * Math.PI || radius <= 0)) {\n      labelData = [];\n      radius = Math.min(seriesRectWidth, seriesRectHeight) / 2 - nodeWidth;\n      spacingSweep = nodeSpacing / radius;\n    }\n    if (nodeCount * spacingSweep >= 2 * Math.PI || radius <= 0) {\n      Logger7.warnOnce(\"There was insufficient space to display the Chord Series.\");\n      return {\n        itemId: this.id,\n        nodeData: [],\n        labelData: []\n      };\n    }\n    const innerRadius = radius;\n    const outerRadius = radius + nodeWidth;\n    const sizeScale = Math.max((2 * Math.PI - nodeCount * spacingSweep) / totalSize, 0);\n    let nodeAngle = 0;\n    nodeGraph.forEach(({ datum: node }) => {\n      node.innerRadius = innerRadius;\n      node.outerRadius = outerRadius;\n      node.startAngle = nodeAngle;\n      node.endAngle = nodeAngle + node.size * sizeScale;\n      nodeAngle = node.endAngle + spacingSweep;\n      const midR = (node.innerRadius + node.outerRadius) / 2;\n      const midAngle = nodeMidAngle(node);\n      node.midPoint = {\n        x: node.centerX + midR * Math.cos(midAngle),\n        y: node.centerY + midR * Math.sin(midAngle)\n      };\n    });\n    const nodeData = [];\n    nodeGraph.forEach(({ datum: node, linksBefore, linksAfter }) => {\n      const midAngle = nodeMidAngle(node);\n      const combinedLinks = [\n        ...linksBefore.map((l) => ({\n          link: l.link,\n          distance: angleBetween3(nodeMidAngle(l.node.datum), midAngle),\n          after: false\n        })),\n        ...linksAfter.map((l) => ({\n          link: l.link,\n          distance: angleBetween3(nodeMidAngle(l.node.datum), midAngle),\n          after: true\n        }))\n      ];\n      let linkAngle = node.startAngle;\n      combinedLinks.sort((a, b) => a.distance - b.distance).forEach(({ link, after }) => {\n        const linkSweep = link.size * sizeScale;\n        if (after) {\n          link.startAngle1 = linkAngle;\n          link.endAngle1 = linkAngle + linkSweep;\n        } else {\n          link.startAngle2 = linkAngle;\n          link.endAngle2 = linkAngle + linkSweep;\n        }\n        linkAngle += link.size * sizeScale;\n      });\n      nodeData.push(node);\n    });\n    links.forEach((link) => {\n      link.radius = radius;\n      const cpa0 = link.startAngle1 + angleBetween3(link.startAngle1, link.endAngle1) / 2;\n      const cpa3 = link.startAngle2 + angleBetween3(link.startAngle2, link.endAngle2) / 2;\n      const cp0x = radius * Math.cos(cpa0);\n      const cp0y = radius * Math.sin(cpa0);\n      const cp3x = radius * Math.cos(cpa3);\n      const cp3y = radius * Math.sin(cpa3);\n      link.midPoint = {\n        x: link.centerX + (cp0x + cp3x) * 0.125,\n        y: link.centerY + (cp0y + cp3y) * 0.125\n      };\n      nodeData.push(link);\n    });\n    labelData.forEach((label) => {\n      const node = nodeGraph.get(label.id)?.datum;\n      if (node == null)\n        return;\n      label.radius = outerRadius + labelSpacing;\n      label.angle = normalizeAngle3605(node.startAngle + angleBetween3(node.startAngle, node.endAngle) / 2);\n    });\n    labelData.sort((a, b) => a.angle - b.angle);\n    let minAngle = Infinity;\n    let maxAngle = -Infinity;\n    labelData = labelData.filter((label) => {\n      const labelHeight = fontSize * Text7.defaultLineHeightRatio;\n      const da = Math.atan2(labelHeight / 2, label.radius);\n      const a0 = label.angle - da;\n      const a1 = label.angle + da;\n      if (isBetweenAngles(minAngle, a0, a1))\n        return false;\n      if (isBetweenAngles(maxAngle, a0, a1))\n        return false;\n      minAngle = Math.min(a0, minAngle);\n      maxAngle = Math.max(a1, maxAngle);\n      return true;\n    });\n    return {\n      itemId: seriesId,\n      nodeData,\n      labelData\n    };\n  }\n  async updateLabelSelection(opts) {\n    const labels = this.isLabelEnabled() ? opts.labelData : [];\n    return opts.labelSelection.update(labels);\n  }\n  async updateLabelNodes(opts) {\n    const { labelSelection } = opts;\n    const { color: fill, fontStyle, fontWeight, fontSize, fontFamily } = this.properties.label;\n    labelSelection.each((label, { text, centerX, centerY, radius, angle }) => {\n      label.visible = true;\n      label.translationX = centerX + radius * Math.cos(angle);\n      label.translationY = centerY + radius * Math.sin(angle);\n      label.text = text;\n      label.fill = fill;\n      label.fontStyle = fontStyle;\n      label.fontWeight = fontWeight;\n      label.fontSize = fontSize;\n      label.fontFamily = fontFamily;\n      label.textBaseline = \"middle\";\n      if (Math.cos(angle) >= 0) {\n        label.textAlign = \"left\";\n        label.rotation = angle;\n      } else {\n        label.textAlign = \"right\";\n        label.rotation = angle - Math.PI;\n      }\n    });\n  }\n  async updateNodeSelection(opts) {\n    return opts.datumSelection.update(opts.nodeData, void 0, (datum) => createDatumId2([datum.type, datum.id]));\n  }\n  async updateNodeNodes(opts) {\n    const { datumSelection, isHighlight } = opts;\n    const {\n      id: seriesId,\n      properties,\n      ctx: { callbackCache }\n    } = this;\n    const { fromKey, toKey, sizeKey } = this.properties;\n    const {\n      fill: baseFill,\n      fillOpacity,\n      stroke: baseStroke,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      itemStyler\n    } = properties.node;\n    const highlightStyle = isHighlight ? properties.highlightStyle.item : void 0;\n    const strokeWidth = this.getStrokeWidth(properties.node.strokeWidth);\n    datumSelection.each((sector, datum) => {\n      const fill = baseFill ?? datum.fill;\n      const stroke = baseStroke ?? datum.stroke;\n      let format;\n      if (itemStyler != null) {\n        const { label, size } = datum;\n        format = callbackCache.call(itemStyler, {\n          seriesId,\n          datum: datum.datum,\n          label,\n          size,\n          fromKey,\n          toKey,\n          sizeKey,\n          fill,\n          fillOpacity,\n          strokeOpacity,\n          stroke,\n          strokeWidth,\n          lineDash,\n          lineDashOffset,\n          highlighted: isHighlight\n        });\n      }\n      sector.centerX = datum.centerX;\n      sector.centerY = datum.centerY;\n      sector.innerRadius = datum.innerRadius;\n      sector.outerRadius = datum.outerRadius;\n      sector.startAngle = datum.startAngle;\n      sector.endAngle = datum.endAngle;\n      sector.fill = highlightStyle?.fill ?? format?.fill ?? fill;\n      sector.fillOpacity = highlightStyle?.fillOpacity ?? format?.fillOpacity ?? fillOpacity;\n      sector.stroke = highlightStyle?.stroke ?? format?.stroke ?? stroke;\n      sector.strokeOpacity = highlightStyle?.strokeOpacity ?? format?.strokeOpacity ?? strokeOpacity;\n      sector.strokeWidth = highlightStyle?.strokeWidth ?? format?.strokeWidth ?? strokeWidth;\n      sector.lineDash = highlightStyle?.lineDash ?? format?.lineDash ?? lineDash;\n      sector.lineDashOffset = highlightStyle?.lineDashOffset ?? format?.lineDashOffset ?? lineDashOffset;\n      sector.inset = sector.strokeWidth / 2;\n    });\n  }\n  async updateLinkSelection(opts) {\n    return opts.datumSelection.update(\n      opts.nodeData,\n      void 0,\n      (datum) => createDatumId2([datum.type, datum.index, datum.fromNode.id, datum.toNode.id])\n    );\n  }\n  async updateLinkNodes(opts) {\n    const { datumSelection, isHighlight } = opts;\n    const {\n      id: seriesId,\n      properties,\n      ctx: { callbackCache }\n    } = this;\n    const { fromKey, toKey, sizeKey } = properties;\n    const {\n      fill: baseFill,\n      fillOpacity,\n      stroke: baseStroke,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      tension,\n      itemStyler\n    } = properties.link;\n    const highlightStyle = isHighlight ? properties.highlightStyle.item : void 0;\n    const strokeWidth = this.getStrokeWidth(properties.link.strokeWidth);\n    datumSelection.each((link, datum) => {\n      const fill = baseFill ?? datum.fromNode.fill;\n      const stroke = baseStroke ?? datum.fromNode.stroke;\n      let format;\n      if (itemStyler != null) {\n        format = callbackCache.call(itemStyler, {\n          seriesId,\n          datum: datum.datum,\n          fromKey,\n          toKey,\n          sizeKey,\n          fill,\n          fillOpacity,\n          strokeOpacity,\n          stroke,\n          strokeWidth,\n          lineDash,\n          lineDashOffset,\n          tension,\n          highlighted: isHighlight\n        });\n      }\n      link.centerX = datum.centerX;\n      link.centerY = datum.centerY;\n      link.radius = datum.radius;\n      link.startAngle1 = datum.startAngle1;\n      link.endAngle1 = datum.endAngle1;\n      link.startAngle2 = datum.startAngle2;\n      link.endAngle2 = datum.endAngle2;\n      link.fill = highlightStyle?.fill ?? format?.fill ?? fill;\n      link.fillOpacity = highlightStyle?.fillOpacity ?? format?.fillOpacity ?? fillOpacity;\n      link.stroke = highlightStyle?.stroke ?? format?.stroke ?? stroke;\n      link.strokeOpacity = highlightStyle?.strokeOpacity ?? format?.strokeOpacity ?? strokeOpacity;\n      link.strokeWidth = highlightStyle?.strokeWidth ?? format?.strokeWidth ?? strokeWidth;\n      link.lineDash = highlightStyle?.lineDash ?? format?.lineDash ?? lineDash;\n      link.lineDashOffset = highlightStyle?.lineDashOffset ?? format?.lineDashOffset ?? lineDashOffset;\n      link.tension = format?.tension ?? tension;\n    });\n  }\n  resetAnimation(_chartAnimationPhase) {\n  }\n  getTooltipHtml(nodeDatum) {\n    const {\n      id: seriesId,\n      processedData,\n      ctx: { callbackCache },\n      properties\n    } = this;\n    if (!processedData || !properties.isValid()) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { fromKey, toKey, sizeKey, sizeName, tooltip } = properties;\n    const { datum, itemId } = nodeDatum;\n    let title;\n    const contentLines = [];\n    let fill;\n    if (nodeDatum.type === 0 /* Link */) {\n      const { fillOpacity, strokeOpacity, strokeWidth, lineDash, lineDashOffset, tension, itemStyler } = properties.link;\n      const { fromNode, toNode, size } = nodeDatum;\n      title = `${fromNode.label ?? fromNode.id} - ${toNode.label ?? toNode.id}`;\n      if (sizeKey != null) {\n        contentLines.push(sanitizeHtml3(`${sizeName ?? sizeKey}: ` + size));\n      }\n      fill = properties.link.fill ?? fromNode.fill;\n      const stroke = properties.link.stroke ?? fromNode.stroke;\n      let format;\n      if (itemStyler != null) {\n        format = callbackCache.call(itemStyler, {\n          seriesId,\n          datum: datum.datum,\n          fromKey,\n          toKey,\n          sizeKey,\n          fill,\n          fillOpacity,\n          strokeOpacity,\n          stroke,\n          strokeWidth,\n          lineDash,\n          lineDashOffset,\n          tension,\n          highlighted: true\n        });\n      }\n      fill = format?.fill ?? fill;\n    } else {\n      const { fillOpacity, strokeOpacity, strokeWidth, lineDash, lineDashOffset, itemStyler } = properties.node;\n      const { id, label, size } = nodeDatum;\n      title = label ?? id;\n      if (sizeKey != null) {\n        contentLines.push(sanitizeHtml3(`${sizeName ?? sizeKey}: ` + size));\n      }\n      fill = properties.link.fill ?? nodeDatum.fill;\n      const stroke = properties.link.stroke ?? nodeDatum.stroke;\n      let format;\n      if (itemStyler != null) {\n        format = callbackCache.call(itemStyler, {\n          seriesId,\n          datum: datum.datum,\n          label,\n          size,\n          fromKey,\n          toKey,\n          sizeKey,\n          fill,\n          fillOpacity,\n          strokeOpacity,\n          stroke,\n          strokeWidth,\n          lineDash,\n          lineDashOffset,\n          highlighted: true\n        });\n      }\n      fill = format?.fill ?? nodeDatum.fill;\n    }\n    const content = contentLines.join(\"<br>\");\n    const color = fill;\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        seriesId,\n        datum,\n        title,\n        color,\n        itemId,\n        fromKey,\n        toKey,\n        sizeKey,\n        sizeName,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  getLabelData() {\n    return [];\n  }\n  computeFocusBounds({\n    datumIndex\n  }) {\n    const datum = this.contextNodeData?.nodeData[datumIndex];\n    if (datum?.type === 1 /* Node */) {\n      for (const node of this.nodeSelection) {\n        if (node.datum === datum) {\n          return node.node;\n        }\n      }\n      return void 0;\n    } else if (datum?.type === 0 /* Link */) {\n      for (const link of this.linkSelection) {\n        if (link.datum === datum) {\n          return link.node;\n        }\n      }\n      return void 0;\n    }\n  }\n};\nChordSeries.className = \"ChordSeries\";\nChordSeries.type = \"chord\";\n\n// packages/ag-charts-enterprise/src/series/chord/chordModule.ts\nvar { DEFAULT_FONT_FAMILY, DEFAULT_LABEL_COLOUR } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme;\nvar ChordModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"flow-proportion\"],\n  solo: true,\n  identifier: \"chord\",\n  tooltipDefaults: { range: \"exact\" },\n  instanceConstructor: ChordSeries,\n  themeTemplate: {\n    series: {\n      highlightStyle: {\n        series: {\n          dimOpacity: 0.2\n        }\n      },\n      label: {\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR,\n        spacing: 5,\n        maxWidth: 100\n      },\n      node: {\n        spacing: 8,\n        width: 10,\n        strokeWidth: 0\n      },\n      link: {\n        fillOpacity: 0.5,\n        strokeWidth: 0,\n        tension: 0.4\n      }\n    },\n    legend: {\n      enabled: false,\n      toggleSeries: false\n    }\n  },\n  paletteFactory({ takeColors, colorsCount }) {\n    const { fills, strokes } = takeColors(colorsCount);\n    return {\n      fills,\n      strokes\n    };\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/heatmap/heatmapModule.ts\n\n\n// packages/ag-charts-enterprise/src/series/heatmap/heatmapSeries.ts\n\n\n// packages/ag-charts-enterprise/src/series/util/labelFormatter.ts\n\nvar { Validate: Validate38, NUMBER: NUMBER11, TEXT_WRAP, OVERFLOW_STRATEGY } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { Logger: Logger8 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar { Text: Text8, Label: Label4 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar BaseAutoSizedLabel = class extends Label4 {\n  constructor() {\n    super(...arguments);\n    this.wrapping = \"on-space\";\n    this.overflowStrategy = \"ellipsis\";\n  }\n  static lineHeight(fontSize) {\n    return Math.ceil(fontSize * Text8.defaultLineHeightRatio);\n  }\n};\n__decorateClass([\n  Validate38(TEXT_WRAP)\n], BaseAutoSizedLabel.prototype, \"wrapping\", 2);\n__decorateClass([\n  Validate38(OVERFLOW_STRATEGY)\n], BaseAutoSizedLabel.prototype, \"overflowStrategy\", 2);\n__decorateClass([\n  Validate38(NUMBER11, { optional: true })\n], BaseAutoSizedLabel.prototype, \"minimumFontSize\", 2);\nvar AutoSizedLabel = class extends BaseAutoSizedLabel {\n  constructor() {\n    super(...arguments);\n    this.spacing = 0;\n  }\n};\n__decorateClass([\n  Validate38(NUMBER11)\n], AutoSizedLabel.prototype, \"spacing\", 2);\nvar AutoSizeableSecondaryLabel = class extends BaseAutoSizedLabel {\n};\nfunction generateLabelSecondaryLabelFontSizeCandidates(label, secondaryLabel) {\n  const { fontSize: labelFontSize, minimumFontSize: labelMinimumFontSize = labelFontSize } = label;\n  const {\n    fontSize: secondaryLabelFontSize,\n    minimumFontSize: secondaryLabelMinimumFontSize = secondaryLabelFontSize\n  } = secondaryLabel;\n  const labelTracks = labelFontSize - labelMinimumFontSize;\n  const secondaryLabelTracks = secondaryLabelFontSize - secondaryLabelMinimumFontSize;\n  let currentLabelFontSize = label.fontSize;\n  let currentSecondaryLabelFontSize = secondaryLabel.fontSize;\n  const out = [{ labelFontSize, secondaryLabelFontSize }];\n  while (currentLabelFontSize > labelMinimumFontSize || currentSecondaryLabelFontSize > secondaryLabelMinimumFontSize) {\n    const labelProgress = labelTracks > 0 ? (currentLabelFontSize - labelMinimumFontSize) / labelTracks : -1;\n    const secondaryLabelProgress = secondaryLabelTracks > 0 ? (currentSecondaryLabelFontSize - secondaryLabelMinimumFontSize) / secondaryLabelTracks : -1;\n    if (labelProgress > secondaryLabelProgress) {\n      currentLabelFontSize--;\n    } else {\n      currentSecondaryLabelFontSize--;\n    }\n    out.push({\n      labelFontSize: currentLabelFontSize,\n      secondaryLabelFontSize: currentSecondaryLabelFontSize\n    });\n  }\n  out.reverse();\n  return out;\n}\nfunction maximumValueSatisfying(from, to, iteratee) {\n  if (from > to) {\n    return;\n  }\n  let min = from;\n  let max = to;\n  let found;\n  while (max >= min) {\n    const index = (max + min) / 2 | 0;\n    const value = iteratee(index);\n    if (value == null) {\n      max = index - 1;\n    } else {\n      found = value;\n      min = index + 1;\n    }\n  }\n  return found;\n}\nfunction formatStackedLabels(labelValue, labelProps, secondaryLabelValue, secondaryLabelProps, { padding }, sizeFittingHeight) {\n  const { spacing } = labelProps;\n  const widthAdjust = 2 * padding;\n  const heightAdjust = 2 * padding + spacing;\n  const minimumHeight = (labelProps.minimumFontSize ?? labelProps.fontSize) + (secondaryLabelProps.minimumFontSize ?? secondaryLabelProps.fontSize);\n  if (minimumHeight > sizeFittingHeight(minimumHeight + heightAdjust, false).height - heightAdjust) {\n    return;\n  }\n  const fontSizeCandidates = generateLabelSecondaryLabelFontSizeCandidates(labelProps, secondaryLabelProps);\n  const labelTextNode = new Text8();\n  labelTextNode.setFont(labelProps);\n  const labelTextSizeProps = {\n    fontFamily: labelProps.fontFamily,\n    fontSize: labelProps.fontSize,\n    fontStyle: labelProps.fontStyle,\n    fontWeight: labelProps.fontWeight\n  };\n  const secondaryLabelTextNode = new Text8();\n  secondaryLabelTextNode.setFont(secondaryLabelProps);\n  const secondaryLabelTextSizeProps = {\n    fontFamily: secondaryLabelProps.fontFamily,\n    fontSize: secondaryLabelProps.fontSize,\n    fontStyle: secondaryLabelProps.fontStyle,\n    fontWeight: secondaryLabelProps.fontWeight\n  };\n  let label;\n  let secondaryLabel;\n  return maximumValueSatisfying(0, fontSizeCandidates.length - 1, (index) => {\n    const { labelFontSize, secondaryLabelFontSize } = fontSizeCandidates[index];\n    const allowTruncation = index === 0;\n    const labelLineHeight = AutoSizedLabel.lineHeight(labelFontSize);\n    const secondaryLabelLineHeight = AutoSizeableSecondaryLabel.lineHeight(secondaryLabelFontSize);\n    const sizeFitting = sizeFittingHeight(\n      labelLineHeight + secondaryLabelLineHeight + heightAdjust,\n      allowTruncation\n    );\n    const availableWidth = sizeFitting.width - widthAdjust;\n    const availableHeight = sizeFitting.height - heightAdjust;\n    if (labelLineHeight + secondaryLabelLineHeight > availableHeight) {\n      return;\n    }\n    if (label == null || label.fontSize !== labelFontSize) {\n      labelTextSizeProps.fontSize = labelFontSize;\n      const labelLines = Text8.wrapLines(\n        labelValue,\n        availableWidth,\n        availableHeight,\n        labelTextSizeProps,\n        labelProps.wrapping,\n        allowTruncation ? labelProps.overflowStrategy : \"hide\"\n      );\n      if (labelLines == null) {\n        label = void 0;\n      } else {\n        const labelText = labelLines.join(\"\\n\");\n        labelTextNode.text = labelText;\n        labelTextNode.fontSize = labelFontSize;\n        labelTextNode.lineHeight = labelFontSize;\n        const labelWidth = labelTextNode.computeBBox().width;\n        const labelHeight = labelLines.length * labelLineHeight;\n        label = {\n          text: labelText,\n          fontSize: labelFontSize,\n          lineHeight: labelLineHeight,\n          width: labelWidth,\n          height: labelHeight\n        };\n      }\n    }\n    if (label == null || label.width > availableWidth || label.height > availableHeight) {\n      return;\n    }\n    if (secondaryLabel == null || secondaryLabel.fontSize !== secondaryLabelFontSize) {\n      secondaryLabelTextSizeProps.fontSize = secondaryLabelFontSize;\n      const secondaryLabelLines = Text8.wrapLines(\n        secondaryLabelValue,\n        availableWidth,\n        availableHeight,\n        secondaryLabelTextSizeProps,\n        secondaryLabelProps.wrapping,\n        allowTruncation ? secondaryLabelProps.overflowStrategy : \"hide\"\n      );\n      if (secondaryLabelLines == null) {\n        secondaryLabel = void 0;\n      } else {\n        const secondaryLabelText = secondaryLabelLines.join(\"\\n\");\n        secondaryLabelTextNode.text = secondaryLabelText;\n        secondaryLabelTextNode.fontSize = secondaryLabelFontSize;\n        secondaryLabelTextNode.lineHeight = secondaryLabelLineHeight;\n        const secondaryLabelWidth = secondaryLabelTextNode.computeBBox().width;\n        const secondaryLabelHeight = secondaryLabelLines.length * secondaryLabelLineHeight;\n        secondaryLabel = {\n          text: secondaryLabelText,\n          fontSize: secondaryLabelFontSize,\n          lineHeight: secondaryLabelLineHeight,\n          width: secondaryLabelWidth,\n          height: secondaryLabelHeight\n        };\n      }\n    }\n    if (secondaryLabel == null) {\n      return;\n    }\n    const totalLabelHeight = label.height + secondaryLabel.height;\n    if (secondaryLabel.width > availableWidth || totalLabelHeight > availableHeight) {\n      return;\n    }\n    return {\n      width: Math.max(label.width, secondaryLabel.width),\n      height: totalLabelHeight + spacing,\n      meta: sizeFitting.meta,\n      label,\n      secondaryLabel\n    };\n  });\n}\nfunction formatSingleLabel(value, props, { padding }, sizeFittingHeight) {\n  const sizeAdjust = 2 * padding;\n  const minimumFontSize = Math.min(props.minimumFontSize ?? props.fontSize, props.fontSize);\n  const textNode = new Text8();\n  textNode.setFont(props);\n  const textSizeProps = {\n    fontFamily: props.fontFamily,\n    fontSize: props.fontSize,\n    fontStyle: props.fontStyle,\n    fontWeight: props.fontWeight\n  };\n  return maximumValueSatisfying(minimumFontSize, props.fontSize, (fontSize) => {\n    const lineHeight = AutoSizedLabel.lineHeight(fontSize);\n    const allowTruncation = fontSize === minimumFontSize;\n    const sizeFitting = sizeFittingHeight(lineHeight + sizeAdjust, allowTruncation);\n    const availableWidth = sizeFitting.width - sizeAdjust;\n    const availableHeight = sizeFitting.height - sizeAdjust;\n    if (lineHeight > availableHeight) {\n      return;\n    }\n    textSizeProps.fontSize = fontSize;\n    const lines = Text8.wrapLines(\n      value,\n      availableWidth,\n      availableHeight,\n      textSizeProps,\n      props.wrapping,\n      allowTruncation ? props.overflowStrategy : \"hide\"\n    );\n    if (lines == null) {\n      return;\n    }\n    const text = lines.join(\"\\n\");\n    textNode.text = text;\n    textNode.fontSize = fontSize;\n    textNode.lineHeight = lineHeight;\n    const size = textNode.computeBBox();\n    const width = textNode.computeBBox().width;\n    const height = lineHeight * lines.length;\n    if (size.width > availableWidth || height > availableHeight) {\n      return;\n    }\n    return [{ text, fontSize, lineHeight, width, height }, sizeFitting.meta];\n  });\n}\nfunction hasInvalidFontSize(label) {\n  return label?.minimumFontSize != null && label?.fontSize && label?.minimumFontSize > label?.fontSize;\n}\nfunction formatLabels(baseLabelValue, labelProps, baseSecondaryLabelValue, secondaryLabelProps, layoutParams, sizeFittingHeight) {\n  const labelValue = labelProps.enabled ? baseLabelValue : void 0;\n  const secondaryLabelValue = secondaryLabelProps.enabled ? baseSecondaryLabelValue : void 0;\n  if (hasInvalidFontSize(labelProps) || hasInvalidFontSize(secondaryLabelProps)) {\n    Logger8.warnOnce(`minimumFontSize should be set to a value less than or equal to the font size`);\n  }\n  let value;\n  if (labelValue != null && secondaryLabelValue != null) {\n    value = formatStackedLabels(\n      labelValue,\n      labelProps,\n      secondaryLabelValue,\n      secondaryLabelProps,\n      layoutParams,\n      sizeFittingHeight\n    );\n  }\n  let labelMeta;\n  if (value == null && labelValue != null) {\n    labelMeta = formatSingleLabel(labelValue, labelProps, layoutParams, sizeFittingHeight);\n  }\n  if (labelMeta != null) {\n    const [label, meta] = labelMeta;\n    value = {\n      width: label.width,\n      height: label.height,\n      meta,\n      label,\n      secondaryLabel: void 0\n    };\n  }\n  let secondaryLabelMeta;\n  if (value == null && labelValue == null && secondaryLabelValue != null) {\n    secondaryLabelMeta = formatSingleLabel(\n      secondaryLabelValue,\n      secondaryLabelProps,\n      layoutParams,\n      sizeFittingHeight\n    );\n  }\n  if (secondaryLabelMeta != null) {\n    const [secondaryLabel, meta] = secondaryLabelMeta;\n    value = {\n      width: secondaryLabel.width,\n      height: secondaryLabel.height,\n      meta,\n      label: void 0,\n      secondaryLabel\n    };\n  }\n  return value;\n}\n\n// packages/ag-charts-enterprise/src/series/heatmap/heatmapSeriesProperties.ts\n\nvar {\n  CartesianSeriesProperties,\n  SeriesTooltip: SeriesTooltip5,\n  Validate: Validate39,\n  AND: AND7,\n  ARRAY: ARRAY6,\n  COLOR_STRING: COLOR_STRING10,\n  COLOR_STRING_ARRAY: COLOR_STRING_ARRAY2,\n  FUNCTION: FUNCTION8,\n  OBJECT: OBJECT14,\n  POSITIVE_NUMBER: POSITIVE_NUMBER14,\n  RATIO: RATIO15,\n  STRING: STRING16,\n  TEXT_ALIGN: TEXT_ALIGN2,\n  VERTICAL_ALIGN\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar HeatmapSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.colorRange = [\"black\", \"black\"];\n    this.stroke = \"black\";\n    this.strokeWidth = 0;\n    this.textAlign = \"center\";\n    this.verticalAlign = \"middle\";\n    this.itemPadding = 0;\n    this.label = new AutoSizedLabel();\n    this.tooltip = new SeriesTooltip5();\n  }\n};\n__decorateClass([\n  Validate39(STRING16, { optional: true })\n], HeatmapSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  Validate39(STRING16)\n], HeatmapSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate39(STRING16)\n], HeatmapSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate39(STRING16, { optional: true })\n], HeatmapSeriesProperties.prototype, \"colorKey\", 2);\n__decorateClass([\n  Validate39(STRING16, { optional: true })\n], HeatmapSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate39(STRING16, { optional: true })\n], HeatmapSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate39(STRING16, { optional: true })\n], HeatmapSeriesProperties.prototype, \"colorName\", 2);\n__decorateClass([\n  Validate39(AND7(COLOR_STRING_ARRAY2, ARRAY6.restrict({ minLength: 1 })))\n], HeatmapSeriesProperties.prototype, \"colorRange\", 2);\n__decorateClass([\n  Validate39(COLOR_STRING10, { optional: true })\n], HeatmapSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate39(RATIO15, { optional: true })\n], HeatmapSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate39(POSITIVE_NUMBER14, { optional: true })\n], HeatmapSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate39(TEXT_ALIGN2)\n], HeatmapSeriesProperties.prototype, \"textAlign\", 2);\n__decorateClass([\n  Validate39(VERTICAL_ALIGN)\n], HeatmapSeriesProperties.prototype, \"verticalAlign\", 2);\n__decorateClass([\n  Validate39(POSITIVE_NUMBER14)\n], HeatmapSeriesProperties.prototype, \"itemPadding\", 2);\n__decorateClass([\n  Validate39(FUNCTION8, { optional: true })\n], HeatmapSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate39(OBJECT14)\n], HeatmapSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate39(OBJECT14)\n], HeatmapSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-enterprise/src/series/heatmap/heatmapSeries.ts\nvar {\n  SeriesNodePickMode: SeriesNodePickMode4,\n  computeBarFocusBounds: computeBarFocusBounds4,\n  getMissCount,\n  valueProperty: valueProperty7,\n  ChartAxisDirection: ChartAxisDirection14,\n  DEFAULT_CARTESIAN_DIRECTION_KEYS,\n  DEFAULT_CARTESIAN_DIRECTION_NAMES\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { Rect: Rect3, PointerEvents } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar { ColorScale } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scale;\nvar { sanitizeHtml: sanitizeHtml4, Logger: Logger9 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar HeatmapSeriesNodeEvent = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.CartesianSeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.colorKey = series.properties.colorKey;\n  }\n};\nvar textAlignFactors = {\n  left: -0.5,\n  center: 0,\n  right: -0.5\n};\nvar verticalAlignFactors = {\n  top: -0.5,\n  middle: 0,\n  bottom: -0.5\n};\nvar HeatmapSeries = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [SeriesNodePickMode4.NEAREST_NODE, SeriesNodePickMode4.EXACT_SHAPE_MATCH],\n      pathsPerSeries: 0,\n      hasMarkers: false,\n      hasHighlightedLabels: true\n    });\n    this.properties = new HeatmapSeriesProperties();\n    this.NodeEvent = HeatmapSeriesNodeEvent;\n    this.colorScale = new ColorScale();\n  }\n  async processData(dataController) {\n    const xAxis = this.axes[ChartAxisDirection14.X];\n    const yAxis = this.axes[ChartAxisDirection14.Y];\n    if (!xAxis || !yAxis || !this.properties.isValid() || !this.data?.length) {\n      return;\n    }\n    const { xKey, yKey, colorRange, colorKey } = this.properties;\n    const xScale = this.axes[ChartAxisDirection14.X]?.scale;\n    const yScale = this.axes[ChartAxisDirection14.Y]?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const colorScaleType = this.colorScale.type;\n    const { dataModel, processedData } = await this.requestDataModel(dataController, this.data, {\n      props: [\n        valueProperty7(xKey, xScaleType, { id: \"xValue\" }),\n        valueProperty7(yKey, yScaleType, { id: \"yValue\" }),\n        ...colorKey ? [valueProperty7(colorKey, colorScaleType, { id: \"colorValue\" })] : []\n      ]\n    });\n    if (this.isColorScaleValid()) {\n      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, \"colorValue\");\n      this.colorScale.domain = processedData.domain.values[colorKeyIdx];\n      this.colorScale.range = colorRange;\n      this.colorScale.update();\n    }\n  }\n  isColorScaleValid() {\n    const { colorKey } = this.properties;\n    if (!colorKey) {\n      return false;\n    }\n    const { dataModel, processedData } = this;\n    if (!dataModel || !processedData) {\n      return false;\n    }\n    const colorDataIdx = dataModel.resolveProcessedDataIndexById(this, \"colorValue\");\n    const dataCount = processedData.data.length;\n    const missCount = getMissCount(this, processedData.defs.values[colorDataIdx].missing);\n    const colorDataMissing = dataCount === 0 || dataCount === missCount;\n    return !colorDataMissing;\n  }\n  getSeriesDomain(direction) {\n    const { dataModel, processedData } = this;\n    if (!dataModel || !processedData)\n      return [];\n    if (direction === ChartAxisDirection14.X) {\n      return dataModel.getDomain(this, `xValue`, \"value\", processedData);\n    } else {\n      return dataModel.getDomain(this, `yValue`, \"value\", processedData);\n    }\n  }\n  async createNodeData() {\n    const { data, visible, axes, dataModel } = this;\n    const xAxis = axes[ChartAxisDirection14.X];\n    const yAxis = axes[ChartAxisDirection14.Y];\n    if (!(data && dataModel && visible && xAxis && yAxis)) {\n      return;\n    }\n    if (xAxis.type !== \"category\" || yAxis.type !== \"category\") {\n      Logger9.warnOnce(\n        `Heatmap series expected axes to have \"category\" type, but received \"${xAxis.type}\" and \"${yAxis.type}\" instead.`\n      );\n      return;\n    }\n    const {\n      xKey,\n      xName,\n      yKey,\n      yName,\n      colorKey,\n      colorName,\n      textAlign,\n      verticalAlign,\n      itemPadding,\n      colorRange,\n      label\n    } = this.properties;\n    const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`);\n    const colorDataIdx = colorKey ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : void 0;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const yOffset = (yScale.bandwidth ?? 0) / 2;\n    const colorScaleValid = this.isColorScaleValid();\n    const nodeData = [];\n    const labelData = [];\n    const width = xScale.bandwidth ?? 10;\n    const height = yScale.bandwidth ?? 10;\n    const textAlignFactor = (width - 2 * itemPadding) * textAlignFactors[textAlign];\n    const verticalAlignFactor = (height - 2 * itemPadding) * verticalAlignFactors[verticalAlign];\n    const sizeFittingHeight = () => ({ width, height, meta: null });\n    for (const { values, datum } of this.processedData?.data ?? []) {\n      const xDatum = values[xDataIdx];\n      const yDatum = values[yDataIdx];\n      const x = xScale.convert(xDatum) + xOffset;\n      const y = yScale.convert(yDatum) + yOffset;\n      const colorValue = values[colorDataIdx ?? -1];\n      const fill = colorScaleValid && colorValue != null ? this.colorScale.convert(colorValue) : colorRange[0];\n      const labelText = colorValue == null ? void 0 : this.getLabelText(label, {\n        value: colorValue,\n        datum,\n        colorKey,\n        colorName,\n        xKey,\n        yKey,\n        xName,\n        yName\n      });\n      const labels = formatLabels(\n        labelText,\n        this.properties.label,\n        void 0,\n        this.properties.label,\n        { padding: itemPadding },\n        sizeFittingHeight\n      );\n      const point = { x, y, size: 0 };\n      nodeData.push({\n        series: this,\n        itemId: yKey,\n        yKey,\n        xKey,\n        xValue: xDatum,\n        yValue: yDatum,\n        colorValue,\n        datum,\n        point,\n        width,\n        height,\n        fill,\n        midPoint: { x, y },\n        missing: colorValue == null\n      });\n      if (labels?.label != null) {\n        const { text, fontSize, lineHeight, height: labelHeight } = labels.label;\n        const { fontStyle, fontFamily, fontWeight, color } = this.properties.label;\n        const lx = point.x + textAlignFactor * (width - 2 * itemPadding);\n        const ly = point.y + verticalAlignFactor * (height - 2 * itemPadding) - (labels.height - labelHeight) * 0.5;\n        labelData.push({\n          series: this,\n          itemId: yKey,\n          datum,\n          text,\n          fontSize,\n          lineHeight,\n          fontStyle,\n          fontFamily,\n          fontWeight,\n          color,\n          textAlign,\n          verticalAlign,\n          x: lx,\n          y: ly\n        });\n      }\n    }\n    return {\n      itemId: this.properties.yKey ?? this.id,\n      nodeData,\n      labelData,\n      scales: this.calculateScaling(),\n      visible: this.visible\n    };\n  }\n  nodeFactory() {\n    return new Rect3();\n  }\n  async updateDatumSelection(opts) {\n    const { nodeData, datumSelection } = opts;\n    const data = nodeData ?? [];\n    return datumSelection.update(data);\n  }\n  async updateDatumNodes(opts) {\n    const { isHighlight: isDatumHighlighted } = opts;\n    const {\n      id: seriesId,\n      ctx: { callbackCache },\n      properties\n    } = this;\n    const { xKey, yKey, colorKey, itemStyler } = properties;\n    const highlightStyle = isDatumHighlighted ? properties.highlightStyle.item : void 0;\n    const fillOpacity = highlightStyle?.fillOpacity ?? 1;\n    const stroke = highlightStyle?.stroke ?? properties.stroke;\n    const strokeWidth = highlightStyle?.strokeWidth ?? this.getStrokeWidth(properties.strokeWidth);\n    const strokeOpacity = highlightStyle?.strokeOpacity ?? properties.strokeOpacity ?? 1;\n    const xAxis = this.axes[ChartAxisDirection14.X];\n    const [visibleMin, visibleMax] = xAxis?.visibleRange ?? [];\n    const isZoomed = visibleMin !== 0 || visibleMax !== 1;\n    const crisp = !isZoomed;\n    opts.datumSelection.each((rect, nodeDatum) => {\n      const { datum, point, width, height } = nodeDatum;\n      const fill = highlightStyle?.fill ?? nodeDatum.fill;\n      let format;\n      if (itemStyler) {\n        format = callbackCache.call(itemStyler, {\n          datum,\n          fill,\n          fillOpacity,\n          stroke,\n          strokeOpacity,\n          strokeWidth,\n          highlighted: isDatumHighlighted,\n          xKey,\n          yKey,\n          colorKey,\n          seriesId\n        });\n      }\n      rect.crisp = crisp;\n      rect.x = Math.floor(point.x - width / 2);\n      rect.y = Math.floor(point.y - height / 2);\n      rect.width = Math.ceil(width);\n      rect.height = Math.ceil(height);\n      rect.fill = format?.fill ?? fill;\n      rect.fillOpacity = format?.fillOpacity ?? fillOpacity;\n      rect.stroke = format?.stroke ?? stroke;\n      rect.strokeWidth = format?.strokeWidth ?? strokeWidth;\n      rect.strokeOpacity = format?.strokeOpacity ?? strokeOpacity;\n    });\n  }\n  async updateLabelSelection(opts) {\n    const { labelData, labelSelection } = opts;\n    const { enabled } = this.properties.label;\n    const data = enabled ? labelData : [];\n    return labelSelection.update(data);\n  }\n  async updateLabelNodes(opts) {\n    opts.labelSelection.each((text, datum) => {\n      text.text = datum.text;\n      text.fontSize = datum.fontSize;\n      text.lineHeight = datum.lineHeight;\n      text.fontStyle = datum.fontStyle;\n      text.fontFamily = datum.fontFamily;\n      text.fontWeight = datum.fontWeight;\n      text.fill = datum.color;\n      text.textAlign = datum.textAlign;\n      text.textBaseline = datum.verticalAlign;\n      text.x = datum.x;\n      text.y = datum.y;\n      text.pointerEvents = PointerEvents.None;\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const xAxis = this.axes[ChartAxisDirection14.X];\n    const yAxis = this.axes[ChartAxisDirection14.Y];\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.EMPTY_TOOLTIP_CONTENT;\n    }\n    const {\n      xKey,\n      yKey,\n      colorKey,\n      xName,\n      yName,\n      colorName,\n      stroke,\n      strokeWidth,\n      strokeOpacity = 1,\n      colorRange,\n      itemStyler,\n      tooltip\n    } = this.properties;\n    const {\n      colorScale,\n      id: seriesId,\n      ctx: { callbackCache }\n    } = this;\n    const { datum, xValue, yValue, colorValue, itemId } = nodeDatum;\n    const fill = this.isColorScaleValid() ? colorScale.convert(colorValue) : colorRange[0];\n    let format;\n    if (itemStyler) {\n      format = callbackCache.call(itemStyler, {\n        datum,\n        xKey,\n        yKey,\n        colorKey,\n        fill,\n        fillOpacity: 1,\n        stroke,\n        strokeWidth,\n        strokeOpacity,\n        highlighted: false,\n        seriesId\n      });\n    }\n    const color = format?.fill ?? fill ?? \"gray\";\n    const title = this.properties.title ?? yName;\n    const xString = sanitizeHtml4(xAxis.formatDatum(xValue));\n    const yString = sanitizeHtml4(yAxis.formatDatum(yValue));\n    let content = `<b>${sanitizeHtml4(xName ?? xKey)}</b>: ${xString}<br><b>${sanitizeHtml4(yName ?? yKey)}</b>: ${yString}`;\n    if (colorKey) {\n      content = `<b>${sanitizeHtml4(colorName ?? colorKey)}</b>: ${sanitizeHtml4(colorValue)}<br>` + content;\n    }\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        seriesId,\n        datum,\n        xKey,\n        yKey,\n        xName,\n        yName,\n        title,\n        color,\n        colorKey,\n        colorName,\n        itemId\n      }\n    );\n  }\n  getLegendData(legendType) {\n    if (legendType !== \"gradient\" || !this.data?.length || !this.properties.isValid() || !this.isColorScaleValid() || !this.dataModel) {\n      return [];\n    }\n    return [\n      {\n        legendType: \"gradient\",\n        enabled: this.visible,\n        seriesId: this.id,\n        colorName: this.properties.colorName,\n        colorDomain: this.processedData.domain.values[this.dataModel.resolveProcessedDataIndexById(this, \"colorValue\")],\n        colorRange: this.properties.colorRange\n      }\n    ];\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled && Boolean(this.properties.colorKey);\n  }\n  getBandScalePadding() {\n    return { inner: 0, outer: 0 };\n  }\n  computeFocusBounds({ datumIndex, seriesRect }) {\n    const datum = this.contextNodeData?.nodeData[datumIndex];\n    if (datum === void 0)\n      return void 0;\n    const { width, height, midPoint } = datum;\n    const focusRect = { x: midPoint.x - width / 2, y: midPoint.y - height / 2, width, height };\n    return computeBarFocusBounds4(focusRect, this.contentGroup, seriesRect);\n  }\n};\nHeatmapSeries.className = \"HeatmapSeries\";\nHeatmapSeries.type = \"heatmap\";\n\n// packages/ag-charts-enterprise/src/series/heatmap/heatmapThemes.ts\n\nvar HEATMAP_SERIES_THEME = {\n  series: {\n    label: {\n      enabled: false,\n      color: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_LABEL_COLOUR,\n      fontSize: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.FONT_SIZE.SMALL,\n      fontFamily: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_FONT_FAMILY,\n      wrapping: \"on-space\",\n      overflowStrategy: \"ellipsis\"\n    },\n    itemPadding: 3\n  },\n  gradientLegend: {\n    enabled: true\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/heatmap/heatmapModule.ts\nvar HeatmapModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"heatmap\",\n  instanceConstructor: HeatmapSeries,\n  tooltipDefaults: { range: \"exact\" },\n  defaultAxes: [\n    {\n      type: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.CARTESIAN_AXIS_TYPE.CATEGORY,\n      position: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POSITION.LEFT\n    },\n    {\n      type: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.CARTESIAN_AXIS_TYPE.CATEGORY,\n      position: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POSITION.BOTTOM\n    }\n  ],\n  themeTemplate: HEATMAP_SERIES_THEME,\n  paletteFactory: ({ takeColors, colorsCount, userPalette, themeTemplateParameters }) => {\n    const defaultColorRange = themeTemplateParameters.get(ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_DIVERGING_SERIES_COLOUR_RANGE);\n    const defaultBackgroundColor = themeTemplateParameters.get(ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_BACKGROUND_COLOUR);\n    const backgroundFill = (Array.isArray(defaultBackgroundColor) ? defaultBackgroundColor[0] : defaultBackgroundColor) ?? \"white\";\n    const { fills, strokes } = takeColors(colorsCount);\n    return {\n      stroke: userPalette === \"inbuilt\" ? backgroundFill : strokes[0],\n      colorRange: userPalette === \"inbuilt\" ? defaultColorRange : [fills[0], fills[1]]\n    };\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/map-line-background/mapLineBackgroundModule.ts\n\n\n// packages/ag-charts-enterprise/src/series/map-util/mapThemeDefaults.ts\nvar MAP_THEME_DEFAULTS = {\n  zoom: {\n    axes: \"xy\",\n    anchorPointX: \"pointer\",\n    anchorPointY: \"pointer\"\n  },\n  legend: {\n    enabled: false\n  },\n  gradientLegend: {\n    enabled: false\n  },\n  tooltip: {\n    range: \"exact\"\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/map-line-background/mapLineBackgroundSeries.ts\n\n\n// packages/ag-charts-enterprise/src/series/map-util/geoGeometry.ts\n\n\n// packages/ag-charts-enterprise/src/series/map-util/lineStringUtil.ts\nvar delta = 1e-9;\nfunction lineSegmentDistanceToPointSquared(a, b, x, y) {\n  const [ax, ay] = a;\n  const [bx, by] = b;\n  const abx = bx - ax;\n  const aby = by - ay;\n  const l = abx * abx + aby * aby;\n  let x0;\n  let y0;\n  if (Math.abs(l) < delta) {\n    x0 = ax;\n    y0 = ay;\n  } else {\n    let t = ((x - ax) * abx + (y - ay) * aby) / l;\n    t = Math.max(0, Math.min(1, t));\n    x0 = ax + t * (bx - ax);\n    y0 = ay + t * (by - ay);\n  }\n  const dx2 = x - x0;\n  const dy2 = y - y0;\n  return dx2 * dx2 + dy2 * dy2;\n}\nfunction lineStringDistance(lineString, x, y) {\n  let minDistanceSquared = Infinity;\n  let p0 = lineString[lineString.length - 1];\n  for (const p1 of lineString) {\n    minDistanceSquared = Math.min(minDistanceSquared, lineSegmentDistanceToPointSquared(p0, p1, x, y));\n    p0 = p1;\n  }\n  return Math.sqrt(minDistanceSquared);\n}\nfunction lineStringLength(lineSegment) {\n  let [x0, y0] = lineSegment[0];\n  let totalDistance = 0;\n  for (let i = 1; i < lineSegment.length; i += 1) {\n    const [x1, y1] = lineSegment[i];\n    const distance = Math.hypot(x1 - x0, y1 - y0);\n    totalDistance += distance;\n    x0 = x1;\n    y0 = y1;\n  }\n  return totalDistance;\n}\nfunction lineStringCenter(lineSegment) {\n  if (lineSegment.length === 0)\n    return;\n  const targetDistance = lineStringLength(lineSegment) / 2;\n  let [x0, y0] = lineSegment[0];\n  let totalDistance = 0;\n  for (let i = 1; i < lineSegment.length; i += 1) {\n    const [x1, y1] = lineSegment[i];\n    const segmentDistance = Math.hypot(x1 - x0, y1 - y0);\n    const nextDistance = totalDistance + segmentDistance;\n    if (nextDistance > targetDistance) {\n      const ratio = (targetDistance - totalDistance) / segmentDistance;\n      const point = [x0 + (x1 - x0) * ratio, y0 + (y1 - y0) * ratio];\n      const angle = Math.atan2(y1 - y0, x1 - x0);\n      return { point, angle };\n    }\n    totalDistance = nextDistance;\n    x0 = x1;\n    y0 = y1;\n  }\n}\n\n// packages/ag-charts-enterprise/src/series/map-util/bboxUtil.ts\n\nvar { LonLatBBox } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nfunction extendBbox(into, lon0, lat0, lon1, lat1) {\n  if (into == null) {\n    into = new LonLatBBox(lon0, lat0, lon1, lat1);\n  } else {\n    into.lon0 = Math.min(into.lon0, lon0);\n    into.lat0 = Math.min(into.lat0, lat0);\n    into.lon1 = Math.max(into.lon1, lon1);\n    into.lat1 = Math.max(into.lat1, lat1);\n  }\n  return into;\n}\n\n// packages/ag-charts-enterprise/src/series/map-util/linkedList.ts\nvar insertManySorted = (list, items, cmp) => {\n  let head = list;\n  let current = head;\n  for (const value of items) {\n    if (head == null || cmp(head.value, value) > 0) {\n      head = { value, next: head };\n      current = head;\n    } else {\n      current = current;\n      while (current.next != null && cmp(current.next.value, value) <= 0) {\n        current = current.next;\n      }\n      current.next = { value, next: current.next };\n    }\n  }\n  return head;\n};\n\n// packages/ag-charts-enterprise/src/series/map-util/polygonUtil.ts\nfunction polygonBbox(polygon, into) {\n  polygon.forEach((coordinates) => {\n    const [lon, lat] = coordinates;\n    into = extendBbox(into, lon, lat, lon, lat);\n  });\n  return into;\n}\nfunction polygonCentroid(polygon) {\n  if (polygon.length === 0)\n    return;\n  let x = 0;\n  let y = 0;\n  let k = 0;\n  let [x0, y0] = polygon[polygon.length - 1];\n  for (const [x1, y1] of polygon) {\n    const c = x0 * y1 - x1 * y0;\n    k += c;\n    x += (x0 + x1) * c;\n    y += (y0 + y1) * c;\n    x0 = x1;\n    y0 = y1;\n  }\n  k *= 3;\n  return [x / k, y / k];\n}\nfunction polygonDistance(polygons, x, y) {\n  let inside = false;\n  let minDistanceSquared = Infinity;\n  for (const polygon of polygons) {\n    let p0 = polygon[polygon.length - 1];\n    let [x0, y0] = p0;\n    for (const p1 of polygon) {\n      const [x1, y1] = p1;\n      if (y1 > y !== y0 > y && x < (x0 - x1) * (y - y1) / (y0 - y1) + x1) {\n        inside = !inside;\n      }\n      minDistanceSquared = Math.min(minDistanceSquared, lineSegmentDistanceToPointSquared(p0, p1, x, y));\n      p0 = p1;\n      x0 = x1;\n      y0 = y1;\n    }\n  }\n  return (inside ? -1 : 1) * Math.sqrt(minDistanceSquared);\n}\n\n// packages/ag-charts-enterprise/src/series/map-util/geoGeometry.ts\nvar { Path: Path6, ExtendedPath2D, BBox: BBox7, ScenePathChangeDetection: ScenePathChangeDetection2 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar GeoGeometry = class extends Path6 {\n  constructor() {\n    super(...arguments);\n    this.projectedGeometry = void 0;\n    this.renderMode = 3 /* All */;\n    // Keep non-filled shapes separate so we don't fill them\n    this.strokePath = new ExtendedPath2D();\n  }\n  computeBBox() {\n    if (this.dirtyPath || this.isDirtyPath()) {\n      this.updatePath();\n      this.dirtyPath = false;\n    }\n    return this.bbox?.clone();\n  }\n  updatePath() {\n    const { projectedGeometry } = this;\n    this.strokePath.clear();\n    this.path.clear();\n    this.bbox = projectedGeometry != null ? this.drawGeometry(projectedGeometry, void 0) : void 0;\n  }\n  drawPath(ctx) {\n    super.drawPath(ctx);\n    this.renderStroke(ctx, this.strokePath.getPath2D());\n  }\n  containsPoint(x, y) {\n    const { projectedGeometry } = this;\n    if (projectedGeometry == null)\n      return false;\n    ({ x, y } = this.transformPoint(x, y));\n    if (!this.getCachedBBox().containsPoint(x, y))\n      return false;\n    return this.geometryDistance(projectedGeometry, x, y) <= 0;\n  }\n  distanceToPoint(x, y) {\n    const { projectedGeometry } = this;\n    ({ x, y } = this.transformPoint(x, y));\n    return projectedGeometry != null ? this.geometryDistance(projectedGeometry, x, y) : Infinity;\n  }\n  geometryDistance(geometry, x, y) {\n    const { renderMode, strokeWidth } = this;\n    const drawPolygons = (renderMode & 1 /* Polygons */) !== 0;\n    const drawLines = (renderMode & 2 /* Lines */) !== 0;\n    const minStrokeDistance = Math.max(strokeWidth / 2, 1) + 1;\n    switch (geometry.type) {\n      case \"GeometryCollection\":\n        return geometry.geometries.reduce(\n          (minDistance, g) => Math.min(minDistance, this.geometryDistance(g, x, y)),\n          Infinity\n        );\n      case \"MultiPolygon\":\n        return drawPolygons ? geometry.coordinates.reduce(\n          (minDistance, polygon) => Math.min(minDistance, Math.max(polygonDistance(polygon, x, y), 0)),\n          Infinity\n        ) : Infinity;\n      case \"Polygon\":\n        return drawPolygons ? Math.max(polygonDistance(geometry.coordinates, x, y), 0) : Infinity;\n      case \"MultiLineString\":\n        return drawLines ? geometry.coordinates.reduce((minDistance, lineString) => {\n          return Math.min(\n            minDistance,\n            Math.max(lineStringDistance(lineString, x, y) - minStrokeDistance, 0)\n          );\n        }, Infinity) : Infinity;\n      case \"LineString\":\n        return drawLines ? Math.max(lineStringDistance(geometry.coordinates, x, y) - minStrokeDistance, 0) : Infinity;\n      case \"MultiPoint\":\n      case \"Point\":\n      default:\n        return Infinity;\n    }\n  }\n  drawGeometry(geometry, bbox) {\n    const { renderMode, path, strokePath } = this;\n    const drawPolygons = (renderMode & 1 /* Polygons */) !== 0;\n    const drawLines = (renderMode & 2 /* Lines */) !== 0;\n    switch (geometry.type) {\n      case \"GeometryCollection\":\n        geometry.geometries.forEach((g) => {\n          bbox = this.drawGeometry(g, bbox);\n        });\n        break;\n      case \"MultiPolygon\":\n        if (drawPolygons) {\n          geometry.coordinates.forEach((coordinates) => {\n            bbox = this.drawPolygon(path, coordinates, bbox);\n          });\n        }\n        break;\n      case \"Polygon\":\n        if (drawPolygons) {\n          bbox = this.drawPolygon(path, geometry.coordinates, bbox);\n        }\n        break;\n      case \"LineString\":\n        if (drawLines) {\n          bbox = this.drawLineString(strokePath, geometry.coordinates, bbox, false);\n        }\n        break;\n      case \"MultiLineString\":\n        if (drawLines) {\n          geometry.coordinates.forEach((coordinates) => {\n            bbox = this.drawLineString(strokePath, coordinates, bbox, false);\n          });\n        }\n        break;\n      case \"Point\":\n      case \"MultiPoint\":\n        break;\n    }\n    return bbox;\n  }\n  drawPolygon(path, polygons, bbox) {\n    if (polygons.length < 1)\n      return bbox;\n    bbox = this.drawLineString(path, polygons[0], bbox, true);\n    for (let i = 1; i < polygons.length; i += 1) {\n      const enclave = polygons[i];\n      this.drawLineString(path, enclave, void 0, true);\n    }\n    return bbox;\n  }\n  drawLineString(path, coordinates, bbox, isClosed) {\n    if (coordinates.length < 2)\n      return bbox;\n    const end = isClosed ? coordinates.length - 1 : coordinates.length;\n    for (let i = 0; i < end; i += 1) {\n      const [x, y] = coordinates[i];\n      if (i === 0) {\n        path.moveTo(x, y);\n      } else {\n        path.lineTo(x, y);\n      }\n      if (bbox == null) {\n        bbox = new BBox7(x, y, 0, 0);\n      } else {\n        const { x: x0, y: y0 } = bbox;\n        const x1 = x0 + bbox.width;\n        const y1 = y0 + bbox.height;\n        bbox.x = Math.min(x0, x);\n        bbox.y = Math.min(y0, y);\n        bbox.width = Math.max(x1, x) - bbox.x;\n        bbox.height = Math.max(y1, y) - bbox.y;\n      }\n    }\n    if (isClosed) {\n      path.closePath();\n    }\n    return bbox;\n  }\n};\n__decorateClass([\n  ScenePathChangeDetection2()\n], GeoGeometry.prototype, \"projectedGeometry\", 2);\n__decorateClass([\n  ScenePathChangeDetection2()\n], GeoGeometry.prototype, \"renderMode\", 2);\n\n// packages/ag-charts-enterprise/src/series/map-util/geometryUtil.ts\nfunction geometryBbox(geometry, into) {\n  if (geometry.bbox != null) {\n    const [lon0, lat0, lon1, lat1] = geometry.bbox;\n    into = extendBbox(into, lon0, lat0, lon1, lat1);\n    return into;\n  }\n  switch (geometry.type) {\n    case \"GeometryCollection\":\n      geometry.geometries.forEach((g) => {\n        into = geometryBbox(g, into);\n      });\n      break;\n    case \"MultiPolygon\":\n      geometry.coordinates.forEach((c) => {\n        if (c.length > 0) {\n          into = polygonBbox(c[0], into);\n        }\n      });\n      break;\n    case \"Polygon\":\n      if (geometry.coordinates.length > 0) {\n        into = polygonBbox(geometry.coordinates[0], into);\n      }\n      break;\n    case \"MultiLineString\":\n      geometry.coordinates.forEach((c) => {\n        into = polygonBbox(c, into);\n      });\n      break;\n    case \"LineString\":\n      into = polygonBbox(geometry.coordinates, into);\n      break;\n    case \"MultiPoint\":\n      geometry.coordinates.forEach((p) => {\n        const [lon, lat] = p;\n        into = extendBbox(into, lon, lat, lon, lat);\n      });\n      break;\n    case \"Point\": {\n      const [lon, lat] = geometry.coordinates;\n      into = extendBbox(into, lon, lat, lon, lat);\n      break;\n    }\n  }\n  return into;\n}\nfunction largestPolygon(geometry) {\n  switch (geometry.type) {\n    case \"GeometryCollection\": {\n      let maxArea;\n      let maxPolygon;\n      geometry.geometries.map((g) => {\n        const polygon = largestPolygon(g);\n        if (polygon == null)\n          return;\n        const bbox = polygonBbox(polygon[0], void 0);\n        if (bbox == null)\n          return;\n        const area = Math.abs(bbox.lat1 - bbox.lat0) * Math.abs(bbox.lon1 - bbox.lon0);\n        if (maxArea == null || area > maxArea) {\n          maxArea = area;\n          maxPolygon = polygon;\n        }\n      });\n      return maxPolygon;\n    }\n    case \"MultiPolygon\": {\n      let maxArea;\n      let maxPolygon;\n      geometry.coordinates.forEach((polygon) => {\n        const bbox = polygonBbox(polygon[0], void 0);\n        if (bbox == null)\n          return;\n        const area = Math.abs(bbox.lat1 - bbox.lat0) * Math.abs(bbox.lon1 - bbox.lon0);\n        if (maxArea == null || area > maxArea) {\n          maxArea = area;\n          maxPolygon = polygon;\n        }\n      });\n      return maxPolygon;\n    }\n    case \"Polygon\":\n      return geometry.coordinates;\n    case \"MultiLineString\":\n    case \"LineString\":\n    case \"MultiPoint\":\n    case \"Point\":\n      return;\n  }\n}\nfunction largestLineString(geometry) {\n  switch (geometry.type) {\n    case \"GeometryCollection\": {\n      let maxLength;\n      let maxLineString;\n      geometry.geometries.map((g) => {\n        const lineString = largestLineString(g);\n        if (lineString == null)\n          return;\n        const length = lineStringLength(lineString);\n        if (length == null)\n          return;\n        if (maxLength == null || length > maxLength) {\n          maxLength = length;\n          maxLineString = lineString;\n        }\n      });\n      return maxLineString;\n    }\n    case \"MultiLineString\": {\n      let maxLength = 0;\n      let maxLineString;\n      geometry.coordinates.forEach((lineString) => {\n        const length = lineStringLength(lineString);\n        if (length > maxLength) {\n          maxLength = length;\n          maxLineString = lineString;\n        }\n      });\n      return maxLineString;\n    }\n    case \"LineString\":\n      return geometry.coordinates;\n    case \"MultiPolygon\":\n    case \"Polygon\":\n    case \"MultiPoint\":\n    case \"Point\":\n      return;\n  }\n}\nfunction containsType(geometry, type) {\n  if (geometry == null)\n    return false;\n  switch (geometry.type) {\n    case \"GeometryCollection\":\n      return geometry.geometries.some((g) => containsType(g, type));\n    case \"MultiPolygon\":\n    case \"Polygon\":\n      return (type & 1 /* Polygon */) !== 0;\n    case \"MultiLineString\":\n    case \"LineString\":\n      return (type & 2 /* LineString */) !== 0;\n    case \"MultiPoint\":\n    case \"Point\":\n      return (type & 4 /* Point */) !== 0;\n  }\n}\nfunction projectGeometry(geometry, scale) {\n  switch (geometry.type) {\n    case \"GeometryCollection\":\n      return {\n        type: \"GeometryCollection\",\n        geometries: geometry.geometries.map((g) => projectGeometry(g, scale))\n      };\n    case \"Polygon\":\n      return {\n        type: \"Polygon\",\n        coordinates: projectPolygon(geometry.coordinates, scale)\n      };\n    case \"MultiPolygon\":\n      return {\n        type: \"MultiPolygon\",\n        coordinates: projectMultiPolygon(geometry.coordinates, scale)\n      };\n    case \"MultiLineString\":\n      return {\n        type: \"MultiLineString\",\n        coordinates: projectPolygon(geometry.coordinates, scale)\n      };\n    case \"LineString\":\n      return {\n        type: \"LineString\",\n        coordinates: projectLineString(geometry.coordinates, scale)\n      };\n    case \"MultiPoint\":\n      return {\n        type: \"MultiPoint\",\n        coordinates: projectLineString(geometry.coordinates, scale)\n      };\n    case \"Point\":\n      return {\n        type: \"Point\",\n        coordinates: scale.convert(geometry.coordinates)\n      };\n  }\n}\nfunction projectMultiPolygon(multiPolygon, scale) {\n  return multiPolygon.map((polygon) => projectPolygon(polygon, scale));\n}\nfunction projectPolygon(polygon, scale) {\n  return polygon.map((lineString) => projectLineString(lineString, scale));\n}\nfunction projectLineString(lineString, scale) {\n  return lineString.map((lonLat) => scale.convert(lonLat));\n}\n\n// packages/ag-charts-enterprise/src/series/map-util/validation.ts\n\nfunction isValidCoordinate(v) {\n  return Array.isArray(v) && v.length >= 2 && v.every(ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.isFiniteNumber);\n}\nfunction isValidCoordinates(v) {\n  return Array.isArray(v) && v.length >= 2 && v.every(isValidCoordinate);\n}\nvar delta2 = 1e-3;\nfunction hasSameStartEndPoint(c) {\n  return Math.abs(c[0][0] - c[c.length - 1][0]) < delta2 && Math.abs(c[0][1] - c[c.length - 1][1]) < delta2;\n}\nfunction isValidPolygon(v) {\n  return Array.isArray(v) && v.every(isValidCoordinates) && v.every(hasSameStartEndPoint);\n}\nfunction isValidGeometry(v) {\n  if (v === null)\n    return true;\n  if (typeof v !== \"object\" || v.type == null)\n    return false;\n  const { type, coordinates } = v;\n  switch (type) {\n    case \"GeometryCollection\":\n      return Array.isArray(v.geometries) && v.geometries.every(isValidGeometry);\n    case \"MultiPolygon\":\n      return Array.isArray(coordinates) && coordinates.every(isValidPolygon);\n    case \"Polygon\":\n      return isValidPolygon(coordinates);\n    case \"MultiLineString\":\n      return Array.isArray(coordinates) && coordinates.every(isValidCoordinates);\n    case \"LineString\":\n      return isValidCoordinates(coordinates);\n    case \"MultiPoint\":\n      return isValidCoordinates(coordinates);\n    case \"Point\":\n      return isValidCoordinate(coordinates);\n  }\n}\nfunction isValidFeature(v) {\n  return v !== null && typeof v === \"object\" && v.type === \"Feature\" && isValidGeometry(v.geometry);\n}\nfunction isValidFeatureCollection(v) {\n  return v !== null && typeof v === \"object\" && v.type === \"FeatureCollection\" && Array.isArray(v.features) && v.features.every(isValidFeature);\n}\nvar GEOJSON_OBJECT = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.predicateWithMessage(isValidFeatureCollection, \"a GeoJSON object\");\n\n// packages/ag-charts-enterprise/src/series/map-line-background/mapLineBackgroundSeriesProperties.ts\n\nvar { COLOR_STRING: COLOR_STRING11, LINE_DASH: LINE_DASH9, OBJECT: OBJECT15, POSITIVE_NUMBER: POSITIVE_NUMBER15, RATIO: RATIO16, Validate: Validate40, SeriesProperties: SeriesProperties2, SeriesTooltip: SeriesTooltip6 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar MapLineBackgroundSeriesProperties = class extends SeriesProperties2 {\n  constructor() {\n    super(...arguments);\n    this.topology = void 0;\n    this.stroke = \"black\";\n    this.strokeOpacity = 1;\n    this.strokeWidth = 0;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.tooltip = new SeriesTooltip6();\n  }\n};\n__decorateClass([\n  Validate40(GEOJSON_OBJECT, { optional: true })\n], MapLineBackgroundSeriesProperties.prototype, \"topology\", 2);\n__decorateClass([\n  Validate40(COLOR_STRING11)\n], MapLineBackgroundSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate40(RATIO16)\n], MapLineBackgroundSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate40(POSITIVE_NUMBER15)\n], MapLineBackgroundSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate40(LINE_DASH9)\n], MapLineBackgroundSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate40(POSITIVE_NUMBER15)\n], MapLineBackgroundSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate40(OBJECT15)\n], MapLineBackgroundSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-enterprise/src/series/map-line-background/mapLineBackgroundSeries.ts\nvar { createDatumId: createDatumId3, DataModelSeries: DataModelSeries2, SeriesNodePickMode: SeriesNodePickMode5, Validate: Validate41 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { Group: Group9, Selection: Selection4, PointerEvents: PointerEvents2 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar { Logger: Logger10 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar MapLineBackgroundSeries = class extends DataModelSeries2 {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      contentGroupVirtual: false,\n      useLabelLayer: true,\n      pickModes: [SeriesNodePickMode5.EXACT_SHAPE_MATCH]\n    });\n    this.properties = new MapLineBackgroundSeriesProperties();\n    this._chartTopology = void 0;\n    this.itemGroup = this.contentGroup.appendChild(new Group9({ name: \"itemGroup\" }));\n    this.datumSelection = Selection4.select(\n      this.itemGroup,\n      () => this.nodeFactory()\n    );\n  }\n  getNodeData() {\n    return this.contextNodeData?.nodeData;\n  }\n  get topology() {\n    return this.properties.topology ?? this._chartTopology;\n  }\n  setOptionsData() {\n  }\n  setChartData() {\n  }\n  get hasData() {\n    return false;\n  }\n  setChartTopology(topology) {\n    this._chartTopology = topology;\n    if (this.topology === topology) {\n      this.nodeDataRefresh = true;\n    }\n  }\n  nodeFactory() {\n    const geoGeometry = new GeoGeometry();\n    geoGeometry.renderMode = 2 /* Lines */;\n    geoGeometry.lineJoin = \"round\";\n    geoGeometry.lineCap = \"round\";\n    geoGeometry.pointerEvents = PointerEvents2.None;\n    return geoGeometry;\n  }\n  async processData() {\n    const { topology } = this;\n    this.topologyBounds = topology?.features.reduce((current, feature) => {\n      const geometry = feature.geometry;\n      if (geometry == null)\n        return current;\n      return geometryBbox(geometry, current);\n    }, void 0);\n    if (topology == null) {\n      Logger10.warnOnce(`no topology was provided for [MapShapeBackgroundSeries]; nothing will be rendered.`);\n    }\n  }\n  async createNodeData() {\n    const { id: seriesId, topology, scale } = this;\n    if (topology == null)\n      return;\n    const nodeData = [];\n    const labelData = [];\n    topology.features.forEach((feature, index) => {\n      const { geometry } = feature;\n      const projectedGeometry = geometry != null && scale != null ? projectGeometry(geometry, scale) : void 0;\n      if (projectedGeometry == null)\n        return;\n      nodeData.push({\n        series: this,\n        itemId: index,\n        datum: feature,\n        index,\n        projectedGeometry\n      });\n    });\n    return {\n      itemId: seriesId,\n      nodeData,\n      labelData\n    };\n  }\n  async updateSelections() {\n    if (this.nodeDataRefresh) {\n      this.contextNodeData = await this.createNodeData();\n      this.nodeDataRefresh = false;\n    }\n  }\n  async update() {\n    const { datumSelection } = this;\n    await this.updateSelections();\n    this.contentGroup.visible = this.visible;\n    const { nodeData = [] } = this.contextNodeData ?? {};\n    this.datumSelection = await this.updateDatumSelection({ nodeData, datumSelection });\n    await this.updateDatumNodes({ datumSelection });\n  }\n  async updateDatumSelection(opts) {\n    return opts.datumSelection.update(opts.nodeData, void 0, (datum) => createDatumId3(datum.index));\n  }\n  async updateDatumNodes(opts) {\n    const { properties } = this;\n    const { datumSelection } = opts;\n    const { stroke, strokeOpacity, lineDash, lineDashOffset } = properties;\n    const strokeWidth = this.getStrokeWidth(properties.strokeWidth);\n    datumSelection.each((geoGeometry, datum) => {\n      const { projectedGeometry } = datum;\n      if (projectedGeometry == null) {\n        geoGeometry.visible = false;\n        geoGeometry.projectedGeometry = void 0;\n        return;\n      }\n      geoGeometry.visible = true;\n      geoGeometry.projectedGeometry = projectedGeometry;\n      geoGeometry.stroke = stroke;\n      geoGeometry.strokeWidth = strokeWidth;\n      geoGeometry.strokeOpacity = strokeOpacity;\n      geoGeometry.lineDash = lineDash;\n      geoGeometry.lineDashOffset = lineDashOffset;\n    });\n  }\n  resetAnimation() {\n  }\n  getLabelData() {\n    return [];\n  }\n  getSeriesDomain() {\n    return [NaN, NaN];\n  }\n  getLegendData() {\n    return [];\n  }\n  getTooltipHtml() {\n    return ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.EMPTY_TOOLTIP_CONTENT;\n  }\n  computeFocusBounds(_opts) {\n    return void 0;\n  }\n};\nMapLineBackgroundSeries.className = \"MapLineBackgroundSeries\";\nMapLineBackgroundSeries.type = \"map-line-background\";\n__decorateClass([\n  Validate41(GEOJSON_OBJECT, { optional: true, property: \"topology\" })\n], MapLineBackgroundSeries.prototype, \"_chartTopology\", 2);\n\n// packages/ag-charts-enterprise/src/series/map-line-background/mapLineBackgroundModule.ts\nvar { DEFAULT_HIERARCHY_STROKES } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme;\nvar MapLineBackgroundModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"topology\"],\n  identifier: \"map-line-background\",\n  instanceConstructor: MapLineBackgroundSeries,\n  tooltipDefaults: { range: \"exact\" },\n  themeTemplate: {\n    ...MAP_THEME_DEFAULTS,\n    series: {\n      strokeWidth: 1,\n      lineDash: [0],\n      lineDashOffset: 0\n    }\n  },\n  paletteFactory: ({ themeTemplateParameters }) => {\n    return {\n      stroke: themeTemplateParameters.get(DEFAULT_HIERARCHY_STROKES)?.[1]\n    };\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/map-line/mapLineModule.ts\n\n\n// packages/ag-charts-enterprise/src/series/map-line/mapLineSeries.ts\n\n\n// packages/ag-charts-enterprise/src/series/map-util/mapUtil.ts\nfunction prepareMapMarkerAnimationFunctions() {\n  const fromFn = (marker, _datum, status) => {\n    if (status === \"removed\") {\n      return { scalingX: 1, scalingY: 1 };\n    } else if (marker.previousDatum == null) {\n      return { scalingX: 0, scalingY: 0 };\n    }\n    return { scalingX: marker.scalingX, scalingY: marker.scalingY };\n  };\n  const toFn = (_marker, _datum, status) => {\n    if (status === \"removed\") {\n      return { scalingX: 0, scalingY: 0 };\n    }\n    return { scalingX: 1, scalingY: 1 };\n  };\n  return { fromFn, toFn };\n}\nfunction findFocusedGeoGeometry(series, opts) {\n  const datum = series.contextNodeData?.nodeData[opts.datumIndex];\n  if (datum === void 0)\n    return void 0;\n  for (const node of series.datumSelection.nodes()) {\n    if (node.datum === datum) {\n      return node;\n    }\n  }\n  return void 0;\n}\n\n// packages/ag-charts-enterprise/src/series/map-line/mapLineSeriesProperties.ts\n\nvar {\n  AND: AND8,\n  ARRAY: ARRAY7,\n  COLOR_STRING: COLOR_STRING12,\n  COLOR_STRING_ARRAY: COLOR_STRING_ARRAY3,\n  FUNCTION: FUNCTION9,\n  LINE_DASH: LINE_DASH10,\n  NUMBER_ARRAY,\n  OBJECT: OBJECT16,\n  POSITIVE_NUMBER: POSITIVE_NUMBER16,\n  RATIO: RATIO17,\n  STRING: STRING17,\n  Validate: Validate42,\n  SeriesProperties: SeriesProperties3,\n  SeriesTooltip: SeriesTooltip7\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { Label: Label5 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar MapLineSeriesProperties = class extends SeriesProperties3 {\n  constructor() {\n    super(...arguments);\n    this.topology = void 0;\n    this.idKey = \"\";\n    this.topologyIdKey = \"name\";\n    this.idName = void 0;\n    this.labelKey = void 0;\n    this.labelName = void 0;\n    this.colorRange = void 0;\n    this.maxStrokeWidth = void 0;\n    this.stroke = \"black\";\n    this.strokeOpacity = 1;\n    this.strokeWidth = 0;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.label = new Label5();\n    this.tooltip = new SeriesTooltip7();\n  }\n};\n__decorateClass([\n  Validate42(GEOJSON_OBJECT, { optional: true })\n], MapLineSeriesProperties.prototype, \"topology\", 2);\n__decorateClass([\n  Validate42(STRING17, { optional: true })\n], MapLineSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  Validate42(STRING17, { optional: true })\n], MapLineSeriesProperties.prototype, \"legendItemName\", 2);\n__decorateClass([\n  Validate42(STRING17)\n], MapLineSeriesProperties.prototype, \"idKey\", 2);\n__decorateClass([\n  Validate42(STRING17)\n], MapLineSeriesProperties.prototype, \"topologyIdKey\", 2);\n__decorateClass([\n  Validate42(STRING17, { optional: true })\n], MapLineSeriesProperties.prototype, \"idName\", 2);\n__decorateClass([\n  Validate42(STRING17, { optional: true })\n], MapLineSeriesProperties.prototype, \"labelKey\", 2);\n__decorateClass([\n  Validate42(STRING17, { optional: true })\n], MapLineSeriesProperties.prototype, \"labelName\", 2);\n__decorateClass([\n  Validate42(STRING17, { optional: true })\n], MapLineSeriesProperties.prototype, \"sizeKey\", 2);\n__decorateClass([\n  Validate42(STRING17, { optional: true })\n], MapLineSeriesProperties.prototype, \"sizeName\", 2);\n__decorateClass([\n  Validate42(STRING17, { optional: true })\n], MapLineSeriesProperties.prototype, \"colorKey\", 2);\n__decorateClass([\n  Validate42(STRING17, { optional: true })\n], MapLineSeriesProperties.prototype, \"colorName\", 2);\n__decorateClass([\n  Validate42(NUMBER_ARRAY, { optional: true })\n], MapLineSeriesProperties.prototype, \"sizeDomain\", 2);\n__decorateClass([\n  Validate42(AND8(COLOR_STRING_ARRAY3, ARRAY7.restrict({ minLength: 1 })), { optional: true })\n], MapLineSeriesProperties.prototype, \"colorRange\", 2);\n__decorateClass([\n  Validate42(POSITIVE_NUMBER16, { optional: true })\n], MapLineSeriesProperties.prototype, \"maxStrokeWidth\", 2);\n__decorateClass([\n  Validate42(COLOR_STRING12)\n], MapLineSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate42(RATIO17)\n], MapLineSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate42(POSITIVE_NUMBER16)\n], MapLineSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate42(LINE_DASH10)\n], MapLineSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate42(POSITIVE_NUMBER16)\n], MapLineSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate42(FUNCTION9, { optional: true })\n], MapLineSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate42(OBJECT16)\n], MapLineSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate42(OBJECT16)\n], MapLineSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-enterprise/src/series/map-line/mapLineSeries.ts\nvar { getMissCount: getMissCount2, createDatumId: createDatumId4, DataModelSeries: DataModelSeries3, SeriesNodePickMode: SeriesNodePickMode6, valueProperty: valueProperty8, Validate: Validate43 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { ColorScale: ColorScale2, LinearScale: LinearScale3 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scale;\nvar { Selection: Selection5, Text: Text9 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar { sanitizeHtml: sanitizeHtml5, Logger: Logger11 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar MapLineSeries = class extends DataModelSeries3 {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      contentGroupVirtual: false,\n      useLabelLayer: true,\n      pickModes: [SeriesNodePickMode6.EXACT_SHAPE_MATCH, SeriesNodePickMode6.NEAREST_NODE]\n    });\n    this.properties = new MapLineSeriesProperties();\n    this._chartTopology = void 0;\n    this.colorScale = new ColorScale2();\n    this.sizeScale = new LinearScale3();\n    this.datumSelection = Selection5.select(\n      this.contentGroup,\n      () => this.nodeFactory()\n    );\n    this.labelSelection = Selection5.select(\n      this.labelGroup,\n      Text9\n    );\n    this.highlightDatumSelection = Selection5.select(\n      this.highlightNode,\n      () => this.nodeFactory()\n    );\n    this._previousDatumMidPoint = void 0;\n  }\n  getNodeData() {\n    return this.contextNodeData?.nodeData;\n  }\n  get topology() {\n    return this.properties.topology ?? this._chartTopology;\n  }\n  get hasData() {\n    return super.hasData && this.topology != null;\n  }\n  setChartTopology(topology) {\n    this._chartTopology = topology;\n    if (this.topology === topology) {\n      this.nodeDataRefresh = true;\n    }\n  }\n  addChartEventListeners() {\n    this.destroyFns.push(\n      this.ctx.chartEventManager.addListener(\"legend-item-click\", (event) => {\n        this.onLegendItemClick(event);\n      }),\n      this.ctx.chartEventManager.addListener(\"legend-item-double-click\", (event) => {\n        this.onLegendItemDoubleClick(event);\n      })\n    );\n  }\n  isLabelEnabled() {\n    return this.properties.labelKey != null && this.properties.label.enabled;\n  }\n  nodeFactory() {\n    const geoGeometry = new GeoGeometry();\n    geoGeometry.renderMode = 2 /* Lines */;\n    geoGeometry.lineJoin = \"round\";\n    geoGeometry.lineCap = \"round\";\n    return geoGeometry;\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    const { data, topology, sizeScale, colorScale } = this;\n    const { topologyIdKey, idKey, sizeKey, colorKey, labelKey, sizeDomain, colorRange } = this.properties;\n    const featureById = /* @__PURE__ */ new Map();\n    topology?.features.forEach((feature) => {\n      const property = feature.properties?.[topologyIdKey];\n      if (property == null || !containsType(feature.geometry, 2 /* LineString */))\n        return;\n      featureById.set(property, feature);\n    });\n    const sizeScaleType = this.sizeScale.type;\n    const colorScaleType = this.colorScale.type;\n    const mercatorScaleType = this.scale?.type;\n    const { dataModel, processedData } = await this.requestDataModel(dataController, data, {\n      props: [\n        valueProperty8(idKey, mercatorScaleType, { id: \"idValue\", includeProperty: false }),\n        valueProperty8(idKey, mercatorScaleType, {\n          id: \"featureValue\",\n          includeProperty: false,\n          processor: () => (datum) => featureById.get(datum)\n        }),\n        ...labelKey != null ? [valueProperty8(labelKey, \"band\", { id: \"labelValue\" })] : [],\n        ...sizeKey != null ? [valueProperty8(sizeKey, sizeScaleType, { id: \"sizeValue\" })] : [],\n        ...colorKey != null ? [valueProperty8(colorKey, colorScaleType, { id: \"colorValue\" })] : []\n      ]\n    });\n    const featureIdx = dataModel.resolveProcessedDataIndexById(this, `featureValue`);\n    this.topologyBounds = processedData.data.reduce(\n      (current, { values }) => {\n        const feature = values[featureIdx];\n        const geometry = feature?.geometry;\n        if (geometry == null)\n          return current;\n        return geometryBbox(geometry, current);\n      },\n      void 0\n    );\n    if (sizeKey != null) {\n      const sizeIdx = dataModel.resolveProcessedDataIndexById(this, `sizeValue`);\n      const processedSize = processedData.domain.values[sizeIdx] ?? [];\n      sizeScale.domain = sizeDomain ?? processedSize;\n    }\n    if (colorRange != null && this.isColorScaleValid()) {\n      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, \"colorValue\");\n      colorScale.domain = processedData.domain.values[colorKeyIdx];\n      colorScale.range = colorRange;\n      colorScale.update();\n    }\n    if (topology == null) {\n      Logger11.warnOnce(`no topology was provided for [MapLineSeries]; nothing will be rendered.`);\n    }\n  }\n  isColorScaleValid() {\n    const { colorKey } = this.properties;\n    if (!colorKey) {\n      return false;\n    }\n    const { dataModel, processedData } = this;\n    if (!dataModel || !processedData) {\n      return false;\n    }\n    const colorIdx = dataModel.resolveProcessedDataIndexById(this, \"colorValue\");\n    const dataCount = processedData.data.length;\n    const missCount = getMissCount2(this, processedData.defs.values[colorIdx].missing);\n    const colorDataMissing = dataCount === 0 || dataCount === missCount;\n    return !colorDataMissing;\n  }\n  getLabelDatum(datum, labelValue, projectedGeometry, font) {\n    if (labelValue == null || projectedGeometry == null)\n      return;\n    const lineString = largestLineString(projectedGeometry);\n    if (lineString == null)\n      return;\n    const { idKey, idName, sizeKey, sizeName, colorKey, colorName, labelKey, labelName, label } = this.properties;\n    const labelText = this.getLabelText(label, {\n      value: labelValue,\n      datum,\n      idKey,\n      idName,\n      sizeKey,\n      sizeName,\n      colorKey,\n      colorName,\n      labelKey,\n      labelName\n    });\n    if (labelText == null)\n      return;\n    const labelSize = Text9.getTextSize(String(labelText), font);\n    const labelCenter = lineStringCenter(lineString);\n    if (labelCenter == null)\n      return;\n    const [x, y] = labelCenter.point;\n    const { width, height } = labelSize;\n    return {\n      point: { x, y, size: 0 },\n      label: { width, height, text: labelText },\n      marker: void 0,\n      placement: void 0\n    };\n  }\n  async createNodeData() {\n    const { id: seriesId, dataModel, processedData, sizeScale, colorScale, properties, scale } = this;\n    const { idKey, sizeKey, colorKey, labelKey, label } = properties;\n    if (dataModel == null || processedData == null)\n      return;\n    const colorScaleValid = this.isColorScaleValid();\n    const idIdx = dataModel.resolveProcessedDataIndexById(this, `idValue`);\n    const featureIdx = dataModel.resolveProcessedDataIndexById(this, `featureValue`);\n    const labelIdx = labelKey != null ? dataModel.resolveProcessedDataIndexById(this, `labelValue`) : void 0;\n    const sizeIdx = sizeKey != null ? dataModel.resolveProcessedDataIndexById(this, `sizeValue`) : void 0;\n    const colorIdx = colorKey != null ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : void 0;\n    const maxStrokeWidth = properties.maxStrokeWidth ?? properties.strokeWidth;\n    sizeScale.range = [Math.min(properties.strokeWidth, maxStrokeWidth), maxStrokeWidth];\n    const font = label.getFont();\n    const projectedGeometries = /* @__PURE__ */ new Map();\n    processedData.data.forEach(({ values }) => {\n      const id = values[idIdx];\n      const geometry = values[featureIdx]?.geometry;\n      const projectedGeometry = geometry != null && scale != null ? projectGeometry(geometry, scale) : void 0;\n      if (id != null && projectedGeometry != null) {\n        projectedGeometries.set(id, projectedGeometry);\n      }\n    });\n    const nodeData = [];\n    const labelData = [];\n    const missingGeometries = [];\n    processedData.data.forEach(({ datum, values }) => {\n      const idValue = values[idIdx];\n      const colorValue = colorIdx != null ? values[colorIdx] : void 0;\n      const sizeValue = sizeIdx != null ? values[sizeIdx] : void 0;\n      const labelValue = labelIdx != null ? values[labelIdx] : void 0;\n      const color = colorScaleValid && colorValue != null ? colorScale.convert(colorValue) : void 0;\n      const size = sizeValue != null ? sizeScale.convert(sizeValue, { clampMode: \"clamped\" }) : void 0;\n      const projectedGeometry = projectedGeometries.get(idValue);\n      if (projectedGeometry == null) {\n        missingGeometries.push(idValue);\n      }\n      const labelDatum = this.getLabelDatum(datum, labelValue, projectedGeometry, font);\n      if (labelDatum != null) {\n        labelData.push(labelDatum);\n      }\n      nodeData.push({\n        series: this,\n        itemId: idKey,\n        datum,\n        stroke: color,\n        strokeWidth: size,\n        idValue,\n        labelValue,\n        colorValue,\n        sizeValue,\n        projectedGeometry\n      });\n    });\n    const missingGeometriesCap = 10;\n    if (missingGeometries.length > missingGeometriesCap) {\n      const excessItems = missingGeometries.length - missingGeometriesCap;\n      missingGeometries.length = missingGeometriesCap;\n      missingGeometries.push(`(+${excessItems} more)`);\n    }\n    if (missingGeometries.length > 0) {\n      Logger11.warnOnce(`some data items do not have matches in the provided topology`, missingGeometries);\n    }\n    return {\n      itemId: seriesId,\n      nodeData,\n      labelData\n    };\n  }\n  async updateSelections() {\n    if (this.nodeDataRefresh) {\n      this.contextNodeData = await this.createNodeData();\n      this.nodeDataRefresh = false;\n    }\n  }\n  async update() {\n    const { datumSelection, labelSelection, highlightDatumSelection } = this;\n    await this.updateSelections();\n    this.contentGroup.visible = this.visible;\n    this.contentGroup.opacity = this.getOpacity();\n    let highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();\n    if (highlightedDatum != null && (highlightedDatum.series !== this || highlightedDatum.datum == null)) {\n      highlightedDatum = void 0;\n    }\n    const nodeData = this.contextNodeData?.nodeData ?? [];\n    this.datumSelection = await this.updateDatumSelection({ nodeData, datumSelection });\n    await this.updateDatumNodes({ datumSelection, isHighlight: false });\n    this.labelSelection = await this.updateLabelSelection({ labelSelection });\n    await this.updateLabelNodes({ labelSelection });\n    this.highlightDatumSelection = await this.updateDatumSelection({\n      nodeData: highlightedDatum != null ? [highlightedDatum] : [],\n      datumSelection: highlightDatumSelection\n    });\n    await this.updateDatumNodes({ datumSelection: highlightDatumSelection, isHighlight: true });\n  }\n  async updateDatumSelection(opts) {\n    return opts.datumSelection.update(opts.nodeData, void 0, (datum) => createDatumId4(datum.idValue));\n  }\n  async updateDatumNodes(opts) {\n    const {\n      id: seriesId,\n      properties,\n      ctx: { callbackCache }\n    } = this;\n    const { datumSelection, isHighlight } = opts;\n    const { idKey, labelKey, sizeKey, colorKey, stroke, strokeOpacity, lineDash, lineDashOffset, itemStyler } = properties;\n    const highlightStyle = isHighlight ? properties.highlightStyle.item : void 0;\n    const strokeWidth = this.getStrokeWidth(properties.strokeWidth);\n    datumSelection.each((geoGeometry, datum) => {\n      const { projectedGeometry } = datum;\n      if (projectedGeometry == null) {\n        geoGeometry.visible = false;\n        geoGeometry.projectedGeometry = void 0;\n        return;\n      }\n      let format;\n      if (itemStyler != null) {\n        format = callbackCache.call(itemStyler, {\n          seriesId,\n          datum: datum.datum,\n          idKey,\n          labelKey,\n          sizeKey,\n          colorKey,\n          strokeOpacity,\n          stroke,\n          strokeWidth,\n          lineDash,\n          lineDashOffset,\n          highlighted: isHighlight\n        });\n      }\n      geoGeometry.visible = true;\n      geoGeometry.projectedGeometry = projectedGeometry;\n      geoGeometry.stroke = highlightStyle?.stroke ?? format?.stroke ?? datum.stroke ?? stroke;\n      geoGeometry.strokeWidth = Math.max(\n        highlightStyle?.strokeWidth ?? 0,\n        format?.strokeWidth ?? datum.strokeWidth ?? strokeWidth\n      );\n      geoGeometry.strokeOpacity = highlightStyle?.strokeOpacity ?? format?.strokeOpacity ?? strokeOpacity;\n      geoGeometry.lineDash = highlightStyle?.lineDash ?? format?.lineDash ?? lineDash;\n      geoGeometry.lineDashOffset = highlightStyle?.lineDashOffset ?? format?.lineDashOffset ?? lineDashOffset;\n    });\n  }\n  async updateLabelSelection(opts) {\n    const placedLabels = (this.isLabelEnabled() ? this.chart?.placeLabels().get(this) : void 0) ?? [];\n    return opts.labelSelection.update(placedLabels);\n  }\n  async updateLabelNodes(opts) {\n    const { labelSelection } = opts;\n    const { color: fill, fontStyle, fontWeight, fontSize, fontFamily } = this.properties.label;\n    labelSelection.each((label, { x, y, width, height, text }) => {\n      label.visible = true;\n      label.x = x + width / 2;\n      label.y = y + height / 2;\n      label.text = text;\n      label.fill = fill;\n      label.fontStyle = fontStyle;\n      label.fontWeight = fontWeight;\n      label.fontSize = fontSize;\n      label.fontFamily = fontFamily;\n      label.textAlign = \"center\";\n      label.textBaseline = \"middle\";\n    });\n  }\n  onLegendItemClick(event) {\n    const { legendItemName } = this.properties;\n    const { enabled, itemId, series } = event;\n    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;\n    if (series.id === this.id || matchedLegendItemName) {\n      this.toggleSeriesItem(itemId, enabled);\n    }\n  }\n  onLegendItemDoubleClick(event) {\n    const { enabled, itemId, series, numVisibleItems } = event;\n    const { legendItemName } = this.properties;\n    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;\n    if (series.id === this.id || matchedLegendItemName) {\n      this.toggleSeriesItem(itemId, true);\n    } else if (enabled && numVisibleItems === 1) {\n      this.toggleSeriesItem(itemId, true);\n    } else {\n      this.toggleSeriesItem(itemId, false);\n    }\n  }\n  resetAnimation() {\n  }\n  getLabelData() {\n    return this.contextNodeData?.labelData ?? [];\n  }\n  getSeriesDomain() {\n    return [NaN, NaN];\n  }\n  pickNodeClosestDatum({ x, y }) {\n    let minDistance = Infinity;\n    let minDatum;\n    this.datumSelection.each((node, datum) => {\n      const distance = node.distanceToPoint(x, y);\n      if (distance < minDistance) {\n        minDistance = distance;\n        minDatum = datum;\n      }\n    });\n    return minDatum != null ? { datum: minDatum, distance: minDistance } : void 0;\n  }\n  datumMidPoint(datum) {\n    const { _previousDatumMidPoint } = this;\n    if (_previousDatumMidPoint?.datum === datum) {\n      return _previousDatumMidPoint.point;\n    }\n    const projectedGeometry = datum.projectedGeometry;\n    const lineString = projectedGeometry != null ? largestLineString(projectedGeometry) : void 0;\n    const center = lineString != null ? lineStringCenter(lineString)?.point : void 0;\n    const point = center != null ? { x: center[0], y: center[1] } : void 0;\n    this._previousDatumMidPoint = { datum, point };\n    return point;\n  }\n  getLegendData(legendType) {\n    const { processedData, dataModel } = this;\n    if (processedData == null || dataModel == null)\n      return [];\n    const {\n      title,\n      legendItemName,\n      idKey,\n      idName,\n      colorKey,\n      colorName,\n      colorRange,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      visible\n    } = this.properties;\n    if (legendType === \"gradient\" && colorKey != null && colorRange != null) {\n      const colorDomain = processedData.domain.values[dataModel.resolveProcessedDataIndexById(this, \"colorValue\")];\n      const legendDatum = {\n        legendType: \"gradient\",\n        enabled: visible,\n        seriesId: this.id,\n        colorName,\n        colorRange,\n        colorDomain\n      };\n      return [legendDatum];\n    } else if (legendType === \"category\") {\n      const legendDatum = {\n        legendType: \"category\",\n        id: this.id,\n        itemId: legendItemName ?? title ?? idName ?? idKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: { text: legendItemName ?? title ?? idName ?? idKey },\n        symbols: [\n          {\n            marker: {\n              fill: stroke,\n              fillOpacity: strokeOpacity,\n              stroke: void 0,\n              strokeWidth: 0,\n              strokeOpacity: 0,\n              enabled: false\n            },\n            line: {\n              stroke,\n              strokeOpacity,\n              strokeWidth,\n              lineDash\n            }\n          }\n        ],\n        legendItemName\n      };\n      return [legendDatum];\n    } else {\n      return [];\n    }\n  }\n  getTooltipHtml(nodeDatum) {\n    const {\n      id: seriesId,\n      processedData,\n      properties,\n      ctx: { callbackCache }\n    } = this;\n    if (!processedData || !properties.isValid()) {\n      return ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.EMPTY_TOOLTIP_CONTENT;\n    }\n    const {\n      legendItemName,\n      idKey,\n      idName,\n      colorKey,\n      colorName,\n      sizeKey,\n      sizeName,\n      labelKey,\n      labelName,\n      itemStyler,\n      tooltip,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset\n    } = properties;\n    const { datum, stroke, idValue, colorValue, sizeValue, labelValue, itemId } = nodeDatum;\n    const title = sanitizeHtml5(properties.title ?? legendItemName) ?? \"\";\n    const contentLines = [];\n    contentLines.push(sanitizeHtml5((idName != null ? `${idName}: ` : \"\") + idValue));\n    if (colorValue != null) {\n      contentLines.push(sanitizeHtml5((colorName ?? colorKey) + \": \" + colorValue));\n    }\n    if (sizeValue != null) {\n      contentLines.push(sanitizeHtml5((sizeName ?? sizeKey) + \": \" + sizeValue));\n    }\n    if (labelValue != null && labelKey !== idKey) {\n      contentLines.push(sanitizeHtml5((labelName ?? labelKey) + \": \" + labelValue));\n    }\n    const content = contentLines.join(\"<br>\");\n    let format;\n    if (itemStyler) {\n      format = callbackCache.call(itemStyler, {\n        highlighted: false,\n        seriesId,\n        datum,\n        idKey,\n        sizeKey,\n        colorKey,\n        labelKey,\n        stroke,\n        strokeWidth: this.getStrokeWidth(nodeDatum.strokeWidth ?? properties.strokeWidth),\n        strokeOpacity,\n        lineDash,\n        lineDashOffset\n      });\n    }\n    const color = format?.stroke ?? stroke ?? properties.stroke;\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        seriesId,\n        datum,\n        idKey,\n        title,\n        color,\n        itemId,\n        sizeKey,\n        colorKey,\n        colorName,\n        idName,\n        labelKey,\n        labelName,\n        sizeName,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  computeFocusBounds(opts) {\n    return findFocusedGeoGeometry(this, opts)?.computeTransformedBBox();\n  }\n};\nMapLineSeries.className = \"MapLineSeries\";\nMapLineSeries.type = \"map-line\";\n__decorateClass([\n  Validate43(GEOJSON_OBJECT, { optional: true, property: \"topology\" })\n], MapLineSeries.prototype, \"_chartTopology\", 2);\n\n// packages/ag-charts-enterprise/src/series/map-line/mapLineModule.ts\nvar { DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, DEFAULT_FONT_FAMILY: DEFAULT_FONT_FAMILY2, DEFAULT_LABEL_COLOUR: DEFAULT_LABEL_COLOUR2, singleSeriesPaletteFactory } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme;\nvar MapLineModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"topology\"],\n  identifier: \"map-line\",\n  instanceConstructor: MapLineSeries,\n  tooltipDefaults: { range: \"exact\" },\n  themeTemplate: {\n    ...MAP_THEME_DEFAULTS,\n    series: {\n      strokeWidth: 1,\n      maxStrokeWidth: 3,\n      lineDash: [0],\n      lineDashOffset: 0,\n      label: {\n        enabled: true,\n        fontStyle: void 0,\n        fontWeight: void 0,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY2,\n        color: DEFAULT_LABEL_COLOUR2\n      }\n    }\n  },\n  paletteFactory: (opts) => {\n    const { takeColors, colorsCount, userPalette, themeTemplateParameters } = opts;\n    const { fill } = singleSeriesPaletteFactory(opts);\n    const defaultColorRange = themeTemplateParameters.get(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE);\n    const { fills } = takeColors(colorsCount);\n    return {\n      colorRange: userPalette === \"inbuilt\" ? defaultColorRange : [fills[0], fills[1]],\n      stroke: fill\n    };\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/map-marker/mapMarkerModule.ts\n\n\n// packages/ag-charts-enterprise/src/series/map-marker/mapMarkerSeries.ts\n\n\n// packages/ag-charts-enterprise/src/series/map-util/polygonPointSearch.ts\nfunction polygonPointSearch(polygons, precision, valueFn) {\n  const bbox = polygonBbox(polygons[0], void 0);\n  if (bbox == null)\n    return;\n  const boundingXCenter = (bbox.lon0 + bbox.lon1) / 2;\n  const boundingYCenter = (bbox.lat0 + bbox.lat1) / 2;\n  const boundingWidth = Math.abs(bbox.lon1 - bbox.lon0);\n  const boundingHeight = Math.abs(bbox.lat1 - bbox.lat0);\n  const centroid = polygonCentroid(polygons[0]);\n  const [cx, cy] = centroid;\n  const centroidDistanceToPolygon = -polygonDistance(polygons, cx, cy);\n  let bestResult;\n  const cellValue = (distanceToPolygon, distanceToCentroid) => {\n    const centroidDriftFactor = 0.5;\n    const centroidDrift = Math.max(distanceToCentroid - centroidDistanceToPolygon, 0);\n    return distanceToPolygon - centroidDriftFactor * centroidDrift;\n  };\n  const createLabelPlacement = (x2, y2, stride) => {\n    const { distance: distance2, maxDistance } = valueFn(polygons, x2, y2, stride);\n    const distanceToCentroid = Math.hypot(cx - x2, cy - y2);\n    const maxXTowardsCentroid = Math.min(Math.max(cx, x2 - stride / 2), x2 + stride / 2);\n    const maxYTowardsCentroid = Math.min(Math.max(cy, y2 - stride / 2), y2 + stride / 2);\n    const minDistanceToCentroid = Math.hypot(cx - maxXTowardsCentroid, cy - maxYTowardsCentroid);\n    const value = cellValue(distance2, distanceToCentroid);\n    const maxValue = cellValue(maxDistance, minDistanceToCentroid);\n    return { distance: distance2, maxDistance, value, maxValue, x: x2, y: y2, stride };\n  };\n  const appendLabelPlacement = (into, x2, y2, stride) => {\n    const labelPlacement = createLabelPlacement(x2, y2, stride);\n    if (labelPlacement.maxDistance >= 0) {\n      into.push(labelPlacement);\n    }\n  };\n  const initialStride = Math.min(boundingWidth, boundingHeight) / 2;\n  let queue = {\n    value: createLabelPlacement(boundingXCenter, boundingYCenter, initialStride),\n    next: null\n  };\n  while (queue != null) {\n    const item = queue.value;\n    const { distance: distance2, value, maxValue, x: x2, y: y2, stride } = item;\n    queue = queue.next;\n    if (distance2 > 0 && (bestResult == null || value > bestResult.value)) {\n      bestResult = item;\n    }\n    if (bestResult != null && maxValue - bestResult.value <= precision) {\n      continue;\n    }\n    const nextStride = stride / 2;\n    const newLabelPlacements = [];\n    appendLabelPlacement(newLabelPlacements, x2 - nextStride, y2 - nextStride, nextStride);\n    appendLabelPlacement(newLabelPlacements, x2 + nextStride, y2 - nextStride, nextStride);\n    appendLabelPlacement(newLabelPlacements, x2 - nextStride, y2 + nextStride, nextStride);\n    appendLabelPlacement(newLabelPlacements, x2 + nextStride, y2 + nextStride, nextStride);\n    newLabelPlacements.sort(labelPlacementCmp);\n    queue = insertManySorted(queue, newLabelPlacements, labelPlacementCmp);\n  }\n  if (bestResult == null)\n    return;\n  const { distance, x, y } = bestResult;\n  return { x, y, distance };\n}\nvar labelPlacementCmp = (a, b) => b.maxValue - a.maxValue;\n\n// packages/ag-charts-enterprise/src/series/map-util/markerUtil.ts\nfunction polygonMarkerCenter(polygons, precision) {\n  const result = polygonPointSearch(polygons, precision, (p, x2, y2, stride) => {\n    const distance = -polygonDistance(p, x2, y2);\n    const maxDistance = distance + stride * Math.SQRT2;\n    return { distance, maxDistance };\n  });\n  if (result == null)\n    return;\n  const { x, y } = result;\n  return [x, y];\n}\nfunction markerPositions(geometry, precision) {\n  let center;\n  switch (geometry.type) {\n    case \"GeometryCollection\":\n      return geometry.geometries.flatMap((g) => markerPositions(g, precision));\n    case \"MultiPoint\":\n      return geometry.coordinates;\n    case \"Point\":\n      return [geometry.coordinates];\n    case \"MultiPolygon\": {\n      const polygon = largestPolygon(geometry);\n      center = polygon != null ? polygonMarkerCenter(polygon, precision) : void 0;\n      break;\n    }\n    case \"Polygon\": {\n      const polygon = geometry.coordinates;\n      center = polygon != null ? polygonMarkerCenter(polygon, precision) : void 0;\n      break;\n    }\n    case \"MultiLineString\": {\n      const lineString = largestLineString(geometry);\n      center = lineString != null ? lineStringCenter(lineString)?.point : void 0;\n      break;\n    }\n    case \"LineString\": {\n      const lineString = geometry.coordinates;\n      center = lineStringCenter(lineString)?.point;\n      break;\n    }\n  }\n  return center != null ? [center] : [];\n}\n\n// packages/ag-charts-enterprise/src/series/map-marker/mapMarkerSeriesProperties.ts\n\nvar {\n  AND: AND9,\n  ARRAY: ARRAY8,\n  COLOR_STRING: COLOR_STRING13,\n  COLOR_STRING_ARRAY: COLOR_STRING_ARRAY4,\n  FUNCTION: FUNCTION10,\n  NUMBER_ARRAY: NUMBER_ARRAY2,\n  OBJECT: OBJECT17,\n  POSITIVE_NUMBER: POSITIVE_NUMBER17,\n  RATIO: RATIO18,\n  STRING: STRING18,\n  MARKER_SHAPE,\n  Validate: Validate44,\n  SeriesProperties: SeriesProperties4,\n  SeriesTooltip: SeriesTooltip8\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { Label: Label6, Circle } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar { Logger: Logger12 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar MapMarkerSeriesLabel = class extends Label6 {\n  constructor() {\n    super(...arguments);\n    this.placement = \"bottom\";\n  }\n};\n__decorateClass([\n  Validate44(STRING18)\n], MapMarkerSeriesLabel.prototype, \"placement\", 2);\nvar MapMarkerSeriesProperties = class extends SeriesProperties4 {\n  constructor() {\n    super(...arguments);\n    this.topology = void 0;\n    this.idKey = void 0;\n    this.topologyIdKey = \"name\";\n    this.idName = void 0;\n    this.latitudeKey = void 0;\n    this.latitudeName = void 0;\n    this.longitudeKey = void 0;\n    this.longitudeName = void 0;\n    this.labelKey = void 0;\n    this.labelName = void 0;\n    this.colorRange = void 0;\n    this.shape = Circle;\n    this.size = 6;\n    this.fillOpacity = 1;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.label = new MapMarkerSeriesLabel();\n    this.tooltip = new SeriesTooltip8();\n  }\n  isValid() {\n    const superIsValid = super.isValid();\n    const hasTopology = this.idKey != null;\n    const hasLatLon = this.latitudeKey != null && this.longitudeKey != null;\n    if (!hasTopology && !hasLatLon) {\n      Logger12.warnOnce(\n        \"Either both [topology] and [idKey] or both [latitudeKey] and [longitudeKey] must be set to render a map marker series.\"\n      );\n      return false;\n    }\n    return superIsValid;\n  }\n};\n__decorateClass([\n  Validate44(GEOJSON_OBJECT, { optional: true })\n], MapMarkerSeriesProperties.prototype, \"topology\", 2);\n__decorateClass([\n  Validate44(STRING18, { optional: true })\n], MapMarkerSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  Validate44(STRING18, { optional: true })\n], MapMarkerSeriesProperties.prototype, \"legendItemName\", 2);\n__decorateClass([\n  Validate44(STRING18, { optional: true })\n], MapMarkerSeriesProperties.prototype, \"idKey\", 2);\n__decorateClass([\n  Validate44(STRING18)\n], MapMarkerSeriesProperties.prototype, \"topologyIdKey\", 2);\n__decorateClass([\n  Validate44(STRING18, { optional: true })\n], MapMarkerSeriesProperties.prototype, \"idName\", 2);\n__decorateClass([\n  Validate44(STRING18, { optional: true })\n], MapMarkerSeriesProperties.prototype, \"latitudeKey\", 2);\n__decorateClass([\n  Validate44(STRING18, { optional: true })\n], MapMarkerSeriesProperties.prototype, \"latitudeName\", 2);\n__decorateClass([\n  Validate44(STRING18, { optional: true })\n], MapMarkerSeriesProperties.prototype, \"longitudeKey\", 2);\n__decorateClass([\n  Validate44(STRING18, { optional: true })\n], MapMarkerSeriesProperties.prototype, \"longitudeName\", 2);\n__decorateClass([\n  Validate44(STRING18, { optional: true })\n], MapMarkerSeriesProperties.prototype, \"labelKey\", 2);\n__decorateClass([\n  Validate44(STRING18, { optional: true })\n], MapMarkerSeriesProperties.prototype, \"labelName\", 2);\n__decorateClass([\n  Validate44(STRING18, { optional: true })\n], MapMarkerSeriesProperties.prototype, \"sizeKey\", 2);\n__decorateClass([\n  Validate44(STRING18, { optional: true })\n], MapMarkerSeriesProperties.prototype, \"sizeName\", 2);\n__decorateClass([\n  Validate44(STRING18, { optional: true })\n], MapMarkerSeriesProperties.prototype, \"colorKey\", 2);\n__decorateClass([\n  Validate44(STRING18, { optional: true })\n], MapMarkerSeriesProperties.prototype, \"colorName\", 2);\n__decorateClass([\n  Validate44(AND9(COLOR_STRING_ARRAY4, ARRAY8.restrict({ minLength: 1 })), { optional: true })\n], MapMarkerSeriesProperties.prototype, \"colorRange\", 2);\n__decorateClass([\n  Validate44(MARKER_SHAPE)\n], MapMarkerSeriesProperties.prototype, \"shape\", 2);\n__decorateClass([\n  Validate44(POSITIVE_NUMBER17)\n], MapMarkerSeriesProperties.prototype, \"size\", 2);\n__decorateClass([\n  Validate44(POSITIVE_NUMBER17, { optional: true })\n], MapMarkerSeriesProperties.prototype, \"maxSize\", 2);\n__decorateClass([\n  Validate44(NUMBER_ARRAY2, { optional: true })\n], MapMarkerSeriesProperties.prototype, \"sizeDomain\", 2);\n__decorateClass([\n  Validate44(COLOR_STRING13, { optional: true })\n], MapMarkerSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate44(RATIO18)\n], MapMarkerSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate44(COLOR_STRING13, { optional: true })\n], MapMarkerSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate44(POSITIVE_NUMBER17)\n], MapMarkerSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate44(RATIO18)\n], MapMarkerSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate44(FUNCTION10, { optional: true })\n], MapMarkerSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate44(OBJECT17)\n], MapMarkerSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate44(OBJECT17)\n], MapMarkerSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-enterprise/src/series/map-marker/mapMarkerSeries.ts\nvar {\n  Validate: Validate45,\n  fromToMotion: fromToMotion2,\n  StateMachine: StateMachine2,\n  getMissCount: getMissCount3,\n  createDatumId: createDatumId5,\n  DataModelSeries: DataModelSeries4,\n  SeriesNodePickMode: SeriesNodePickMode7,\n  Layers: Layers6,\n  valueProperty: valueProperty9,\n  computeMarkerFocusBounds\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { ColorScale: ColorScale3, LinearScale: LinearScale4 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scale;\nvar { Group: Group10, Selection: Selection6, Text: Text10, getMarker } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar { sanitizeHtml: sanitizeHtml6, Logger: Logger13 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar MapMarkerSeries = class extends DataModelSeries4 {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      contentGroupVirtual: true,\n      useLabelLayer: true,\n      pickModes: [SeriesNodePickMode7.EXACT_SHAPE_MATCH, SeriesNodePickMode7.NEAREST_NODE]\n    });\n    this.properties = new MapMarkerSeriesProperties();\n    this._chartTopology = void 0;\n    this.colorScale = new ColorScale3();\n    this.sizeScale = new LinearScale4();\n    this.markerGroup = this.contentGroup.appendChild(\n      new Group10({\n        name: \"markerGroup\",\n        layer: true,\n        isVirtual: false,\n        zIndex: Layers6.SERIES_LAYER_ZINDEX,\n        zIndexSubOrder: this.getGroupZIndexSubOrder(\"marker\")\n      })\n    );\n    this.labelSelection = Selection6.select(\n      this.labelGroup,\n      Text10,\n      false\n    );\n    this.markerSelection = Selection6.select(\n      this.markerGroup,\n      () => this.markerFactory(),\n      false\n    );\n    this.highlightMarkerSelection = Selection6.select(\n      this.highlightNode,\n      () => this.markerFactory()\n    );\n    this.animationState = new StateMachine2(\n      \"empty\",\n      {\n        empty: {\n          update: {\n            target: \"ready\",\n            action: () => this.animateMarkers()\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        ready: {\n          updateData: \"waiting\",\n          clear: \"clearing\",\n          resize: () => this.resetAllAnimation(),\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        waiting: {\n          update: {\n            target: \"ready\",\n            action: () => this.animateMarkers()\n          },\n          // chart.ts transitions to updateData on zoom change\n          resize: {\n            target: \"ready\",\n            action: () => this.resetAllAnimation()\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        clearing: {\n          update: {\n            target: \"empty\",\n            action: () => this.resetAllAnimation()\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        }\n      },\n      () => this.checkProcessedDataAnimatable()\n    );\n  }\n  getNodeData() {\n    return this.contextNodeData?.nodeData;\n  }\n  get topology() {\n    return this.properties.topology ?? this._chartTopology;\n  }\n  get hasData() {\n    const hasLatLon = this.properties.latitudeKey != null && this.properties.longitudeKey != null;\n    return super.hasData && (this.topology != null || hasLatLon);\n  }\n  setChartTopology(topology) {\n    this._chartTopology = topology;\n    if (this.topology === topology) {\n      this.nodeDataRefresh = true;\n    }\n  }\n  addChartEventListeners() {\n    this.destroyFns.push(\n      this.ctx.chartEventManager.addListener(\"legend-item-click\", (event) => {\n        this.onLegendItemClick(event);\n      }),\n      this.ctx.chartEventManager.addListener(\"legend-item-double-click\", (event) => {\n        this.onLegendItemDoubleClick(event);\n      })\n    );\n  }\n  isLabelEnabled() {\n    return this.properties.labelKey != null && this.properties.label.enabled;\n  }\n  markerFactory() {\n    const { shape } = this.properties;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    const { data, topology, sizeScale, colorScale } = this;\n    const { topologyIdKey, idKey, latitudeKey, longitudeKey, sizeKey, colorKey, labelKey, sizeDomain, colorRange } = this.properties;\n    const featureById = /* @__PURE__ */ new Map();\n    topology?.features.forEach((feature) => {\n      const property = feature.properties?.[topologyIdKey];\n      if (property == null)\n        return;\n      featureById.set(property, feature);\n    });\n    const sizeScaleType = this.sizeScale.type;\n    const colorScaleType = this.colorScale.type;\n    const mercatorScaleType = this.scale?.type;\n    const hasLatLon = latitudeKey != null && longitudeKey != null;\n    const { dataModel, processedData } = await this.requestDataModel(dataController, data, {\n      props: [\n        ...idKey != null ? [\n          valueProperty9(idKey, mercatorScaleType, { id: \"idValue\", includeProperty: false }),\n          valueProperty9(idKey, mercatorScaleType, {\n            id: \"featureValue\",\n            includeProperty: false,\n            processor: () => (datum) => featureById.get(datum)\n          })\n        ] : [],\n        ...hasLatLon ? [\n          valueProperty9(latitudeKey, mercatorScaleType, { id: \"latValue\" }),\n          valueProperty9(longitudeKey, mercatorScaleType, { id: \"lonValue\" })\n        ] : [],\n        ...labelKey ? [valueProperty9(labelKey, \"band\", { id: \"labelValue\" })] : [],\n        ...sizeKey ? [valueProperty9(sizeKey, sizeScaleType, { id: \"sizeValue\" })] : [],\n        ...colorKey ? [valueProperty9(colorKey, colorScaleType, { id: \"colorValue\" })] : []\n      ]\n    });\n    const featureIdx = idKey != null ? dataModel.resolveProcessedDataIndexById(this, `featureValue`) : void 0;\n    const latIdx = hasLatLon ? dataModel.resolveProcessedDataIndexById(this, `latValue`) : void 0;\n    const lonIdx = hasLatLon ? dataModel.resolveProcessedDataIndexById(this, `lonValue`) : void 0;\n    this.topologyBounds = processedData.data.reduce(\n      (current, { values }) => {\n        const feature = featureIdx != null ? values[featureIdx] : void 0;\n        const geometry = feature?.geometry;\n        if (geometry != null) {\n          current = geometryBbox(geometry, current);\n        }\n        if (latIdx != null && lonIdx != null) {\n          const lon = values[lonIdx];\n          const lat = values[latIdx];\n          current = extendBbox(current, lon, lat, lon, lat);\n        }\n        return current;\n      },\n      void 0\n    );\n    if (sizeKey != null) {\n      const sizeIdx = dataModel.resolveProcessedDataIndexById(this, `sizeValue`);\n      const processedSize = processedData.domain.values[sizeIdx] ?? [];\n      sizeScale.domain = sizeDomain ?? processedSize;\n    }\n    if (colorRange != null && this.isColorScaleValid()) {\n      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, \"colorValue\");\n      colorScale.domain = processedData.domain.values[colorKeyIdx];\n      colorScale.range = colorRange;\n      colorScale.update();\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  isColorScaleValid() {\n    const { colorKey } = this.properties;\n    if (!colorKey) {\n      return false;\n    }\n    const { dataModel, processedData } = this;\n    if (!dataModel || !processedData) {\n      return false;\n    }\n    const colorIdx = dataModel.resolveProcessedDataIndexById(this, \"colorValue\");\n    const dataCount = processedData.data.length;\n    const missCount = getMissCount3(this, processedData.defs.values[colorIdx].missing);\n    const colorDataMissing = dataCount === 0 || dataCount === missCount;\n    return !colorDataMissing;\n  }\n  getLabelDatum(datum, labelValue, x, y, size, font) {\n    if (labelValue == null)\n      return;\n    const {\n      idKey,\n      idName,\n      latitudeKey,\n      latitudeName,\n      longitudeKey,\n      longitudeName,\n      sizeKey,\n      sizeName,\n      colorKey,\n      colorName,\n      labelKey,\n      labelName,\n      label\n    } = this.properties;\n    const { placement } = label;\n    const labelText = this.getLabelText(label, {\n      value: labelValue,\n      datum,\n      idKey,\n      idName,\n      latitudeKey,\n      latitudeName,\n      longitudeKey,\n      longitudeName,\n      sizeKey,\n      sizeName,\n      colorKey,\n      colorName,\n      labelKey,\n      labelName\n    });\n    if (labelText == null)\n      return;\n    const { width, height } = Text10.getTextSize(String(labelText), font);\n    return {\n      point: { x, y, size },\n      label: { width, height, text: labelText },\n      marker: getMarker(this.properties.shape),\n      placement\n    };\n  }\n  async createNodeData() {\n    const { id: seriesId, dataModel, processedData, colorScale, sizeScale, properties, scale } = this;\n    const { idKey, latitudeKey, longitudeKey, sizeKey, colorKey, labelKey, label } = properties;\n    if (dataModel == null || processedData == null || scale == null)\n      return;\n    const colorScaleValid = this.isColorScaleValid();\n    const hasLatLon = latitudeKey != null && longitudeKey != null;\n    const idIdx = idKey != null ? dataModel.resolveProcessedDataIndexById(this, `idValue`) : void 0;\n    const featureIdx = idKey != null ? dataModel.resolveProcessedDataIndexById(this, `featureValue`) : void 0;\n    const latIdx = hasLatLon ? dataModel.resolveProcessedDataIndexById(this, `latValue`) : void 0;\n    const lonIdx = hasLatLon ? dataModel.resolveProcessedDataIndexById(this, `lonValue`) : void 0;\n    const labelIdx = labelKey != null ? dataModel.resolveProcessedDataIndexById(this, `labelValue`) : void 0;\n    const sizeIdx = sizeKey != null ? dataModel.resolveProcessedDataIndexById(this, `sizeValue`) : void 0;\n    const colorIdx = colorKey != null ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : void 0;\n    const markerMaxSize = properties.maxSize ?? properties.size;\n    sizeScale.range = [Math.min(properties.size, markerMaxSize), markerMaxSize];\n    const font = label.getFont();\n    let projectedGeometries;\n    if (idIdx != null && featureIdx != null) {\n      projectedGeometries = /* @__PURE__ */ new Map();\n      processedData.data.forEach(({ values }) => {\n        const id = values[idIdx];\n        const geometry = values[featureIdx]?.geometry;\n        const projectedGeometry = geometry != null && scale != null ? projectGeometry(geometry, scale) : void 0;\n        if (id != null && projectedGeometry != null) {\n          projectedGeometries.set(id, projectedGeometry);\n        }\n      });\n    }\n    const nodeData = [];\n    const labelData = [];\n    const missingGeometries = [];\n    processedData.data.forEach(({ datum, values }) => {\n      const idValue = idIdx != null ? values[idIdx] : void 0;\n      const lonValue = lonIdx != null ? values[lonIdx] : void 0;\n      const latValue = latIdx != null ? values[latIdx] : void 0;\n      const colorValue = colorIdx != null ? values[colorIdx] : void 0;\n      const sizeValue = sizeIdx != null ? values[sizeIdx] : void 0;\n      const labelValue = labelIdx != null ? values[labelIdx] : void 0;\n      const color = colorScaleValid && colorValue != null ? colorScale.convert(colorValue) : void 0;\n      const size = sizeValue != null ? sizeScale.convert(sizeValue, { clampMode: \"clamped\" }) : properties.size;\n      const projectedGeometry = idValue != null ? projectedGeometries?.get(idValue) : void 0;\n      if (idValue != null && projectGeometry == null) {\n        missingGeometries.push(idValue);\n      }\n      if (lonValue != null && latValue != null) {\n        const [x, y] = scale.convert([lonValue, latValue]);\n        const labelDatum = this.getLabelDatum(datum, labelValue, x, y, size, font);\n        if (labelDatum) {\n          labelData.push(labelDatum);\n        }\n        nodeData.push({\n          series: this,\n          itemId: latitudeKey,\n          datum,\n          index: -1,\n          fill: color,\n          idValue,\n          lonValue,\n          latValue,\n          labelValue,\n          sizeValue,\n          colorValue,\n          point: { x, y, size },\n          midPoint: { x, y }\n        });\n      } else if (projectedGeometry != null) {\n        markerPositions(projectedGeometry, 1).forEach(([x, y], index) => {\n          const labelDatum = this.getLabelDatum(datum, labelValue, x, y, size, font);\n          if (labelDatum) {\n            labelData.push(labelDatum);\n          }\n          nodeData.push({\n            series: this,\n            itemId: latitudeKey,\n            datum,\n            index,\n            fill: color,\n            idValue,\n            lonValue,\n            latValue,\n            labelValue,\n            sizeValue,\n            colorValue,\n            point: { x, y, size },\n            midPoint: { x, y }\n          });\n        });\n      }\n    });\n    const missingGeometriesCap = 10;\n    if (missingGeometries.length > missingGeometriesCap) {\n      const excessItems = missingGeometries.length - missingGeometriesCap;\n      missingGeometries.length = missingGeometriesCap;\n      missingGeometries.push(`(+${excessItems} more)`);\n    }\n    if (missingGeometries.length > 0) {\n      Logger13.warnOnce(`some data items do not have matches in the provided topology`, missingGeometries);\n    }\n    return {\n      itemId: seriesId,\n      nodeData,\n      labelData\n    };\n  }\n  async updateSelections() {\n    if (this.nodeDataRefresh) {\n      this.contextNodeData = await this.createNodeData();\n      this.nodeDataRefresh = false;\n    }\n  }\n  checkScaleChange() {\n    if (this.previousScale === this.scale)\n      return false;\n    this.previousScale = this.scale;\n    return true;\n  }\n  async update({ seriesRect }) {\n    const resize = this.checkResize(seriesRect);\n    const scaleChange = this.checkScaleChange();\n    const { labelSelection, markerSelection, highlightMarkerSelection } = this;\n    await this.updateSelections();\n    this.contentGroup.visible = this.visible;\n    this.contentGroup.opacity = this.getOpacity();\n    let highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();\n    if (highlightedDatum != null && (highlightedDatum.series !== this || highlightedDatum.datum == null)) {\n      highlightedDatum = void 0;\n    }\n    const nodeData = this.contextNodeData?.nodeData ?? [];\n    this.labelSelection = await this.updateLabelSelection({ labelSelection });\n    await this.updateLabelNodes({ labelSelection });\n    this.markerSelection = await this.updateMarkerSelection({ markerData: nodeData, markerSelection });\n    await this.updateMarkerNodes({ markerSelection, isHighlight: false, highlightedDatum });\n    this.highlightMarkerSelection = await this.updateMarkerSelection({\n      markerData: highlightedDatum != null ? [highlightedDatum] : [],\n      markerSelection: highlightMarkerSelection\n    });\n    await this.updateMarkerNodes({\n      markerSelection: highlightMarkerSelection,\n      isHighlight: true,\n      highlightedDatum\n    });\n    if (scaleChange || resize) {\n      this.animationState.transition(\"resize\");\n    }\n    this.animationState.transition(\"update\");\n  }\n  async updateLabelSelection(opts) {\n    const placedLabels = (this.isLabelEnabled() ? this.chart?.placeLabels().get(this) : void 0) ?? [];\n    return opts.labelSelection.update(placedLabels);\n  }\n  async updateLabelNodes(opts) {\n    const { labelSelection } = opts;\n    const { color: fill, fontStyle, fontWeight, fontSize, fontFamily } = this.properties.label;\n    labelSelection.each((label, { x, y, width, height, text }) => {\n      label.visible = true;\n      label.x = x + width / 2;\n      label.y = y + height / 2;\n      label.text = text;\n      label.fill = fill;\n      label.fontStyle = fontStyle;\n      label.fontWeight = fontWeight;\n      label.fontSize = fontSize;\n      label.fontFamily = fontFamily;\n      label.textAlign = \"center\";\n      label.textBaseline = \"middle\";\n    });\n  }\n  async updateMarkerSelection(opts) {\n    const { markerData, markerSelection } = opts;\n    return markerSelection.update(\n      markerData,\n      void 0,\n      (datum) => createDatumId5([datum.index, datum.idValue, datum.lonValue, datum.latValue])\n    );\n  }\n  async updateMarkerNodes(opts) {\n    const { properties } = this;\n    const { markerSelection, isHighlight, highlightedDatum } = opts;\n    const { fill, fillOpacity, stroke, strokeOpacity } = properties;\n    const highlightStyle = isHighlight ? properties.highlightStyle.item : void 0;\n    const strokeWidth = this.getStrokeWidth(properties.strokeWidth);\n    markerSelection.each((marker, markerDatum) => {\n      const { datum, point } = markerDatum;\n      const format = this.getMapMarkerStyle(markerDatum, isHighlight);\n      marker.size = format?.size ?? point.size;\n      marker.fill = highlightStyle?.fill ?? format?.fill ?? markerDatum.fill ?? fill;\n      marker.fillOpacity = highlightStyle?.fillOpacity ?? format?.fillOpacity ?? fillOpacity;\n      marker.stroke = highlightStyle?.stroke ?? format?.stroke ?? stroke;\n      marker.strokeWidth = highlightStyle?.strokeWidth ?? format?.strokeWidth ?? strokeWidth;\n      marker.strokeOpacity = highlightStyle?.strokeOpacity ?? format?.strokeOpacity ?? strokeOpacity;\n      marker.translationX = point.x;\n      marker.translationY = point.y;\n      marker.zIndex = !isHighlight && highlightedDatum != null && datum === highlightedDatum.datum ? 1 : 0;\n    });\n  }\n  onLegendItemClick(event) {\n    const { legendItemName } = this.properties;\n    const { enabled, itemId, series } = event;\n    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;\n    if (series.id === this.id || matchedLegendItemName) {\n      this.toggleSeriesItem(itemId, enabled);\n    }\n  }\n  onLegendItemDoubleClick(event) {\n    const { enabled, itemId, series, numVisibleItems } = event;\n    const { legendItemName } = this.properties;\n    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;\n    if (series.id === this.id || matchedLegendItemName) {\n      this.toggleSeriesItem(itemId, true);\n    } else if (enabled && numVisibleItems === 1) {\n      this.toggleSeriesItem(itemId, true);\n    } else {\n      this.toggleSeriesItem(itemId, false);\n    }\n  }\n  isProcessedDataAnimatable() {\n    return true;\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    } else if (phase === \"ready\") {\n      this.animationState.transition(\"skip\");\n    }\n  }\n  resetAllAnimation() {\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    this.ctx.animationManager.skipCurrentBatch();\n    this.labelSelection.cleanup();\n    this.markerSelection.cleanup();\n    this.highlightMarkerSelection.cleanup();\n  }\n  animateMarkers() {\n    const { animationManager } = this.ctx;\n    const fns = prepareMapMarkerAnimationFunctions();\n    fromToMotion2(this.id, \"markers\", animationManager, [this.markerSelection, this.highlightMarkerSelection], fns);\n  }\n  getLabelData() {\n    return this.contextNodeData?.labelData ?? [];\n  }\n  getSeriesDomain() {\n    return [NaN, NaN];\n  }\n  pickNodeClosestDatum(p) {\n    const { x: x0, y: y0 } = this.rootGroup.transformPoint(p.x, p.y);\n    let minDistanceSquared = Infinity;\n    let minDatum;\n    this.contextNodeData?.nodeData.forEach((datum) => {\n      const { x, y, size } = datum.point;\n      const dx2 = Math.max(Math.abs(x - x0) - size, 0);\n      const dy2 = Math.max(Math.abs(y - y0) - size, 0);\n      const distanceSquared = dx2 * dx2 + dy2 * dy2;\n      if (distanceSquared < minDistanceSquared) {\n        minDistanceSquared = distanceSquared;\n        minDatum = datum;\n      }\n    });\n    return minDatum != null ? { datum: minDatum, distance: Math.sqrt(minDistanceSquared) } : void 0;\n  }\n  getLegendData(legendType) {\n    const { processedData, dataModel } = this;\n    if (processedData == null || dataModel == null)\n      return [];\n    const {\n      title,\n      legendItemName,\n      idName,\n      idKey,\n      colorKey,\n      colorName,\n      colorRange,\n      visible,\n      shape,\n      fill,\n      stroke,\n      fillOpacity,\n      strokeOpacity,\n      strokeWidth\n    } = this.properties;\n    if (legendType === \"gradient\" && colorKey != null && colorRange != null) {\n      const colorDomain = processedData.domain.values[dataModel.resolveProcessedDataIndexById(this, \"colorValue\")];\n      const legendDatum = {\n        legendType: \"gradient\",\n        enabled: visible,\n        seriesId: this.id,\n        colorName,\n        colorRange,\n        colorDomain\n      };\n      return [legendDatum];\n    } else if (legendType === \"category\") {\n      const legendDatum = {\n        legendType: \"category\",\n        id: this.id,\n        itemId: legendItemName ?? title ?? idName ?? idKey ?? this.id,\n        seriesId: this.id,\n        enabled: visible,\n        label: { text: legendItemName ?? title ?? idName ?? idKey ?? this.id },\n        symbols: [\n          {\n            marker: {\n              shape,\n              fill,\n              fillOpacity,\n              stroke,\n              strokeWidth,\n              strokeOpacity\n            }\n          }\n        ],\n        legendItemName\n      };\n      return [legendDatum];\n    } else {\n      return [];\n    }\n  }\n  getTooltipHtml(nodeDatum) {\n    const {\n      id: seriesId,\n      processedData,\n      ctx: { callbackCache },\n      properties\n    } = this;\n    if (!processedData || !this.properties.isValid()) {\n      return ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.EMPTY_TOOLTIP_CONTENT;\n    }\n    const {\n      legendItemName,\n      idKey,\n      idName,\n      latitudeKey,\n      longitudeKey,\n      sizeKey,\n      sizeName,\n      colorKey,\n      colorName,\n      labelKey,\n      labelName,\n      itemStyler,\n      tooltip,\n      latitudeName,\n      longitudeName,\n      shape,\n      size,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity\n    } = properties;\n    const { datum, fill, idValue, latValue, lonValue, sizeValue, colorValue, labelValue, itemId } = nodeDatum;\n    const title = sanitizeHtml6(properties.title ?? legendItemName) ?? \"\";\n    const contentLines = [];\n    if (idValue != null) {\n      contentLines.push(sanitizeHtml6((idName != null ? `${idName}: ` : \"\") + idValue));\n    }\n    if (colorValue != null) {\n      contentLines.push(sanitizeHtml6((colorName ?? colorKey) + \": \" + colorValue));\n    }\n    if (sizeValue != null) {\n      contentLines.push(sanitizeHtml6((sizeName ?? sizeKey) + \": \" + sizeValue));\n    }\n    if (labelValue != null && (idKey == null || idKey !== labelKey)) {\n      contentLines.push(sanitizeHtml6((labelName ?? labelKey) + \": \" + labelValue));\n    }\n    if (latValue != null && lonValue != null) {\n      contentLines.push(\n        sanitizeHtml6(\n          `${Math.abs(latValue).toFixed(4)}\\xB0 ${latValue >= 0 ? \"N\" : \"S\"}, ${Math.abs(lonValue).toFixed(4)}\\xB0 ${latValue >= 0 ? \"W\" : \"E\"}`\n        )\n      );\n    }\n    const content = contentLines.join(\"<br>\");\n    let format;\n    if (itemStyler) {\n      format = callbackCache.call(itemStyler, {\n        highlighted: false,\n        seriesId,\n        datum,\n        idKey,\n        sizeKey,\n        colorKey,\n        labelKey,\n        latitudeKey,\n        longitudeKey,\n        shape,\n        size,\n        fill,\n        fillOpacity,\n        stroke,\n        strokeWidth,\n        strokeOpacity\n      });\n    }\n    const color = format?.fill ?? fill ?? properties.fill;\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        seriesId,\n        datum,\n        idKey,\n        latitudeKey,\n        longitudeKey,\n        title,\n        color,\n        colorKey,\n        colorName,\n        idName,\n        itemId,\n        labelKey,\n        labelName,\n        latitudeName,\n        longitudeName,\n        sizeKey,\n        sizeName,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  getMapMarkerStyle(markerDatum, highlighted) {\n    const {\n      id: seriesId,\n      properties,\n      ctx: { callbackCache }\n    } = this;\n    const { datum, point } = markerDatum;\n    const {\n      idKey,\n      latitudeKey,\n      longitudeKey,\n      labelKey,\n      sizeKey,\n      colorKey,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeOpacity,\n      shape,\n      itemStyler\n    } = properties;\n    const strokeWidth = this.getStrokeWidth(properties.strokeWidth);\n    if (itemStyler !== void 0) {\n      return callbackCache.call(itemStyler, {\n        seriesId,\n        datum,\n        size: point.size,\n        idKey,\n        latitudeKey,\n        longitudeKey,\n        labelKey,\n        sizeKey,\n        colorKey,\n        fill,\n        fillOpacity,\n        stroke,\n        strokeWidth,\n        strokeOpacity,\n        shape,\n        highlighted\n      });\n    }\n  }\n  getFormattedMarkerStyle(markerDatum) {\n    const style = this.getMapMarkerStyle(markerDatum, true);\n    return { size: style?.size ?? markerDatum.point.size };\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nMapMarkerSeries.className = \"MapMarkerSeries\";\nMapMarkerSeries.type = \"map-marker\";\n__decorateClass([\n  Validate45(GEOJSON_OBJECT, { optional: true, property: \"topology\" })\n], MapMarkerSeries.prototype, \"_chartTopology\", 2);\n\n// packages/ag-charts-enterprise/src/series/map-marker/mapMarkerModule.ts\nvar { DEFAULT_LABEL_COLOUR: DEFAULT_LABEL_COLOUR3, DEFAULT_DIVERGING_SERIES_COLOUR_RANGE: DEFAULT_DIVERGING_SERIES_COLOUR_RANGE2, singleSeriesPaletteFactory: singleSeriesPaletteFactory2 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme;\nvar MapMarkerModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"topology\"],\n  identifier: \"map-marker\",\n  instanceConstructor: MapMarkerSeries,\n  tooltipDefaults: { range: \"exact\" },\n  themeTemplate: {\n    ...MAP_THEME_DEFAULTS,\n    series: {\n      shape: \"circle\",\n      maxSize: 30,\n      fillOpacity: 0.5,\n      label: {\n        color: DEFAULT_LABEL_COLOUR3\n      }\n    }\n  },\n  paletteFactory: (opts) => {\n    const { takeColors, colorsCount, userPalette, themeTemplateParameters } = opts;\n    const { fill, stroke } = singleSeriesPaletteFactory2(opts);\n    const defaultColorRange = themeTemplateParameters.get(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE2);\n    const { fills } = takeColors(colorsCount);\n    return {\n      fill,\n      stroke,\n      colorRange: userPalette === \"inbuilt\" ? defaultColorRange : [fills[0], fills[1]]\n    };\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/map-shape-background/mapShapeBackgroundModule.ts\n\n\n// packages/ag-charts-enterprise/src/series/map-shape-background/mapShapeBackgroundSeries.ts\n\n\n// packages/ag-charts-enterprise/src/series/map-shape-background/mapShapeBackgroundSeriesProperties.ts\n\nvar { COLOR_STRING: COLOR_STRING14, LINE_DASH: LINE_DASH11, OBJECT: OBJECT18, POSITIVE_NUMBER: POSITIVE_NUMBER18, RATIO: RATIO19, Validate: Validate46, SeriesProperties: SeriesProperties5, SeriesTooltip: SeriesTooltip9 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar MapShapeBackgroundSeriesProperties = class extends SeriesProperties5 {\n  constructor() {\n    super(...arguments);\n    this.topology = void 0;\n    this.fill = \"black\";\n    this.fillOpacity = 1;\n    this.stroke = \"black\";\n    this.strokeOpacity = 1;\n    this.strokeWidth = 0;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.tooltip = new SeriesTooltip9();\n  }\n};\n__decorateClass([\n  Validate46(GEOJSON_OBJECT, { optional: true })\n], MapShapeBackgroundSeriesProperties.prototype, \"topology\", 2);\n__decorateClass([\n  Validate46(COLOR_STRING14)\n], MapShapeBackgroundSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate46(RATIO19)\n], MapShapeBackgroundSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate46(COLOR_STRING14)\n], MapShapeBackgroundSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate46(RATIO19)\n], MapShapeBackgroundSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate46(POSITIVE_NUMBER18)\n], MapShapeBackgroundSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate46(LINE_DASH11)\n], MapShapeBackgroundSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate46(POSITIVE_NUMBER18)\n], MapShapeBackgroundSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate46(OBJECT18)\n], MapShapeBackgroundSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-enterprise/src/series/map-shape-background/mapShapeBackgroundSeries.ts\nvar { createDatumId: createDatumId6, Series, SeriesNodePickMode: SeriesNodePickMode8, Validate: Validate47 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { Selection: Selection7, Group: Group11, PointerEvents: PointerEvents3 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar { Logger: Logger14 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar MapShapeBackgroundSeries = class extends Series {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      contentGroupVirtual: false,\n      useLabelLayer: true,\n      pickModes: [SeriesNodePickMode8.EXACT_SHAPE_MATCH]\n    });\n    this.properties = new MapShapeBackgroundSeriesProperties();\n    this._chartTopology = void 0;\n    this.itemGroup = this.contentGroup.appendChild(new Group11({ name: \"itemGroup\" }));\n    this.datumSelection = Selection7.select(\n      this.itemGroup,\n      () => this.nodeFactory()\n    );\n  }\n  get topology() {\n    return this.properties.topology ?? this._chartTopology;\n  }\n  setOptionsData() {\n  }\n  setChartData() {\n  }\n  get hasData() {\n    return false;\n  }\n  setChartTopology(topology) {\n    this._chartTopology = topology;\n    if (this.topology === topology) {\n      this.nodeDataRefresh = true;\n    }\n  }\n  nodeFactory() {\n    const geoGeometry = new GeoGeometry();\n    geoGeometry.renderMode = 1 /* Polygons */;\n    geoGeometry.lineJoin = \"round\";\n    geoGeometry.pointerEvents = PointerEvents3.None;\n    return geoGeometry;\n  }\n  async processData() {\n    const { topology } = this;\n    this.topologyBounds = topology?.features.reduce((current, feature) => {\n      const geometry = feature.geometry;\n      if (geometry == null)\n        return current;\n      return geometryBbox(geometry, current);\n    }, void 0);\n    if (topology == null) {\n      Logger14.warnOnce(`no topology was provided for [MapShapeBackgroundSeries]; nothing will be rendered.`);\n    }\n  }\n  async createNodeData() {\n    const { id: seriesId, topology, scale } = this;\n    if (topology == null)\n      return;\n    const nodeData = [];\n    const labelData = [];\n    topology.features.forEach((feature, index) => {\n      const { geometry } = feature;\n      const projectedGeometry = geometry != null && scale != null ? projectGeometry(geometry, scale) : void 0;\n      if (projectedGeometry == null)\n        return;\n      nodeData.push({\n        series: this,\n        itemId: index,\n        datum: feature,\n        index,\n        projectedGeometry\n      });\n    });\n    return {\n      itemId: seriesId,\n      nodeData,\n      labelData\n    };\n  }\n  async updateSelections() {\n    if (this.nodeDataRefresh) {\n      this.contextNodeData = await this.createNodeData();\n      this.nodeDataRefresh = false;\n    }\n  }\n  async update() {\n    const { datumSelection } = this;\n    await this.updateSelections();\n    this.contentGroup.visible = this.visible;\n    const { nodeData = [] } = this.contextNodeData ?? {};\n    this.datumSelection = await this.updateDatumSelection({ nodeData, datumSelection });\n    await this.updateDatumNodes({ datumSelection });\n  }\n  async updateDatumSelection(opts) {\n    return opts.datumSelection.update(opts.nodeData, void 0, (datum) => createDatumId6(datum.index));\n  }\n  async updateDatumNodes(opts) {\n    const { properties } = this;\n    const { datumSelection } = opts;\n    const { fill, fillOpacity, stroke, strokeOpacity, lineDash, lineDashOffset } = properties;\n    const strokeWidth = this.getStrokeWidth(properties.strokeWidth);\n    datumSelection.each((geoGeometry, datum) => {\n      const { projectedGeometry } = datum;\n      if (projectedGeometry == null) {\n        geoGeometry.visible = false;\n        geoGeometry.projectedGeometry = void 0;\n        return;\n      }\n      geoGeometry.visible = true;\n      geoGeometry.projectedGeometry = projectedGeometry;\n      geoGeometry.fill = fill;\n      geoGeometry.fillOpacity = fillOpacity;\n      geoGeometry.stroke = stroke;\n      geoGeometry.strokeWidth = strokeWidth;\n      geoGeometry.strokeOpacity = strokeOpacity;\n      geoGeometry.lineDash = lineDash;\n      geoGeometry.lineDashOffset = lineDashOffset;\n    });\n  }\n  resetAnimation() {\n  }\n  getLabelData() {\n    return [];\n  }\n  getSeriesDomain() {\n    return [NaN, NaN];\n  }\n  getLegendData() {\n    return [];\n  }\n  getTooltipHtml() {\n    return ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.EMPTY_TOOLTIP_CONTENT;\n  }\n  pickFocus(_opts) {\n    return void 0;\n  }\n};\nMapShapeBackgroundSeries.className = \"MapShapeBackgroundSeries\";\nMapShapeBackgroundSeries.type = \"map-shape-background\";\n__decorateClass([\n  Validate47(GEOJSON_OBJECT, { optional: true, property: \"topology\" })\n], MapShapeBackgroundSeries.prototype, \"_chartTopology\", 2);\n\n// packages/ag-charts-enterprise/src/series/map-shape-background/mapShapeBackgroundModule.ts\nvar { DEFAULT_BACKGROUND_COLOUR, DEFAULT_HIERARCHY_FILLS } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme;\nvar MapShapeBackgroundModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"topology\"],\n  identifier: \"map-shape-background\",\n  instanceConstructor: MapShapeBackgroundSeries,\n  tooltipDefaults: { range: \"exact\" },\n  themeTemplate: {\n    ...MAP_THEME_DEFAULTS,\n    series: {\n      stroke: DEFAULT_BACKGROUND_COLOUR,\n      strokeWidth: 1\n    }\n  },\n  paletteFactory: ({ themeTemplateParameters }) => {\n    return {\n      fill: themeTemplateParameters.get(DEFAULT_HIERARCHY_FILLS)?.[1]\n    };\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/map-shape/mapShapeModule.ts\n\n\n// packages/ag-charts-enterprise/src/series/map-shape/mapShapeSeries.ts\n\n\n// packages/ag-charts-enterprise/src/series/map-util/polygonLabelUtil.ts\nfunction preferredLabelCenter(polygons, { aspectRatio, precision }) {\n  const result = polygonPointSearch(polygons, precision, (p, cx, cy, stride) => {\n    const width = maxWidthOfRectConstrainedByCenterAndAspectRatioToPolygon(p, cx, cy, aspectRatio);\n    const maxWidth2 = width + 2 * stride * aspectRatio;\n    const distance2 = width * Math.SQRT2;\n    const maxDistance = maxWidth2 * Math.SQRT2;\n    return { distance: distance2, maxDistance };\n  });\n  if (result == null)\n    return;\n  const { x, y, distance } = result;\n  const maxWidth = distance / Math.SQRT2;\n  return { x, y, maxWidth };\n}\nfunction maxWidthOfRectConstrainedByCenterAndAspectRatioToLineSegment(a, b, cx, cy, aspectRatio) {\n  const [ax, ay] = a;\n  const [bx, by] = b;\n  const positiveM = 1 / aspectRatio;\n  const abx = bx - ax;\n  const aby = by - ay;\n  const [topPointX, topPointY] = ay <= by ? a : b;\n  const [leftPointX, leftPointY] = ax <= bx ? a : b;\n  const [bottomPointX, bottomPointY] = ay <= by ? b : a;\n  const [rightPointX, rightPointY] = ax <= bx ? b : a;\n  let maxWidth = Infinity;\n  if (abx !== 0) {\n    const abm = aby / abx;\n    for (let i = 0; i <= 1; i += 1) {\n      const m = i === 0 ? positiveM : -positiveM;\n      const x = (abm * ax - ay - m * cx + cy) / (abm - m);\n      if (x >= leftPointX && x <= rightPointX) {\n        const width = Math.abs(cx - x) * 2;\n        maxWidth = Math.min(maxWidth, width);\n      }\n    }\n  } else {\n    for (let i = 0; i <= 1; i += 1) {\n      const m = i === 0 ? positiveM : -positiveM;\n      const y = m * (ax - cx) + cy;\n      if (y >= topPointY && y <= bottomPointY) {\n        const height = Math.abs(cy - y) * 2;\n        const width = height * aspectRatio;\n        maxWidth = Math.min(maxWidth, width);\n      }\n    }\n  }\n  const positiveMRecip = aspectRatio;\n  const centerToTopMRecip = Math.abs((topPointX - cx) / (topPointY - cy));\n  const centerToBottomMRecip = Math.abs((bottomPointX - cx) / (bottomPointY - cy));\n  if (bottomPointY < cy && centerToBottomMRecip < positiveMRecip) {\n    const height = Math.abs(cy - bottomPointY) * 2;\n    const width = height * aspectRatio;\n    maxWidth = Math.min(maxWidth, width);\n  } else if (topPointY > cy && centerToTopMRecip < positiveMRecip) {\n    const height = Math.abs(cy - topPointY) * 2;\n    const width = height * aspectRatio;\n    maxWidth = Math.min(maxWidth, width);\n  }\n  const centerToLeftM = Math.abs((leftPointY - cy) / (leftPointX - cx));\n  const centerToRightM = Math.abs((rightPointY - cy) / (rightPointX - cx));\n  if (rightPointX < cx && centerToRightM < positiveM) {\n    const width = Math.abs(cx - rightPointX) * 2;\n    maxWidth = Math.min(maxWidth, width);\n  } else if (leftPointX > cx && centerToLeftM < positiveM) {\n    const width = Math.abs(cx - leftPointX) * 2;\n    maxWidth = Math.min(maxWidth, width);\n  }\n  return maxWidth;\n}\nfunction maxWidthOfRectConstrainedByCenterAndAspectRatioToPolygon(polygons, cx, cy, aspectRatio) {\n  let inside = false;\n  let minWidth = Infinity;\n  for (const polygon of polygons) {\n    let p0 = polygon[polygon.length - 1];\n    let [x0, y0] = p0;\n    for (const p1 of polygon) {\n      const [x1, y1] = p1;\n      if (y1 > cy !== y0 > cy && cx < (x0 - x1) * (cy - y1) / (y0 - y1) + x1) {\n        inside = !inside;\n      }\n      const width = maxWidthOfRectConstrainedByCenterAndAspectRatioToLineSegment(p0, p1, cx, cy, aspectRatio);\n      minWidth = Math.min(minWidth, width);\n      p0 = p1;\n      x0 = x1;\n      y0 = y1;\n    }\n  }\n  return (inside ? 1 : -1) * minWidth;\n}\nfunction applyX(into, cx, x) {\n  if (x >= cx) {\n    into.maxX = Math.min(into.maxX, x - cx);\n  }\n  if (x <= cx) {\n    into.minX = Math.max(into.minX, x - cx);\n  }\n}\nfunction xExtentsOfRectConstrainedByCenterAndHeightToLineSegment(into, a, b, cx, cy, height) {\n  const ry0 = cy - height / 2;\n  const ry1 = cy + height / 2;\n  const [ax, ay] = a;\n  const [bx, by] = b;\n  const abx = bx - ax;\n  const aby = by - ay;\n  const [leftPointX, leftPointY] = ax <= bx ? a : b;\n  const [rightPointX, rightPointY] = ax <= bx ? b : a;\n  if (abx !== 0) {\n    const abm = aby / abx;\n    for (let i = 0; i <= 1; i += 1) {\n      const y = i === 0 ? ry0 : ry1;\n      const x = (y - ay) / abm + ax;\n      if (x >= leftPointX && x <= rightPointX) {\n        applyX(into, cx, x);\n      }\n    }\n  } else if (Math.max(ry0, Math.min(ay, by)) <= Math.min(ry1, Math.max(ay, by))) {\n    applyX(into, cx, ax);\n  }\n  if (rightPointX < cx && rightPointY >= ry0 && rightPointY <= ry1) {\n    applyX(into, cx, rightPointX);\n  } else if (leftPointX > cx && leftPointY >= ry0 && leftPointY <= ry1) {\n    applyX(into, cx, leftPointX);\n  }\n  return into;\n}\nfunction maxWidthInPolygonForRectOfHeight(polygons, cx, cy, height) {\n  const result = {\n    minX: -Infinity,\n    maxX: Infinity\n  };\n  for (const polygon of polygons) {\n    let p0 = polygon[polygon.length - 1];\n    for (const p1 of polygon) {\n      xExtentsOfRectConstrainedByCenterAndHeightToLineSegment(result, p0, p1, cx, cy, height);\n      p0 = p1;\n    }\n  }\n  const { minX, maxX } = result;\n  if (Number.isFinite(minX) && Number.isFinite(maxX)) {\n    return { x: cx + (minX + maxX) / 2, width: maxX - minX };\n  } else {\n    return { x: cx, width: 0 };\n  }\n}\n\n// packages/ag-charts-enterprise/src/series/map-shape/mapShapeSeriesProperties.ts\n\nvar {\n  AND: AND10,\n  ARRAY: ARRAY9,\n  COLOR_STRING: COLOR_STRING15,\n  COLOR_STRING_ARRAY: COLOR_STRING_ARRAY5,\n  FUNCTION: FUNCTION11,\n  LINE_DASH: LINE_DASH12,\n  OBJECT: OBJECT19,\n  POSITIVE_NUMBER: POSITIVE_NUMBER19,\n  RATIO: RATIO20,\n  STRING: STRING19,\n  Validate: Validate48,\n  SeriesProperties: SeriesProperties6,\n  SeriesTooltip: SeriesTooltip10\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar MapShapeSeriesProperties = class extends SeriesProperties6 {\n  constructor() {\n    super(...arguments);\n    this.topology = void 0;\n    this.idKey = \"\";\n    this.idName = void 0;\n    this.topologyIdKey = \"name\";\n    this.labelKey = void 0;\n    this.labelName = void 0;\n    this.colorRange = void 0;\n    this.fill = \"black\";\n    this.fillOpacity = 1;\n    this.stroke = \"black\";\n    this.strokeOpacity = 1;\n    this.strokeWidth = 0;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.padding = 0;\n    this.label = new AutoSizeableSecondaryLabel();\n    this.tooltip = new SeriesTooltip10();\n  }\n};\n__decorateClass([\n  Validate48(GEOJSON_OBJECT, { optional: true })\n], MapShapeSeriesProperties.prototype, \"topology\", 2);\n__decorateClass([\n  Validate48(STRING19, { optional: true })\n], MapShapeSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  Validate48(STRING19, { optional: true })\n], MapShapeSeriesProperties.prototype, \"legendItemName\", 2);\n__decorateClass([\n  Validate48(STRING19)\n], MapShapeSeriesProperties.prototype, \"idKey\", 2);\n__decorateClass([\n  Validate48(STRING19, { optional: true })\n], MapShapeSeriesProperties.prototype, \"idName\", 2);\n__decorateClass([\n  Validate48(STRING19)\n], MapShapeSeriesProperties.prototype, \"topologyIdKey\", 2);\n__decorateClass([\n  Validate48(STRING19, { optional: true })\n], MapShapeSeriesProperties.prototype, \"labelKey\", 2);\n__decorateClass([\n  Validate48(STRING19, { optional: true })\n], MapShapeSeriesProperties.prototype, \"labelName\", 2);\n__decorateClass([\n  Validate48(STRING19, { optional: true })\n], MapShapeSeriesProperties.prototype, \"colorKey\", 2);\n__decorateClass([\n  Validate48(STRING19, { optional: true })\n], MapShapeSeriesProperties.prototype, \"colorName\", 2);\n__decorateClass([\n  Validate48(AND10(COLOR_STRING_ARRAY5, ARRAY9.restrict({ minLength: 1 })), { optional: true })\n], MapShapeSeriesProperties.prototype, \"colorRange\", 2);\n__decorateClass([\n  Validate48(COLOR_STRING15)\n], MapShapeSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate48(RATIO20)\n], MapShapeSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate48(COLOR_STRING15)\n], MapShapeSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate48(RATIO20)\n], MapShapeSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate48(POSITIVE_NUMBER19)\n], MapShapeSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate48(LINE_DASH12)\n], MapShapeSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate48(POSITIVE_NUMBER19)\n], MapShapeSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate48(POSITIVE_NUMBER19)\n], MapShapeSeriesProperties.prototype, \"padding\", 2);\n__decorateClass([\n  Validate48(FUNCTION11, { optional: true })\n], MapShapeSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate48(OBJECT19)\n], MapShapeSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate48(OBJECT19)\n], MapShapeSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-enterprise/src/series/map-shape/mapShapeSeries.ts\nvar { getMissCount: getMissCount4, createDatumId: createDatumId7, DataModelSeries: DataModelSeries5, SeriesNodePickMode: SeriesNodePickMode9, valueProperty: valueProperty10, Validate: Validate49 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { ColorScale: ColorScale4 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scale;\nvar { Group: Group12, Selection: Selection8, Text: Text11, PointerEvents: PointerEvents4 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar { sanitizeHtml: sanitizeHtml7, Logger: Logger15 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar fixedScale = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.MercatorScale.fixedScale();\nvar MapShapeSeries = class extends DataModelSeries5 {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      contentGroupVirtual: false,\n      useLabelLayer: true,\n      pickModes: [SeriesNodePickMode9.EXACT_SHAPE_MATCH, SeriesNodePickMode9.NEAREST_NODE]\n    });\n    this.properties = new MapShapeSeriesProperties();\n    this._chartTopology = void 0;\n    this.colorScale = new ColorScale4();\n    this.itemGroup = this.contentGroup.appendChild(new Group12({ name: \"itemGroup\" }));\n    this.itemLabelGroup = this.contentGroup.appendChild(new Group12({ name: \"itemLabelGroup\" }));\n    this.datumSelection = Selection8.select(\n      this.itemGroup,\n      () => this.nodeFactory()\n    );\n    this.labelSelection = Selection8.select(\n      this.itemLabelGroup,\n      Text11\n    );\n    this.highlightDatumSelection = Selection8.select(\n      this.highlightNode,\n      () => this.nodeFactory()\n    );\n    this.previousLabelLayouts = void 0;\n    this._previousDatumMidPoint = void 0;\n    this.itemLabelGroup.pointerEvents = PointerEvents4.None;\n  }\n  getNodeData() {\n    return this.contextNodeData?.nodeData;\n  }\n  get topology() {\n    return this.properties.topology ?? this._chartTopology;\n  }\n  get hasData() {\n    return super.hasData && this.topology != null;\n  }\n  setChartTopology(topology) {\n    this._chartTopology = topology;\n    if (this.topology === topology) {\n      this.nodeDataRefresh = true;\n    }\n  }\n  addChartEventListeners() {\n    this.destroyFns.push(\n      this.ctx.chartEventManager.addListener(\"legend-item-click\", (event) => {\n        this.onLegendItemClick(event);\n      }),\n      this.ctx.chartEventManager.addListener(\"legend-item-double-click\", (event) => {\n        this.onLegendItemDoubleClick(event);\n      })\n    );\n  }\n  isLabelEnabled() {\n    return this.properties.labelKey != null && this.properties.label.enabled;\n  }\n  nodeFactory() {\n    const geoGeometry = new GeoGeometry();\n    geoGeometry.renderMode = 1 /* Polygons */;\n    geoGeometry.lineJoin = \"round\";\n    return geoGeometry;\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    const { data, topology, colorScale } = this;\n    const { topologyIdKey, idKey, colorKey, labelKey, colorRange } = this.properties;\n    const featureById = /* @__PURE__ */ new Map();\n    topology?.features.forEach((feature) => {\n      const property = feature.properties?.[topologyIdKey];\n      if (property == null || !containsType(feature.geometry, 1 /* Polygon */))\n        return;\n      featureById.set(property, feature);\n    });\n    const colorScaleType = this.colorScale.type;\n    const mercatorScaleType = this.scale?.type;\n    const { dataModel, processedData } = await this.requestDataModel(dataController, data, {\n      props: [\n        valueProperty10(idKey, mercatorScaleType, { id: \"idValue\", includeProperty: false }),\n        valueProperty10(idKey, mercatorScaleType, {\n          id: \"featureValue\",\n          includeProperty: false,\n          processor: () => (datum) => featureById.get(datum)\n        }),\n        ...labelKey ? [valueProperty10(labelKey, \"band\", { id: \"labelValue\" })] : [],\n        ...colorKey ? [valueProperty10(colorKey, colorScaleType, { id: \"colorValue\" })] : []\n      ]\n    });\n    const featureIdx = dataModel.resolveProcessedDataIndexById(this, `featureValue`);\n    this.topologyBounds = processedData.data.reduce(\n      (current, { values }) => {\n        const feature = values[featureIdx];\n        const geometry = feature?.geometry;\n        if (geometry == null)\n          return current;\n        return geometryBbox(geometry, current);\n      },\n      void 0\n    );\n    if (colorRange != null && this.isColorScaleValid()) {\n      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, \"colorValue\");\n      colorScale.domain = processedData.domain.values[colorKeyIdx];\n      colorScale.range = colorRange;\n      colorScale.update();\n    }\n    if (topology == null) {\n      Logger15.warnOnce(`no topology was provided for [MapShapeSeries]; nothing will be rendered.`);\n    }\n  }\n  isColorScaleValid() {\n    const { colorKey } = this.properties;\n    if (!colorKey) {\n      return false;\n    }\n    const { dataModel, processedData } = this;\n    if (!dataModel || !processedData) {\n      return false;\n    }\n    const colorIdx = dataModel.resolveProcessedDataIndexById(this, \"colorValue\");\n    const dataCount = processedData.data.length;\n    const missCount = getMissCount4(this, processedData.defs.values[colorIdx].missing);\n    const colorDataMissing = dataCount === 0 || dataCount === missCount;\n    return !colorDataMissing;\n  }\n  getLabelLayout(datum, labelValue, font, geometry, previousLabelLayout) {\n    if (labelValue == null || geometry == null)\n      return;\n    const { idKey, idName, colorKey, colorName, labelKey, labelName, padding, label } = this.properties;\n    const labelText = this.getLabelText(label, {\n      value: labelValue,\n      datum,\n      idKey,\n      idName,\n      colorKey,\n      colorName,\n      labelKey,\n      labelName\n    });\n    if (labelText == null)\n      return;\n    const baseSize = Text11.getTextSize(String(labelText), font);\n    const numLines = labelText.split(\"\\n\").length;\n    const aspectRatio = (baseSize.width + 2 * padding) / (numLines * AutoSizedLabel.lineHeight(label.fontSize) + 2 * padding);\n    if (previousLabelLayout?.geometry === geometry && previousLabelLayout?.labelText === labelText && previousLabelLayout?.aspectRatio === aspectRatio) {\n      return previousLabelLayout;\n    }\n    const fixedGeometry = projectGeometry(geometry, fixedScale);\n    const fixedPolygon = largestPolygon(fixedGeometry);\n    if (fixedPolygon == null)\n      return;\n    const labelPlacement = preferredLabelCenter(fixedPolygon, {\n      aspectRatio,\n      precision: 1e-3\n    });\n    if (labelPlacement == null)\n      return;\n    const { x, y, maxWidth } = labelPlacement;\n    return { geometry, labelText, aspectRatio, x, y, maxWidth, fixedPolygon };\n  }\n  getLabelDatum(labelLayout, scaling) {\n    const { scale } = this;\n    if (scale == null)\n      return;\n    const { padding, label } = this.properties;\n    const { labelText, aspectRatio, x: untruncatedX, y, maxWidth, fixedPolygon } = labelLayout;\n    const maxSizeWithoutTruncation = {\n      width: Math.ceil(maxWidth * scaling),\n      height: Math.ceil(maxWidth * scaling / aspectRatio),\n      meta: untruncatedX\n    };\n    const labelFormatting = formatSingleLabel(\n      labelText,\n      label,\n      { padding },\n      (height, allowTruncation) => {\n        if (!allowTruncation)\n          return maxSizeWithoutTruncation;\n        const result = maxWidthInPolygonForRectOfHeight(fixedPolygon, untruncatedX, y, height / scaling);\n        return {\n          width: result.width * scaling,\n          height,\n          meta: result.x\n        };\n      }\n    );\n    if (labelFormatting == null)\n      return;\n    const [{ text, fontSize, lineHeight, width }, formattingX] = labelFormatting;\n    if (text === Text11.ellipsis)\n      return;\n    const x = width < maxSizeWithoutTruncation.width ? untruncatedX : formattingX;\n    const position = this.scale.convert(fixedScale.invert([x, y]));\n    return {\n      x: position[0],\n      y: position[1],\n      text,\n      fontSize,\n      lineHeight\n    };\n  }\n  async createNodeData() {\n    const { id: seriesId, dataModel, processedData, colorScale, properties, scale, previousLabelLayouts } = this;\n    const { idKey, colorKey, labelKey, label, fill: fillProperty } = properties;\n    if (dataModel == null || processedData == null)\n      return;\n    const scaling = scale != null ? (scale.range[1][0] - scale.range[0][0]) / scale.bounds.width : NaN;\n    const colorScaleValid = this.isColorScaleValid();\n    const idIdx = dataModel.resolveProcessedDataIndexById(this, `idValue`);\n    const featureIdx = dataModel.resolveProcessedDataIndexById(this, `featureValue`);\n    const labelIdx = labelKey != null ? dataModel.resolveProcessedDataIndexById(this, `labelValue`) : void 0;\n    const colorIdx = colorKey != null ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : void 0;\n    const font = label.getFont();\n    const labelLayouts = /* @__PURE__ */ new Map();\n    this.previousLabelLayouts = labelLayouts;\n    const nodeData = [];\n    const labelData = [];\n    const missingGeometries = [];\n    processedData.data.forEach(({ datum, values }) => {\n      const idValue = values[idIdx];\n      const colorValue = colorIdx != null ? values[colorIdx] : void 0;\n      const labelValue = labelIdx != null ? values[labelIdx] : void 0;\n      const geometry = values[featureIdx]?.geometry;\n      if (geometry == null) {\n        missingGeometries.push(idValue);\n      }\n      const color = colorScaleValid && colorValue != null ? colorScale.convert(colorValue) : void 0;\n      const labelLayout = this.getLabelLayout(\n        datum,\n        labelValue,\n        font,\n        geometry,\n        previousLabelLayouts?.get(idValue)\n      );\n      if (labelLayout != null) {\n        labelLayouts.set(idValue, labelLayout);\n      }\n      const labelDatum = labelLayout != null && scale != null ? this.getLabelDatum(labelLayout, scaling) : void 0;\n      if (labelDatum != null) {\n        labelData.push(labelDatum);\n      }\n      const projectedGeometry = geometry != null && scale != null ? projectGeometry(geometry, scale) : void 0;\n      nodeData.push({\n        series: this,\n        itemId: idKey,\n        datum,\n        idValue,\n        colorValue,\n        labelValue,\n        fill: color ?? fillProperty,\n        projectedGeometry\n      });\n    });\n    const missingGeometriesCap = 10;\n    if (missingGeometries.length > missingGeometriesCap) {\n      const excessItems = missingGeometries.length - missingGeometriesCap;\n      missingGeometries.length = missingGeometriesCap;\n      missingGeometries.push(`(+${excessItems} more)`);\n    }\n    if (missingGeometries.length > 0) {\n      Logger15.warnOnce(`some data items do not have matches in the provided topology`, missingGeometries);\n    }\n    return {\n      itemId: seriesId,\n      nodeData,\n      labelData\n    };\n  }\n  async updateSelections() {\n    if (this.nodeDataRefresh) {\n      this.contextNodeData = await this.createNodeData();\n      this.nodeDataRefresh = false;\n    }\n  }\n  async update() {\n    const { datumSelection, labelSelection, highlightDatumSelection } = this;\n    await this.updateSelections();\n    this.contentGroup.visible = this.visible;\n    this.contentGroup.opacity = this.getOpacity();\n    let highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();\n    if (highlightedDatum != null && (highlightedDatum.series !== this || highlightedDatum.datum == null)) {\n      highlightedDatum = void 0;\n    }\n    const nodeData = this.contextNodeData?.nodeData ?? [];\n    const labelData = this.contextNodeData?.labelData ?? [];\n    this.datumSelection = await this.updateDatumSelection({ nodeData, datumSelection });\n    await this.updateDatumNodes({ datumSelection, isHighlight: false });\n    this.labelSelection = await this.updateLabelSelection({ labelData, labelSelection });\n    await this.updateLabelNodes({ labelSelection });\n    this.highlightDatumSelection = await this.updateDatumSelection({\n      nodeData: highlightedDatum != null ? [highlightedDatum] : [],\n      datumSelection: highlightDatumSelection\n    });\n    await this.updateDatumNodes({ datumSelection: highlightDatumSelection, isHighlight: true });\n  }\n  async updateDatumSelection(opts) {\n    return opts.datumSelection.update(opts.nodeData, void 0, (datum) => createDatumId7(datum.idValue));\n  }\n  async updateDatumNodes(opts) {\n    const {\n      id: seriesId,\n      properties,\n      ctx: { callbackCache }\n    } = this;\n    const { datumSelection, isHighlight } = opts;\n    const { idKey, colorKey, labelKey, fillOpacity, stroke, strokeOpacity, lineDash, lineDashOffset, itemStyler } = properties;\n    const highlightStyle = isHighlight ? properties.highlightStyle.item : void 0;\n    const strokeWidth = this.getStrokeWidth(properties.strokeWidth);\n    datumSelection.each((geoGeometry, datum) => {\n      const { projectedGeometry } = datum;\n      if (projectedGeometry == null) {\n        geoGeometry.visible = false;\n        geoGeometry.projectedGeometry = void 0;\n        return;\n      }\n      let format;\n      if (itemStyler != null) {\n        format = callbackCache.call(itemStyler, {\n          seriesId,\n          datum: datum.datum,\n          idKey,\n          colorKey,\n          labelKey,\n          fill: datum.fill,\n          fillOpacity,\n          strokeOpacity,\n          stroke,\n          strokeWidth,\n          lineDash,\n          lineDashOffset,\n          highlighted: isHighlight\n        });\n      }\n      geoGeometry.visible = true;\n      geoGeometry.projectedGeometry = projectedGeometry;\n      geoGeometry.fill = highlightStyle?.fill ?? format?.fill ?? datum.fill;\n      geoGeometry.fillOpacity = highlightStyle?.fillOpacity ?? format?.fillOpacity ?? fillOpacity;\n      geoGeometry.stroke = highlightStyle?.stroke ?? format?.stroke ?? stroke;\n      geoGeometry.strokeWidth = highlightStyle?.strokeWidth ?? format?.strokeWidth ?? strokeWidth;\n      geoGeometry.strokeOpacity = highlightStyle?.strokeOpacity ?? format?.strokeOpacity ?? strokeOpacity;\n      geoGeometry.lineDash = highlightStyle?.lineDash ?? format?.lineDash ?? lineDash;\n      geoGeometry.lineDashOffset = highlightStyle?.lineDashOffset ?? format?.lineDashOffset ?? lineDashOffset;\n    });\n  }\n  async updateLabelSelection(opts) {\n    const labels = this.isLabelEnabled() ? opts.labelData : [];\n    return opts.labelSelection.update(labels);\n  }\n  async updateLabelNodes(opts) {\n    const { labelSelection } = opts;\n    const { color: fill, fontStyle, fontWeight, fontFamily } = this.properties.label;\n    labelSelection.each((label, { x, y, text, fontSize, lineHeight }) => {\n      label.visible = true;\n      label.x = x;\n      label.y = y;\n      label.text = text;\n      label.fill = fill;\n      label.fontStyle = fontStyle;\n      label.fontWeight = fontWeight;\n      label.fontSize = fontSize;\n      label.lineHeight = lineHeight;\n      label.fontFamily = fontFamily;\n      label.textAlign = \"center\";\n      label.textBaseline = \"middle\";\n    });\n  }\n  onLegendItemClick(event) {\n    const { legendItemName } = this.properties;\n    const { enabled, itemId, series } = event;\n    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;\n    if (series.id === this.id || matchedLegendItemName) {\n      this.toggleSeriesItem(itemId, enabled);\n    }\n  }\n  onLegendItemDoubleClick(event) {\n    const { enabled, itemId, series, numVisibleItems } = event;\n    const { legendItemName } = this.properties;\n    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;\n    if (series.id === this.id || matchedLegendItemName) {\n      this.toggleSeriesItem(itemId, true);\n    } else if (enabled && numVisibleItems === 1) {\n      this.toggleSeriesItem(itemId, true);\n    } else {\n      this.toggleSeriesItem(itemId, false);\n    }\n  }\n  resetAnimation() {\n  }\n  getLabelData() {\n    return [];\n  }\n  getSeriesDomain() {\n    return [NaN, NaN];\n  }\n  pickNodeClosestDatum({ x, y }) {\n    let minDistance = Infinity;\n    let minDatum;\n    this.datumSelection.each((node, datum) => {\n      const distance = node.distanceToPoint(x, y);\n      if (distance < minDistance) {\n        minDistance = distance;\n        minDatum = datum;\n      }\n    });\n    return minDatum != null ? { datum: minDatum, distance: minDistance } : void 0;\n  }\n  datumMidPoint(datum) {\n    const { _previousDatumMidPoint } = this;\n    if (_previousDatumMidPoint?.datum === datum) {\n      return _previousDatumMidPoint.point;\n    }\n    const projectedGeometry = datum.projectedGeometry;\n    const polygon = projectedGeometry != null ? largestPolygon(projectedGeometry) : void 0;\n    const center = polygon != null ? polygonMarkerCenter(polygon, 2) : void 0;\n    const point = center != null ? { x: center[0], y: center[1] } : void 0;\n    this._previousDatumMidPoint = { datum, point };\n    return point;\n  }\n  getLegendData(legendType) {\n    const { processedData, dataModel } = this;\n    if (processedData == null || dataModel == null)\n      return [];\n    const {\n      title,\n      legendItemName,\n      idKey,\n      idName,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      colorKey,\n      colorName,\n      colorRange,\n      visible\n    } = this.properties;\n    if (legendType === \"gradient\" && colorKey != null && colorRange != null) {\n      const colorDomain = processedData.domain.values[dataModel.resolveProcessedDataIndexById(this, \"colorValue\")];\n      const legendDatum = {\n        legendType: \"gradient\",\n        enabled: visible,\n        seriesId: this.id,\n        colorName,\n        colorRange,\n        colorDomain\n      };\n      return [legendDatum];\n    } else if (legendType === \"category\") {\n      const legendDatum = {\n        legendType: \"category\",\n        id: this.id,\n        itemId: legendItemName ?? title ?? idName ?? idKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: { text: legendItemName ?? title ?? idName ?? idKey },\n        symbols: [\n          {\n            marker: {\n              fill,\n              fillOpacity,\n              stroke,\n              strokeWidth,\n              strokeOpacity\n            }\n          }\n        ],\n        legendItemName\n      };\n      return [legendDatum];\n    } else {\n      return [];\n    }\n  }\n  getTooltipHtml(nodeDatum) {\n    const {\n      id: seriesId,\n      processedData,\n      ctx: { callbackCache },\n      properties\n    } = this;\n    if (!processedData || !properties.isValid()) {\n      return ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.EMPTY_TOOLTIP_CONTENT;\n    }\n    const {\n      legendItemName,\n      idKey,\n      idName,\n      colorKey,\n      colorName,\n      labelKey,\n      labelName,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      fillOpacity,\n      lineDash,\n      lineDashOffset,\n      itemStyler,\n      tooltip\n    } = properties;\n    const { datum, fill, idValue, colorValue, labelValue, itemId } = nodeDatum;\n    const title = sanitizeHtml7(properties.title ?? legendItemName) ?? \"\";\n    const contentLines = [];\n    contentLines.push(sanitizeHtml7((idName != null ? `${idName}: ` : \"\") + idValue));\n    if (colorValue != null) {\n      contentLines.push(sanitizeHtml7((colorName ?? colorKey) + \": \" + colorValue));\n    }\n    if (labelValue != null && labelKey !== idKey) {\n      contentLines.push(sanitizeHtml7((labelName ?? labelKey) + \": \" + labelValue));\n    }\n    const content = contentLines.join(\"<br>\");\n    let format;\n    if (itemStyler) {\n      format = callbackCache.call(itemStyler, {\n        seriesId,\n        datum,\n        idKey,\n        colorKey,\n        labelKey,\n        fill,\n        stroke,\n        strokeWidth: this.getStrokeWidth(strokeWidth),\n        highlighted: false,\n        fillOpacity,\n        strokeOpacity,\n        lineDash,\n        lineDashOffset\n      });\n    }\n    const color = format?.fill ?? fill;\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        seriesId,\n        datum,\n        idKey,\n        title,\n        color,\n        colorKey,\n        colorName,\n        idName,\n        itemId,\n        labelKey,\n        labelName,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  computeFocusBounds(opts) {\n    return findFocusedGeoGeometry(this, opts);\n  }\n};\nMapShapeSeries.className = \"MapShapeSeries\";\nMapShapeSeries.type = \"map-shape\";\n__decorateClass([\n  Validate49(GEOJSON_OBJECT, { optional: true, property: \"topology\" })\n], MapShapeSeries.prototype, \"_chartTopology\", 2);\n\n// packages/ag-charts-enterprise/src/series/map-shape/mapShapeModule.ts\nvar {\n  DEFAULT_INVERTED_LABEL_COLOUR,\n  DEFAULT_DIVERGING_SERIES_COLOUR_RANGE: DEFAULT_DIVERGING_SERIES_COLOUR_RANGE3,\n  DEFAULT_BACKGROUND_COLOUR: DEFAULT_BACKGROUND_COLOUR2,\n  singleSeriesPaletteFactory: singleSeriesPaletteFactory3\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme;\nvar MapShapeModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"topology\"],\n  identifier: \"map-shape\",\n  instanceConstructor: MapShapeSeries,\n  tooltipDefaults: { range: \"exact\" },\n  themeTemplate: {\n    ...MAP_THEME_DEFAULTS,\n    series: {\n      fillOpacity: 1,\n      strokeWidth: 1,\n      lineDash: [0],\n      lineDashOffset: 0,\n      padding: 2,\n      label: {\n        color: DEFAULT_INVERTED_LABEL_COLOUR,\n        fontWeight: \"bold\",\n        overflowStrategy: \"hide\"\n      }\n    }\n  },\n  paletteFactory: (opts) => {\n    const { takeColors, colorsCount, userPalette, themeTemplateParameters } = opts;\n    const { fill } = singleSeriesPaletteFactory3(opts);\n    const defaultColorRange = themeTemplateParameters.get(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE3);\n    const { fills } = takeColors(colorsCount);\n    return {\n      fill,\n      stroke: themeTemplateParameters.get(DEFAULT_BACKGROUND_COLOUR2),\n      colorRange: userPalette === \"inbuilt\" ? defaultColorRange : [fills[0], fills[1]]\n    };\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/nightingale/nightingaleModule.ts\n\n\n// packages/ag-charts-enterprise/src/series/nightingale/nightingaleSeries.ts\n\n\n// packages/ag-charts-enterprise/src/series/radial-column/radialColumnSeriesBase.ts\n\nvar {\n  isDefined: isDefined3,\n  ChartAxisDirection: ChartAxisDirection15,\n  PolarAxis,\n  diff: diff4,\n  fixNumericExtent: fixNumericExtent4,\n  groupAccumulativeValueProperty: groupAccumulativeValueProperty2,\n  keyProperty: keyProperty5,\n  mergeDefaults: mergeDefaults6,\n  normaliseGroupTo,\n  resetLabelFn,\n  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation2,\n  seriesLabelFadeOutAnimation,\n  valueProperty: valueProperty11,\n  animationValidation: animationValidation4,\n  isFiniteNumber: isFiniteNumber5,\n  SeriesNodePickMode: SeriesNodePickMode10\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { BandScale: BandScale3 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scale;\nvar { motion: motion3 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar { isNumber, normalizeAngle360: normalizeAngle3606, sanitizeHtml: sanitizeHtml8 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar RadialColumnSeriesNodeEvent = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.angleKey = series.properties.angleKey;\n    this.radiusKey = series.properties.radiusKey;\n  }\n};\nvar RadialColumnSeriesBase = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.PolarSeries {\n  constructor(moduleCtx, {\n    animationResetFns\n  }) {\n    super({\n      moduleCtx,\n      useLabelLayer: true,\n      canHaveAxes: true,\n      pickModes: [SeriesNodePickMode10.NEAREST_NODE, SeriesNodePickMode10.EXACT_SHAPE_MATCH],\n      animationResetFns: {\n        ...animationResetFns,\n        label: resetLabelFn\n      }\n    });\n    this.NodeEvent = RadialColumnSeriesNodeEvent;\n    this.groupScale = new BandScale3();\n    this.circleCache = { r: 0, cx: 0, cy: 0 };\n  }\n  addChartEventListeners() {\n    this.destroyFns.push(\n      this.ctx.chartEventManager?.addListener(\"legend-item-click\", (event) => this.onLegendItemClick(event)),\n      this.ctx.chartEventManager?.addListener(\n        \"legend-item-double-click\",\n        (event) => this.onLegendItemDoubleClick(event)\n      )\n    );\n  }\n  getSeriesDomain(direction) {\n    const { axes, dataModel, processedData } = this;\n    if (!processedData || !dataModel)\n      return [];\n    if (direction === ChartAxisDirection15.X) {\n      return dataModel.getDomain(this, \"angleValue\", \"key\", processedData);\n    } else {\n      const radiusAxis = axes[ChartAxisDirection15.Y];\n      const yExtent = dataModel.getDomain(this, \"radiusValue-end\", \"value\", processedData);\n      const fixedYExtent = [yExtent[0] > 0 ? 0 : yExtent[0], yExtent[1] < 0 ? 0 : yExtent[1]];\n      return fixNumericExtent4(fixedYExtent, radiusAxis);\n    }\n  }\n  async processData(dataController) {\n    const { angleKey, radiusKey, normalizedTo, visible } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    if (!this.properties.isValid() || !(visible || animationEnabled))\n      return;\n    const stackGroupId = this.getStackId();\n    const stackGroupTrailingId = `${stackGroupId}-trailing`;\n    const extraProps = [];\n    if (isDefined3(normalizedTo)) {\n      extraProps.push(normaliseGroupTo([stackGroupId, stackGroupTrailingId], Math.abs(normalizedTo), \"range\"));\n    }\n    if (animationEnabled && this.processedData) {\n      extraProps.push(diff4(this.processedData));\n    }\n    if (animationEnabled) {\n      extraProps.push(animationValidation4());\n    }\n    const visibleProps = visible || !animationEnabled ? {} : { forceValue: 0 };\n    const radiusScaleType = this.axes[ChartAxisDirection15.Y]?.scale.type;\n    const angleScaleType = this.axes[ChartAxisDirection15.X]?.scale.type;\n    await this.requestDataModel(dataController, this.data, {\n      props: [\n        keyProperty5(angleKey, angleScaleType, { id: \"angleValue\" }),\n        valueProperty11(radiusKey, radiusScaleType, {\n          id: \"radiusValue-raw\",\n          invalidValue: null,\n          ...visibleProps\n        }),\n        ...groupAccumulativeValueProperty2(\n          radiusKey,\n          \"normal\",\n          \"current\",\n          {\n            id: `radiusValue-end`,\n            rangeId: `radiusValue-range`,\n            invalidValue: null,\n            groupId: stackGroupId,\n            separateNegative: true,\n            ...visibleProps\n          },\n          radiusScaleType\n        ),\n        ...groupAccumulativeValueProperty2(\n          radiusKey,\n          \"trailing\",\n          \"current\",\n          {\n            id: `radiusValue-start`,\n            invalidValue: null,\n            groupId: stackGroupTrailingId,\n            separateNegative: true,\n            ...visibleProps\n          },\n          radiusScaleType\n        ),\n        ...extraProps\n      ]\n    });\n    this.animationState.transition(\"updateData\");\n  }\n  didCircleChange() {\n    const r = this.radius;\n    const cx = this.centerX;\n    const cy = this.centerY;\n    const cache = this.circleCache;\n    if (!(r === cache.r && cx === cache.cx && cy === cache.cy)) {\n      this.circleCache = { r, cx, cy };\n      return true;\n    }\n    return false;\n  }\n  isRadiusAxisReversed() {\n    return this.axes[ChartAxisDirection15.Y]?.isReversed();\n  }\n  async maybeRefreshNodeData() {\n    const circleChanged = this.didCircleChange();\n    if (!circleChanged && !this.nodeDataRefresh)\n      return;\n    const { nodeData = [] } = await this.createNodeData() ?? {};\n    this.nodeData = nodeData;\n    this.nodeDataRefresh = false;\n  }\n  getAxisInnerRadius() {\n    const radiusAxis = this.axes[ChartAxisDirection15.Y];\n    return radiusAxis instanceof PolarAxis ? this.radius * radiusAxis.innerRadiusRatio : 0;\n  }\n  async createNodeData() {\n    const { processedData, dataModel, groupScale } = this;\n    if (!processedData || !dataModel || !this.properties.isValid()) {\n      return;\n    }\n    const angleAxis = this.axes[ChartAxisDirection15.X];\n    const radiusAxis = this.axes[ChartAxisDirection15.Y];\n    const angleScale = angleAxis?.scale;\n    const radiusScale = radiusAxis?.scale;\n    if (!angleScale || !radiusScale) {\n      return;\n    }\n    const radiusStartIndex = dataModel.resolveProcessedDataIndexById(this, `radiusValue-start`);\n    const radiusEndIndex = dataModel.resolveProcessedDataIndexById(this, `radiusValue-end`);\n    const radiusRangeIndex = dataModel.resolveProcessedDataIndexById(this, `radiusValue-range`);\n    const radiusRawIndex = dataModel.resolveProcessedDataIndexById(this, `radiusValue-raw`);\n    let groupPaddingInner = 0;\n    let groupPaddingOuter = 0;\n    if (angleAxis instanceof AngleCategoryAxis) {\n      groupPaddingInner = angleAxis.groupPaddingInner;\n      groupPaddingOuter = angleAxis.paddingInner;\n    }\n    const groupAngleStep = angleScale.bandwidth ?? 0;\n    const paddedGroupAngleStep = groupAngleStep * (1 - groupPaddingOuter);\n    const { index: groupIndex, visibleGroupCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);\n    groupScale.domain = Array.from({ length: visibleGroupCount }).map((_, i) => String(i));\n    groupScale.range = [-paddedGroupAngleStep / 2, paddedGroupAngleStep / 2];\n    groupScale.paddingInner = visibleGroupCount > 1 ? groupPaddingInner : 0;\n    const radiusAxisReversed = this.isRadiusAxisReversed();\n    const axisInnerRadius = radiusAxisReversed ? this.radius : this.getAxisInnerRadius();\n    const axisOuterRadius = radiusAxisReversed ? this.getAxisInnerRadius() : this.radius;\n    const axisTotalRadius = axisOuterRadius + axisInnerRadius;\n    const { angleKey, radiusKey, angleName, radiusName, label } = this.properties;\n    const getLabelNodeDatum = (datum, radiusDatum, x, y) => {\n      const labelText = this.getLabelText(\n        label,\n        { value: radiusDatum, datum, angleKey, radiusKey, angleName, radiusName },\n        (value) => isFiniteNumber5(value) ? value.toFixed(2) : String(value)\n      );\n      if (labelText) {\n        return { x, y, text: labelText, textAlign: \"center\", textBaseline: \"middle\" };\n      }\n    };\n    const nodeData = [];\n    const context = { itemId: radiusKey, nodeData, labelData: nodeData };\n    if (!this.visible)\n      return context;\n    processedData.data.forEach((group, index, data) => {\n      const { datum, keys, values, aggValues } = group;\n      const angleDatum = keys[0];\n      const radiusDatum = values[radiusRawIndex];\n      const isPositive = radiusDatum >= 0 && !Object.is(radiusDatum, -0);\n      const innerRadiusDatum = values[radiusStartIndex];\n      const outerRadiusDatum = values[radiusEndIndex];\n      const radiusRange = aggValues?.[radiusRangeIndex][isPositive ? 1 : 0] ?? 0;\n      const negative = isPositive === radiusAxisReversed;\n      if (innerRadiusDatum === void 0 || outerRadiusDatum === void 0) {\n        return;\n      }\n      let startAngle;\n      let endAngle;\n      if (data.length === 1) {\n        startAngle = -0.5 * Math.PI;\n        endAngle = 1.5 * Math.PI;\n      } else {\n        let groupAngle = angleScale.convert(angleDatum);\n        if (visibleGroupCount === 1) {\n          groupAngle -= groupScale.bandwidth / 2;\n        }\n        startAngle = normalizeAngle3606(groupAngle + groupScale.convert(String(groupIndex)));\n        endAngle = normalizeAngle3606(startAngle + groupScale.bandwidth);\n      }\n      const angle = startAngle + groupScale.bandwidth / 2;\n      const innerRadius = axisTotalRadius - radiusScale.convert(innerRadiusDatum);\n      const outerRadius = axisTotalRadius - radiusScale.convert(outerRadiusDatum);\n      const midRadius = (innerRadius + outerRadius) / 2;\n      const stackInnerRadius = axisTotalRadius - radiusScale.convert(0);\n      const stackOuterRadius = axisTotalRadius - radiusScale.convert(radiusRange);\n      const x = Math.cos(angle) * midRadius;\n      const y = Math.sin(angle) * midRadius;\n      const labelNodeDatum = this.properties.label.enabled ? getLabelNodeDatum(datum, radiusDatum, x, y) : void 0;\n      const columnWidth = this.getColumnWidth(startAngle, endAngle);\n      nodeData.push({\n        series: this,\n        datum,\n        point: { x, y, size: 0 },\n        midPoint: { x, y },\n        label: labelNodeDatum,\n        angleValue: angleDatum,\n        radiusValue: radiusDatum,\n        negative,\n        innerRadius,\n        outerRadius,\n        stackInnerRadius,\n        stackOuterRadius,\n        startAngle,\n        endAngle,\n        axisInnerRadius,\n        axisOuterRadius,\n        columnWidth,\n        index\n      });\n    });\n    return { itemId: radiusKey, nodeData, labelData: nodeData };\n  }\n  getColumnWidth(_startAngle, _endAngle) {\n    return NaN;\n  }\n  async update({ seriesRect }) {\n    const resize = this.checkResize(seriesRect);\n    await this.maybeRefreshNodeData();\n    this.contentGroup.translationX = this.centerX;\n    this.contentGroup.translationY = this.centerY;\n    this.highlightGroup.translationX = this.centerX;\n    this.highlightGroup.translationY = this.centerY;\n    if (this.labelGroup) {\n      this.labelGroup.translationX = this.centerX;\n      this.labelGroup.translationY = this.centerY;\n    }\n    this.updateSectorSelection(this.itemSelection, false);\n    this.updateSectorSelection(this.highlightSelection, true);\n    this.updateLabels();\n    if (resize) {\n      this.animationState.transition(\"resize\");\n    }\n    this.animationState.transition(\"update\");\n  }\n  updateSectorSelection(selection, highlighted) {\n    let selectionData = [];\n    if (highlighted) {\n      const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();\n      if (activeHighlight?.datum && activeHighlight.series === this) {\n        selectionData = [activeHighlight];\n      }\n    } else {\n      selectionData = this.nodeData;\n    }\n    const {\n      fill,\n      fillOpacity,\n      stroke,\n      strokeOpacity,\n      strokeWidth,\n      lineDash,\n      lineDashOffset,\n      cornerRadius,\n      angleKey,\n      radiusKey\n    } = mergeDefaults6(highlighted ? this.properties.highlightStyle.item : null, this.properties);\n    const idFn = (datum) => datum.angleValue;\n    selection.update(selectionData, void 0, idFn).each((node, datum) => {\n      const format = this.properties.itemStyler ? this.ctx.callbackCache.call(this.properties.itemStyler, {\n        datum: datum.datum,\n        fill,\n        fillOpacity,\n        stroke,\n        strokeWidth,\n        strokeOpacity,\n        lineDash,\n        lineDashOffset,\n        cornerRadius,\n        highlighted,\n        angleKey,\n        radiusKey,\n        seriesId: this.id\n      }) : void 0;\n      this.updateItemPath(node, datum, highlighted, format);\n      node.fill = format?.fill ?? fill;\n      node.fillOpacity = format?.fillOpacity ?? fillOpacity;\n      node.stroke = format?.stroke ?? stroke;\n      node.strokeWidth = format?.strokeWidth ?? strokeWidth;\n      node.strokeOpacity = format?.strokeOpacity ?? strokeOpacity;\n      node.lineDash = format?.lineDash ?? lineDash;\n      node.lineDashOffset = format?.lineDashOffset ?? lineDashOffset;\n      node.cornerRadius = format?.cornerRadius ?? cornerRadius;\n      node.lineJoin = \"round\";\n    });\n  }\n  updateLabels() {\n    const { label } = this.properties;\n    this.labelSelection.update(this.nodeData).each((node, datum) => {\n      if (label.enabled && datum.label) {\n        node.x = datum.label.x;\n        node.y = datum.label.y;\n        node.fill = label.color;\n        node.fontFamily = label.fontFamily;\n        node.fontSize = label.fontSize;\n        node.fontStyle = label.fontStyle;\n        node.fontWeight = label.fontWeight;\n        node.text = datum.label.text;\n        node.textAlign = datum.label.textAlign;\n        node.textBaseline = datum.label.textBaseline;\n        node.visible = true;\n      } else {\n        node.visible = false;\n      }\n    });\n  }\n  animateEmptyUpdateReady() {\n    const { labelSelection } = this;\n    const fns = this.getColumnTransitionFunctions();\n    motion3.fromToMotion(this.id, \"datums\", this.ctx.animationManager, [this.itemSelection], fns);\n    seriesLabelFadeInAnimation2(this, \"labels\", this.ctx.animationManager, labelSelection);\n  }\n  animateClearingUpdateEmpty() {\n    const { itemSelection } = this;\n    const { animationManager } = this.ctx;\n    const fns = this.getColumnTransitionFunctions();\n    motion3.fromToMotion(this.id, \"datums\", animationManager, [itemSelection], fns);\n    seriesLabelFadeOutAnimation(this, \"labels\", animationManager, this.labelSelection);\n  }\n  getTooltipHtml(nodeDatum) {\n    const { id: seriesId, axes, dataModel } = this;\n    const {\n      angleKey,\n      radiusKey,\n      angleName,\n      radiusName,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      cornerRadius,\n      itemStyler,\n      tooltip\n    } = this.properties;\n    const { angleValue, radiusValue, datum, itemId } = nodeDatum;\n    const xAxis = axes[ChartAxisDirection15.X];\n    const yAxis = axes[ChartAxisDirection15.Y];\n    if (!this.properties.isValid() || !(xAxis && yAxis && isNumber(radiusValue)) || !dataModel) {\n      return ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.EMPTY_TOOLTIP_CONTENT;\n    }\n    const angleString = xAxis.formatDatum(angleValue);\n    const radiusString = yAxis.formatDatum(radiusValue);\n    const title = sanitizeHtml8(radiusName);\n    const content = sanitizeHtml8(`${angleString}: ${radiusString}`);\n    const { fill: color } = (itemStyler && this.ctx.callbackCache.call(itemStyler, {\n      highlighted: false,\n      seriesId,\n      datum,\n      angleKey,\n      radiusKey,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      cornerRadius\n    })) ?? { fill };\n    return tooltip.toTooltipHtml(\n      { title, backgroundColor: fill, content },\n      {\n        seriesId,\n        datum,\n        color,\n        title,\n        angleKey,\n        radiusKey,\n        angleName,\n        radiusName,\n        angleValue,\n        itemId,\n        radiusValue\n      }\n    );\n  }\n  pickNodeClosestDatum(point) {\n    return this.pickNodeNearestDistantObject(point, this.itemSelection.nodes());\n  }\n  getLegendData(legendType) {\n    if (!this.data?.length || !this.properties.isValid() || legendType !== \"category\") {\n      return [];\n    }\n    const { radiusKey, radiusName, fill, stroke, fillOpacity, strokeOpacity, strokeWidth, visible } = this.properties;\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: radiusKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: radiusName ?? radiusKey\n        },\n        symbols: [\n          {\n            marker: {\n              fill: fill ?? \"rgba(0, 0, 0, 0)\",\n              stroke: stroke ?? \"rgba(0, 0, 0, 0)\",\n              fillOpacity: fillOpacity ?? 1,\n              strokeOpacity: strokeOpacity ?? 1,\n              strokeWidth\n            }\n          }\n        ]\n      }\n    ];\n  }\n  onLegendItemClick(event) {\n    const { enabled, itemId, series } = event;\n    if (series.id === this.id) {\n      this.toggleSeriesItem(itemId, enabled);\n    }\n  }\n  onLegendItemDoubleClick(event) {\n    const { enabled, itemId, series, numVisibleItems } = event;\n    const wasClicked = series.id === this.id;\n    const newEnabled = wasClicked || enabled && numVisibleItems === 1;\n    this.toggleSeriesItem(itemId, newEnabled);\n  }\n  computeLabelsBBox() {\n    return null;\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/radial-column/radialColumnSeriesBaseProperties.ts\n\nvar { Label: Label7 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar {\n  SeriesProperties: SeriesProperties7,\n  SeriesTooltip: SeriesTooltip11,\n  Validate: Validate50,\n  COLOR_STRING: COLOR_STRING16,\n  DEGREE: DEGREE3,\n  FUNCTION: FUNCTION12,\n  LINE_DASH: LINE_DASH13,\n  NUMBER: NUMBER12,\n  OBJECT: OBJECT20,\n  POSITIVE_NUMBER: POSITIVE_NUMBER20,\n  RATIO: RATIO21,\n  STRING: STRING20\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar RadialColumnSeriesBaseProperties = class extends SeriesProperties7 {\n  constructor() {\n    super(...arguments);\n    this.fill = \"black\";\n    this.fillOpacity = 1;\n    this.stroke = \"black\";\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.rotation = 0;\n    this.label = new Label7();\n    this.tooltip = new SeriesTooltip11();\n  }\n};\n__decorateClass([\n  Validate50(STRING20)\n], RadialColumnSeriesBaseProperties.prototype, \"angleKey\", 2);\n__decorateClass([\n  Validate50(STRING20, { optional: true })\n], RadialColumnSeriesBaseProperties.prototype, \"angleName\", 2);\n__decorateClass([\n  Validate50(STRING20)\n], RadialColumnSeriesBaseProperties.prototype, \"radiusKey\", 2);\n__decorateClass([\n  Validate50(STRING20, { optional: true })\n], RadialColumnSeriesBaseProperties.prototype, \"radiusName\", 2);\n__decorateClass([\n  Validate50(COLOR_STRING16)\n], RadialColumnSeriesBaseProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate50(RATIO21)\n], RadialColumnSeriesBaseProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate50(COLOR_STRING16)\n], RadialColumnSeriesBaseProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate50(POSITIVE_NUMBER20)\n], RadialColumnSeriesBaseProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate50(RATIO21)\n], RadialColumnSeriesBaseProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate50(LINE_DASH13)\n], RadialColumnSeriesBaseProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate50(POSITIVE_NUMBER20)\n], RadialColumnSeriesBaseProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate50(POSITIVE_NUMBER20)\n], RadialColumnSeriesBaseProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate50(FUNCTION12, { optional: true })\n], RadialColumnSeriesBaseProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate50(DEGREE3)\n], RadialColumnSeriesBaseProperties.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate50(STRING20, { optional: true })\n], RadialColumnSeriesBaseProperties.prototype, \"stackGroup\", 2);\n__decorateClass([\n  Validate50(NUMBER12, { optional: true })\n], RadialColumnSeriesBaseProperties.prototype, \"normalizedTo\", 2);\n__decorateClass([\n  Validate50(OBJECT20)\n], RadialColumnSeriesBaseProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate50(OBJECT20)\n], RadialColumnSeriesBaseProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-enterprise/src/series/nightingale/nightingaleUtil.ts\n\n\n// packages/ag-charts-enterprise/src/series/radial-column/radialColumnUtil.ts\n\nvar { motion: motion4 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nfunction createAngleMotionCalculator() {\n  const angles = {\n    startAngle: /* @__PURE__ */ new Map(),\n    endAngle: /* @__PURE__ */ new Map()\n  };\n  const angleKeys = [\"startAngle\", \"endAngle\"];\n  const calculate = (node, datum, status) => {\n    angleKeys.forEach((key) => {\n      const map = angles[key];\n      let from2 = (status === \"removed\" || status === \"updated\" ? node : datum)[key];\n      let to2 = (status === \"removed\" ? node : datum)[key];\n      if (isNaN(to2)) {\n        to2 = node.previousDatum?.[key] ?? NaN;\n      }\n      const diff8 = from2 - to2;\n      if (Math.abs(diff8) > Math.PI) {\n        from2 -= Math.sign(diff8) * 2 * Math.PI;\n      }\n      map.set(datum, { from: from2, to: to2 });\n    });\n  };\n  const getAngles = (datum, fromToKey) => {\n    return {\n      startAngle: angles.startAngle.get(datum)[fromToKey],\n      endAngle: angles.endAngle.get(datum)[fromToKey]\n    };\n  };\n  const from = (datum) => getAngles(datum, \"from\");\n  const to = (datum) => getAngles(datum, \"to\");\n  return { calculate, from, to };\n}\nfunction fixRadialColumnAnimationStatus(node, datum, status) {\n  if (status === \"updated\") {\n    if (node.previousDatum == null || isNaN(node.previousDatum.startAngle) || isNaN(node.previousDatum.endAngle)) {\n      return \"added\";\n    }\n    if (isNaN(datum.startAngle) || isNaN(datum.endAngle)) {\n      return \"removed\";\n    }\n  }\n  if (status === \"added\" && node.previousDatum != null) {\n    return \"updated\";\n  }\n  return status;\n}\nfunction prepareRadialColumnAnimationFunctions(axisZeroRadius) {\n  const angles = createAngleMotionCalculator();\n  const fromFn = (node, datum, status) => {\n    status = fixRadialColumnAnimationStatus(node, datum, status);\n    angles.calculate(node, datum, status);\n    const { startAngle, endAngle } = angles.from(datum);\n    let innerRadius;\n    let outerRadius;\n    let columnWidth;\n    let axisInnerRadius;\n    let axisOuterRadius;\n    if (status === \"removed\" || status === \"updated\") {\n      innerRadius = node.innerRadius;\n      outerRadius = node.outerRadius;\n      columnWidth = node.columnWidth;\n      axisInnerRadius = node.axisInnerRadius;\n      axisOuterRadius = node.axisOuterRadius;\n    } else {\n      innerRadius = axisZeroRadius;\n      outerRadius = axisZeroRadius;\n      columnWidth = datum.columnWidth;\n      axisInnerRadius = datum.axisInnerRadius;\n      axisOuterRadius = datum.axisOuterRadius;\n    }\n    const phase = motion4.NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];\n    return {\n      innerRadius,\n      outerRadius,\n      columnWidth,\n      axisInnerRadius,\n      axisOuterRadius,\n      startAngle,\n      endAngle,\n      phase\n    };\n  };\n  const toFn = (node, datum, status) => {\n    const { startAngle, endAngle } = angles.to(datum);\n    let innerRadius;\n    let outerRadius;\n    let columnWidth;\n    let axisInnerRadius;\n    let axisOuterRadius;\n    if (status === \"removed\") {\n      innerRadius = node.innerRadius;\n      outerRadius = node.innerRadius;\n      columnWidth = node.columnWidth;\n      axisInnerRadius = node.axisInnerRadius;\n      axisOuterRadius = node.axisOuterRadius;\n    } else {\n      innerRadius = isNaN(datum.innerRadius) ? axisZeroRadius : datum.innerRadius;\n      outerRadius = isNaN(datum.outerRadius) ? axisZeroRadius : datum.outerRadius;\n      columnWidth = isNaN(datum.columnWidth) ? node.columnWidth : datum.columnWidth;\n      axisInnerRadius = datum.axisInnerRadius;\n      axisOuterRadius = datum.axisOuterRadius;\n    }\n    return { innerRadius, outerRadius, columnWidth, axisInnerRadius, axisOuterRadius, startAngle, endAngle };\n  };\n  return { toFn, fromFn };\n}\nfunction resetRadialColumnSelectionFn(_node, {\n  innerRadius,\n  outerRadius,\n  columnWidth,\n  axisInnerRadius,\n  axisOuterRadius,\n  startAngle,\n  endAngle\n}) {\n  return { innerRadius, outerRadius, columnWidth, axisInnerRadius, axisOuterRadius, startAngle, endAngle };\n}\n\n// packages/ag-charts-enterprise/src/series/nightingale/nightingaleUtil.ts\nvar { SectorBox, motion: motion5 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nfunction getRadii(datum) {\n  const { negative, innerRadius, outerRadius, stackInnerRadius, stackOuterRadius } = datum;\n  return {\n    innerRadius: negative ? stackOuterRadius : stackInnerRadius,\n    outerRadius: negative ? stackInnerRadius : stackOuterRadius,\n    clipInnerRadius: negative ? outerRadius : innerRadius,\n    clipOuterRadius: negative ? innerRadius : outerRadius\n  };\n}\nfunction prepareNightingaleAnimationFunctions(axisZeroRadius) {\n  const angles = createAngleMotionCalculator();\n  const fromFn = (sect, datum, status) => {\n    status = fixRadialColumnAnimationStatus(sect, datum, status);\n    angles.calculate(sect, datum, status);\n    const { startAngle, endAngle } = angles.from(datum);\n    let innerRadius;\n    let outerRadius;\n    let clipSector;\n    if (status === \"removed\" || status === \"updated\") {\n      innerRadius = sect.innerRadius;\n      outerRadius = sect.outerRadius;\n      clipSector = sect.clipSector;\n    } else {\n      innerRadius = axisZeroRadius;\n      outerRadius = axisZeroRadius;\n    }\n    clipSector ?? (clipSector = new SectorBox(startAngle, endAngle, innerRadius, outerRadius));\n    const phase = motion5.NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];\n    return { innerRadius, outerRadius, startAngle, endAngle, clipSector, phase };\n  };\n  const toFn = (_sect, datum, status) => {\n    const { startAngle, endAngle } = angles.to(datum);\n    let innerRadius;\n    let outerRadius;\n    let clipSector;\n    if (status === \"removed\") {\n      innerRadius = axisZeroRadius;\n      outerRadius = axisZeroRadius;\n      clipSector = new SectorBox(startAngle, endAngle, innerRadius, outerRadius);\n    } else {\n      let clipInnerRadius, clipOuterRadius;\n      ({ innerRadius, outerRadius, clipInnerRadius, clipOuterRadius } = getRadii(datum));\n      if (isNaN(innerRadius))\n        innerRadius = axisZeroRadius;\n      if (isNaN(outerRadius))\n        outerRadius = axisZeroRadius;\n      if (isNaN(clipInnerRadius))\n        clipInnerRadius = axisZeroRadius;\n      if (isNaN(clipOuterRadius))\n        clipOuterRadius = axisZeroRadius;\n      clipSector = new SectorBox(startAngle, endAngle, clipInnerRadius, clipOuterRadius);\n    }\n    return { innerRadius, outerRadius, startAngle, endAngle, clipSector };\n  };\n  return { toFn, fromFn };\n}\nfunction resetNightingaleSelectionFn(_sect, datum) {\n  const { startAngle, endAngle } = datum;\n  const { innerRadius, outerRadius, clipInnerRadius, clipOuterRadius } = getRadii(datum);\n  const clipSector = new SectorBox(startAngle, endAngle, clipInnerRadius, clipOuterRadius);\n  return { innerRadius, outerRadius, startAngle, endAngle, clipSector };\n}\n\n// packages/ag-charts-enterprise/src/series/nightingale/nightingaleSeries.ts\nvar { Sector: Sector4, SectorBox: SectorBox2 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar NightingaleSeries = class extends RadialColumnSeriesBase {\n  // TODO: Enable once the options contract has been revisited\n  // @Validate(POSITIVE_NUMBER)\n  // sectorSpacing = 1;\n  constructor(moduleCtx) {\n    super(moduleCtx, { animationResetFns: { item: resetNightingaleSelectionFn } });\n    this.properties = new RadialColumnSeriesBaseProperties();\n  }\n  getStackId() {\n    const groupIndex = this.seriesGrouping?.groupIndex ?? this.id;\n    return `nightingale-stack-${groupIndex}-yValues`;\n  }\n  nodeFactory() {\n    return new Sector4();\n  }\n  updateItemPath(node, datum, highlight, _format) {\n    const { negative } = datum;\n    node.centerX = 0;\n    node.centerY = 0;\n    node.startOuterCornerRadius = !negative ? this.properties.cornerRadius : 0;\n    node.endOuterCornerRadius = !negative ? this.properties.cornerRadius : 0;\n    node.startInnerCornerRadius = negative ? this.properties.cornerRadius : 0;\n    node.endInnerCornerRadius = negative ? this.properties.cornerRadius : 0;\n    if (highlight) {\n      const { startAngle, endAngle } = datum;\n      const { innerRadius, outerRadius, clipInnerRadius, clipOuterRadius } = getRadii(datum);\n      node.innerRadius = innerRadius;\n      node.outerRadius = outerRadius;\n      node.startAngle = startAngle;\n      node.endAngle = endAngle;\n      node.clipSector = new SectorBox2(startAngle, endAngle, clipInnerRadius, clipOuterRadius);\n    }\n  }\n  getColumnTransitionFunctions() {\n    const axisZeroRadius = this.isRadiusAxisReversed() ? this.radius : this.getAxisInnerRadius();\n    return prepareNightingaleAnimationFunctions(axisZeroRadius);\n  }\n};\nNightingaleSeries.className = \"NightingaleSeries\";\nNightingaleSeries.type = \"nightingale\";\n\n// packages/ag-charts-enterprise/src/series/nightingale/nightingaleThemes.ts\n\nvar NIGHTINGALE_SERIES_THEME = {\n  series: {\n    strokeWidth: 1,\n    label: {\n      enabled: false,\n      fontSize: 12,\n      fontFamily: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_FONT_FAMILY,\n      color: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_LABEL_COLOUR\n    }\n  },\n  axes: {\n    [ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POLAR_AXIS_TYPE.ANGLE_CATEGORY]: {\n      shape: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POLAR_AXIS_SHAPE.CIRCLE,\n      groupPaddingInner: 0,\n      paddingInner: 0,\n      label: {\n        padding: 10\n      }\n    },\n    [ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POLAR_AXIS_TYPE.RADIUS_NUMBER]: {\n      shape: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POLAR_AXIS_SHAPE.CIRCLE\n    }\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/nightingale/nightingaleModule.ts\nvar NightingaleModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"polar\"],\n  identifier: \"nightingale\",\n  instanceConstructor: NightingaleSeries,\n  tooltipDefaults: { range: \"exact\" },\n  defaultAxes: [\n    {\n      type: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POLAR_AXIS_TYPE.ANGLE_CATEGORY\n    },\n    {\n      type: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POLAR_AXIS_TYPE.RADIUS_NUMBER\n    }\n  ],\n  themeTemplate: NIGHTINGALE_SERIES_THEME,\n  paletteFactory({ takeColors, userPalette }) {\n    const {\n      fills: [fill],\n      strokes: [stroke]\n    } = takeColors(1);\n    return {\n      fill,\n      stroke: userPalette !== \"inbuilt\" ? stroke : ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_POLAR_SERIES_STROKE\n    };\n  },\n  stackable: true,\n  groupable: true,\n  stackedByDefault: true\n};\n\n// packages/ag-charts-enterprise/src/series/ohlc/ohlcModule.ts\n\n\n// packages/ag-charts-enterprise/src/series/ohlc/ohlcSeries.ts\n\n\n// packages/ag-charts-enterprise/src/series/ohlc/ohlcGroup.ts\n\nvar OhlcGroup = class extends CandlestickBaseGroup {\n  constructor() {\n    super();\n    this.append([\n      new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Line({ tag: 0 /* Body */ }),\n      new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Line({ tag: 1 /* Open */ }),\n      new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Line({ tag: 2 /* Close */ })\n    ]);\n  }\n  updateCoordinates() {\n    const {\n      x,\n      y,\n      yBottom,\n      yHigh,\n      yLow,\n      width,\n      height,\n      datum: { itemId }\n    } = this;\n    const selection = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Selection.select(this, ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Rect);\n    const [body] = selection.selectByTag(0 /* Body */);\n    const [open] = selection.selectByTag(1 /* Open */);\n    const [close] = selection.selectByTag(2 /* Close */);\n    if (width === 0 || height === 0) {\n      body.visible = false;\n      open.visible = false;\n      close.visible = false;\n      return;\n    }\n    body.visible = true;\n    open.visible = true;\n    close.visible = true;\n    const halfWidth = width / 2;\n    body.setProperties({\n      x1: Math.floor(x + halfWidth),\n      x2: Math.floor(x + halfWidth),\n      y1: yHigh,\n      y2: yLow\n    });\n    const isRising = itemId === \"up\";\n    const openY = isRising ? yBottom : y;\n    const closeY = isRising ? y : yBottom;\n    open.setProperties({\n      x1: Math.floor(x),\n      x2: Math.floor(x + halfWidth),\n      y: Math.round(openY)\n    });\n    close.setProperties({\n      x1: Math.floor(x + halfWidth),\n      x2: Math.floor(x + width),\n      y: Math.round(closeY)\n    });\n  }\n  updateDatumStyles(_datum, activeStyles) {\n    const selection = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Selection.select(this, ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Rect);\n    const [body] = selection.selectByTag(0 /* Body */);\n    const [open] = selection.selectByTag(1 /* Open */);\n    const [close] = selection.selectByTag(2 /* Close */);\n    body.setProperties(activeStyles);\n    open.setProperties(activeStyles);\n    close.setProperties(activeStyles);\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/ohlc/ohlcSeriesProperties.ts\n\nvar { BaseProperties: BaseProperties14, Validate: Validate51, COLOR_STRING: COLOR_STRING17, FUNCTION: FUNCTION13, LINE_DASH: LINE_DASH14, OBJECT: OBJECT21, POSITIVE_NUMBER: POSITIVE_NUMBER21, RATIO: RATIO22 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar OhlcSeriesItem = class extends BaseProperties14 {\n  constructor() {\n    super(...arguments);\n    this.stroke = \"#333\";\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n  }\n};\n__decorateClass([\n  Validate51(COLOR_STRING17)\n], OhlcSeriesItem.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate51(POSITIVE_NUMBER21)\n], OhlcSeriesItem.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate51(RATIO22)\n], OhlcSeriesItem.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate51(LINE_DASH14)\n], OhlcSeriesItem.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate51(POSITIVE_NUMBER21)\n], OhlcSeriesItem.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate51(FUNCTION13, { optional: true })\n], OhlcSeriesItem.prototype, \"itemStyler\", 2);\nvar OhlcSeriesItems = class extends BaseProperties14 {\n  constructor() {\n    super(...arguments);\n    this.up = new OhlcSeriesItem();\n    this.down = new OhlcSeriesItem();\n  }\n};\n__decorateClass([\n  Validate51(OBJECT21)\n], OhlcSeriesItems.prototype, \"up\", 2);\n__decorateClass([\n  Validate51(OBJECT21)\n], OhlcSeriesItems.prototype, \"down\", 2);\nvar OhlcSeriesProperties = class extends CandlestickSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.item = new OhlcSeriesItems();\n  }\n};\n__decorateClass([\n  Validate51(OBJECT21)\n], OhlcSeriesProperties.prototype, \"item\", 2);\n__decorateClass([\n  Validate51(FUNCTION13, { optional: true })\n], OhlcSeriesProperties.prototype, \"itemStyler\", 2);\n\n// packages/ag-charts-enterprise/src/series/ohlc/ohlcSeries.ts\nvar { mergeDefaults: mergeDefaults7 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar OhlcSeries = class extends OhlcSeriesBase {\n  constructor(moduleCtx) {\n    super(moduleCtx, resetCandlestickSelectionsFn);\n    this.properties = new OhlcSeriesProperties();\n  }\n  async createNodeData() {\n    const baseNodeData = this.createBaseNodeData();\n    if (!baseNodeData) {\n      return;\n    }\n    const nodeData = baseNodeData.nodeData.map((datum) => {\n      const { stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this.getItemConfig(datum.itemId);\n      return {\n        ...datum,\n        stroke,\n        strokeWidth,\n        strokeOpacity,\n        lineDash,\n        lineDashOffset\n      };\n    });\n    return { ...baseNodeData, nodeData };\n  }\n  getFormattedStyles(nodeDatum, highlighted = false) {\n    const {\n      id: seriesId,\n      ctx: { callbackCache }\n    } = this;\n    const { xKey, openKey, closeKey, highKey, lowKey, itemStyler } = this.properties;\n    const { stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this.getItemConfig(nodeDatum.itemId);\n    if (itemStyler) {\n      const formatStyles = callbackCache.call(itemStyler, {\n        datum: nodeDatum.datum,\n        itemId: nodeDatum.itemId,\n        seriesId,\n        highlighted,\n        xKey,\n        openKey,\n        closeKey,\n        highKey,\n        lowKey,\n        stroke,\n        strokeWidth,\n        strokeOpacity,\n        lineDash,\n        lineDashOffset\n      });\n      if (formatStyles) {\n        return mergeDefaults7(formatStyles, this.getSeriesStyles(nodeDatum));\n      }\n    }\n    return this.getSeriesStyles(nodeDatum);\n  }\n  nodeFactory() {\n    return new OhlcGroup();\n  }\n  getSeriesStyles(nodeDatum) {\n    const { stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = nodeDatum;\n    return {\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset\n    };\n  }\n  getActiveStyles(nodeDatum, highlighted) {\n    const activeStyles = this.getFormattedStyles(nodeDatum, highlighted);\n    return highlighted ? mergeDefaults7(this.properties.highlightStyle.item, activeStyles) : activeStyles;\n  }\n  computeFocusBounds(opts) {\n    return computeCandleFocusBounds(this, opts);\n  }\n};\nOhlcSeries.className = \"ohlc\";\nOhlcSeries.type = \"ohlc\";\n\n// packages/ag-charts-enterprise/src/series/ohlc/ohlcModule.ts\nvar OhlcModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"ohlc\",\n  instanceConstructor: OhlcSeries,\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.CARTESIAN_AXIS_TYPE.NUMBER,\n      position: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POSITION.LEFT\n    },\n    {\n      type: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.CARTESIAN_AXIS_TYPE.ORDINAL_TIME,\n      position: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POSITION.BOTTOM\n    }\n  ],\n  themeTemplate: {\n    animation: { enabled: false },\n    axes: {\n      [ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.CARTESIAN_AXIS_TYPE.NUMBER]: {\n        crosshair: {\n          snap: false\n        }\n      },\n      [ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.CARTESIAN_AXIS_TYPE.ORDINAL_TIME]: {\n        groupPaddingInner: 0,\n        crosshair: {\n          enabled: true\n        }\n      }\n    }\n  },\n  groupable: false,\n  paletteFactory: ({ takeColors, colorsCount, userPalette, palette }) => {\n    if (userPalette === \"user-indexed\") {\n      const {\n        strokes: [stroke]\n      } = takeColors(colorsCount);\n      return {\n        item: {\n          up: {\n            stroke\n          },\n          down: {\n            stroke\n          }\n        }\n      };\n    }\n    return {\n      item: {\n        up: { stroke: palette.up.stroke },\n        down: { stroke: palette.down.stroke }\n      }\n    };\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/radar-area/radarAreaModule.ts\n\n\n// packages/ag-charts-enterprise/src/series/radar/radarThemes.ts\n\nvar BASE_RADAR_SERIES_THEME = {\n  series: {\n    label: {\n      enabled: false,\n      fontSize: 12,\n      fontFamily: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_FONT_FAMILY,\n      color: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_LABEL_COLOUR\n    },\n    marker: {\n      enabled: true,\n      fillOpacity: 1,\n      shape: \"circle\",\n      size: 6,\n      strokeOpacity: 1,\n      strokeWidth: 0\n    }\n  },\n  axes: {\n    [ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POLAR_AXIS_TYPE.ANGLE_CATEGORY]: {\n      label: {\n        padding: 10\n      }\n    }\n  }\n};\nvar RADAR_LINE_SERIES_THEME = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.mergeDefaults(\n  {\n    series: {\n      strokeWidth: 2\n    }\n  },\n  BASE_RADAR_SERIES_THEME\n);\nvar RADAR_AREA_SERIES_THEME = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.mergeDefaults(\n  {\n    series: {\n      fillOpacity: 0.8,\n      strokeWidth: 2,\n      marker: {\n        enabled: false\n      }\n    }\n  },\n  BASE_RADAR_SERIES_THEME\n);\n\n// packages/ag-charts-enterprise/src/series/radar-area/radarAreaSeries.ts\n\n\n// packages/ag-charts-enterprise/src/series/radar/radarSeries.ts\n\n\n// packages/ag-charts-enterprise/src/series/radar/radarSeriesProperties.ts\n\nvar { Label: Label8 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar {\n  SeriesMarker,\n  SeriesProperties: SeriesProperties8,\n  SeriesTooltip: SeriesTooltip12,\n  Validate: Validate52,\n  BOOLEAN: BOOLEAN17,\n  COLOR_STRING: COLOR_STRING18,\n  DEGREE: DEGREE4,\n  FUNCTION: FUNCTION14,\n  LINE_DASH: LINE_DASH15,\n  OBJECT: OBJECT22,\n  POSITIVE_NUMBER: POSITIVE_NUMBER22,\n  RATIO: RATIO23,\n  STRING: STRING21\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar RadarSeriesProperties = class extends SeriesProperties8 {\n  constructor() {\n    super(...arguments);\n    this.stroke = \"black\";\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.rotation = 0;\n    this.marker = new SeriesMarker();\n    this.label = new Label8();\n    this.tooltip = new SeriesTooltip12();\n    this.connectMissingData = false;\n  }\n};\n__decorateClass([\n  Validate52(STRING21)\n], RadarSeriesProperties.prototype, \"angleKey\", 2);\n__decorateClass([\n  Validate52(STRING21)\n], RadarSeriesProperties.prototype, \"radiusKey\", 2);\n__decorateClass([\n  Validate52(STRING21, { optional: true })\n], RadarSeriesProperties.prototype, \"angleName\", 2);\n__decorateClass([\n  Validate52(STRING21, { optional: true })\n], RadarSeriesProperties.prototype, \"radiusName\", 2);\n__decorateClass([\n  Validate52(COLOR_STRING18)\n], RadarSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate52(POSITIVE_NUMBER22)\n], RadarSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate52(RATIO23)\n], RadarSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate52(LINE_DASH15)\n], RadarSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate52(POSITIVE_NUMBER22)\n], RadarSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate52(FUNCTION14, { optional: true })\n], RadarSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate52(DEGREE4)\n], RadarSeriesProperties.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate52(OBJECT22)\n], RadarSeriesProperties.prototype, \"marker\", 2);\n__decorateClass([\n  Validate52(OBJECT22)\n], RadarSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate52(OBJECT22)\n], RadarSeriesProperties.prototype, \"tooltip\", 2);\n__decorateClass([\n  Validate52(BOOLEAN17)\n], RadarSeriesProperties.prototype, \"connectMissingData\", 2);\n\n// packages/ag-charts-enterprise/src/series/radar/radarSeries.ts\nvar {\n  ChartAxisDirection: ChartAxisDirection16,\n  PolarAxis: PolarAxis2,\n  SeriesNodePickMode: SeriesNodePickMode11,\n  valueProperty: valueProperty12,\n  fixNumericExtent: fixNumericExtent5,\n  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation3,\n  markerFadeInAnimation,\n  resetMarkerFn,\n  animationValidation: animationValidation5,\n  isFiniteNumber: isFiniteNumber6,\n  computeMarkerFocusBounds: computeMarkerFocusBounds2\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { BBox: BBox8, Group: Group13, Path: Path7, PointerEvents: PointerEvents5, Selection: Selection9, Text: Text12, getMarker: getMarker2 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar { extent: extent3, isNumberEqual: isNumberEqual8, sanitizeHtml: sanitizeHtml9, toFixed } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar RadarSeriesNodeEvent = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.angleKey = series.properties.angleKey;\n    this.radiusKey = series.properties.radiusKey;\n  }\n};\nvar RadarSeries = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.PolarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      useLabelLayer: true,\n      pickModes: [SeriesNodePickMode11.NEAREST_NODE, SeriesNodePickMode11.EXACT_SHAPE_MATCH],\n      canHaveAxes: true,\n      animationResetFns: {\n        item: resetMarkerFn\n      }\n    });\n    this.properties = new RadarSeriesProperties();\n    this.NodeEvent = RadarSeriesNodeEvent;\n    this.resetInvalidToZero = false;\n    this.circleCache = { r: 0, cx: 0, cy: 0 };\n    const lineGroup = new Group13();\n    this.contentGroup.append(lineGroup);\n    this.lineSelection = Selection9.select(lineGroup, Path7);\n    lineGroup.zIndexSubOrder = [() => this._declarationOrder, 1];\n  }\n  nodeFactory() {\n    const { shape } = this.properties.marker;\n    const MarkerShape = getMarker2(shape);\n    return new MarkerShape();\n  }\n  addChartEventListeners() {\n    this.destroyFns.push(\n      this.ctx.chartEventManager?.addListener(\"legend-item-click\", (event) => this.onLegendItemClick(event)),\n      this.ctx.chartEventManager?.addListener(\n        \"legend-item-double-click\",\n        (event) => this.onLegendItemDoubleClick(event)\n      )\n    );\n  }\n  getSeriesDomain(direction) {\n    const { dataModel, processedData } = this;\n    if (!processedData || !dataModel)\n      return [];\n    if (direction === ChartAxisDirection16.X) {\n      return dataModel.getDomain(this, `angleValue`, \"value\", processedData);\n    } else {\n      const domain = dataModel.getDomain(this, `radiusValue`, \"value\", processedData);\n      const ext = extent3(domain.length === 0 ? domain : [0].concat(domain));\n      return fixNumericExtent5(ext);\n    }\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid()) {\n      return;\n    }\n    const { angleKey, radiusKey } = this.properties;\n    const extraProps = [];\n    if (!this.ctx.animationManager.isSkipped()) {\n      extraProps.push(animationValidation5());\n    }\n    const radiusScaleType = this.axes[ChartAxisDirection16.Y]?.scale.type;\n    const angleScaleType = this.axes[ChartAxisDirection16.X]?.scale.type;\n    await this.requestDataModel(dataController, this.data, {\n      props: [\n        valueProperty12(angleKey, angleScaleType, { id: \"angleValue\" }),\n        valueProperty12(radiusKey, radiusScaleType, { id: \"radiusValue\", invalidValue: void 0 }),\n        ...extraProps\n      ]\n    });\n    this.animationState.transition(\"updateData\");\n  }\n  didCircleChange() {\n    const r = this.radius;\n    const cx = this.centerX;\n    const cy = this.centerY;\n    const cache = this.circleCache;\n    if (!(r === cache.r && cx === cache.cx && cy === cache.cy)) {\n      this.circleCache = { r, cx, cy };\n      return true;\n    }\n    return false;\n  }\n  getAxisInnerRadius() {\n    const radiusAxis = this.axes[ChartAxisDirection16.Y];\n    return radiusAxis instanceof PolarAxis2 ? this.radius * radiusAxis.innerRadiusRatio : 0;\n  }\n  async maybeRefreshNodeData() {\n    const didCircleChange = this.didCircleChange();\n    if (!didCircleChange && !this.nodeDataRefresh)\n      return;\n    const { nodeData = [] } = await this.createNodeData() ?? {};\n    this.nodeData = nodeData;\n    this.nodeDataRefresh = false;\n  }\n  async createNodeData() {\n    const { processedData, dataModel } = this;\n    if (!processedData || !dataModel || !this.properties.isValid()) {\n      return;\n    }\n    const { angleKey, radiusKey, angleName, radiusName, marker, label } = this.properties;\n    const angleScale = this.axes[ChartAxisDirection16.X]?.scale;\n    const radiusScale = this.axes[ChartAxisDirection16.Y]?.scale;\n    if (!angleScale || !radiusScale) {\n      return;\n    }\n    const angleIdx = dataModel.resolveProcessedDataIndexById(this, `angleValue`);\n    const radiusIdx = dataModel.resolveProcessedDataIndexById(this, `radiusValue`);\n    const axisInnerRadius = this.getAxisInnerRadius();\n    const nodeData = processedData.data.map((group) => {\n      const { datum, values } = group;\n      const angleDatum = values[angleIdx];\n      const radiusDatum = values[radiusIdx];\n      const angle = angleScale.convert(angleDatum);\n      const radius = this.radius + axisInnerRadius - radiusScale.convert(radiusDatum);\n      const cos = Math.cos(angle);\n      const sin = Math.sin(angle);\n      const x = cos * radius;\n      const y = sin * radius;\n      let labelNodeDatum;\n      if (label.enabled) {\n        const labelText = this.getLabelText(\n          label,\n          { value: radiusDatum, datum, angleKey, radiusKey, angleName, radiusName },\n          (value) => isFiniteNumber6(value) ? value.toFixed(2) : String(value)\n        );\n        if (labelText) {\n          let textAlign = \"right\";\n          if (isNumberEqual8(cos, 0)) {\n            textAlign = \"center\";\n          } else if (cos > 0) {\n            textAlign = \"left\";\n          }\n          let textBaseline = \"bottom\";\n          if (isNumberEqual8(sin, 0)) {\n            textBaseline = \"middle\";\n          } else if (sin > 0) {\n            textBaseline = \"top\";\n          }\n          labelNodeDatum = {\n            x: x + cos * marker.size,\n            y: y + sin * marker.size,\n            text: labelText,\n            textAlign,\n            textBaseline\n          };\n        }\n      }\n      return {\n        series: this,\n        datum,\n        point: { x, y, size: marker.size },\n        midPoint: { x, y },\n        label: labelNodeDatum,\n        angleValue: angleDatum,\n        radiusValue: radiusDatum,\n        missing: !ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util.isNumber(angle) || !ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util.isNumber(radius)\n      };\n    });\n    return { itemId: radiusKey, nodeData, labelData: nodeData };\n  }\n  async update({ seriesRect }) {\n    const resize = this.checkResize(seriesRect);\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const { series } = this.ctx.highlightManager?.getActiveHighlight() ?? {};\n    this.highlightGroup.visible = (animationEnabled || this.visible) && !!(series === this);\n    await this.maybeRefreshNodeData();\n    this.contentGroup.translationX = this.centerX;\n    this.contentGroup.translationY = this.centerY;\n    this.highlightGroup.translationX = this.centerX;\n    this.highlightGroup.translationY = this.centerY;\n    if (this.labelGroup) {\n      this.labelGroup.translationX = this.centerX;\n      this.labelGroup.translationY = this.centerY;\n    }\n    this.updatePathSelections();\n    this.updateMarkerSelection();\n    this.updateMarkers(this.itemSelection, false);\n    this.updateMarkers(this.highlightSelection, true);\n    this.updateLabels();\n    if (resize) {\n      this.animationState.transition(\"resize\");\n    }\n    this.animationState.transition(\"update\");\n  }\n  updatePathSelections() {\n    const pathData = this.visible ? [true] : [];\n    this.lineSelection.update(pathData);\n  }\n  updateMarkerSelection() {\n    if (this.properties.marker.isDirty()) {\n      this.itemSelection.clear();\n      this.itemSelection.cleanup();\n      this.itemSelection = Selection9.select(this.itemGroup, () => this.nodeFactory(), false);\n    }\n    this.itemSelection.update(this.properties.marker.enabled ? this.nodeData : []);\n  }\n  getMarkerFill(highlightedStyle) {\n    return highlightedStyle?.fill ?? this.properties.marker.fill;\n  }\n  updateMarkers(selection, highlight) {\n    const { angleKey, radiusKey, marker, visible } = this.properties;\n    let selectionData = [];\n    if (visible && marker.shape && marker.enabled) {\n      if (highlight) {\n        const highlighted = this.ctx.highlightManager?.getActiveHighlight();\n        if (highlighted?.datum) {\n          selectionData = [highlighted];\n        }\n      } else {\n        selectionData = this.nodeData;\n      }\n    }\n    const highlightedStyle = highlight ? this.properties.highlightStyle.item : void 0;\n    selection.update(selectionData).each((node, datum) => {\n      const fill = this.getMarkerFill(highlightedStyle);\n      const fillOpacity = highlightedStyle?.fillOpacity ?? this.properties.marker.fillOpacity;\n      const stroke = highlightedStyle?.stroke ?? marker.stroke ?? this.properties.stroke;\n      const strokeWidth = highlightedStyle?.strokeWidth ?? marker.strokeWidth ?? this.properties.strokeWidth ?? 1;\n      const strokeOpacity = highlightedStyle?.strokeOpacity ?? this.properties.marker.strokeOpacity;\n      const format = marker.itemStyler ? this.ctx.callbackCache.call(marker.itemStyler, {\n        datum: datum.datum,\n        angleKey,\n        radiusKey,\n        fill,\n        fillOpacity,\n        stroke,\n        strokeWidth,\n        strokeOpacity,\n        shape: marker.shape,\n        size: marker.size,\n        highlighted: highlight,\n        seriesId: this.id\n      }) : void 0;\n      node.fill = format?.fill ?? fill;\n      node.stroke = format?.stroke ?? stroke;\n      node.strokeWidth = format?.strokeWidth ?? strokeWidth;\n      node.fillOpacity = highlightedStyle?.fillOpacity ?? marker.fillOpacity ?? 1;\n      node.strokeOpacity = marker.strokeOpacity ?? this.properties.strokeOpacity ?? 1;\n      node.size = format?.size ?? marker.size;\n      const { x, y } = datum.point;\n      node.translationX = x;\n      node.translationY = y;\n      node.visible = visible && node.size > 0 && !isNaN(x) && !isNaN(y);\n    });\n  }\n  updateLabels() {\n    const { label } = this.properties;\n    this.labelSelection.update(this.nodeData).each((node, datum) => {\n      if (label.enabled && datum.label) {\n        node.x = datum.label.x;\n        node.y = datum.label.y;\n        node.fill = label.color;\n        node.fontFamily = label.fontFamily;\n        node.fontSize = label.fontSize;\n        node.fontStyle = label.fontStyle;\n        node.fontWeight = label.fontWeight;\n        node.text = datum.label.text;\n        node.textAlign = datum.label.textAlign;\n        node.textBaseline = datum.label.textBaseline;\n        node.visible = true;\n      } else {\n        node.visible = false;\n      }\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    if (!this.properties.isValid()) {\n      return ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.EMPTY_TOOLTIP_CONTENT;\n    }\n    const { id: seriesId } = this;\n    const { angleKey, radiusKey, angleName, radiusName, marker, tooltip } = this.properties;\n    const { datum, angleValue, radiusValue, itemId } = nodeDatum;\n    const formattedAngleValue = typeof angleValue === \"number\" ? toFixed(angleValue) : String(angleValue);\n    const formattedRadiusValue = typeof radiusValue === \"number\" ? toFixed(radiusValue) : String(radiusValue);\n    const title = sanitizeHtml9(radiusName);\n    const content = sanitizeHtml9(`${formattedAngleValue}: ${formattedRadiusValue}`);\n    const {\n      itemStyler,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth = this.properties.strokeWidth,\n      strokeOpacity,\n      shape,\n      size\n    } = marker;\n    const { fill: color } = (itemStyler && this.ctx.callbackCache.call(itemStyler, {\n      datum,\n      angleKey,\n      radiusKey,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      shape,\n      size,\n      highlighted: false,\n      seriesId\n    })) ?? { fill };\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        datum,\n        angleKey,\n        angleName,\n        radiusKey,\n        radiusName,\n        title,\n        color,\n        seriesId,\n        itemId\n      }\n    );\n  }\n  getLegendData(legendType) {\n    if (!this.data?.length || !this.properties.isValid() || legendType !== \"category\") {\n      return [];\n    }\n    const { radiusKey, radiusName, stroke, strokeWidth, strokeOpacity, lineDash, visible, marker } = this.properties;\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: radiusKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: radiusName ?? radiusKey\n        },\n        symbols: [\n          {\n            marker: {\n              shape: marker.shape,\n              fill: this.getMarkerFill() ?? marker.stroke ?? stroke ?? \"rgba(0, 0, 0, 0)\",\n              stroke: marker.stroke ?? stroke ?? \"rgba(0, 0, 0, 0)\",\n              fillOpacity: marker.fillOpacity ?? 1,\n              strokeOpacity: marker.strokeOpacity ?? strokeOpacity ?? 1,\n              strokeWidth: marker.strokeWidth ?? 0,\n              enabled: marker.enabled || strokeWidth <= 0\n            },\n            line: {\n              stroke,\n              strokeOpacity,\n              strokeWidth,\n              lineDash\n            }\n          }\n        ]\n      }\n    ];\n  }\n  onLegendItemClick(event) {\n    const { enabled, itemId, series } = event;\n    if (series.id === this.id) {\n      this.toggleSeriesItem(itemId, enabled);\n    }\n  }\n  onLegendItemDoubleClick(event) {\n    const { enabled, itemId, series, numVisibleItems } = event;\n    const wasClicked = series.id === this.id;\n    const newEnabled = wasClicked || enabled && numVisibleItems === 1;\n    this.toggleSeriesItem(itemId, newEnabled);\n  }\n  pickNodeClosestDatum(point) {\n    const { x, y } = point;\n    const { rootGroup, nodeData, centerX: cx, centerY: cy } = this;\n    const hitPoint = rootGroup.transformPoint(x, y);\n    const radius = this.radius;\n    const distanceFromCenter = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);\n    if (distanceFromCenter > radius + this.properties.marker.size) {\n      return;\n    }\n    let minDistance = Infinity;\n    let closestDatum;\n    for (const datum of nodeData) {\n      const { point: { x: datumX = NaN, y: datumY = NaN } = {} } = datum;\n      if (isNaN(datumX) || isNaN(datumY)) {\n        continue;\n      }\n      const distance = Math.sqrt((hitPoint.x - datumX - cx) ** 2 + (hitPoint.y - datumY - cy) ** 2);\n      if (distance < minDistance) {\n        minDistance = distance;\n        closestDatum = datum;\n      }\n    }\n    if (closestDatum) {\n      const distance = Math.max(minDistance - (closestDatum.point?.size ?? 0), 0);\n      return { datum: closestDatum, distance };\n    }\n  }\n  async computeLabelsBBox() {\n    const { label } = this.properties;\n    await this.maybeRefreshNodeData();\n    const textBoxes = [];\n    const tempText2 = new Text12();\n    this.nodeData.forEach((nodeDatum) => {\n      if (!label.enabled || !nodeDatum.label) {\n        return;\n      }\n      tempText2.text = nodeDatum.label.text;\n      tempText2.x = nodeDatum.label.x;\n      tempText2.y = nodeDatum.label.y;\n      tempText2.setFont(label);\n      tempText2.setAlign(nodeDatum.label);\n      const box = tempText2.computeBBox();\n      textBoxes.push(box);\n    });\n    if (textBoxes.length === 0) {\n      return null;\n    }\n    return BBox8.merge(textBoxes);\n  }\n  getLineNode() {\n    return this.lineSelection.nodes()[0];\n  }\n  beforePathAnimation() {\n    const lineNode = this.getLineNode();\n    lineNode.fill = void 0;\n    lineNode.lineJoin = \"round\";\n    lineNode.lineCap = \"round\";\n    lineNode.pointerEvents = PointerEvents5.None;\n    lineNode.stroke = this.properties.stroke;\n    lineNode.strokeWidth = this.getStrokeWidth(this.properties.strokeWidth);\n    lineNode.strokeOpacity = this.properties.strokeOpacity;\n    lineNode.lineDash = this.properties.lineDash;\n    lineNode.lineDashOffset = this.properties.lineDashOffset;\n  }\n  getLinePoints() {\n    const { nodeData, resetInvalidToZero } = this;\n    const { connectMissingData } = this.properties;\n    if (nodeData.length === 0) {\n      return [];\n    }\n    const radiusAxis = this.axes[ChartAxisDirection16.Y];\n    const angleAxis = this.axes[ChartAxisDirection16.X];\n    const reversedAngleAxis = angleAxis?.isReversed();\n    const reversedRadiusAxis = radiusAxis?.isReversed();\n    const data = reversedRadiusAxis && !reversedAngleAxis ? [...nodeData].reverse() : nodeData;\n    const points = [];\n    let prevPointInvalid = false;\n    let firstValid;\n    data.forEach((datum, index) => {\n      let { x, y } = datum.point;\n      const isPointInvalid = isNaN(x) || isNaN(y);\n      if (!isPointInvalid) {\n        firstValid ?? (firstValid = datum);\n      }\n      if (isPointInvalid && !connectMissingData) {\n        x = 0;\n        y = 0;\n      }\n      const moveTo = index === 0 || !resetInvalidToZero && !connectMissingData && (isPointInvalid || prevPointInvalid);\n      points.push({ x, y, moveTo });\n      prevPointInvalid = isPointInvalid;\n    });\n    if (firstValid !== void 0) {\n      points.push({ x: firstValid.point.x, y: firstValid.point.y, moveTo: false });\n    }\n    return points;\n  }\n  animateSinglePath(pathNode, points, ratio) {\n    const { path } = pathNode;\n    path.clear(true);\n    const axisInnerRadius = this.getAxisInnerRadius();\n    const radiusAxis = this.axes[ChartAxisDirection16.Y];\n    const reversedRadiusAxis = radiusAxis?.isReversed();\n    const radiusZero = reversedRadiusAxis ? this.radius + axisInnerRadius - radiusAxis?.scale.convert(0) : axisInnerRadius;\n    points.forEach((point) => {\n      const { x: x1, y: y1, arc, radius = 0, startAngle = 0, endAngle = 0, moveTo } = point;\n      const angle = Math.atan2(y1, x1);\n      const x0 = radiusZero * Math.cos(angle);\n      const y0 = radiusZero * Math.sin(angle);\n      const t = ratio;\n      const x = x0 * (1 - t) + x1 * t;\n      const y = y0 * (1 - t) + y1 * t;\n      if (arc) {\n        path.arc(x1, y1, radius, startAngle, endAngle);\n      } else if (moveTo) {\n        path.moveTo(x, y);\n      } else {\n        path.lineTo(x, y);\n      }\n    });\n    pathNode.checkPathDirty();\n  }\n  animatePaths(ratio) {\n    const linePoints = this.getLinePoints();\n    this.animateSinglePath(this.getLineNode(), linePoints, ratio);\n  }\n  animateEmptyUpdateReady() {\n    const { itemSelection, labelSelection } = this;\n    const { animationManager } = this.ctx;\n    this.beforePathAnimation();\n    animationManager.animate({\n      id: `${this.id}_'path`,\n      groupId: this.id,\n      from: 0,\n      to: 1,\n      phase: \"initial\",\n      collapsable: false,\n      onUpdate: (ratio) => this.animatePaths(ratio),\n      onStop: () => this.animatePaths(1)\n    });\n    markerFadeInAnimation(this, animationManager, \"added\", itemSelection);\n    seriesLabelFadeInAnimation3(this, \"labels\", animationManager, labelSelection);\n  }\n  animateWaitingUpdateReady(data) {\n    super.animateWaitingUpdateReady(data);\n    this.resetPaths();\n  }\n  animateReadyResize(data) {\n    super.animateReadyResize(data);\n    this.resetPaths();\n  }\n  resetPaths() {\n    const lineNode = this.getLineNode();\n    if (lineNode) {\n      const { path: linePath } = lineNode;\n      const linePoints = this.getLinePoints();\n      lineNode.fill = void 0;\n      lineNode.stroke = this.properties.stroke;\n      lineNode.strokeWidth = this.getStrokeWidth(this.properties.strokeWidth);\n      lineNode.strokeOpacity = this.properties.strokeOpacity;\n      lineNode.lineDash = this.properties.lineDash;\n      lineNode.lineDashOffset = this.properties.lineDashOffset;\n      linePath.clear(true);\n      linePoints.forEach(({ x, y, moveTo }) => {\n        if (moveTo) {\n          linePath.moveTo(x, y);\n        } else {\n          linePath.lineTo(x, y);\n        }\n      });\n      lineNode.checkPathDirty();\n    }\n  }\n  getFormattedMarkerStyle(datum) {\n    const { angleKey, radiusKey } = this.properties;\n    return this.getMarkerStyle(this.properties.marker, { datum, angleKey, radiusKey, highlighted: true });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds2(this, opts);\n  }\n};\nRadarSeries.className = \"RadarSeries\";\n\n// packages/ag-charts-enterprise/src/series/radar-area/radarAreaSeriesProperties.ts\n\nvar { RATIO: RATIO24, COLOR_STRING: COLOR_STRING19, Validate: Validate53 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar RadarAreaSeriesProperties = class extends RadarSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fill = \"black\";\n    this.fillOpacity = 1;\n  }\n};\n__decorateClass([\n  Validate53(COLOR_STRING19)\n], RadarAreaSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate53(RATIO24)\n], RadarAreaSeriesProperties.prototype, \"fillOpacity\", 2);\n\n// packages/ag-charts-enterprise/src/series/radar-area/radarAreaSeries.ts\nvar { Group: Group14, Path: Path8, PointerEvents: PointerEvents6, Selection: Selection10 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar { ChartAxisDirection: ChartAxisDirection17 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar RadarAreaSeries = class extends RadarSeries {\n  constructor(moduleCtx) {\n    super(moduleCtx);\n    this.properties = new RadarAreaSeriesProperties();\n    this.resetInvalidToZero = true;\n    const areaGroup = new Group14();\n    areaGroup.zIndexSubOrder = [() => this._declarationOrder, 0];\n    this.contentGroup.append(areaGroup);\n    this.areaSelection = Selection10.select(areaGroup, Path8);\n  }\n  updatePathSelections() {\n    const pathData = this.visible ? [true] : [];\n    this.areaSelection.update(pathData);\n    super.updatePathSelections();\n  }\n  getAreaNode() {\n    return this.areaSelection.nodes()[0];\n  }\n  getMarkerFill(highlightedStyle) {\n    return highlightedStyle?.fill ?? this.properties.marker.fill ?? this.properties.fill;\n  }\n  beforePathAnimation() {\n    super.beforePathAnimation();\n    const areaNode = this.getAreaNode();\n    areaNode.fill = this.properties.fill;\n    areaNode.fillOpacity = this.properties.fillOpacity;\n    areaNode.pointerEvents = PointerEvents6.None;\n    areaNode.stroke = void 0;\n  }\n  animatePaths(ratio) {\n    super.animatePaths(ratio);\n    this.animateSinglePath(this.getAreaNode(), this.getAreaPoints(), ratio);\n  }\n  getAreaPoints() {\n    const points = this.getLinePoints();\n    const getPolarAxis = (direction) => {\n      const axis = this.axes[direction];\n      return axis instanceof ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.PolarAxis ? axis : void 0;\n    };\n    const radiusAxis = getPolarAxis(ChartAxisDirection17.Y);\n    const angleAxis = getPolarAxis(ChartAxisDirection17.X);\n    const reversedRadiusAxis = radiusAxis?.isReversed();\n    if (!reversedRadiusAxis) {\n      return points;\n    }\n    const { points: zeroLinePoints = [] } = angleAxis?.getAxisLinePoints?.() ?? {};\n    return points.concat(...zeroLinePoints);\n  }\n  resetPaths() {\n    super.resetPaths();\n    const areaNode = this.getAreaNode();\n    if (areaNode) {\n      const { path: areaPath } = areaNode;\n      const areaPoints = this.getAreaPoints();\n      areaNode.fill = this.properties.fill;\n      areaNode.fillOpacity = this.properties.fillOpacity;\n      areaNode.stroke = void 0;\n      areaNode.lineDash = this.properties.lineDash;\n      areaNode.lineDashOffset = this.properties.lineDashOffset;\n      areaNode.lineJoin = areaNode.lineCap = \"round\";\n      areaPath.clear(true);\n      areaPoints.forEach(({ x, y, moveTo, arc, radius = 0, startAngle = 0, endAngle = 0 }) => {\n        if (arc) {\n          areaPath.arc(x, y, radius, startAngle, endAngle);\n        } else if (moveTo) {\n          areaPath.moveTo(x, y);\n        } else {\n          areaPath.lineTo(x, y);\n        }\n      });\n      areaPath.closePath();\n      areaNode.checkPathDirty();\n    }\n  }\n};\nRadarAreaSeries.className = \"RadarAreaSeries\";\nRadarAreaSeries.type = \"radar-area\";\n\n// packages/ag-charts-enterprise/src/series/radar-area/radarAreaModule.ts\nvar { markerPaletteFactory } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar RadarAreaModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"polar\"],\n  identifier: \"radar-area\",\n  instanceConstructor: RadarAreaSeries,\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POLAR_AXIS_TYPE.ANGLE_CATEGORY\n    },\n    {\n      type: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POLAR_AXIS_TYPE.RADIUS_NUMBER\n    }\n  ],\n  themeTemplate: RADAR_AREA_SERIES_THEME,\n  paletteFactory: (params) => {\n    const { marker } = markerPaletteFactory(params);\n    return {\n      stroke: marker.stroke,\n      fill: marker.fill,\n      marker\n    };\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/radar-line/radarLineModule.ts\n\n\n// packages/ag-charts-enterprise/src/series/radar-line/radarLineSeries.ts\nvar RadarLineSeries = class extends RadarSeries {\n  updatePathSelections() {\n    this.lineSelection.update(this.visible ? [true] : []);\n  }\n};\nRadarLineSeries.className = \"RadarLineSeries\";\nRadarLineSeries.type = \"radar-line\";\n\n// packages/ag-charts-enterprise/src/series/radar-line/radarLineModule.ts\nvar RadarLineModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"polar\"],\n  identifier: \"radar-line\",\n  instanceConstructor: RadarLineSeries,\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POLAR_AXIS_TYPE.ANGLE_CATEGORY\n    },\n    {\n      type: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POLAR_AXIS_TYPE.RADIUS_NUMBER\n    }\n  ],\n  themeTemplate: RADAR_LINE_SERIES_THEME,\n  paletteFactory: ({ takeColors }) => {\n    const {\n      fills: [fill],\n      strokes: [stroke]\n    } = takeColors(1);\n    return {\n      stroke: fill,\n      marker: { fill, stroke }\n    };\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/radial-bar/radialBarModule.ts\n\n\n// packages/ag-charts-enterprise/src/series/radial-bar/radialBarSeries.ts\n\n\n// packages/ag-charts-enterprise/src/series/radial-bar/radialBarSeriesProperties.ts\n\nvar { Label: Label9 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar {\n  SeriesProperties: SeriesProperties9,\n  SeriesTooltip: SeriesTooltip13,\n  Validate: Validate54,\n  COLOR_STRING: COLOR_STRING20,\n  DEGREE: DEGREE5,\n  FUNCTION: FUNCTION15,\n  LINE_DASH: LINE_DASH16,\n  NUMBER: NUMBER13,\n  OBJECT: OBJECT23,\n  POSITIVE_NUMBER: POSITIVE_NUMBER23,\n  RATIO: RATIO25,\n  STRING: STRING22\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar RadialBarSeriesProperties = class extends SeriesProperties9 {\n  constructor() {\n    super(...arguments);\n    this.fill = \"black\";\n    this.fillOpacity = 1;\n    this.stroke = \"black\";\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.rotation = 0;\n    this.label = new Label9();\n    this.tooltip = new SeriesTooltip13();\n  }\n};\n__decorateClass([\n  Validate54(STRING22)\n], RadialBarSeriesProperties.prototype, \"angleKey\", 2);\n__decorateClass([\n  Validate54(STRING22)\n], RadialBarSeriesProperties.prototype, \"radiusKey\", 2);\n__decorateClass([\n  Validate54(STRING22, { optional: true })\n], RadialBarSeriesProperties.prototype, \"angleName\", 2);\n__decorateClass([\n  Validate54(STRING22, { optional: true })\n], RadialBarSeriesProperties.prototype, \"radiusName\", 2);\n__decorateClass([\n  Validate54(COLOR_STRING20)\n], RadialBarSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate54(RATIO25)\n], RadialBarSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate54(COLOR_STRING20)\n], RadialBarSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate54(POSITIVE_NUMBER23)\n], RadialBarSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate54(RATIO25)\n], RadialBarSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate54(LINE_DASH16)\n], RadialBarSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate54(POSITIVE_NUMBER23)\n], RadialBarSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate54(POSITIVE_NUMBER23)\n], RadialBarSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate54(FUNCTION15, { optional: true })\n], RadialBarSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate54(DEGREE5)\n], RadialBarSeriesProperties.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate54(STRING22, { optional: true })\n], RadialBarSeriesProperties.prototype, \"stackGroup\", 2);\n__decorateClass([\n  Validate54(NUMBER13, { optional: true })\n], RadialBarSeriesProperties.prototype, \"normalizedTo\", 2);\n__decorateClass([\n  Validate54(OBJECT23)\n], RadialBarSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate54(OBJECT23)\n], RadialBarSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-enterprise/src/series/radial-bar/radialBarUtil.ts\n\nvar { SectorBox: SectorBox3, motion: motion6 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nfunction fixRadialBarAnimationStatus(node, datum, status) {\n  if (status === \"updated\") {\n    if (node.previousDatum == null || isNaN(node.previousDatum.innerRadius) || isNaN(node.previousDatum.outerRadius)) {\n      return \"added\";\n    }\n    if (isNaN(datum.innerRadius) || isNaN(datum.outerRadius)) {\n      return \"removed\";\n    }\n  }\n  if (status === \"added\" && node.previousDatum != null) {\n    return \"updated\";\n  }\n  return status;\n}\nfunction prepareRadialBarSeriesAnimationFunctions(axisZeroAngle) {\n  const fromFn = (sect, datum, status) => {\n    status = fixRadialBarAnimationStatus(sect, datum, status);\n    let startAngle;\n    let endAngle;\n    let innerRadius;\n    let outerRadius;\n    let clipSector;\n    if (status === \"removed\" || status === \"updated\") {\n      startAngle = sect.startAngle;\n      endAngle = sect.endAngle;\n      innerRadius = sect.innerRadius;\n      outerRadius = sect.outerRadius;\n      clipSector = sect.clipSector;\n    } else {\n      startAngle = axisZeroAngle;\n      endAngle = axisZeroAngle;\n      innerRadius = datum.innerRadius;\n      outerRadius = datum.outerRadius;\n    }\n    clipSector ?? (clipSector = new SectorBox3(startAngle, endAngle, innerRadius, outerRadius));\n    const phase = motion6.NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];\n    return { startAngle, endAngle, innerRadius, outerRadius, clipSector, phase };\n  };\n  const toFn = (sect, datum, status) => {\n    let startAngle;\n    let endAngle;\n    let innerRadius;\n    let outerRadius;\n    let clipSector;\n    if (status === \"removed\") {\n      startAngle = axisZeroAngle;\n      endAngle = axisZeroAngle;\n      innerRadius = datum.innerRadius;\n      outerRadius = datum.outerRadius;\n      clipSector = new SectorBox3(startAngle, endAngle, innerRadius, outerRadius);\n    } else {\n      startAngle = datum.startAngle;\n      endAngle = datum.endAngle;\n      innerRadius = isNaN(datum.innerRadius) ? sect.innerRadius : datum.innerRadius;\n      outerRadius = isNaN(datum.outerRadius) ? sect.outerRadius : datum.outerRadius;\n      clipSector = datum.clipSector;\n    }\n    return { startAngle, endAngle, innerRadius, outerRadius, clipSector };\n  };\n  return { toFn, fromFn };\n}\nfunction resetRadialBarSelectionsFn(_node, datum) {\n  return {\n    centerX: 0,\n    centerY: 0,\n    innerRadius: datum.innerRadius,\n    outerRadius: datum.outerRadius,\n    startAngle: datum.startAngle,\n    endAngle: datum.endAngle,\n    clipSector: datum.clipSector\n  };\n}\n\n// packages/ag-charts-enterprise/src/series/radial-bar/radialBarSeries.ts\nvar {\n  ChartAxisDirection: ChartAxisDirection18,\n  PolarAxis: PolarAxis3,\n  diff: diff5,\n  isDefined: isDefined4,\n  groupAccumulativeValueProperty: groupAccumulativeValueProperty3,\n  keyProperty: keyProperty6,\n  mergeDefaults: mergeDefaults8,\n  normaliseGroupTo: normaliseGroupTo2,\n  valueProperty: valueProperty13,\n  fixNumericExtent: fixNumericExtent6,\n  resetLabelFn: resetLabelFn2,\n  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation4,\n  seriesLabelFadeOutAnimation: seriesLabelFadeOutAnimation2,\n  animationValidation: animationValidation6,\n  isFiniteNumber: isFiniteNumber7\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { BandScale: BandScale4 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scale;\nvar { Sector: Sector5, SectorBox: SectorBox4, motion: motion7 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar { angleBetween: angleBetween4, isNumber: isNumber2, sanitizeHtml: sanitizeHtml10 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar RadialBarSeriesNodeEvent = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.angleKey = series.properties.angleKey;\n    this.radiusKey = series.properties.radiusKey;\n  }\n};\nvar RadialBarSeries = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.PolarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      useLabelLayer: true,\n      canHaveAxes: true,\n      animationResetFns: {\n        item: resetRadialBarSelectionsFn,\n        label: resetLabelFn2\n      }\n    });\n    this.properties = new RadialBarSeriesProperties();\n    this.NodeEvent = RadialBarSeriesNodeEvent;\n    this.groupScale = new BandScale4();\n    this.circleCache = { r: 0, cx: 0, cy: 0 };\n  }\n  nodeFactory() {\n    return new Sector5();\n  }\n  addChartEventListeners() {\n    this.destroyFns.push(\n      this.ctx.chartEventManager?.addListener(\"legend-item-click\", (event) => this.onLegendItemClick(event)),\n      this.ctx.chartEventManager?.addListener(\n        \"legend-item-double-click\",\n        (event) => this.onLegendItemDoubleClick(event)\n      )\n    );\n  }\n  getSeriesDomain(direction) {\n    const { axes, dataModel, processedData } = this;\n    if (!processedData || !dataModel)\n      return [];\n    if (direction === ChartAxisDirection18.X) {\n      const angleAxis = axes[ChartAxisDirection18.X];\n      const xExtent = dataModel.getDomain(this, \"angleValue-end\", \"value\", processedData);\n      const fixedXExtent = [xExtent[0] > 0 ? 0 : xExtent[0], xExtent[1] < 0 ? 0 : xExtent[1]];\n      return fixNumericExtent6(fixedXExtent, angleAxis);\n    } else {\n      return dataModel.getDomain(this, \"radiusValue\", \"key\", processedData);\n    }\n  }\n  async processData(dataController) {\n    const { angleKey, radiusKey, normalizedTo, visible } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    if (!this.properties.isValid() || !(visible || animationEnabled))\n      return;\n    const stackGroupId = this.getStackId();\n    const stackGroupTrailingId = `${stackGroupId}-trailing`;\n    const extraProps = [];\n    if (isDefined4(normalizedTo)) {\n      extraProps.push(normaliseGroupTo2([stackGroupId, stackGroupTrailingId], Math.abs(normalizedTo), \"range\"));\n    }\n    if (animationEnabled) {\n      if (this.processedData) {\n        extraProps.push(diff5(this.processedData));\n      }\n      extraProps.push(animationValidation6());\n    }\n    const visibleProps = this.visible || !animationEnabled ? {} : { forceValue: 0 };\n    const radiusScaleType = this.axes[ChartAxisDirection18.Y]?.scale.type;\n    const angleScaleType = this.axes[ChartAxisDirection18.X]?.scale.type;\n    await this.requestDataModel(dataController, this.data, {\n      props: [\n        keyProperty6(radiusKey, radiusScaleType, { id: \"radiusValue\" }),\n        valueProperty13(angleKey, angleScaleType, {\n          id: \"angleValue-raw\",\n          invalidValue: null,\n          ...visibleProps\n        }),\n        ...groupAccumulativeValueProperty3(\n          angleKey,\n          \"normal\",\n          \"current\",\n          {\n            id: `angleValue-end`,\n            rangeId: `angleValue-range`,\n            invalidValue: null,\n            groupId: stackGroupId,\n            separateNegative: true,\n            ...visibleProps\n          },\n          angleScaleType\n        ),\n        ...groupAccumulativeValueProperty3(\n          angleKey,\n          \"trailing\",\n          \"current\",\n          {\n            id: `angleValue-start`,\n            invalidValue: null,\n            groupId: stackGroupTrailingId,\n            separateNegative: true,\n            ...visibleProps\n          },\n          angleScaleType\n        ),\n        ...extraProps\n      ]\n    });\n    this.animationState.transition(\"updateData\");\n  }\n  didCircleChange() {\n    const r = this.radius;\n    const cx = this.centerX;\n    const cy = this.centerY;\n    const cache = this.circleCache;\n    if (!(r === cache.r && cx === cache.cx && cy === cache.cy)) {\n      this.circleCache = { r, cx, cy };\n      return true;\n    }\n    return false;\n  }\n  async maybeRefreshNodeData() {\n    const circleChanged = this.didCircleChange();\n    if (!circleChanged && !this.nodeDataRefresh)\n      return;\n    const { nodeData = [] } = await this.createNodeData() ?? {};\n    this.nodeData = nodeData;\n    this.nodeDataRefresh = false;\n  }\n  getAxisInnerRadius() {\n    const radiusAxis = this.axes[ChartAxisDirection18.Y];\n    return radiusAxis instanceof PolarAxis3 ? this.radius * radiusAxis.innerRadiusRatio : 0;\n  }\n  async createNodeData() {\n    const { processedData, dataModel } = this;\n    if (!processedData || !dataModel || !this.properties.isValid()) {\n      return;\n    }\n    const angleAxis = this.axes[ChartAxisDirection18.X];\n    const radiusAxis = this.axes[ChartAxisDirection18.Y];\n    const angleScale = angleAxis?.scale;\n    const radiusScale = radiusAxis?.scale;\n    if (!angleScale || !radiusScale) {\n      return;\n    }\n    const angleStartIndex = dataModel.resolveProcessedDataIndexById(this, `angleValue-start`);\n    const angleEndIndex = dataModel.resolveProcessedDataIndexById(this, `angleValue-end`);\n    const angleRangeIndex = dataModel.resolveProcessedDataIndexById(this, `angleValue-range`);\n    const angleRawIndex = dataModel.resolveProcessedDataIndexById(this, `angleValue-raw`);\n    let groupPaddingInner = 0;\n    if (radiusAxis instanceof RadiusCategoryAxis) {\n      groupPaddingInner = radiusAxis.groupPaddingInner;\n    }\n    const { groupScale } = this;\n    const { index: groupIndex, visibleGroupCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);\n    groupScale.domain = Array.from({ length: visibleGroupCount }).map((_, i) => String(i));\n    groupScale.range = [0, Math.abs(radiusScale.bandwidth ?? 0)];\n    groupScale.paddingInner = visibleGroupCount > 1 ? groupPaddingInner : 0;\n    const barWidth = groupScale.bandwidth >= 1 ? groupScale.bandwidth : groupScale.rawBandwidth;\n    const angleAxisReversed = angleAxis.isReversed();\n    const radiusAxisReversed = radiusAxis.isReversed();\n    const axisInnerRadius = radiusAxisReversed ? this.radius : this.getAxisInnerRadius();\n    const axisOuterRadius = radiusAxisReversed ? this.getAxisInnerRadius() : this.radius;\n    const axisTotalRadius = axisOuterRadius + axisInnerRadius;\n    const { angleKey, radiusKey, angleName, radiusName, label } = this.properties;\n    const getLabelNodeDatum = (datum, angleDatum, x, y) => {\n      const labelText = this.getLabelText(\n        label,\n        { value: angleDatum, datum, angleKey, radiusKey, angleName, radiusName },\n        (value) => isFiniteNumber7(value) ? value.toFixed(2) : String(value)\n      );\n      if (labelText) {\n        return { x, y, text: labelText, textAlign: \"center\", textBaseline: \"middle\" };\n      }\n    };\n    const nodeData = [];\n    const context = { itemId: radiusKey, nodeData, labelData: nodeData };\n    if (!this.visible)\n      return context;\n    processedData.data.forEach((group, index) => {\n      const { datum, keys, values, aggValues } = group;\n      const radiusDatum = keys[0];\n      const angleDatum = values[angleRawIndex];\n      const isPositive = angleDatum >= 0 && !Object.is(angleDatum, -0);\n      const angleStartDatum = values[angleStartIndex];\n      const angleEndDatum = values[angleEndIndex];\n      const angleRange = aggValues?.[angleRangeIndex][isPositive ? 1 : 0] ?? 0;\n      const reversed = isPositive === angleAxisReversed;\n      let startAngle = angleScale.convert(angleStartDatum, { clampMode: \"clamped\" });\n      let endAngle = angleScale.convert(angleEndDatum, { clampMode: \"clamped\" });\n      let rangeStartAngle = angleScale.convert(0, { clampMode: \"clamped\" });\n      let rangeEndAngle = angleScale.convert(angleRange, { clampMode: \"clamped\" });\n      if (reversed) {\n        [rangeStartAngle, rangeEndAngle] = [rangeEndAngle, rangeStartAngle];\n        [startAngle, endAngle] = [endAngle, startAngle];\n      }\n      const dataRadius = axisTotalRadius - radiusScale.convert(radiusDatum);\n      const innerRadius = dataRadius + groupScale.convert(String(groupIndex));\n      const outerRadius = innerRadius + barWidth;\n      const midRadius = (innerRadius + outerRadius) / 2;\n      const midAngle = startAngle + angleBetween4(startAngle, endAngle) / 2;\n      const x = Math.cos(midAngle) * midRadius;\n      const y = Math.sin(midAngle) * midRadius;\n      const labelNodeDatum = this.properties.label.enabled ? getLabelNodeDatum(datum, angleDatum, x, y) : void 0;\n      const clipSector = new SectorBox4(startAngle, endAngle, innerRadius, outerRadius);\n      nodeData.push({\n        series: this,\n        datum,\n        point: { x, y, size: 0 },\n        midPoint: { x, y },\n        label: labelNodeDatum,\n        angleValue: angleDatum,\n        radiusValue: radiusDatum,\n        innerRadius,\n        outerRadius,\n        startAngle: rangeStartAngle,\n        endAngle: rangeEndAngle,\n        clipSector,\n        reversed,\n        index\n      });\n    });\n    return context;\n  }\n  async update({ seriesRect }) {\n    const resize = this.checkResize(seriesRect);\n    await this.maybeRefreshNodeData();\n    this.contentGroup.translationX = this.centerX;\n    this.contentGroup.translationY = this.centerY;\n    this.highlightGroup.translationX = this.centerX;\n    this.highlightGroup.translationY = this.centerY;\n    if (this.labelGroup) {\n      this.labelGroup.translationX = this.centerX;\n      this.labelGroup.translationY = this.centerY;\n    }\n    this.updateSectorSelection(this.itemSelection, false);\n    this.updateSectorSelection(this.highlightSelection, true);\n    this.updateLabels();\n    if (resize) {\n      this.animationState.transition(\"resize\");\n    }\n    this.animationState.transition(\"update\");\n  }\n  updateSectorSelection(selection, highlighted) {\n    let selectionData = [];\n    if (highlighted) {\n      const activeHighlight = this.ctx.highlightManager?.getActiveHighlight();\n      if (activeHighlight?.datum && activeHighlight.series === this) {\n        selectionData = [activeHighlight];\n      }\n    } else {\n      selectionData = this.nodeData;\n    }\n    const {\n      fill,\n      fillOpacity,\n      stroke,\n      strokeOpacity,\n      strokeWidth,\n      lineDash,\n      lineDashOffset,\n      cornerRadius,\n      angleKey,\n      radiusKey\n    } = mergeDefaults8(highlighted ? this.properties.highlightStyle.item : null, this.properties);\n    const idFn = (datum) => datum.radiusValue;\n    selection.update(selectionData, void 0, idFn).each((node, datum) => {\n      const format = this.properties.itemStyler ? this.ctx.callbackCache.call(this.properties.itemStyler, {\n        seriesId: this.id,\n        datum: datum.datum,\n        highlighted,\n        angleKey,\n        radiusKey,\n        fill,\n        fillOpacity,\n        stroke,\n        strokeWidth,\n        strokeOpacity,\n        lineDash,\n        lineDashOffset,\n        cornerRadius\n      }) : void 0;\n      node.fill = format?.fill ?? fill;\n      node.fillOpacity = format?.fillOpacity ?? fillOpacity;\n      node.stroke = format?.stroke ?? stroke;\n      node.strokeWidth = format?.strokeWidth ?? strokeWidth;\n      node.strokeOpacity = format?.strokeOpacity ?? strokeOpacity;\n      node.lineDash = format?.lineDash ?? lineDash;\n      node.lineDashOffset = format?.lineDashOffset ?? lineDashOffset;\n      node.lineJoin = \"round\";\n      node.inset = stroke != null ? (format?.strokeWidth ?? strokeWidth) / 2 : 0;\n      node.startInnerCornerRadius = datum.reversed ? format?.cornerRadius ?? cornerRadius : 0;\n      node.startOuterCornerRadius = datum.reversed ? format?.cornerRadius ?? cornerRadius : 0;\n      node.endInnerCornerRadius = datum.reversed ? 0 : format?.cornerRadius ?? cornerRadius;\n      node.endOuterCornerRadius = datum.reversed ? 0 : format?.cornerRadius ?? cornerRadius;\n      if (highlighted) {\n        node.startAngle = datum.startAngle;\n        node.endAngle = datum.endAngle;\n        node.clipSector = datum.clipSector;\n        node.innerRadius = datum.innerRadius;\n        node.outerRadius = datum.outerRadius;\n      }\n    });\n  }\n  updateLabels() {\n    const { label } = this.properties;\n    this.labelSelection.update(this.nodeData).each((node, datum) => {\n      if (label.enabled && datum.label) {\n        node.x = datum.label.x;\n        node.y = datum.label.y;\n        node.fill = label.color;\n        node.fontFamily = label.fontFamily;\n        node.fontSize = label.fontSize;\n        node.fontStyle = label.fontStyle;\n        node.fontWeight = label.fontWeight;\n        node.text = datum.label.text;\n        node.textAlign = datum.label.textAlign;\n        node.textBaseline = datum.label.textBaseline;\n        node.visible = true;\n      } else {\n        node.visible = false;\n      }\n    });\n  }\n  getBarTransitionFunctions() {\n    const angleScale = this.axes[ChartAxisDirection18.X]?.scale;\n    let axisZeroAngle = 0;\n    if (!angleScale) {\n      return prepareRadialBarSeriesAnimationFunctions(axisZeroAngle);\n    }\n    const d0 = Math.min(angleScale.domain[0], angleScale.domain[1]);\n    const d1 = Math.max(angleScale.domain[0], angleScale.domain[1]);\n    if (d0 <= 0 && d1 >= 0) {\n      axisZeroAngle = angleScale.convert(0);\n    }\n    return prepareRadialBarSeriesAnimationFunctions(axisZeroAngle);\n  }\n  animateEmptyUpdateReady() {\n    const { labelSelection } = this;\n    const fns = this.getBarTransitionFunctions();\n    motion7.fromToMotion(this.id, \"datums\", this.ctx.animationManager, [this.itemSelection], fns);\n    seriesLabelFadeInAnimation4(this, \"labels\", this.ctx.animationManager, labelSelection);\n  }\n  animateClearingUpdateEmpty() {\n    const { itemSelection } = this;\n    const { animationManager } = this.ctx;\n    const fns = this.getBarTransitionFunctions();\n    motion7.fromToMotion(this.id, \"datums\", animationManager, [itemSelection], fns);\n    seriesLabelFadeOutAnimation2(this, \"labels\", animationManager, this.labelSelection);\n  }\n  getTooltipHtml(nodeDatum) {\n    const { id: seriesId, axes, dataModel } = this;\n    const {\n      angleKey,\n      angleName,\n      radiusKey,\n      radiusName,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      cornerRadius,\n      itemStyler,\n      tooltip\n    } = this.properties;\n    const { angleValue, radiusValue, datum, itemId } = nodeDatum;\n    const xAxis = axes[ChartAxisDirection18.X];\n    const yAxis = axes[ChartAxisDirection18.Y];\n    if (!this.properties.isValid() || !(xAxis && yAxis && isNumber2(angleValue)) || !dataModel) {\n      return ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.EMPTY_TOOLTIP_CONTENT;\n    }\n    const angleString = xAxis.formatDatum(angleValue);\n    const radiusString = yAxis.formatDatum(radiusValue);\n    const title = sanitizeHtml10(angleName);\n    const content = sanitizeHtml10(`${radiusString}: ${angleString}`);\n    const { fill: color } = (itemStyler && this.ctx.callbackCache.call(itemStyler, {\n      highlighted: false,\n      seriesId,\n      datum,\n      angleKey,\n      radiusKey,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      cornerRadius\n    })) ?? { fill };\n    return tooltip.toTooltipHtml(\n      { title, backgroundColor: fill, content },\n      {\n        seriesId,\n        datum,\n        color,\n        title,\n        angleKey,\n        radiusKey,\n        angleName,\n        radiusName,\n        angleValue,\n        itemId,\n        radiusValue\n      }\n    );\n  }\n  pickNodeClosestDatum(point) {\n    return this.pickNodeNearestDistantObject(point, this.itemSelection.nodes());\n  }\n  getLegendData(legendType) {\n    if (!this.data?.length || !this.properties.isValid() || legendType !== \"category\") {\n      return [];\n    }\n    const { angleKey, angleName, fill, stroke, fillOpacity, strokeOpacity, strokeWidth, visible } = this.properties;\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: angleKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: angleName ?? angleKey\n        },\n        symbols: [\n          {\n            marker: {\n              fill: fill ?? \"rgba(0, 0, 0, 0)\",\n              stroke: stroke ?? \"rgba(0, 0, 0, 0)\",\n              fillOpacity: fillOpacity ?? 1,\n              strokeOpacity: strokeOpacity ?? 1,\n              strokeWidth\n            }\n          }\n        ]\n      }\n    ];\n  }\n  onLegendItemClick(event) {\n    const { enabled, itemId, series } = event;\n    if (series.id === this.id) {\n      this.toggleSeriesItem(itemId, enabled);\n    }\n  }\n  onLegendItemDoubleClick(event) {\n    const { enabled, itemId, series, numVisibleItems } = event;\n    const wasClicked = series.id === this.id;\n    const newEnabled = wasClicked || enabled && numVisibleItems === 1;\n    this.toggleSeriesItem(itemId, newEnabled);\n  }\n  computeLabelsBBox() {\n    return null;\n  }\n  getStackId() {\n    const groupIndex = this.seriesGrouping?.groupIndex ?? this.id;\n    return `radialBar-stack-${groupIndex}-xValues`;\n  }\n};\nRadialBarSeries.className = \"RadialBarSeries\";\nRadialBarSeries.type = \"radial-bar\";\n\n// packages/ag-charts-enterprise/src/series/radial-bar/radialBarThemes.ts\n\nvar RADIAL_BAR_SERIES_THEME = {\n  series: {\n    strokeWidth: 0,\n    label: {\n      enabled: false,\n      fontSize: 12,\n      fontFamily: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_FONT_FAMILY,\n      color: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_INVERTED_LABEL_COLOUR\n    }\n  },\n  axes: {\n    [ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POLAR_AXIS_TYPE.RADIUS_CATEGORY]: {\n      innerRadiusRatio: 0.2,\n      groupPaddingInner: 0.2,\n      paddingInner: 0.2,\n      paddingOuter: 0.1\n    }\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/radial-bar/radialBarModule.ts\nvar RadialBarModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"polar\"],\n  identifier: \"radial-bar\",\n  instanceConstructor: RadialBarSeries,\n  tooltipDefaults: { range: \"exact\" },\n  defaultAxes: [\n    {\n      type: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POLAR_AXIS_TYPE.ANGLE_NUMBER\n    },\n    {\n      type: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POLAR_AXIS_TYPE.RADIUS_CATEGORY\n    }\n  ],\n  themeTemplate: RADIAL_BAR_SERIES_THEME,\n  paletteFactory: ({ takeColors }) => {\n    const {\n      fills: [fill],\n      strokes: [stroke]\n    } = takeColors(1);\n    return {\n      fill,\n      stroke\n    };\n  },\n  stackable: true,\n  groupable: true\n};\n\n// packages/ag-charts-enterprise/src/series/radial-column/radialColumnModule.ts\n\n\n// packages/ag-charts-enterprise/src/series/radial-column/radialColumnSeries.ts\n\n\n// packages/ag-charts-enterprise/src/series/radial-column/radialColumnSeriesProperties.ts\n\nvar { Validate: Validate55, RATIO: RATIO26 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar RadialColumnSeriesProperties = class extends RadialColumnSeriesBaseProperties {\n};\n__decorateClass([\n  Validate55(RATIO26, { optional: true })\n], RadialColumnSeriesProperties.prototype, \"columnWidthRatio\", 2);\n__decorateClass([\n  Validate55(RATIO26, { optional: true })\n], RadialColumnSeriesProperties.prototype, \"maxColumnWidthRatio\", 2);\n\n// packages/ag-charts-enterprise/src/series/radial-column/radialColumnSeries.ts\nvar { ChartAxisDirection: ChartAxisDirection19, PolarAxis: PolarAxis4 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { RadialColumnShape, getRadialColumnWidth } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar RadialColumnSeries = class extends RadialColumnSeriesBase {\n  constructor(moduleCtx) {\n    super(moduleCtx, {\n      animationResetFns: {\n        item: resetRadialColumnSelectionFn\n      }\n    });\n    this.properties = new RadialColumnSeriesProperties();\n  }\n  getStackId() {\n    const groupIndex = this.seriesGrouping?.groupIndex ?? this.id;\n    return `radarColumn-stack-${groupIndex}-yValues`;\n  }\n  nodeFactory() {\n    return new RadialColumnShape();\n  }\n  getColumnTransitionFunctions() {\n    const axisZeroRadius = this.isRadiusAxisReversed() ? this.radius : this.getAxisInnerRadius();\n    return prepareRadialColumnAnimationFunctions(axisZeroRadius);\n  }\n  isRadiusAxisCircle() {\n    const radiusAxis = this.axes[ChartAxisDirection19.Y];\n    return radiusAxis instanceof PolarAxis4 ? radiusAxis.shape === \"circle\" : false;\n  }\n  updateItemPath(node, datum, highlight) {\n    node.isBeveled = this.isRadiusAxisCircle();\n    node.isRadiusAxisReversed = this.isRadiusAxisReversed();\n    if (highlight) {\n      node.innerRadius = datum.innerRadius;\n      node.outerRadius = datum.outerRadius;\n      node.startAngle = datum.startAngle;\n      node.endAngle = datum.endAngle;\n      node.columnWidth = datum.columnWidth;\n      node.axisInnerRadius = datum.axisInnerRadius;\n      node.axisOuterRadius = datum.axisOuterRadius;\n    }\n  }\n  getColumnWidth(startAngle, endAngle) {\n    const { columnWidthRatio = 0.5, maxColumnWidthRatio = 0.5 } = this.properties;\n    return getRadialColumnWidth(startAngle, endAngle, this.radius, columnWidthRatio, maxColumnWidthRatio);\n  }\n};\nRadialColumnSeries.className = \"RadialColumnSeries\";\nRadialColumnSeries.type = \"radial-column\";\n\n// packages/ag-charts-enterprise/src/series/radial-column/radialColumnThemes.ts\n\nvar RADIAL_COLUMN_SERIES_THEME = {\n  series: {\n    columnWidthRatio: 0.5,\n    maxColumnWidthRatio: 0.5,\n    strokeWidth: 0,\n    label: {\n      enabled: false,\n      fontSize: 12,\n      fontFamily: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_FONT_FAMILY,\n      color: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_LABEL_COLOUR\n    }\n  },\n  axes: {\n    [ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POLAR_AXIS_TYPE.ANGLE_CATEGORY]: {\n      shape: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POLAR_AXIS_SHAPE.CIRCLE,\n      groupPaddingInner: 0,\n      paddingInner: 0,\n      label: {\n        padding: 10\n      }\n    },\n    [ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POLAR_AXIS_TYPE.RADIUS_NUMBER]: {\n      shape: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POLAR_AXIS_SHAPE.CIRCLE,\n      innerRadiusRatio: 0.5\n    }\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/radial-column/radialColumnModule.ts\nvar RadialColumnModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"polar\"],\n  identifier: \"radial-column\",\n  instanceConstructor: RadialColumnSeries,\n  tooltipDefaults: { range: \"exact\" },\n  defaultAxes: [\n    {\n      type: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POLAR_AXIS_TYPE.ANGLE_CATEGORY\n    },\n    {\n      type: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POLAR_AXIS_TYPE.RADIUS_NUMBER\n    }\n  ],\n  themeTemplate: RADIAL_COLUMN_SERIES_THEME,\n  paletteFactory: ({ takeColors }) => {\n    const {\n      fills: [fill],\n      strokes: [stroke]\n    } = takeColors(1);\n    return {\n      fill,\n      stroke\n    };\n  },\n  stackable: true,\n  groupable: true\n};\n\n// packages/ag-charts-enterprise/src/series/range-area/rangeAreaModule.ts\n\n\n// packages/ag-charts-enterprise/src/series/range-area/rangeArea.ts\n\n\n// packages/ag-charts-enterprise/src/series/range-area/rangeAreaProperties.ts\n\nvar { DropShadow, Label: Label10 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar {\n  CartesianSeriesProperties: CartesianSeriesProperties2,\n  InterpolationProperties,\n  SeriesMarker: SeriesMarker2,\n  SeriesTooltip: SeriesTooltip14,\n  Validate: Validate56,\n  BOOLEAN: BOOLEAN18,\n  COLOR_STRING: COLOR_STRING21,\n  LINE_DASH: LINE_DASH17,\n  OBJECT: OBJECT24,\n  PLACEMENT,\n  POSITIVE_NUMBER: POSITIVE_NUMBER24,\n  RATIO: RATIO27,\n  STRING: STRING23\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar RangeAreaSeriesLabel = class extends Label10 {\n  constructor() {\n    super(...arguments);\n    this.placement = \"outside\";\n    this.padding = 6;\n  }\n};\n__decorateClass([\n  Validate56(PLACEMENT)\n], RangeAreaSeriesLabel.prototype, \"placement\", 2);\n__decorateClass([\n  Validate56(POSITIVE_NUMBER24)\n], RangeAreaSeriesLabel.prototype, \"padding\", 2);\nvar RangeAreaProperties = class extends CartesianSeriesProperties2 {\n  constructor() {\n    super(...arguments);\n    this.fill = \"#99CCFF\";\n    this.fillOpacity = 1;\n    this.stroke = \"#99CCFF\";\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.interpolation = new InterpolationProperties();\n    this.shadow = new DropShadow().set({ enabled: false });\n    this.marker = new SeriesMarker2();\n    this.label = new RangeAreaSeriesLabel();\n    this.tooltip = new SeriesTooltip14();\n    this.connectMissingData = false;\n  }\n};\n__decorateClass([\n  Validate56(STRING23)\n], RangeAreaProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate56(STRING23)\n], RangeAreaProperties.prototype, \"yLowKey\", 2);\n__decorateClass([\n  Validate56(STRING23)\n], RangeAreaProperties.prototype, \"yHighKey\", 2);\n__decorateClass([\n  Validate56(STRING23, { optional: true })\n], RangeAreaProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate56(STRING23, { optional: true })\n], RangeAreaProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate56(STRING23, { optional: true })\n], RangeAreaProperties.prototype, \"yLowName\", 2);\n__decorateClass([\n  Validate56(STRING23, { optional: true })\n], RangeAreaProperties.prototype, \"yHighName\", 2);\n__decorateClass([\n  Validate56(COLOR_STRING21)\n], RangeAreaProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate56(RATIO27)\n], RangeAreaProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate56(COLOR_STRING21)\n], RangeAreaProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate56(POSITIVE_NUMBER24)\n], RangeAreaProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate56(RATIO27)\n], RangeAreaProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate56(LINE_DASH17)\n], RangeAreaProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate56(POSITIVE_NUMBER24)\n], RangeAreaProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate56(OBJECT24)\n], RangeAreaProperties.prototype, \"interpolation\", 2);\n__decorateClass([\n  Validate56(OBJECT24)\n], RangeAreaProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate56(OBJECT24)\n], RangeAreaProperties.prototype, \"marker\", 2);\n__decorateClass([\n  Validate56(OBJECT24)\n], RangeAreaProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate56(OBJECT24)\n], RangeAreaProperties.prototype, \"tooltip\", 2);\n__decorateClass([\n  Validate56(BOOLEAN18)\n], RangeAreaProperties.prototype, \"connectMissingData\", 2);\n\n// packages/ag-charts-enterprise/src/series/range-area/rangeArea.ts\nvar {\n  valueProperty: valueProperty14,\n  keyProperty: keyProperty7,\n  ChartAxisDirection: ChartAxisDirection20,\n  mergeDefaults: mergeDefaults9,\n  updateLabelNode,\n  fixNumericExtent: fixNumericExtent7,\n  AreaSeriesTag,\n  buildResetPathFn,\n  resetLabelFn: resetLabelFn3,\n  resetMarkerFn: resetMarkerFn2,\n  resetMarkerPositionFn,\n  pathSwipeInAnimation,\n  resetMotion,\n  markerSwipeScaleInAnimation,\n  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation5,\n  animationValidation: animationValidation7,\n  diff: diff6,\n  updateClipPath,\n  isFiniteNumber: isFiniteNumber8,\n  computeMarkerFocusBounds: computeMarkerFocusBounds3,\n  plotPath,\n  pathRanges,\n  pathRangePoints,\n  pathRangePointsReverse\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { getMarker: getMarker3, PointerEvents: PointerEvents7 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar { sanitizeHtml: sanitizeHtml11, extent: extent4 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar RangeAreaSeriesNodeEvent = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.xKey = series.properties.xKey;\n    this.yLowKey = series.properties.yLowKey;\n    this.yHighKey = series.properties.yHighKey;\n  }\n};\nvar RangeAreaSeries = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      hasMarkers: true,\n      pathsPerSeries: 2,\n      directionKeys: {\n        [ChartAxisDirection20.X]: [\"xKey\"],\n        [ChartAxisDirection20.Y]: [\"yLowKey\", \"yHighKey\"]\n      },\n      directionNames: {\n        [ChartAxisDirection20.X]: [\"xName\"],\n        [ChartAxisDirection20.Y]: [\"yLowName\", \"yHighName\", \"yName\"]\n      },\n      animationResetFns: {\n        path: buildResetPathFn({ getOpacity: () => this.getOpacity() }),\n        label: resetLabelFn3,\n        marker: (node, datum) => ({ ...resetMarkerFn2(node), ...resetMarkerPositionFn(node, datum) })\n      }\n    });\n    this.properties = new RangeAreaProperties();\n    this.NodeEvent = RangeAreaSeriesNodeEvent;\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid() || !this.visible)\n      return;\n    const { xKey, yLowKey, yHighKey } = this.properties;\n    const xScale = this.axes[ChartAxisDirection20.X]?.scale;\n    const yScale = this.axes[ChartAxisDirection20.Y]?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const extraProps = [];\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    if (!this.ctx.animationManager.isSkipped() && this.processedData) {\n      extraProps.push(diff6(this.processedData));\n    }\n    if (animationEnabled) {\n      extraProps.push(animationValidation7());\n    }\n    await this.requestDataModel(dataController, this.data, {\n      props: [\n        keyProperty7(xKey, xScaleType, { id: `xValue` }),\n        valueProperty14(yLowKey, yScaleType, { id: `yLowValue`, invalidValue: void 0 }),\n        valueProperty14(yHighKey, yScaleType, { id: `yHighValue`, invalidValue: void 0 }),\n        ...extraProps\n      ]\n    });\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel, axes } = this;\n    if (!(processedData && dataModel))\n      return [];\n    const {\n      domain: {\n        keys: [keys],\n        values\n      }\n    } = processedData;\n    if (direction === ChartAxisDirection20.X) {\n      const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n      const xAxis = axes[ChartAxisDirection20.X];\n      if (keyDef?.def.type === \"key\" && keyDef.def.valueType === \"category\") {\n        return keys;\n      }\n      return fixNumericExtent7(extent4(keys), xAxis);\n    } else {\n      const yLowIndex = dataModel.resolveProcessedDataIndexById(this, \"yLowValue\");\n      const yLowExtent = values[yLowIndex];\n      const yHighIndex = dataModel.resolveProcessedDataIndexById(this, \"yHighValue\");\n      const yHighExtent = values[yHighIndex];\n      const fixedYExtent = [\n        yLowExtent[0] > yHighExtent[0] ? yHighExtent[0] : yLowExtent[0],\n        yHighExtent[1] < yLowExtent[1] ? yLowExtent[1] : yHighExtent[1]\n      ];\n      return fixNumericExtent7(fixedYExtent);\n    }\n  }\n  async createNodeData() {\n    const { data, dataModel, axes, visible } = this;\n    const xAxis = axes[ChartAxisDirection20.X];\n    const yAxis = axes[ChartAxisDirection20.Y];\n    if (!(data && visible && xAxis && yAxis && dataModel)) {\n      return;\n    }\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const { xKey, yLowKey, yHighKey, connectMissingData, marker } = this.properties;\n    const itemId = `${yLowKey}-${yHighKey}`;\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const defs = dataModel.resolveProcessedDataDefsByIds(this, [`xValue`, `yHighValue`, `yLowValue`]);\n    const createCoordinates = (xValue, yHigh, yLow, moveTo2) => {\n      const x = xScale.convert(xValue) + xOffset;\n      const yHighCoordinate = yScale.convert(yHigh);\n      const yLowCoordinate = yScale.convert(yLow);\n      const { size } = marker;\n      return [\n        {\n          point: { x, y: yHighCoordinate, moveTo: moveTo2 },\n          size,\n          itemId: `high`,\n          yValue: yHigh,\n          xValue,\n          enabled: true\n        },\n        {\n          point: { x, y: yLowCoordinate, moveTo: moveTo2 },\n          size,\n          itemId: `low`,\n          yValue: yLow,\n          xValue,\n          enabled: false\n        }\n      ];\n    };\n    const labelData = [];\n    const markerData = [];\n    const strokeData = { itemId, highPoints: [], lowPoints: [] };\n    const fillData = { itemId, highPoints: [], lowPoints: [] };\n    const context = {\n      itemId,\n      labelData,\n      nodeData: markerData,\n      fillData,\n      strokeData,\n      scales: this.calculateScaling(),\n      visible: this.visible\n    };\n    if (!this.visible)\n      return context;\n    const fillHighPoints = fillData.highPoints;\n    const fillLowPoints = fillData.lowPoints;\n    const strokeHighPoints = strokeData.highPoints;\n    const strokeLowPoints = strokeData.lowPoints;\n    let moveTo = true;\n    this.processedData?.data.forEach(({ keys, datum, values }, datumIdx) => {\n      const dataValues = dataModel.resolveProcessedDataDefsValues(defs, { keys, values });\n      const { xValue, yHighValue, yLowValue } = dataValues;\n      const invalidRange = yHighValue == null || yLowValue == null;\n      const points = invalidRange ? [] : createCoordinates(xValue, yHighValue, yLowValue, false);\n      const inverted = yLowValue > yHighValue;\n      points.forEach(({ point: { x, y }, enabled, size, itemId: datumItemId = \"\", yValue }) => {\n        markerData.push({\n          index: datumIdx,\n          series: this,\n          itemId: datumItemId,\n          datum,\n          midPoint: { x, y },\n          yHighValue,\n          yLowValue,\n          xValue,\n          xKey,\n          yLowKey,\n          yHighKey,\n          point: { x, y, size },\n          enabled\n        });\n        const labelDatum = this.createLabelData({\n          point: { x, y },\n          value: yValue,\n          yLowValue,\n          yHighValue,\n          itemId: datumItemId,\n          inverted,\n          datum,\n          series: this\n        });\n        labelData.push(labelDatum);\n      });\n      const xValid = xValue != null;\n      const yValid = yHighValue != null && yLowValue != null;\n      const [high, low] = createCoordinates(xValue, yHighValue ?? 0, yLowValue ?? 0, moveTo);\n      if (xValid && yValid) {\n        fillHighPoints.push(high);\n        fillLowPoints.push(low);\n        strokeHighPoints.push(high);\n        strokeLowPoints.push(low);\n        moveTo = false;\n      } else if (!connectMissingData) {\n        moveTo = true;\n      }\n    });\n    return context;\n  }\n  createLabelData({\n    point,\n    value,\n    itemId,\n    inverted,\n    datum,\n    series\n  }) {\n    const { xKey, yLowKey, yHighKey, xName, yName, yLowName, yHighName, label } = this.properties;\n    const { placement, padding = 10 } = label;\n    let actualItemId = itemId;\n    if (inverted) {\n      actualItemId = itemId === \"low\" ? \"high\" : \"low\";\n    }\n    const direction = placement === \"outside\" && actualItemId === \"high\" || placement === \"inside\" && actualItemId === \"low\" ? -1 : 1;\n    return {\n      x: point.x,\n      y: point.y + padding * direction,\n      series,\n      itemId,\n      datum,\n      text: this.getLabelText(\n        label,\n        { value, datum, itemId, xKey, yLowKey, yHighKey, xName, yLowName, yHighName, yName },\n        (v) => isFiniteNumber8(v) ? v.toFixed(2) : String(v)\n      ),\n      textAlign: \"center\",\n      textBaseline: direction === -1 ? \"bottom\" : \"top\"\n    };\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  markerFactory() {\n    const { shape } = this.properties.marker;\n    const MarkerShape = getMarker3(shape);\n    return new MarkerShape();\n  }\n  async updatePathNodes(opts) {\n    const { opacity, visible } = opts;\n    const [fill, stroke] = opts.paths;\n    const strokeWidth = this.getStrokeWidth(this.properties.strokeWidth);\n    stroke.setProperties({\n      tag: AreaSeriesTag.Stroke,\n      fill: void 0,\n      lineJoin: stroke.lineCap = \"round\",\n      pointerEvents: PointerEvents7.None,\n      stroke: this.properties.stroke,\n      strokeWidth,\n      strokeOpacity: this.properties.strokeOpacity,\n      lineDash: this.properties.lineDash,\n      lineDashOffset: this.properties.lineDashOffset,\n      opacity,\n      visible\n    });\n    fill.setProperties({\n      tag: AreaSeriesTag.Fill,\n      stroke: void 0,\n      lineJoin: \"round\",\n      pointerEvents: PointerEvents7.None,\n      fill: this.properties.fill,\n      fillOpacity: this.properties.fillOpacity,\n      lineDash: this.properties.lineDash,\n      lineDashOffset: this.properties.lineDashOffset,\n      strokeOpacity: this.properties.strokeOpacity,\n      fillShadow: this.properties.shadow,\n      strokeWidth,\n      opacity,\n      visible\n    });\n    updateClipPath(this, stroke);\n    updateClipPath(this, fill);\n  }\n  async updatePaths(opts) {\n    this.updateAreaPaths(opts.paths, opts.contextData);\n  }\n  updateAreaPaths(paths, contextData) {\n    this.updateFillPath(paths, contextData);\n    this.updateStrokePath(paths, contextData);\n  }\n  updateFillPath(paths, contextData) {\n    const { interpolation } = this.properties;\n    const { fillData } = contextData;\n    const [fill] = paths;\n    fill.path.clear();\n    for (const range2 of pathRanges(fillData.highPoints)) {\n      plotPath(pathRangePoints(fillData.highPoints, range2), fill, interpolation);\n      plotPath(pathRangePointsReverse(fillData.lowPoints, range2), fill, interpolation, true);\n      fill.path.closePath();\n    }\n    fill.checkPathDirty();\n  }\n  updateStrokePath(paths, contextData) {\n    const { interpolation } = this.properties;\n    const { strokeData } = contextData;\n    const [, stroke] = paths;\n    stroke.path.clear(true);\n    for (const range2 of pathRanges(strokeData.highPoints)) {\n      plotPath(pathRangePoints(strokeData.highPoints, range2), stroke, interpolation);\n      plotPath(pathRangePoints(strokeData.lowPoints, range2), stroke, interpolation);\n    }\n    stroke.checkPathDirty();\n  }\n  async updateMarkerSelection(opts) {\n    const { nodeData, markerSelection } = opts;\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    return markerSelection.update(this.properties.marker.enabled ? nodeData : []);\n  }\n  async updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yLowKey, yHighKey, marker, fill, stroke, strokeWidth, fillOpacity, strokeOpacity } = this.properties;\n    const baseStyle = mergeDefaults9(highlighted && this.properties.highlightStyle.item, marker.getStyle(), {\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity\n    });\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yHighKey, yLowKey }, baseStyle);\n    });\n    if (!highlighted) {\n      this.properties.marker.markClean();\n    }\n  }\n  async updateLabelSelection(opts) {\n    const { labelData, labelSelection } = opts;\n    return labelSelection.update(labelData, (text) => {\n      text.tag = AreaSeriesTag.Label;\n      text.pointerEvents = PointerEvents7.None;\n    });\n  }\n  async updateLabelNodes(opts) {\n    opts.labelSelection.each((textNode, datum) => {\n      updateLabelNode(textNode, this.properties.label, datum);\n    });\n  }\n  getHighlightLabelData(labelData, highlightedItem) {\n    const labelItems = labelData.filter((ld) => ld.datum === highlightedItem.datum);\n    return labelItems.length > 0 ? labelItems : void 0;\n  }\n  getHighlightData(nodeData, highlightedItem) {\n    const highlightItems = nodeData.filter((nodeDatum) => nodeDatum.datum === highlightedItem.datum);\n    return highlightItems.length > 0 ? highlightItems : void 0;\n  }\n  getTooltipHtml(nodeDatum) {\n    const xAxis = this.axes[ChartAxisDirection20.X];\n    const yAxis = this.axes[ChartAxisDirection20.Y];\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.EMPTY_TOOLTIP_CONTENT;\n    }\n    const { id: seriesId } = this;\n    const { xKey, yLowKey, yHighKey, xName, yName, yLowName, yHighName, fill, tooltip } = this.properties;\n    const { datum, itemId, xValue, yLowValue, yHighValue } = nodeDatum;\n    const color = fill ?? \"gray\";\n    const xString = sanitizeHtml11(xAxis.formatDatum(xValue));\n    const yLowString = sanitizeHtml11(yAxis.formatDatum(yLowValue));\n    const yHighString = sanitizeHtml11(yAxis.formatDatum(yHighValue));\n    const xSubheading = xName ?? xKey;\n    const yLowSubheading = yLowName ?? yLowKey;\n    const yHighSubheading = yHighName ?? yHighKey;\n    const title = sanitizeHtml11(yName);\n    const content = yName ? `<b>${sanitizeHtml11(xSubheading)}</b>: ${xString}<br><b>${sanitizeHtml11(yLowSubheading)}</b>: ${yLowString}<br><b>${sanitizeHtml11(yHighSubheading)}</b>: ${yHighString}<br>` : `${xString}: ${yLowString} - ${yHighString}`;\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        seriesId,\n        itemId,\n        datum,\n        xKey,\n        yLowKey,\n        yHighKey,\n        xName,\n        yLowName,\n        yHighName,\n        yName,\n        color,\n        title,\n        yHighValue,\n        yLowValue\n      }\n    );\n  }\n  getLegendData(legendType) {\n    if (legendType !== \"category\") {\n      return [];\n    }\n    const {\n      yLowKey,\n      yHighKey,\n      yName,\n      yLowName,\n      yHighName,\n      fill,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      visible,\n      marker\n    } = this.properties;\n    const legendItemText = yName ?? `${yLowName ?? yLowKey} - ${yHighName ?? yHighKey}`;\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: `${yLowKey}-${yHighKey}`,\n        seriesId: this.id,\n        enabled: visible,\n        label: { text: `${legendItemText}` },\n        symbols: [\n          {\n            marker: {\n              shape: marker.shape,\n              fill: marker.fill ?? fill,\n              stroke: marker.stroke ?? stroke,\n              fillOpacity: marker.fillOpacity,\n              strokeOpacity: marker.strokeOpacity,\n              strokeWidth: marker.strokeWidth\n            },\n            line: {\n              stroke,\n              strokeOpacity,\n              strokeWidth,\n              lineDash\n            }\n          }\n        ]\n      }\n    ];\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  onDataChange() {\n  }\n  nodeFactory() {\n    return new ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Group();\n  }\n  animateEmptyUpdateReady(animationData) {\n    const { markerSelection, labelSelection, contextData, paths } = animationData;\n    const { animationManager } = this.ctx;\n    this.updateAreaPaths(paths, contextData);\n    pathSwipeInAnimation(this, animationManager, ...paths);\n    resetMotion([markerSelection], resetMarkerPositionFn);\n    markerSwipeScaleInAnimation(this, animationManager, markerSelection);\n    seriesLabelFadeInAnimation5(this, \"labels\", animationManager, labelSelection);\n  }\n  animateReadyResize(animationData) {\n    const { contextData, paths } = animationData;\n    this.updateAreaPaths(paths, contextData);\n    super.animateReadyResize(animationData);\n  }\n  animateWaitingUpdateReady(animationData) {\n    const { contextData, paths } = animationData;\n    super.animateWaitingUpdateReady(animationData);\n    this.updateAreaPaths(paths, contextData);\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yLowKey, yHighKey } = this.properties;\n    return this.getMarkerStyle(this.properties.marker, { datum, xKey, yLowKey, yHighKey, highlighted: true });\n  }\n  computeFocusBounds(opts) {\n    const hiBox = computeMarkerFocusBounds3(this, opts);\n    const loBox = computeMarkerFocusBounds3(this, { ...opts, datumIndex: opts.datumIndex + 1 });\n    if (hiBox && loBox) {\n      return ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.BBox.merge([hiBox, loBox]);\n    }\n    return void 0;\n  }\n};\nRangeAreaSeries.className = \"RangeAreaSeries\";\nRangeAreaSeries.type = \"range-area\";\n\n// packages/ag-charts-enterprise/src/series/range-area/rangeAreaThemes.ts\n\nvar RANGE_AREA_SERIES_THEME = {\n  series: {\n    fillOpacity: 0.7,\n    nodeClickRange: \"nearest\",\n    marker: {\n      enabled: false,\n      size: 6,\n      strokeWidth: 2\n    },\n    label: {\n      enabled: false,\n      placement: \"outside\",\n      padding: 10,\n      fontSize: 12,\n      fontFamily: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_FONT_FAMILY,\n      color: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_LABEL_COLOUR\n    },\n    interpolation: {\n      type: \"linear\",\n      // @ts-expect-error - users shouldn't specify all options, but we have to for theming to work\n      tension: 1,\n      position: \"end\"\n    }\n  },\n  axes: {\n    [ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.CARTESIAN_AXIS_TYPE.NUMBER]: {\n      crosshair: { enabled: true }\n    }\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/range-area/rangeAreaModule.ts\nvar { markerPaletteFactory: markerPaletteFactory2 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar RangeAreaModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"range-area\",\n  instanceConstructor: RangeAreaSeries,\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.CARTESIAN_AXIS_TYPE.NUMBER,\n      position: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POSITION.LEFT\n    },\n    {\n      type: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.CARTESIAN_AXIS_TYPE.CATEGORY,\n      position: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POSITION.BOTTOM\n    }\n  ],\n  themeTemplate: RANGE_AREA_SERIES_THEME,\n  paletteFactory: (params) => {\n    const { marker } = markerPaletteFactory2(params);\n    return {\n      fill: marker.fill,\n      stroke: marker.stroke,\n      marker\n    };\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/range-bar/rangeBarModule.ts\n\n\n// packages/ag-charts-enterprise/src/series/range-bar/rangeBarSeries.ts\n\n\n// packages/ag-charts-enterprise/src/series/range-bar/rangeBarProperties.ts\n\nvar { DropShadow: DropShadow2, Label: Label11 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar {\n  AbstractBarSeriesProperties: AbstractBarSeriesProperties4,\n  SeriesTooltip: SeriesTooltip15,\n  Validate: Validate57,\n  COLOR_STRING: COLOR_STRING22,\n  FUNCTION: FUNCTION16,\n  LINE_DASH: LINE_DASH18,\n  OBJECT: OBJECT25,\n  PLACEMENT: PLACEMENT2,\n  POSITIVE_NUMBER: POSITIVE_NUMBER25,\n  RATIO: RATIO28,\n  STRING: STRING24\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar RangeBarSeriesLabel = class extends Label11 {\n  constructor() {\n    super(...arguments);\n    this.placement = \"inside\";\n    this.padding = 6;\n  }\n};\n__decorateClass([\n  Validate57(PLACEMENT2)\n], RangeBarSeriesLabel.prototype, \"placement\", 2);\n__decorateClass([\n  Validate57(POSITIVE_NUMBER25)\n], RangeBarSeriesLabel.prototype, \"padding\", 2);\nvar RangeBarProperties = class extends AbstractBarSeriesProperties4 {\n  constructor() {\n    super(...arguments);\n    this.fill = \"#99CCFF\";\n    this.fillOpacity = 1;\n    this.stroke = \"#99CCFF\";\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.shadow = new DropShadow2().set({ enabled: false });\n    this.label = new RangeBarSeriesLabel();\n    this.tooltip = new SeriesTooltip15();\n  }\n};\n__decorateClass([\n  Validate57(STRING24)\n], RangeBarProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate57(STRING24)\n], RangeBarProperties.prototype, \"yLowKey\", 2);\n__decorateClass([\n  Validate57(STRING24)\n], RangeBarProperties.prototype, \"yHighKey\", 2);\n__decorateClass([\n  Validate57(STRING24, { optional: true })\n], RangeBarProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate57(STRING24, { optional: true })\n], RangeBarProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate57(STRING24, { optional: true })\n], RangeBarProperties.prototype, \"yLowName\", 2);\n__decorateClass([\n  Validate57(STRING24, { optional: true })\n], RangeBarProperties.prototype, \"yHighName\", 2);\n__decorateClass([\n  Validate57(COLOR_STRING22)\n], RangeBarProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate57(RATIO28)\n], RangeBarProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate57(COLOR_STRING22)\n], RangeBarProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate57(POSITIVE_NUMBER25)\n], RangeBarProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate57(RATIO28)\n], RangeBarProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate57(LINE_DASH18)\n], RangeBarProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate57(POSITIVE_NUMBER25)\n], RangeBarProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate57(POSITIVE_NUMBER25)\n], RangeBarProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate57(FUNCTION16, { optional: true })\n], RangeBarProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate57(OBJECT25)\n], RangeBarProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate57(OBJECT25)\n], RangeBarProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate57(OBJECT25)\n], RangeBarProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-enterprise/src/series/range-bar/rangeBarSeries.ts\nvar {\n  SeriesNodePickMode: SeriesNodePickMode12,\n  valueProperty: valueProperty15,\n  keyProperty: keyProperty8,\n  ChartAxisDirection: ChartAxisDirection21,\n  getRectConfig,\n  updateRect,\n  checkCrisp,\n  updateLabelNode: updateLabelNode2,\n  SMALLEST_KEY_INTERVAL: SMALLEST_KEY_INTERVAL3,\n  LARGEST_KEY_INTERVAL,\n  diff: diff7,\n  prepareBarAnimationFunctions: prepareBarAnimationFunctions2,\n  midpointStartingBarPosition,\n  resetBarSelectionsFn: resetBarSelectionsFn2,\n  fixNumericExtent: fixNumericExtent8,\n  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation6,\n  resetLabelFn: resetLabelFn4,\n  animationValidation: animationValidation8,\n  createDatumId: createDatumId8,\n  isFiniteNumber: isFiniteNumber9,\n  computeBarFocusBounds: computeBarFocusBounds5\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { Rect: Rect4, PointerEvents: PointerEvents8, motion: motion8 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar { sanitizeHtml: sanitizeHtml12, isNumber: isNumber3, extent: extent5 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar { ContinuousScale: ContinuousScale3 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scale;\nvar RangeBarSeriesNodeEvent = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.xKey = series.properties.xKey;\n    this.yLowKey = series.properties.yLowKey;\n    this.yHighKey = series.properties.yHighKey;\n  }\n};\nvar RangeBarSeries = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.AbstractBarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [SeriesNodePickMode12.NEAREST_NODE, SeriesNodePickMode12.EXACT_SHAPE_MATCH],\n      hasHighlightedLabels: true,\n      directionKeys: {\n        x: [\"xKey\"],\n        y: [\"yLowKey\", \"yHighKey\"]\n      },\n      directionNames: {\n        x: [\"xName\"],\n        y: [\"yLowName\", \"yHighName\", \"yName\"]\n      },\n      datumSelectionGarbageCollection: false,\n      animationResetFns: {\n        datum: resetBarSelectionsFn2,\n        label: resetLabelFn4\n      }\n    });\n    this.properties = new RangeBarProperties();\n    this.NodeEvent = RangeBarSeriesNodeEvent;\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid()) {\n      return;\n    }\n    const { xKey, yLowKey, yHighKey } = this.properties;\n    const xScale = this.getCategoryAxis()?.scale;\n    const yScale = this.getValueAxis()?.scale;\n    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const extraProps = [];\n    if (!this.ctx.animationManager.isSkipped()) {\n      if (this.processedData) {\n        extraProps.push(diff7(this.processedData));\n      }\n      extraProps.push(animationValidation8());\n    }\n    const visibleProps = this.visible ? {} : { forceValue: 0 };\n    const { processedData } = await this.requestDataModel(dataController, this.data, {\n      props: [\n        keyProperty8(xKey, xScaleType, { id: \"xValue\" }),\n        valueProperty15(yLowKey, yScaleType, { id: `yLowValue`, ...visibleProps }),\n        valueProperty15(yHighKey, yScaleType, { id: `yHighValue`, ...visibleProps }),\n        ...isContinuousX ? [SMALLEST_KEY_INTERVAL3, LARGEST_KEY_INTERVAL] : [],\n        ...extraProps\n      ],\n      groupByKeys: true\n    });\n    this.smallestDataInterval = processedData.reduced?.smallestKeyInterval;\n    this.largestDataInterval = processedData.reduced?.largestKeyInterval;\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel, smallestDataInterval } = this;\n    if (!(processedData && dataModel))\n      return [];\n    const {\n      domain: {\n        keys: [keys],\n        values\n      }\n    } = processedData;\n    if (direction === this.getCategoryDirection()) {\n      const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n      if (keyDef?.def.type === \"key\" && keyDef?.def.valueType === \"category\") {\n        return keys;\n      }\n      const scalePadding = isFiniteNumber9(smallestDataInterval) ? smallestDataInterval : 0;\n      const keysExtent = extent5(keys) ?? [NaN, NaN];\n      const categoryAxis = this.getCategoryAxis();\n      const d0 = keysExtent[0] + -scalePadding;\n      const d1 = keysExtent[1] + scalePadding;\n      return fixNumericExtent8([d0, d1], categoryAxis);\n    } else {\n      const yLowIndex = dataModel.resolveProcessedDataIndexById(this, \"yLowValue\");\n      const yLowExtent = values[yLowIndex];\n      const yHighIndex = dataModel.resolveProcessedDataIndexById(this, \"yHighValue\");\n      const yHighExtent = values[yHighIndex];\n      const fixedYExtent = [\n        yLowExtent[0] > yHighExtent[0] ? yHighExtent[0] : yLowExtent[0],\n        yHighExtent[1] < yLowExtent[1] ? yLowExtent[1] : yHighExtent[1]\n      ];\n      return fixNumericExtent8(fixedYExtent);\n    }\n  }\n  async createNodeData() {\n    const {\n      data,\n      dataModel,\n      groupScale,\n      processedData,\n      properties: { visible }\n    } = this;\n    const xAxis = this.getCategoryAxis();\n    const yAxis = this.getValueAxis();\n    if (!(data && xAxis && yAxis && dataModel)) {\n      return;\n    }\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const barAlongX = this.getBarDirection() === ChartAxisDirection21.X;\n    const { xKey, yLowKey, yHighKey, fill, stroke, strokeWidth } = this.properties;\n    const itemId = `${yLowKey}-${yHighKey}`;\n    const context = {\n      itemId,\n      nodeData: [],\n      labelData: [],\n      scales: this.calculateScaling(),\n      visible: this.visible\n    };\n    if (!visible)\n      return context;\n    const yLowIndex = dataModel.resolveProcessedDataIndexById(this, `yLowValue`);\n    const yHighIndex = dataModel.resolveProcessedDataIndexById(this, `yHighValue`);\n    const xIndex = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const { barWidth, groupIndex } = this.updateGroupScale(xAxis);\n    const barOffset = ContinuousScale3.is(xScale) ? barWidth * -0.5 : 0;\n    processedData?.data.forEach(({ keys, datum, values }, dataIndex) => {\n      values.forEach((value, valueIndex) => {\n        const xDatum = keys[xIndex];\n        const x = Math.round(xScale.convert(xDatum)) + groupScale.convert(String(groupIndex)) + barOffset;\n        const rawLowValue = value[yLowIndex];\n        const rawHighValue = value[yHighIndex];\n        if (!ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util.isNumber(rawHighValue) || !ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util.isNumber(rawLowValue)) {\n          return;\n        }\n        const yLowValue = Math.min(rawLowValue, rawHighValue);\n        const yHighValue = Math.max(rawLowValue, rawHighValue);\n        const yLow = Math.round(yScale.convert(yLowValue));\n        const yHigh = Math.round(yScale.convert(yHighValue));\n        const y = yHigh;\n        const bottomY = yLow;\n        const barHeight = Math.max(strokeWidth, Math.abs(bottomY - y));\n        const rect = {\n          x: barAlongX ? Math.min(y, bottomY) : x,\n          y: barAlongX ? x : Math.min(y, bottomY),\n          width: barAlongX ? barHeight : barWidth,\n          height: barAlongX ? barWidth : barHeight\n        };\n        const nodeMidPoint = {\n          x: rect.x + rect.width / 2,\n          y: rect.y + rect.height / 2\n        };\n        const labelData = this.createLabelData({\n          rect,\n          barAlongX,\n          yLowValue,\n          yHighValue,\n          datum: datum[valueIndex],\n          series: this\n        });\n        const nodeDatum = {\n          index: dataIndex,\n          valueIndex,\n          series: this,\n          itemId,\n          datum: datum[valueIndex],\n          xValue: xDatum,\n          yLowValue: rawLowValue,\n          yHighValue: rawHighValue,\n          yLowKey,\n          yHighKey,\n          xKey,\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height,\n          midPoint: nodeMidPoint,\n          fill,\n          stroke,\n          strokeWidth,\n          opacity: 1,\n          labels: labelData\n        };\n        context.nodeData.push(nodeDatum);\n        context.labelData.push(...labelData);\n      });\n    });\n    return context;\n  }\n  createLabelData({\n    rect,\n    barAlongX,\n    yLowValue,\n    yHighValue,\n    datum,\n    series\n  }) {\n    const { xKey, yLowKey, yHighKey, xName, yLowName, yHighName, yName, label } = this.properties;\n    const labelParams = { datum, xKey, yLowKey, yHighKey, xName, yLowName, yHighName, yName };\n    const { placement, padding } = label;\n    const paddingDirection = placement === \"outside\" ? 1 : -1;\n    const labelPadding = padding * paddingDirection;\n    const yLowLabel = {\n      x: rect.x + (barAlongX ? -labelPadding : rect.width / 2),\n      y: rect.y + (barAlongX ? rect.height / 2 : rect.height + labelPadding),\n      textAlign: barAlongX ? \"left\" : \"center\",\n      textBaseline: barAlongX ? \"middle\" : \"bottom\",\n      text: this.getLabelText(\n        label,\n        { itemId: \"low\", value: yLowValue, ...labelParams },\n        (v) => isFiniteNumber9(v) ? v.toFixed(2) : String(v)\n      ),\n      itemId: \"low\",\n      datum,\n      series\n    };\n    const yHighLabel = {\n      x: rect.x + (barAlongX ? rect.width + labelPadding : rect.width / 2),\n      y: rect.y + (barAlongX ? rect.height / 2 : -labelPadding),\n      textAlign: barAlongX ? \"right\" : \"center\",\n      textBaseline: barAlongX ? \"middle\" : \"top\",\n      text: this.getLabelText(\n        label,\n        { itemId: \"high\", value: yHighValue, ...labelParams },\n        (value) => isNumber3(value) ? value.toFixed(2) : \"\"\n      ),\n      itemId: \"high\",\n      datum,\n      series\n    };\n    if (placement === \"outside\") {\n      yLowLabel.textAlign = barAlongX ? \"right\" : \"center\";\n      yLowLabel.textBaseline = barAlongX ? \"middle\" : \"top\";\n      yHighLabel.textAlign = barAlongX ? \"left\" : \"center\";\n      yHighLabel.textBaseline = barAlongX ? \"middle\" : \"bottom\";\n    }\n    return [yLowLabel, yHighLabel];\n  }\n  nodeFactory() {\n    return new Rect4();\n  }\n  async updateDatumSelection(opts) {\n    const { nodeData, datumSelection } = opts;\n    const data = nodeData ?? [];\n    return datumSelection.update(data, void 0, (datum) => this.getDatumId(datum));\n  }\n  async updateDatumNodes(opts) {\n    const { datumSelection, isHighlight } = opts;\n    const { id: seriesId, ctx } = this;\n    const {\n      yLowKey,\n      yHighKey,\n      highlightStyle: { item: itemHighlightStyle }\n    } = this.properties;\n    const xAxis = this.axes[ChartAxisDirection21.X];\n    const crisp = checkCrisp(\n      xAxis?.scale,\n      xAxis?.visibleRange,\n      this.smallestDataInterval,\n      this.largestDataInterval\n    );\n    const categoryAlongX = this.getCategoryDirection() === ChartAxisDirection21.X;\n    datumSelection.each((rect, datum) => {\n      const {\n        fillOpacity,\n        strokeOpacity,\n        strokeWidth,\n        lineDash,\n        lineDashOffset,\n        itemStyler,\n        shadow: fillShadow\n      } = this.properties;\n      const style = {\n        fill: datum.fill,\n        stroke: datum.stroke,\n        fillOpacity,\n        strokeOpacity,\n        lineDash,\n        lineDashOffset,\n        fillShadow,\n        strokeWidth: this.getStrokeWidth(strokeWidth),\n        cornerRadius: this.properties.cornerRadius\n      };\n      const visible = categoryAlongX ? datum.width > 0 : datum.height > 0;\n      const config = getRectConfig({\n        datum,\n        isHighlighted: isHighlight,\n        style,\n        highlightStyle: itemHighlightStyle,\n        itemStyler,\n        seriesId,\n        ctx,\n        yLowKey,\n        yHighKey\n      });\n      config.crisp = crisp;\n      config.visible = visible;\n      updateRect({ rect, config });\n    });\n  }\n  getHighlightLabelData(labelData, highlightedItem) {\n    const labelItems = labelData.filter((ld) => ld.datum === highlightedItem.datum);\n    return labelItems.length > 0 ? labelItems : void 0;\n  }\n  async updateLabelSelection(opts) {\n    const labelData = this.properties.label.enabled ? opts.labelData : [];\n    return opts.labelSelection.update(labelData, (text) => {\n      text.pointerEvents = PointerEvents8.None;\n    });\n  }\n  async updateLabelNodes(opts) {\n    opts.labelSelection.each((textNode, datum) => {\n      updateLabelNode2(textNode, this.properties.label, datum);\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const {\n      id: seriesId,\n      ctx: { callbackCache }\n    } = this;\n    const xAxis = this.getCategoryAxis();\n    const yAxis = this.getValueAxis();\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.EMPTY_TOOLTIP_CONTENT;\n    }\n    const {\n      xKey,\n      yLowKey,\n      yHighKey,\n      xName,\n      yLowName,\n      yHighName,\n      yName,\n      fill,\n      strokeWidth,\n      itemStyler,\n      tooltip,\n      fillOpacity,\n      stroke,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      cornerRadius\n    } = this.properties;\n    const { datum, xValue, yLowValue, yHighValue } = nodeDatum;\n    let format;\n    if (itemStyler) {\n      format = callbackCache.call(itemStyler, {\n        highlighted: false,\n        seriesId,\n        datum,\n        xKey,\n        yLowKey,\n        yHighKey,\n        fill,\n        fillOpacity,\n        stroke,\n        strokeWidth,\n        strokeOpacity,\n        lineDash,\n        lineDashOffset,\n        cornerRadius\n      });\n    }\n    const color = format?.fill ?? fill ?? \"gray\";\n    const xString = sanitizeHtml12(xAxis.formatDatum(xValue));\n    const yLowString = sanitizeHtml12(yAxis.formatDatum(yLowValue));\n    const yHighString = sanitizeHtml12(yAxis.formatDatum(yHighValue));\n    const xSubheading = xName ?? xKey;\n    const yLowSubheading = yLowName ?? yLowKey;\n    const yHighSubheading = yHighName ?? yHighKey;\n    const title = sanitizeHtml12(yName);\n    const content = yName ? `<b>${sanitizeHtml12(xSubheading)}</b>: ${xString}<br><b>${sanitizeHtml12(yLowSubheading)}</b>: ${yLowString}<br><b>${sanitizeHtml12(yHighSubheading)}</b>: ${yHighString}<br>` : `${xString}: ${yLowString} - ${yHighString}`;\n    const defaults = {\n      title,\n      content,\n      backgroundColor: color\n    };\n    return tooltip.toTooltipHtml(defaults, {\n      itemId: void 0,\n      datum,\n      xKey,\n      xName,\n      yLowKey,\n      yLowName,\n      yHighKey,\n      yHighName,\n      yName,\n      color,\n      seriesId,\n      title\n    });\n  }\n  getLegendData(legendType) {\n    const { id, visible } = this;\n    if (legendType !== \"category\") {\n      return [];\n    }\n    const { fill, stroke, strokeWidth, fillOpacity, strokeOpacity, yName, yLowName, yHighName, yLowKey, yHighKey } = this.properties;\n    const legendItemText = yName ?? `${yLowName ?? yLowKey} - ${yHighName ?? yHighKey}`;\n    return [\n      {\n        legendType: \"category\",\n        id,\n        itemId: `${yLowKey}-${yHighKey}`,\n        seriesId: id,\n        enabled: visible,\n        label: { text: `${legendItemText}` },\n        symbols: [{ marker: { fill, stroke, fillOpacity, strokeOpacity, strokeWidth } }]\n      }\n    ];\n  }\n  animateEmptyUpdateReady({ datumSelection, labelSelection }) {\n    const fns = prepareBarAnimationFunctions2(midpointStartingBarPosition(this.isVertical(), \"normal\"));\n    motion8.fromToMotion(this.id, \"datums\", this.ctx.animationManager, [datumSelection], fns);\n    seriesLabelFadeInAnimation6(this, \"labels\", this.ctx.animationManager, labelSelection);\n  }\n  animateWaitingUpdateReady(data) {\n    const { datumSelection: datumSelections, labelSelection: labelSelections } = data;\n    const { processedData } = this;\n    const dataDiff = processedData?.reduced?.diff;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    const fns = prepareBarAnimationFunctions2(midpointStartingBarPosition(this.isVertical(), \"fade\"));\n    motion8.fromToMotion(\n      this.id,\n      \"datums\",\n      this.ctx.animationManager,\n      [datumSelections],\n      fns,\n      (_, datum) => createDatumId8(datum.xValue, datum.valueIndex),\n      dataDiff\n    );\n    seriesLabelFadeInAnimation6(this, \"labels\", this.ctx.animationManager, labelSelections);\n  }\n  getDatumId(datum) {\n    return `${datum.xValue}-${datum.valueIndex}`;\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  onDataChange() {\n  }\n  computeFocusBounds({ datumIndex, seriesRect }) {\n    return computeBarFocusBounds5(this.contextNodeData?.nodeData[datumIndex], this.contentGroup, seriesRect);\n  }\n};\nRangeBarSeries.className = \"RangeBarSeries\";\nRangeBarSeries.type = \"range-bar\";\n\n// packages/ag-charts-enterprise/src/series/range-bar/rangeBarThemes.ts\n\nvar RANGE_BAR_SERIES_THEME = {\n  series: {\n    direction: \"vertical\",\n    strokeWidth: 0,\n    label: {\n      enabled: false,\n      fontSize: 12,\n      fontFamily: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_FONT_FAMILY,\n      color: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n      placement: \"inside\"\n    }\n  },\n  axes: {\n    [ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.CARTESIAN_AXIS_TYPE.NUMBER]: {\n      crosshair: { enabled: true }\n    }\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/range-bar/rangeBarModule.ts\nvar RangeBarModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"range-bar\",\n  instanceConstructor: RangeBarSeries,\n  tooltipDefaults: { range: \"exact\" },\n  defaultAxes: [\n    {\n      type: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.CARTESIAN_AXIS_TYPE.CATEGORY,\n      position: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POSITION.BOTTOM\n    },\n    {\n      type: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.CARTESIAN_AXIS_TYPE.NUMBER,\n      position: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POSITION.LEFT\n    }\n  ],\n  themeTemplate: RANGE_BAR_SERIES_THEME,\n  paletteFactory: ({ takeColors }) => {\n    const {\n      fills: [fill],\n      strokes: [stroke]\n    } = takeColors(1);\n    return {\n      fill,\n      stroke\n    };\n  },\n  groupable: true,\n  swapDefaultAxesCondition: ({ direction }) => direction === \"horizontal\"\n};\n\n// packages/ag-charts-enterprise/src/series/sankey/sankeyModule.ts\n\n\n// packages/ag-charts-enterprise/src/series/sankey/sankeySeries.ts\n\n\n// packages/ag-charts-enterprise/src/series/sankey/sankeyLayout.ts\nfunction sortNodesByY(column) {\n  column.nodes.sort((a, b) => Math.round((a.datum.y - b.datum.y) * 100) / 100 || -(a.datum.size - b.datum.size));\n}\nfunction justifyNodesAcrossColumn({ nodes, size }, { seriesRectHeight, nodeSpacing, sizeScale }) {\n  const nodesHeight = seriesRectHeight * size * sizeScale;\n  const outerPadding = (seriesRectHeight - (nodesHeight + nodeSpacing * (nodes.length - 1))) / 2;\n  let y = outerPadding;\n  nodes.forEach(({ datum: node }) => {\n    const height = seriesRectHeight * node.size * sizeScale;\n    node.y = y;\n    node.height = height;\n    y += height + nodeSpacing;\n  });\n}\nfunction separateNodesInColumn(column, layout) {\n  const { nodes } = column;\n  const { seriesRectHeight, nodeSpacing } = layout;\n  sortNodesByY(column);\n  let totalShift = 0;\n  let currentTop = 0;\n  for (let i = 0; i < nodes.length; i += 1) {\n    const { datum: node } = nodes[i];\n    const shift = Math.max(currentTop - node.y, 0);\n    node.y += shift;\n    totalShift += shift;\n    currentTop = node.y + node.height + nodeSpacing;\n  }\n  const lastNodeBottom = currentTop - nodeSpacing;\n  if (lastNodeBottom < seriesRectHeight) {\n    return totalShift > 0;\n  }\n  let currentBottom = seriesRectHeight;\n  for (let i = nodes.length - 1; i >= 0; i -= 1) {\n    const { datum: node } = nodes[i];\n    const nodeBottom = node.y + node.height;\n    const shift = Math.min(currentBottom - nodeBottom, 0);\n    node.y += shift;\n    totalShift += shift;\n    currentBottom = node.y - nodeSpacing;\n  }\n  return true;\n}\nfunction hasCrossOver(x00, y00, x01, y01, x10, y10, x11, y11) {\n  const recM0 = (x01 - x00) / (y01 - y00);\n  const recM1 = (x11 - x10) / (y11 - y10);\n  const x = ((y10 - y00) * (recM0 * recM1) + x00 * recM1 - x10 * recM0) / (recM1 - recM0);\n  if (x00 < x01) {\n    return x > x00 && x < Math.min(x01, x11);\n  } else {\n    return x < x00 && x > Math.max(x01, x11);\n  }\n}\nfunction removeColumnCrossoversInDirection(column, getLinks) {\n  let didShift = false;\n  const singleCrossoverColumns = column.nodes.filter((node) => getLinks(node).length === 1);\n  let didRemoveCrossover = true;\n  for (let runs = 0; didRemoveCrossover && runs < singleCrossoverColumns.length; runs += 1) {\n    didRemoveCrossover = false;\n    for (let i = 0; i < singleCrossoverColumns.length - 1; i += 1) {\n      const { datum: node } = singleCrossoverColumns[i];\n      const nodeAfter = getLinks(singleCrossoverColumns[i])[0].node.datum;\n      const { datum: otherNode } = singleCrossoverColumns[i + 1];\n      const otherNodeAfter = getLinks(singleCrossoverColumns[i + 1])[0].node.datum;\n      const crossover = hasCrossOver(\n        node.x,\n        node.y,\n        nodeAfter.x,\n        nodeAfter.y,\n        otherNode.x,\n        otherNode.y,\n        otherNodeAfter.x,\n        otherNodeAfter.y\n      ) || hasCrossOver(\n        node.x,\n        node.y + node.height / 2,\n        nodeAfter.x,\n        nodeAfter.y + nodeAfter.height / 2,\n        otherNode.x,\n        otherNode.y + otherNode.height / 2,\n        otherNodeAfter.x,\n        otherNodeAfter.y + otherNodeAfter.height / 2\n      ) || hasCrossOver(\n        node.x,\n        node.y + node.height,\n        nodeAfter.x,\n        nodeAfter.y + nodeAfter.height,\n        otherNode.x,\n        otherNode.y + otherNode.height,\n        otherNodeAfter.x,\n        otherNodeAfter.y + otherNodeAfter.height\n      );\n      if (!crossover)\n        continue;\n      const current = singleCrossoverColumns[i];\n      singleCrossoverColumns[i] = singleCrossoverColumns[i + 1];\n      singleCrossoverColumns[i + 1] = current;\n      const y = node.y;\n      node.y = otherNode.y + otherNode.height - node.height;\n      otherNode.y = y;\n      didShift = true;\n      didRemoveCrossover = true;\n    }\n  }\n  return didShift;\n}\nfunction removeColumnCrossovers(column) {\n  let didShift = false;\n  sortNodesByY(column);\n  didShift = removeColumnCrossoversInDirection(column, (node) => node.linksBefore) || didShift;\n  didShift = removeColumnCrossoversInDirection(column, (node) => node.linksAfter) || didShift;\n  return didShift;\n}\nfunction weightedNodeY(links) {\n  if (links.length === 0)\n    return;\n  let totalYValues = 0;\n  let totalSize = 0;\n  for (const {\n    node: { datum: node }\n  } of links) {\n    totalYValues += node.y * node.size;\n    totalSize += node.size;\n  }\n  return totalYValues / totalSize;\n}\nfunction layoutColumn(column, layout, weight, direction) {\n  column.nodes.forEach(({ datum: node, linksBefore, linksAfter }) => {\n    const forwardLinks = direction === 1 ? linksBefore : linksAfter;\n    const backwardsLinks = direction === 1 ? linksAfter : linksBefore;\n    const nextY = weightedNodeY(forwardLinks);\n    if (nextY != null) {\n      const nodeWeight = backwardsLinks.length !== 0 ? weight : 1;\n      node.y = node.y + (nextY - node.y) * nodeWeight;\n    }\n  });\n  return separateNodesInColumn(column, layout);\n}\nfunction layoutColumnsForward(columns, layout, weight) {\n  let didShift = false;\n  for (let i = 0; i < columns.length; i += 1) {\n    didShift = layoutColumn(columns[i], layout, weight, 1) || didShift;\n  }\n  return didShift;\n}\nfunction layoutColumnsBackwards(columns, layout, weight) {\n  let didShift = false;\n  for (let i = columns.length - 1; i >= 0; i -= 1) {\n    didShift = layoutColumn(columns[i], layout, weight, -1) || didShift;\n  }\n  return didShift;\n}\nfunction removeColumnsCrossovers(columns) {\n  let didShift = false;\n  for (let i = columns.length - 1; i >= 0; i -= 1) {\n    didShift = removeColumnCrossovers(columns[i]) || didShift;\n  }\n  return didShift;\n}\nfunction layoutColumns(columns, layout) {\n  columns.forEach((column) => {\n    justifyNodesAcrossColumn(column, layout);\n  });\n  let didLayoutColumnsBackwards = false;\n  for (let i = 0; i < 6; i += 1) {\n    const didLayoutColumnsForward = layoutColumnsForward(columns, layout, 1);\n    didLayoutColumnsBackwards = layoutColumnsBackwards(columns, layout, 0.5);\n    const didRemoveColumnCrossovers = removeColumnsCrossovers(columns);\n    if (!didLayoutColumnsForward && !didLayoutColumnsBackwards && !didRemoveColumnCrossovers) {\n      break;\n    }\n  }\n  if (didLayoutColumnsBackwards) {\n    layoutColumnsForward(columns, layout, 1);\n    removeColumnsCrossovers(columns);\n  }\n}\n\n// packages/ag-charts-enterprise/src/series/sankey/sankeyLink.ts\n\nvar { BBox: BBox9, Path: Path9, ScenePathChangeDetection: ScenePathChangeDetection3 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nfunction offsetTrivialCubicBezier(path, p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, offset) {\n  let tx, ty;\n  if (p1y !== p0y && p3y !== p2y) {\n    const slope1 = -(p1x - p0x) / (p1y - p0y);\n    const slope2 = -(p3x - p2x) / (p3y - p2y);\n    tx = (p2y - p0y + slope1 * p0x - slope2 * p2x) / (slope1 - slope2);\n    ty = slope1 * (tx - p0x) + p0y;\n  } else if (p1y === p0y && p3y !== p2y) {\n    tx = p0x;\n    const slope2 = -(p3x - p2x) / (p3y - p2y);\n    ty = slope2 * (tx - p3x) + p3y;\n  } else if (p1y !== p0y && p3y === p2y) {\n    tx = p3x;\n    const slope1 = -(p1x - p0x) / (p1y - p0y);\n    ty = slope1 * (tx - p0x) + p0y;\n  } else {\n    throw new Error(\"Offsetting flat bezier curve\");\n  }\n  const d0 = Math.hypot(p0y - ty, p0x - tx);\n  const s0 = (d0 + offset) / d0;\n  const d1 = Math.hypot(p3y - ty, p3x - tx);\n  const s1 = (d1 + offset) / d1;\n  const q1x = tx + (p1x - tx) * s0;\n  const q1y = ty + (p1y - ty) * s0;\n  const q2x = tx + (p2x - tx) * s1;\n  const q2y = ty + (p2y - ty) * s1;\n  const q3x = tx + (p3x - tx) * s1;\n  const q3y = ty + (p3y - ty) * s1;\n  path.cubicCurveTo(q1x, q1y, q2x, q2y, q3x, q3y);\n}\nvar SankeyLink = class extends Path9 {\n  constructor() {\n    super(...arguments);\n    this.x1 = 0;\n    this.x2 = 0;\n    this.y1 = 0;\n    this.y2 = 0;\n    this.height = 0;\n    this.inset = 0;\n  }\n  computeBBox() {\n    const x = Math.min(this.x1, this.x2);\n    const width = Math.max(this.x1, this.x2) - x;\n    const y = Math.min(this.y1, this.y2);\n    const height = Math.max(this.y1, this.y2) - y + this.height;\n    return new BBox9(x, y, width, height);\n  }\n  updatePath() {\n    const { path, inset } = this;\n    path.clear();\n    const x1 = this.x1 + inset;\n    const x2 = this.x2 - inset;\n    const y1 = this.y1 + inset;\n    const y2 = this.y2 + inset;\n    const height = this.height - 2 * inset;\n    if (height < 0 || x1 > x2)\n      return;\n    const p0x = x1;\n    const p0y = y1 + height / 2;\n    const p1x = (x1 + x2) / 2;\n    const p1y = y1 + height / 2;\n    const p2x = (x1 + x2) / 2;\n    const p2y = y2 + height / 2;\n    const p3x = x2;\n    const p3y = y2 + height / 2;\n    path.moveTo(p0x, p0y - height / 2);\n    if (Math.abs(this.y2 - this.y1) < 1 || this.x2 - this.x1 < this.height * Math.SQRT2) {\n      path.cubicCurveTo(p1x, p1y - height / 2, p2x, p2y - height / 2, p3x, p3y - height / 2);\n      path.lineTo(p3x, p3y + height / 2);\n      path.cubicCurveTo(p2x, p2y + height / 2, p1x, p1y + height / 2, p0x, p0y + height / 2);\n    } else {\n      const x01 = 0.5 * p0x + 0.5 * p1x;\n      const y01 = 0.5 * p0y + 0.5 * p1y;\n      const x12 = 0.5 * p1x + 0.5 * p2x;\n      const y12 = 0.5 * p1y + 0.5 * p2y;\n      const x23 = 0.5 * p2x + 0.5 * p3x;\n      const y23 = 0.5 * p2y + 0.5 * p3y;\n      const x012 = 0.5 * x01 + 0.5 * x12;\n      const y012 = 0.5 * y01 + 0.5 * y12;\n      const x123 = 0.5 * x12 + 0.5 * x23;\n      const y123 = 0.5 * y12 + 0.5 * y23;\n      const x0123 = 0.5 * x012 + 0.5 * x123;\n      const y0123 = 0.5 * y012 + 0.5 * y123;\n      const ap0x = p0x;\n      const ap0y = p0y;\n      const ap1x = x01;\n      const ap1y = y01;\n      const ap2x = x012;\n      const ap2y = y012;\n      const ap3x = x0123;\n      const ap3y = y0123;\n      const bp0x = x0123;\n      const bp0y = y0123;\n      const bp1x = x123;\n      const bp1y = y123;\n      const bp2x = x23;\n      const bp2y = y23;\n      const bp3x = p3x;\n      const bp3y = p3y;\n      const offset = (y2 > y1 ? 1 : -1) * height / 2;\n      offsetTrivialCubicBezier(path, ap0x, ap0y, ap1x, ap1y, ap2x, ap2y, ap3x, ap3y, offset);\n      offsetTrivialCubicBezier(path, bp0x, bp0y, bp1x, bp1y, bp2x, bp2y, bp3x, bp3y, -offset);\n      path.lineTo(p3x, p3y + height / 2);\n      offsetTrivialCubicBezier(path, bp3x, bp3y, bp2x, bp2y, bp1x, bp1y, bp0x, bp0y, offset);\n      offsetTrivialCubicBezier(path, ap3x, ap3y, ap2x, ap2y, ap1x, ap1y, ap0x, ap0y, -offset);\n    }\n    path.closePath();\n  }\n};\n__decorateClass([\n  ScenePathChangeDetection3()\n], SankeyLink.prototype, \"x1\", 2);\n__decorateClass([\n  ScenePathChangeDetection3()\n], SankeyLink.prototype, \"x2\", 2);\n__decorateClass([\n  ScenePathChangeDetection3()\n], SankeyLink.prototype, \"y1\", 2);\n__decorateClass([\n  ScenePathChangeDetection3()\n], SankeyLink.prototype, \"y2\", 2);\n__decorateClass([\n  ScenePathChangeDetection3()\n], SankeyLink.prototype, \"height\", 2);\n__decorateClass([\n  ScenePathChangeDetection3()\n], SankeyLink.prototype, \"inset\", 2);\n\n// packages/ag-charts-enterprise/src/series/sankey/sankeySeriesProperties.ts\n\nvar {\n  BaseProperties: BaseProperties15,\n  SeriesTooltip: SeriesTooltip16,\n  SeriesProperties: SeriesProperties10,\n  ARRAY: ARRAY10,\n  COLOR_STRING: COLOR_STRING23,\n  COLOR_STRING_ARRAY: COLOR_STRING_ARRAY6,\n  FUNCTION: FUNCTION17,\n  LINE_DASH: LINE_DASH19,\n  OBJECT: OBJECT26,\n  POSITIVE_NUMBER: POSITIVE_NUMBER26,\n  RATIO: RATIO29,\n  STRING: STRING25,\n  UNION: UNION7,\n  Validate: Validate58\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { Label: Label12 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar ALIGNMENT = UNION7([\"left\", \"right\", \"center\", \"justify\"], \"a justification value\");\nvar SankeySeriesLabelProperties = class extends Label12 {\n  constructor() {\n    super(...arguments);\n    this.spacing = 1;\n  }\n};\n__decorateClass([\n  Validate58(POSITIVE_NUMBER26)\n], SankeySeriesLabelProperties.prototype, \"spacing\", 2);\nvar SankeySeriesLinkProperties = class extends BaseProperties15 {\n  constructor() {\n    super(...arguments);\n    this.fill = void 0;\n    this.fillOpacity = 1;\n    this.stroke = void 0;\n    this.strokeOpacity = 1;\n    this.strokeWidth = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n  }\n};\n__decorateClass([\n  Validate58(COLOR_STRING23, { optional: true })\n], SankeySeriesLinkProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate58(RATIO29)\n], SankeySeriesLinkProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate58(COLOR_STRING23, { optional: true })\n], SankeySeriesLinkProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate58(RATIO29)\n], SankeySeriesLinkProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate58(POSITIVE_NUMBER26)\n], SankeySeriesLinkProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate58(LINE_DASH19)\n], SankeySeriesLinkProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate58(POSITIVE_NUMBER26)\n], SankeySeriesLinkProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate58(FUNCTION17, { optional: true })\n], SankeySeriesLinkProperties.prototype, \"itemStyler\", 2);\nvar SankeySeriesNodeProperties = class extends BaseProperties15 {\n  constructor() {\n    super(...arguments);\n    this.spacing = 1;\n    this.width = 1;\n    this.alignment = \"justify\";\n    this.fill = void 0;\n    this.fillOpacity = 1;\n    this.stroke = void 0;\n    this.strokeOpacity = 1;\n    this.strokeWidth = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n  }\n};\n__decorateClass([\n  Validate58(POSITIVE_NUMBER26)\n], SankeySeriesNodeProperties.prototype, \"spacing\", 2);\n__decorateClass([\n  Validate58(POSITIVE_NUMBER26)\n], SankeySeriesNodeProperties.prototype, \"width\", 2);\n__decorateClass([\n  Validate58(ALIGNMENT)\n], SankeySeriesNodeProperties.prototype, \"alignment\", 2);\n__decorateClass([\n  Validate58(COLOR_STRING23, { optional: true })\n], SankeySeriesNodeProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate58(RATIO29)\n], SankeySeriesNodeProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate58(COLOR_STRING23, { optional: true })\n], SankeySeriesNodeProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate58(RATIO29)\n], SankeySeriesNodeProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate58(POSITIVE_NUMBER26)\n], SankeySeriesNodeProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate58(LINE_DASH19)\n], SankeySeriesNodeProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate58(POSITIVE_NUMBER26)\n], SankeySeriesNodeProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate58(FUNCTION17, { optional: true })\n], SankeySeriesNodeProperties.prototype, \"itemStyler\", 2);\nvar SankeySeriesProperties = class extends SeriesProperties10 {\n  constructor() {\n    super(...arguments);\n    this.nodes = void 0;\n    this.idKey = \"\";\n    this.idName = void 0;\n    this.labelKey = void 0;\n    this.labelName = void 0;\n    this.sizeKey = void 0;\n    this.sizeName = void 0;\n    this.fills = [];\n    this.strokes = [];\n    this.label = new SankeySeriesLabelProperties();\n    this.link = new SankeySeriesLinkProperties();\n    this.node = new SankeySeriesNodeProperties();\n    this.tooltip = new SeriesTooltip16();\n  }\n};\n__decorateClass([\n  Validate58(ARRAY10, { optional: true })\n], SankeySeriesProperties.prototype, \"nodes\", 2);\n__decorateClass([\n  Validate58(STRING25)\n], SankeySeriesProperties.prototype, \"fromKey\", 2);\n__decorateClass([\n  Validate58(STRING25)\n], SankeySeriesProperties.prototype, \"toKey\", 2);\n__decorateClass([\n  Validate58(STRING25)\n], SankeySeriesProperties.prototype, \"idKey\", 2);\n__decorateClass([\n  Validate58(STRING25, { optional: true })\n], SankeySeriesProperties.prototype, \"idName\", 2);\n__decorateClass([\n  Validate58(STRING25, { optional: true })\n], SankeySeriesProperties.prototype, \"labelKey\", 2);\n__decorateClass([\n  Validate58(STRING25, { optional: true })\n], SankeySeriesProperties.prototype, \"labelName\", 2);\n__decorateClass([\n  Validate58(STRING25, { optional: true })\n], SankeySeriesProperties.prototype, \"sizeKey\", 2);\n__decorateClass([\n  Validate58(STRING25, { optional: true })\n], SankeySeriesProperties.prototype, \"sizeName\", 2);\n__decorateClass([\n  Validate58(COLOR_STRING_ARRAY6)\n], SankeySeriesProperties.prototype, \"fills\", 2);\n__decorateClass([\n  Validate58(COLOR_STRING_ARRAY6)\n], SankeySeriesProperties.prototype, \"strokes\", 2);\n__decorateClass([\n  Validate58(OBJECT26)\n], SankeySeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate58(OBJECT26)\n], SankeySeriesProperties.prototype, \"link\", 2);\n__decorateClass([\n  Validate58(OBJECT26)\n], SankeySeriesProperties.prototype, \"node\", 2);\n__decorateClass([\n  Validate58(OBJECT26)\n], SankeySeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-enterprise/src/series/sankey/sankeySeries.ts\nvar { SeriesNodePickMode: SeriesNodePickMode13, createDatumId: createDatumId9, EMPTY_TOOLTIP_CONTENT: EMPTY_TOOLTIP_CONTENT2 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { sanitizeHtml: sanitizeHtml13 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar { Rect: Rect5, Text: Text13, BBox: BBox10 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar SankeySeries = class extends FlowProportionSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      contentGroupVirtual: false,\n      pickModes: [SeriesNodePickMode13.NEAREST_NODE, SeriesNodePickMode13.EXACT_SHAPE_MATCH]\n    });\n    this.properties = new SankeySeriesProperties();\n  }\n  isLabelEnabled() {\n    return (this.properties.labelKey != null || this.nodes == null) && this.properties.label.enabled;\n  }\n  linkFactory() {\n    return new SankeyLink();\n  }\n  nodeFactory() {\n    return new Rect5();\n  }\n  async createNodeData() {\n    const {\n      id: seriesId,\n      _nodeDataDependencies: { seriesRectWidth, seriesRectHeight } = { seriesRectWidth: 0, seriesRectHeight: 0 }\n    } = this;\n    const {\n      fromKey,\n      toKey,\n      sizeKey,\n      label: { spacing: labelSpacing },\n      node: { spacing: nodeSpacing, width: nodeWidth, alignment }\n    } = this.properties;\n    const defaultLabelFormatter = (v) => String(v);\n    const {\n      nodeGraph: baseNodeGraph,\n      links,\n      maxPathLength\n    } = this.getNodeGraph(\n      (node) => {\n        const label = this.getLabelText(\n          this.properties.label,\n          {\n            datum: node.datum,\n            value: node.label,\n            fromKey,\n            toKey,\n            sizeKey\n          },\n          defaultLabelFormatter\n        );\n        return {\n          ...node,\n          label,\n          size: 0,\n          x: NaN,\n          y: NaN,\n          width: nodeWidth,\n          height: NaN\n        };\n      },\n      (link) => ({\n        ...link,\n        x1: NaN,\n        x2: NaN,\n        y1: NaN,\n        y2: NaN,\n        height: NaN\n      }),\n      { includeCircularReferences: false }\n    );\n    const nodeGraph = baseNodeGraph;\n    const inset = this.isLabelEnabled() ? (seriesRectWidth - nodeWidth) * (1 - maxPathLength / (maxPathLength + 1)) : 0;\n    const columnWidth = (seriesRectWidth - nodeWidth - 2 * inset) / (maxPathLength - 1);\n    const columns = [];\n    for (let index = 0; index < maxPathLength; index += 1) {\n      const x = inset + index * columnWidth;\n      columns.push({ index, size: 0, nodes: [], x });\n    }\n    nodeGraph.forEach((graphNode) => {\n      const { datum: node, linksBefore, linksAfter, maxPathLengthBefore, maxPathLengthAfter } = graphNode;\n      const size = Math.max(\n        linksBefore.reduce((acc, { link }) => acc + link.size, 0),\n        linksAfter.reduce((acc, { link }) => acc + link.size, 0)\n      );\n      if (linksBefore.length === 0 && linksAfter.length === 0 || size === 0) {\n        graphNode.columnIndex = -1;\n        return;\n      }\n      let column;\n      switch (alignment) {\n        case \"left\":\n          column = columns[maxPathLengthBefore];\n          break;\n        case \"right\":\n          column = columns[maxPathLength - 1 - maxPathLengthAfter];\n          break;\n        case \"center\": {\n          if (linksBefore.length !== 0) {\n            column = columns[maxPathLengthBefore];\n          } else if (linksAfter.length !== 0) {\n            const columnIndex = linksAfter.reduce(\n              (acc, link) => Math.min(acc, link.node.maxPathLengthBefore),\n              maxPathLength\n            ) - 1;\n            column = columns[columnIndex];\n          } else {\n            column = columns[0];\n          }\n          break;\n        }\n        case \"justify\": {\n          column = linksAfter.length === 0 ? columns[maxPathLength - 1] : columns[maxPathLengthBefore];\n          break;\n        }\n      }\n      node.x = column.x;\n      node.size = size;\n      column.nodes.push(graphNode);\n      column.size += size;\n      graphNode.columnIndex = column.index;\n    });\n    nodeGraph.forEach((graphNode) => {\n      let closestColumnIndex = Infinity;\n      let maxSizeOfClosestNodesAfter = 0;\n      graphNode.linksAfter.forEach((link) => {\n        const node = link.node;\n        const { columnIndex } = node;\n        if (columnIndex < closestColumnIndex) {\n          closestColumnIndex = columnIndex;\n          maxSizeOfClosestNodesAfter = node.datum.size;\n        } else if (columnIndex === closestColumnIndex) {\n          maxSizeOfClosestNodesAfter = Math.max(maxSizeOfClosestNodesAfter, node.datum.size);\n        }\n      });\n      graphNode.closestColumnIndex = closestColumnIndex;\n      graphNode.maxSizeOfClosestNodesAfter = maxSizeOfClosestNodesAfter;\n    });\n    const sizeScale = columns.reduce((acc, { size, nodes }) => {\n      const columnSizeScale = (1 - (nodes.length - 1) * (nodeSpacing / seriesRectHeight)) / size;\n      return Math.min(acc, columnSizeScale);\n    }, Infinity);\n    for (let i = columns.length - 1; i >= 0; i -= 1) {\n      const nodes = columns[i].nodes;\n      nodes.sort(\n        (a, b) => a.closestColumnIndex - b.closestColumnIndex || a.maxSizeOfClosestNodesAfter - b.maxSizeOfClosestNodesAfter || a.datum.size - b.datum.size\n      );\n    }\n    layoutColumns(columns, {\n      seriesRectHeight,\n      nodeSpacing,\n      sizeScale\n    });\n    nodeGraph.forEach(({ datum: node, linksBefore, linksAfter }) => {\n      const bottom = node.y + node.height;\n      const sortNodes = (l) => {\n        return l.sort((a, b) => {\n          const aNode = a.node.datum;\n          const bNode = b.node.datum;\n          const aBottom = aNode.y + aNode.height;\n          const bBottom = bNode.y + bNode.height;\n          const dAngleTop = Math.atan2(aNode.y - node.y, Math.abs(aNode.x - node.x)) - Math.atan2(bNode.y - node.y, Math.abs(bNode.x - node.x));\n          const dAngleBottom = Math.atan2(aBottom - bottom, Math.abs(aNode.x - node.x)) - Math.atan2(bBottom - bottom, Math.abs(bNode.x - node.x));\n          return dAngleTop + dAngleBottom;\n        });\n      };\n      let y2 = node.y;\n      sortNodes(linksBefore).forEach(({ link }) => {\n        link.y2 = y2;\n        y2 += link.size * seriesRectHeight * sizeScale;\n      });\n      let y1 = node.y;\n      sortNodes(linksAfter).forEach(({ link }) => {\n        link.y1 = y1;\n        y1 += link.size * seriesRectHeight * sizeScale;\n      });\n    });\n    const nodeData = [];\n    const labelData = [];\n    const { fontSize } = this.properties.label;\n    const canvasFont = this.properties.label.getFont();\n    columns.forEach((column, index) => {\n      const leading = index === 0;\n      const trailing = index === columns.length - 1;\n      let bottom = -Infinity;\n      column.nodes.sort((a, b) => a.datum.y - b.datum.y);\n      column.nodes.forEach(({ datum: node }) => {\n        node.midPoint = {\n          x: node.x + node.width / 2,\n          y: node.y + node.height / 2\n        };\n        nodeData.push(node);\n        if (node.label == null)\n          return;\n        const x = leading ? node.x - labelSpacing : node.x + node.width + labelSpacing;\n        const y = node.y + node.height / 2;\n        let text;\n        if (!leading && !trailing) {\n          const y12 = y - fontSize * Text13.defaultLineHeightRatio;\n          const y2 = y + fontSize * Text13.defaultLineHeightRatio;\n          let maxX = seriesRectWidth;\n          nodeGraph.forEach(({ datum }) => {\n            const intersectsLabel = datum.x > node.x && Math.max(datum.y, y12) <= Math.min(datum.y + datum.height, y2);\n            if (intersectsLabel) {\n              maxX = Math.min(maxX, datum.x - labelSpacing);\n            }\n          });\n          const maxWidth = maxX - node.x - 2 * labelSpacing;\n          text = Text13.wrap(node.label, maxWidth, node.height, this.properties.label, \"never\", \"hide\");\n        }\n        if (text == null || text === \"\") {\n          const labelInset = leading || trailing ? labelSpacing : labelSpacing * 2;\n          text = Text13.wrap(node.label, columnWidth - labelInset, node.height, this.properties.label, \"never\");\n        }\n        if (text === \"\")\n          return;\n        const { height } = Text13.measureText(text, canvasFont, \"middle\", \"left\");\n        const y0 = y - height / 2;\n        const y1 = y + height / 2;\n        if (y0 >= bottom) {\n          labelData.push({ x, y, leading, text });\n          bottom = y1;\n        }\n      });\n    });\n    links.forEach((link) => {\n      const { fromNode, toNode, size } = link;\n      link.height = seriesRectHeight * size * sizeScale;\n      link.x1 = fromNode.x + nodeWidth;\n      link.x2 = toNode.x;\n      link.midPoint = {\n        x: (link.x1 + link.x2) / 2,\n        y: (link.y1 + link.y2) / 2 + link.height / 2\n      };\n      nodeData.push(link);\n    });\n    return {\n      itemId: seriesId,\n      nodeData,\n      labelData\n    };\n  }\n  async updateLabelSelection(opts) {\n    const labels = this.isLabelEnabled() ? opts.labelData : [];\n    return opts.labelSelection.update(labels);\n  }\n  async updateLabelNodes(opts) {\n    const { labelSelection } = opts;\n    const { color: fill, fontStyle, fontWeight, fontSize, fontFamily } = this.properties.label;\n    labelSelection.each((label, { x, y, leading, text }) => {\n      label.visible = true;\n      label.x = x;\n      label.y = y;\n      label.text = text;\n      label.fill = fill;\n      label.fontStyle = fontStyle;\n      label.fontWeight = fontWeight;\n      label.fontSize = fontSize;\n      label.fontFamily = fontFamily;\n      label.textAlign = leading ? \"right\" : \"left\";\n      label.textBaseline = \"middle\";\n    });\n  }\n  async updateNodeSelection(opts) {\n    return opts.datumSelection.update(opts.nodeData, void 0, (datum) => createDatumId9([datum.type, datum.id]));\n  }\n  async updateNodeNodes(opts) {\n    const { datumSelection, isHighlight } = opts;\n    const {\n      id: seriesId,\n      properties,\n      ctx: { callbackCache }\n    } = this;\n    const { fromKey, toKey, sizeKey } = this.properties;\n    const {\n      fill: baseFill,\n      fillOpacity,\n      stroke: baseStroke,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      itemStyler\n    } = this.properties.node;\n    const highlightStyle = isHighlight ? properties.highlightStyle.item : void 0;\n    const strokeWidth = this.getStrokeWidth(properties.node.strokeWidth);\n    datumSelection.each((rect, datum) => {\n      const fill = baseFill ?? datum.fill;\n      const stroke = baseStroke ?? datum.stroke;\n      let format;\n      if (itemStyler != null) {\n        const { label, size } = datum;\n        format = callbackCache.call(itemStyler, {\n          seriesId,\n          datum: datum.datum,\n          label,\n          size,\n          fromKey,\n          toKey,\n          sizeKey,\n          fill,\n          fillOpacity,\n          strokeOpacity,\n          stroke,\n          strokeWidth,\n          lineDash,\n          lineDashOffset,\n          highlighted: isHighlight\n        });\n      }\n      rect.x = datum.x;\n      rect.y = datum.y;\n      rect.width = datum.width;\n      rect.height = datum.height;\n      rect.fill = highlightStyle?.fill ?? format?.fill ?? fill;\n      rect.fillOpacity = highlightStyle?.fillOpacity ?? format?.fillOpacity ?? fillOpacity;\n      rect.stroke = highlightStyle?.stroke ?? format?.stroke ?? stroke;\n      rect.strokeOpacity = highlightStyle?.strokeOpacity ?? format?.strokeOpacity ?? strokeOpacity;\n      rect.strokeWidth = highlightStyle?.strokeWidth ?? format?.strokeWidth ?? strokeWidth;\n      rect.lineDash = highlightStyle?.lineDash ?? format?.lineDash ?? lineDash;\n      rect.lineDashOffset = highlightStyle?.lineDashOffset ?? format?.lineDashOffset ?? lineDashOffset;\n    });\n  }\n  async updateLinkSelection(opts) {\n    return opts.datumSelection.update(\n      opts.nodeData,\n      void 0,\n      (datum) => createDatumId9([datum.type, datum.index, datum.fromNode.id, datum.toNode.id])\n    );\n  }\n  async updateLinkNodes(opts) {\n    const { datumSelection, isHighlight } = opts;\n    const {\n      id: seriesId,\n      properties,\n      ctx: { callbackCache }\n    } = this;\n    const { fromKey, toKey, sizeKey } = properties;\n    const {\n      fill: baseFill,\n      fillOpacity,\n      stroke: baseStroke,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      itemStyler\n    } = properties.link;\n    const highlightStyle = isHighlight ? properties.highlightStyle.item : void 0;\n    const strokeWidth = this.getStrokeWidth(properties.link.strokeWidth);\n    datumSelection.each((link, datum) => {\n      const fill = baseFill ?? datum.fromNode.fill;\n      const stroke = baseStroke ?? datum.fromNode.stroke;\n      let format;\n      if (itemStyler != null) {\n        format = callbackCache.call(itemStyler, {\n          seriesId,\n          datum: datum.datum,\n          fromKey,\n          toKey,\n          sizeKey,\n          fill,\n          fillOpacity,\n          strokeOpacity,\n          stroke,\n          strokeWidth,\n          lineDash,\n          lineDashOffset,\n          highlighted: isHighlight\n        });\n      }\n      link.x1 = datum.x1;\n      link.y1 = datum.y1;\n      link.x2 = datum.x2;\n      link.y2 = datum.y2;\n      link.height = datum.height;\n      link.fill = highlightStyle?.fill ?? format?.fill ?? fill;\n      link.fillOpacity = highlightStyle?.fillOpacity ?? format?.fillOpacity ?? fillOpacity;\n      link.stroke = highlightStyle?.stroke ?? format?.stroke ?? stroke;\n      link.strokeOpacity = highlightStyle?.strokeOpacity ?? format?.strokeOpacity ?? strokeOpacity;\n      link.strokeWidth = Math.min(\n        highlightStyle?.strokeWidth ?? format?.strokeWidth ?? strokeWidth,\n        datum.height / 2\n      );\n      link.lineDash = highlightStyle?.lineDash ?? format?.lineDash ?? lineDash;\n      link.lineDashOffset = highlightStyle?.lineDashOffset ?? format?.lineDashOffset ?? lineDashOffset;\n      link.inset = link.strokeWidth / 2;\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const {\n      id: seriesId,\n      processedData,\n      ctx: { callbackCache },\n      properties\n    } = this;\n    if (!processedData || !properties.isValid()) {\n      return EMPTY_TOOLTIP_CONTENT2;\n    }\n    const { fromKey, toKey, sizeKey, sizeName, tooltip } = properties;\n    const { datum, itemId } = nodeDatum;\n    let title;\n    const contentLines = [];\n    let fill;\n    if (nodeDatum.type === 0 /* Link */) {\n      const { fillOpacity, strokeOpacity, strokeWidth, lineDash, lineDashOffset, itemStyler } = properties.link;\n      const { fromNode, toNode, size } = nodeDatum;\n      title = `${fromNode.label ?? fromNode.id} - ${toNode.label ?? toNode.id}`;\n      if (sizeKey != null) {\n        contentLines.push(sanitizeHtml13(`${sizeName ?? sizeKey}: ` + size));\n      }\n      fill = properties.link.fill ?? fromNode.fill;\n      const stroke = properties.link.stroke ?? fromNode.stroke;\n      let format;\n      if (itemStyler != null) {\n        format = callbackCache.call(itemStyler, {\n          seriesId,\n          datum: datum.datum,\n          fromKey,\n          toKey,\n          sizeKey,\n          fill,\n          fillOpacity,\n          strokeOpacity,\n          stroke,\n          strokeWidth,\n          lineDash,\n          lineDashOffset,\n          highlighted: true\n        });\n      }\n      fill = format?.fill ?? fill;\n    } else {\n      const { fillOpacity, strokeOpacity, strokeWidth, lineDash, lineDashOffset, itemStyler } = properties.node;\n      const { id, label, size } = nodeDatum;\n      title = label ?? id;\n      if (sizeKey != null) {\n        contentLines.push(sanitizeHtml13(`${sizeName ?? sizeKey}: ` + size));\n      }\n      fill = properties.link.fill ?? datum.fill;\n      const stroke = properties.link.stroke ?? datum.stroke;\n      let format;\n      if (itemStyler != null) {\n        format = callbackCache.call(itemStyler, {\n          seriesId,\n          datum: datum.datum,\n          label,\n          size,\n          fromKey,\n          toKey,\n          sizeKey,\n          fill,\n          fillOpacity,\n          strokeOpacity,\n          stroke,\n          strokeWidth,\n          lineDash,\n          lineDashOffset,\n          highlighted: true\n        });\n      }\n      fill = format?.fill ?? fill;\n    }\n    const content = contentLines.join(\"<br>\");\n    const color = fill;\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        seriesId,\n        datum,\n        title,\n        color,\n        itemId,\n        fromKey,\n        toKey,\n        sizeKey,\n        sizeName,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  getLabelData() {\n    return [];\n  }\n  computeFocusBounds({\n    datumIndex,\n    seriesRect\n  }) {\n    const datum = this.contextNodeData?.nodeData[datumIndex];\n    if (datum?.type === 1 /* Node */) {\n      const { x, y, width, height } = datum;\n      const bbox = new BBox10(x, y, width, height);\n      return this.contentGroup.inverseTransformBBox(bbox).clip(seriesRect);\n    } else if (datum?.type === 0 /* Link */) {\n      for (const link of this.linkSelection) {\n        if (link.datum === datum) {\n          return link.node;\n        }\n      }\n      return void 0;\n    }\n  }\n};\nSankeySeries.className = \"SankeySeries\";\nSankeySeries.type = \"sankey\";\n\n// packages/ag-charts-enterprise/src/series/sankey/sankeyModule.ts\nvar { DEFAULT_FONT_FAMILY: DEFAULT_FONT_FAMILY3, DEFAULT_LABEL_COLOUR: DEFAULT_LABEL_COLOUR4 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme;\nvar SankeyModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"flow-proportion\"],\n  solo: true,\n  identifier: \"sankey\",\n  instanceConstructor: SankeySeries,\n  tooltipDefaults: { range: \"exact\" },\n  themeTemplate: {\n    seriesArea: {\n      padding: {\n        top: 10,\n        bottom: 10\n      }\n    },\n    series: {\n      highlightStyle: {\n        series: {\n          dimOpacity: 0.2\n        }\n      },\n      label: {\n        fontFamily: DEFAULT_FONT_FAMILY3,\n        color: DEFAULT_LABEL_COLOUR4,\n        fontSize: 12,\n        spacing: 10\n      },\n      node: {\n        spacing: 20,\n        width: 10,\n        strokeWidth: 0\n      },\n      link: {\n        fillOpacity: 0.5,\n        strokeWidth: 0\n      }\n    },\n    legend: {\n      enabled: false,\n      toggleSeries: false\n    }\n  },\n  paletteFactory({ takeColors, colorsCount }) {\n    return takeColors(colorsCount);\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/sunburst/sunburstModule.ts\n\n\n// packages/ag-charts-enterprise/src/series/sunburst/sunburstSeries.ts\n\n\n// packages/ag-charts-enterprise/src/series/sunburst/sunburstSeriesProperties.ts\n\nvar {\n  HierarchySeriesProperties,\n  HighlightStyle,\n  SeriesTooltip: SeriesTooltip17,\n  Validate: Validate59,\n  COLOR_STRING: COLOR_STRING24,\n  FUNCTION: FUNCTION18,\n  NUMBER: NUMBER14,\n  OBJECT: OBJECT27,\n  POSITIVE_NUMBER: POSITIVE_NUMBER27,\n  RATIO: RATIO30,\n  STRING: STRING26\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar SunburstSeriesTileHighlightStyle = class extends HighlightStyle {\n  constructor() {\n    super(...arguments);\n    this.label = new AutoSizedLabel();\n    this.secondaryLabel = new AutoSizedLabel();\n  }\n};\n__decorateClass([\n  Validate59(STRING26, { optional: true })\n], SunburstSeriesTileHighlightStyle.prototype, \"fill\", 2);\n__decorateClass([\n  Validate59(RATIO30, { optional: true })\n], SunburstSeriesTileHighlightStyle.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate59(COLOR_STRING24, { optional: true })\n], SunburstSeriesTileHighlightStyle.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate59(POSITIVE_NUMBER27, { optional: true })\n], SunburstSeriesTileHighlightStyle.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate59(RATIO30, { optional: true })\n], SunburstSeriesTileHighlightStyle.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate59(OBJECT27)\n], SunburstSeriesTileHighlightStyle.prototype, \"label\", 2);\n__decorateClass([\n  Validate59(OBJECT27)\n], SunburstSeriesTileHighlightStyle.prototype, \"secondaryLabel\", 2);\nvar SunburstSeriesProperties = class extends HierarchySeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fillOpacity = 1;\n    this.strokeWidth = 0;\n    this.strokeOpacity = 1;\n    this.cornerRadius = 0;\n    this.highlightStyle = new SunburstSeriesTileHighlightStyle();\n    this.label = new AutoSizedLabel();\n    this.secondaryLabel = new AutoSizeableSecondaryLabel();\n    this.tooltip = new SeriesTooltip17();\n  }\n};\n__decorateClass([\n  Validate59(STRING26, { optional: true })\n], SunburstSeriesProperties.prototype, \"sizeName\", 2);\n__decorateClass([\n  Validate59(STRING26, { optional: true })\n], SunburstSeriesProperties.prototype, \"labelKey\", 2);\n__decorateClass([\n  Validate59(STRING26, { optional: true })\n], SunburstSeriesProperties.prototype, \"secondaryLabelKey\", 2);\n__decorateClass([\n  Validate59(RATIO30)\n], SunburstSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate59(POSITIVE_NUMBER27)\n], SunburstSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate59(RATIO30)\n], SunburstSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate59(POSITIVE_NUMBER27)\n], SunburstSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate59(NUMBER14, { optional: true })\n], SunburstSeriesProperties.prototype, \"sectorSpacing\", 2);\n__decorateClass([\n  Validate59(NUMBER14, { optional: true })\n], SunburstSeriesProperties.prototype, \"padding\", 2);\n__decorateClass([\n  Validate59(FUNCTION18, { optional: true })\n], SunburstSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate59(OBJECT27)\n], SunburstSeriesProperties.prototype, \"highlightStyle\", 2);\n__decorateClass([\n  Validate59(OBJECT27)\n], SunburstSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate59(OBJECT27)\n], SunburstSeriesProperties.prototype, \"secondaryLabel\", 2);\n__decorateClass([\n  Validate59(OBJECT27)\n], SunburstSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-enterprise/src/series/sunburst/sunburstSeries.ts\nvar { fromToMotion: fromToMotion3 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { Sector: Sector6, Group: Group15, Selection: Selection11, Text: Text14 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar { sanitizeHtml: sanitizeHtml14 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar getAngleData = (node, startAngle = 0, angleScale = 2 * Math.PI / node.sumSize, angleData = Array.from(node, () => void 0)) => {\n  let currentAngle = startAngle;\n  for (const child of node.children) {\n    const start = currentAngle;\n    const end = currentAngle + child.sumSize * angleScale;\n    angleData[child.index] = { start, end };\n    getAngleData(child, start, angleScale, angleData);\n    currentAngle = end;\n  }\n  return angleData;\n};\nvar SunburstSeries = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.HierarchySeries {\n  constructor() {\n    super(...arguments);\n    this.properties = new SunburstSeriesProperties();\n    this.groupSelection = Selection11.select(this.contentGroup, Group15);\n    this.highlightSelection = Selection11.select(this.highlightGroup, Group15);\n    this.angleData = [];\n  }\n  async processData() {\n    const { childrenKey, colorKey, colorName, labelKey, secondaryLabelKey, sizeKey, sizeName } = this.properties;\n    await super.processData();\n    this.angleData = getAngleData(this.rootNode);\n    const defaultLabelFormatter = (value) => {\n      if (typeof value === \"number\") {\n        return value.toFixed(2);\n      } else if (typeof value === \"string\") {\n        return value;\n      } else {\n        return \"\";\n      }\n    };\n    this.labelData = Array.from(this.rootNode, ({ datum, depth }) => {\n      let label;\n      if (datum != null && depth != null && labelKey != null) {\n        const value = datum[labelKey];\n        label = this.getLabelText(\n          this.properties.label,\n          {\n            depth,\n            datum,\n            childrenKey,\n            colorKey,\n            colorName,\n            labelKey,\n            secondaryLabelKey,\n            sizeKey,\n            sizeName,\n            value\n          },\n          defaultLabelFormatter\n        );\n      }\n      if (label === \"\") {\n        label = void 0;\n      }\n      let secondaryLabel;\n      if (datum != null && depth != null && secondaryLabelKey != null) {\n        const value = datum[secondaryLabelKey];\n        secondaryLabel = this.getLabelText(\n          this.properties.secondaryLabel,\n          {\n            depth,\n            datum,\n            childrenKey,\n            colorKey,\n            colorName,\n            labelKey,\n            secondaryLabelKey,\n            sizeKey,\n            sizeName,\n            value\n          },\n          defaultLabelFormatter\n        );\n      }\n      if (secondaryLabel === \"\") {\n        secondaryLabel = void 0;\n      }\n      return label != null || secondaryLabel != null ? { label, secondaryLabel } : void 0;\n    });\n  }\n  async updateSelections() {\n    if (!this.nodeDataRefresh)\n      return;\n    this.nodeDataRefresh = false;\n    const { chart } = this;\n    if (chart == null)\n      return;\n    const seriesRect = chart.seriesRect;\n    if (seriesRect == null)\n      return;\n    const descendants = Array.from(this.rootNode);\n    const updateGroup = (group) => {\n      group.append([\n        new Sector6(),\n        new Text14({ tag: 0 /* Primary */ }),\n        new Text14({ tag: 1 /* Secondary */ })\n      ]);\n    };\n    this.groupSelection.update(descendants, updateGroup, (node) => this.getDatumId(node));\n    this.highlightSelection.update(descendants, updateGroup, (node) => this.getDatumId(node));\n  }\n  async updateNodes() {\n    const { chart, data, maxDepth, labelData } = this;\n    if (chart == null || data == null || labelData == null) {\n      return;\n    }\n    const { width, height } = chart.seriesRect;\n    const { sectorSpacing = 0, padding = 0, cornerRadius, highlightStyle } = this.properties;\n    this.contentGroup.translationX = width / 2;\n    this.contentGroup.translationY = height / 2;\n    this.highlightGroup.translationX = width / 2;\n    this.highlightGroup.translationY = height / 2;\n    const baseInset = sectorSpacing * 0.5;\n    const radius = Math.min(width, height) / 2;\n    const radiusScale = radius / (maxDepth + 1);\n    const angleOffset = -Math.PI / 2;\n    const highlightedNode = this.ctx.highlightManager?.getActiveHighlight();\n    const labelTextNode = new Text14();\n    labelTextNode.setFont(this.properties.label);\n    this.rootNode.walk((node) => {\n      const angleDatum = this.angleData[node.index];\n      if (node.depth != null && angleDatum != null) {\n        const midAngle = angleDatum.end - angleDatum.start;\n        const midRadius = (node.depth + 0.5) * radiusScale;\n        node.midPoint.x = Math.cos(midAngle) * midRadius;\n        node.midPoint.y = Math.sin(midAngle) * midRadius;\n      }\n    });\n    const updateSector = (node, sector, highlighted) => {\n      const { depth } = node;\n      const angleDatum = this.angleData[node.index];\n      if (depth == null || angleDatum == null) {\n        sector.visible = false;\n        return;\n      }\n      sector.visible = true;\n      let highlightedFill;\n      let highlightedFillOpacity;\n      let highlightedStroke;\n      let highlightedStrokeWidth;\n      let highlightedStrokeOpacity;\n      if (highlighted) {\n        highlightedFill = highlightStyle.fill;\n        highlightedFillOpacity = highlightStyle.fillOpacity;\n        highlightedStroke = highlightStyle.stroke;\n        highlightedStrokeWidth = highlightStyle.strokeWidth;\n        highlightedStrokeOpacity = highlightStyle.strokeOpacity;\n      }\n      const format = this.getSectorFormat(node, highlighted);\n      const fill = format?.fill ?? highlightedFill ?? node.fill;\n      const fillOpacity = format?.fillOpacity ?? highlightedFillOpacity ?? this.properties.fillOpacity;\n      const stroke = format?.stroke ?? highlightedStroke ?? node.stroke;\n      const strokeWidth = format?.strokeWidth ?? highlightedStrokeWidth ?? this.properties.strokeWidth;\n      const strokeOpacity = format?.strokeOpacity ?? highlightedStrokeOpacity ?? this.properties.strokeOpacity;\n      sector.fill = fill;\n      sector.fillOpacity = fillOpacity;\n      sector.stroke = stroke;\n      sector.strokeWidth = strokeWidth;\n      sector.strokeOpacity = strokeOpacity;\n      sector.centerX = 0;\n      sector.centerY = 0;\n      sector.innerRadius = depth * radiusScale;\n      sector.outerRadius = (depth + 1) * radiusScale;\n      sector.startAngle = angleDatum.start + angleOffset;\n      sector.endAngle = angleDatum.end + angleOffset;\n      sector.inset = baseInset + strokeWidth * 0.5;\n      sector.cornerRadius = cornerRadius;\n    };\n    this.groupSelection.selectByClass(Sector6).forEach((sector) => {\n      updateSector(sector.datum, sector, false);\n    });\n    this.highlightSelection.selectByClass(Sector6).forEach((sector) => {\n      const node = sector.datum;\n      const isHighlighted = highlightedNode === node;\n      sector.visible = isHighlighted;\n      if (sector.visible) {\n        updateSector(sector.datum, sector, isHighlighted);\n      }\n    });\n    const labelMeta = Array.from(this.rootNode, (node, index) => {\n      const { depth } = node;\n      const labelDatum = labelData[index];\n      const angleData = this.angleData[index];\n      if (depth == null || angleData == null) {\n        return;\n      }\n      const innerRadius = depth * radiusScale + baseInset;\n      const outerRadius = (depth + 1) * radiusScale - baseInset;\n      const innerAngleOffset = innerRadius > baseInset ? baseInset / innerRadius : baseInset;\n      const outerAngleOffset = outerRadius > baseInset ? baseInset / outerRadius : baseInset;\n      const innerStartAngle = angleData.start + innerAngleOffset;\n      const innerEndAngle = angleData.end + innerAngleOffset;\n      const deltaInnerAngle = innerEndAngle - innerStartAngle;\n      const outerStartAngle = angleData.start + outerAngleOffset;\n      const outerEndAngle = angleData.end + outerAngleOffset;\n      const deltaOuterAngle = outerEndAngle - outerStartAngle;\n      const sizeFittingHeight = (labelHeight2) => {\n        const isCenterCircle = depth === 0 && node.parent?.sumSize === node.sumSize;\n        if (isCenterCircle) {\n          const labelWidth2 = 2 * Math.sqrt(outerRadius ** 2 - (labelHeight2 * 0.5) ** 2);\n          return { width: labelWidth2, height: labelHeight2, meta: 0 /* CenterCircle */ };\n        }\n        const parallelHeight = labelHeight2;\n        const availableWidthUntilItHitsTheOuterRadius = 2 * Math.sqrt(outerRadius ** 2 - (innerRadius + parallelHeight) ** 2);\n        const availableWidthUntilItHitsTheStraightEdges = deltaInnerAngle < Math.PI ? 2 * innerRadius * Math.tan(deltaInnerAngle * 0.5) : Infinity;\n        const parallelWidth = Math.min(\n          availableWidthUntilItHitsTheOuterRadius,\n          availableWidthUntilItHitsTheStraightEdges\n        );\n        const maxPerpendicularAngle = Math.PI / 4;\n        let perpendicularHeight;\n        let perpendicularWidth;\n        if (depth === 0) {\n          perpendicularHeight = labelHeight2;\n          perpendicularWidth = Math.sqrt(outerRadius ** 2 - (perpendicularHeight / 2) ** 2) - labelHeight2 / (2 * Math.tan(deltaOuterAngle * 0.5));\n        } else if (ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util.normalizeAngle360(deltaInnerAngle) < maxPerpendicularAngle) {\n          perpendicularHeight = 2 * innerRadius * Math.tan(deltaInnerAngle * 0.5);\n          perpendicularWidth = Math.sqrt(outerRadius ** 2 - (perpendicularHeight / 2) ** 2) - innerRadius;\n        } else {\n          perpendicularWidth = 0;\n          perpendicularHeight = 0;\n        }\n        return parallelWidth >= perpendicularWidth ? { width: parallelWidth, height: parallelHeight, meta: 1 /* Parallel */ } : { width: perpendicularWidth, height: perpendicularHeight, meta: 2 /* Perpendicular */ };\n      };\n      const formatting = formatLabels(\n        labelDatum?.label,\n        this.properties.label,\n        labelDatum?.secondaryLabel,\n        this.properties.secondaryLabel,\n        { padding },\n        sizeFittingHeight\n      );\n      if (formatting == null) {\n        return;\n      }\n      const { width: labelWidth, height: labelHeight, meta: labelPlacement, label, secondaryLabel } = formatting;\n      const theta = angleOffset + (angleData.start + angleData.end) / 2;\n      const top = Math.sin(theta) >= 0;\n      const right = Math.cos(theta) >= 0;\n      const circleQuarter = (top ? 3 /* Top */ : 12 /* Bottom */) & (right ? 6 /* Right */ : 9 /* Left */);\n      let labelRadius;\n      switch (labelPlacement) {\n        case 0 /* CenterCircle */:\n          labelRadius = 0;\n          break;\n        case 1 /* Parallel */: {\n          const opticalCentering = 0.58;\n          const idealRadius = outerRadius - (radiusScale - labelHeight) * opticalCentering;\n          const maximumRadius = Math.sqrt((outerRadius - padding) ** 2 - (labelWidth / 2) ** 2);\n          labelRadius = Math.min(idealRadius, maximumRadius);\n          break;\n        }\n        case 2 /* Perpendicular */:\n          if (depth === 0) {\n            const minimumRadius = labelHeight / (2 * Math.tan(deltaInnerAngle * 0.5)) + labelWidth * 0.5;\n            const maximumRadius = Math.sqrt(outerRadius ** 2 - (labelHeight * 0.5) ** 2) - labelWidth * 0.5;\n            labelRadius = (minimumRadius + maximumRadius) * 0.5;\n          } else {\n            labelRadius = (innerRadius + outerRadius) * 0.5;\n          }\n          break;\n      }\n      return {\n        width: labelWidth,\n        height: labelHeight,\n        labelPlacement,\n        circleQuarter,\n        radius: labelRadius,\n        theta,\n        label,\n        secondaryLabel\n      };\n    });\n    const updateText = (node, text, tag, highlighted) => {\n      const { index, depth } = node;\n      const meta = labelMeta?.[index];\n      const labelStyle = tag === 0 /* Primary */ ? this.properties.label : this.properties.secondaryLabel;\n      const label = tag === 0 /* Primary */ ? meta?.label : meta?.secondaryLabel;\n      if (depth == null || meta == null || label == null) {\n        text.visible = false;\n        return;\n      }\n      const { height: textHeight, labelPlacement, circleQuarter, radius: textRadius, theta } = meta;\n      let highlightedColor;\n      if (highlighted) {\n        const highlightedLabelStyle = tag === 0 /* Primary */ ? this.properties.highlightStyle.label : this.properties.highlightStyle.secondaryLabel;\n        highlightedColor = highlightedLabelStyle.color;\n      }\n      text.text = label.text;\n      text.fontSize = label.fontSize;\n      text.lineHeight = label.lineHeight;\n      text.fontStyle = labelStyle.fontStyle;\n      text.fontFamily = labelStyle.fontFamily;\n      text.fontWeight = labelStyle.fontWeight;\n      text.fill = highlightedColor ?? labelStyle.color;\n      switch (labelPlacement) {\n        case 0 /* CenterCircle */:\n          text.textAlign = \"center\";\n          text.textBaseline = \"top\";\n          text.translationX = 0;\n          text.translationY = (tag === 0 /* Primary */ ? 0 : textHeight - label.height) - textHeight * 0.5;\n          text.rotation = 0;\n          break;\n        case 1 /* Parallel */: {\n          const topHalf = (circleQuarter & 3 /* Top */) !== 0;\n          const translationRadius = tag === 0 /* Primary */ === !topHalf ? textRadius : textRadius - (textHeight - label.height);\n          text.textAlign = \"center\";\n          text.textBaseline = topHalf ? \"bottom\" : \"top\";\n          text.translationX = Math.cos(theta) * translationRadius;\n          text.translationY = Math.sin(theta) * translationRadius;\n          text.rotation = topHalf ? theta - Math.PI * 0.5 : theta + Math.PI * 0.5;\n          break;\n        }\n        case 2 /* Perpendicular */: {\n          const rightHalf = (circleQuarter & 6 /* Right */) !== 0;\n          const translation = tag === 0 /* Primary */ === !rightHalf ? (textHeight - label.height) * 0.5 : (label.height - textHeight) * 0.5;\n          text.textAlign = \"center\";\n          text.textBaseline = \"middle\";\n          text.translationX = Math.cos(theta) * textRadius + Math.cos(theta + Math.PI / 2) * translation;\n          text.translationY = Math.sin(theta) * textRadius + Math.sin(theta + Math.PI / 2) * translation;\n          text.rotation = rightHalf ? theta : theta + Math.PI;\n          break;\n        }\n      }\n      text.visible = true;\n    };\n    this.groupSelection.selectByClass(Text14).forEach((text) => {\n      updateText(text.datum, text, text.tag, false);\n    });\n    this.highlightSelection.selectByClass(Text14).forEach((text) => {\n      const node = text.datum;\n      const isHighlighted = highlightedNode === node;\n      text.visible = isHighlighted;\n      if (text.visible) {\n        updateText(text.datum, text, text.tag, isHighlighted);\n      }\n    });\n  }\n  getSectorFormat(node, isHighlighted) {\n    const { datum, fill, stroke, depth } = node;\n    const {\n      ctx: { callbackCache },\n      properties: { itemStyler }\n    } = this;\n    if (!itemStyler || datum == null || depth == null) {\n      return {};\n    }\n    const { colorKey, childrenKey, labelKey, secondaryLabelKey, sizeKey, strokeWidth, fillOpacity, strokeOpacity } = this.properties;\n    return callbackCache.call(itemStyler, {\n      seriesId: this.id,\n      highlighted: isHighlighted,\n      datum,\n      depth,\n      colorKey,\n      childrenKey,\n      labelKey,\n      secondaryLabelKey,\n      sizeKey,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity\n    });\n  }\n  getTooltipHtml(node) {\n    const { id: seriesId } = this;\n    const {\n      tooltip,\n      colorKey,\n      colorName = colorKey,\n      labelKey,\n      secondaryLabelKey,\n      sizeKey,\n      sizeName = sizeKey,\n      childrenKey\n    } = this.properties;\n    const { datum, depth } = node;\n    if (datum == null || depth == null) {\n      return ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.EMPTY_TOOLTIP_CONTENT;\n    }\n    const title = labelKey != null ? datum[labelKey] : void 0;\n    const format = this.getSectorFormat(node, false);\n    const color = format?.fill ?? node.fill;\n    if (!tooltip.renderer && !title) {\n      return ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.EMPTY_TOOLTIP_CONTENT;\n    }\n    const contentArray = [];\n    const datumSecondaryLabel = secondaryLabelKey != null ? datum[secondaryLabelKey] : void 0;\n    if (datumSecondaryLabel != null && secondaryLabelKey !== colorKey && secondaryLabelKey !== sizeKey) {\n      contentArray.push(sanitizeHtml14(datumSecondaryLabel));\n    }\n    const datumSize = sizeKey != null ? datum[sizeKey] : void 0;\n    if (datumSize != null) {\n      contentArray.push(`${sizeName}: ${sanitizeHtml14(datumSize)}`);\n    }\n    const datumColor = colorKey != null ? datum[colorKey] : void 0;\n    if (datumColor != null) {\n      contentArray.push(`${colorName}: ${sanitizeHtml14(datumColor)}`);\n    }\n    const content = contentArray.join(\"<br>\");\n    const defaults = {\n      title,\n      color: this.properties.label.color,\n      backgroundColor: color,\n      content\n    };\n    return tooltip.toTooltipHtml(defaults, {\n      depth,\n      datum,\n      colorKey,\n      labelKey,\n      secondaryLabelKey,\n      sizeKey,\n      title,\n      color,\n      seriesId,\n      childrenKey,\n      colorName,\n      itemId: void 0,\n      sizeName\n    });\n  }\n  async createNodeData() {\n    return void 0;\n  }\n  pickNodeClosestDatum(point) {\n    return this.pickNodeNearestDistantObject(point, this.groupSelection.selectByClass(Sector6));\n  }\n  animateEmptyUpdateReady({\n    datumSelections\n  }) {\n    fromToMotion3(this.id, \"nodes\", this.ctx.animationManager, datumSelections, {\n      toFn(_group, _datum, _status) {\n        return { scalingX: 1, scalingY: 1 };\n      },\n      fromFn(group, datum, status) {\n        if (status === \"unknown\" && datum != null && group.previousDatum == null) {\n          return { scalingX: 0, scalingY: 0 };\n        } else {\n          return { scalingX: 1, scalingY: 1 };\n        }\n      }\n    });\n  }\n  computeFocusBounds(nodeDatum) {\n    let match;\n    for (const { node, datum } of this.groupSelection) {\n      if (datum === nodeDatum) {\n        match = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Selection.selectByClass(node, ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Sector)[0];\n      }\n    }\n    return match;\n  }\n};\nSunburstSeries.className = \"SunburstSeries\";\nSunburstSeries.type = \"sunburst\";\n\n// packages/ag-charts-enterprise/src/series/sunburst/sunburstModule.ts\nvar { DEFAULT_INSIDE_SERIES_LABEL_COLOUR } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme;\nvar SunburstModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"hierarchy\"],\n  identifier: \"sunburst\",\n  instanceConstructor: SunburstSeries,\n  tooltipDefaults: { range: \"exact\" },\n  solo: true,\n  themeTemplate: {\n    series: {\n      label: {\n        fontSize: 14,\n        minimumFontSize: 9,\n        color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n        overflowStrategy: \"ellipsis\",\n        wrapping: \"never\",\n        spacing: 2\n      },\n      secondaryLabel: {\n        fontSize: 8,\n        minimumFontSize: 7,\n        color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n        overflowStrategy: \"ellipsis\",\n        wrapping: \"never\"\n      },\n      sectorSpacing: 2,\n      padding: 3,\n      highlightStyle: {\n        label: {\n          color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR\n        },\n        secondaryLabel: {\n          color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR\n        },\n        stroke: `rgba(0, 0, 0, 0.4)`,\n        strokeWidth: 2\n      }\n    },\n    gradientLegend: {\n      enabled: true\n    }\n  },\n  paletteFactory: ({ takeColors, colorsCount, themeTemplateParameters }) => {\n    const { fills, strokes } = takeColors(colorsCount);\n    const defaultColorRange = themeTemplateParameters.get(ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_DIVERGING_SERIES_COLOUR_RANGE);\n    return { fills, strokes, colorRange: defaultColorRange };\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/treemap/treemapModule.ts\n\n\n// packages/ag-charts-enterprise/src/series/treemap/treemapSeries.ts\n\n\n// packages/ag-charts-enterprise/src/series/treemap/treemapSeriesProperties.ts\n\nvar { Label: Label13 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar {\n  BaseProperties: BaseProperties16,\n  HierarchySeriesProperties: HierarchySeriesProperties2,\n  HighlightStyle: HighlightStyle2,\n  SeriesTooltip: SeriesTooltip18,\n  Validate: Validate60,\n  BOOLEAN: BOOLEAN19,\n  COLOR_STRING: COLOR_STRING25,\n  FUNCTION: FUNCTION19,\n  NUMBER: NUMBER15,\n  OBJECT: OBJECT28,\n  POSITIVE_NUMBER: POSITIVE_NUMBER28,\n  RATIO: RATIO31,\n  STRING: STRING27,\n  STRING_ARRAY,\n  TEXT_ALIGN: TEXT_ALIGN3,\n  VERTICAL_ALIGN: VERTICAL_ALIGN2\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar TreemapGroupLabel = class extends Label13 {\n  constructor() {\n    super(...arguments);\n    this.spacing = 0;\n  }\n};\n__decorateClass([\n  Validate60(NUMBER15)\n], TreemapGroupLabel.prototype, \"spacing\", 2);\nvar TreemapSeriesGroup = class extends BaseProperties16 {\n  constructor() {\n    super(...arguments);\n    this.fillOpacity = 1;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.cornerRadius = 0;\n    this.textAlign = \"center\";\n    this.gap = 0;\n    this.padding = 0;\n    this.interactive = true;\n    this.label = new TreemapGroupLabel();\n  }\n};\n__decorateClass([\n  Validate60(STRING27, { optional: true })\n], TreemapSeriesGroup.prototype, \"fill\", 2);\n__decorateClass([\n  Validate60(RATIO31)\n], TreemapSeriesGroup.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate60(COLOR_STRING25, { optional: true })\n], TreemapSeriesGroup.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate60(POSITIVE_NUMBER28)\n], TreemapSeriesGroup.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate60(RATIO31)\n], TreemapSeriesGroup.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate60(POSITIVE_NUMBER28)\n], TreemapSeriesGroup.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate60(TEXT_ALIGN3)\n], TreemapSeriesGroup.prototype, \"textAlign\", 2);\n__decorateClass([\n  Validate60(POSITIVE_NUMBER28)\n], TreemapSeriesGroup.prototype, \"gap\", 2);\n__decorateClass([\n  Validate60(POSITIVE_NUMBER28)\n], TreemapSeriesGroup.prototype, \"padding\", 2);\n__decorateClass([\n  Validate60(BOOLEAN19)\n], TreemapSeriesGroup.prototype, \"interactive\", 2);\n__decorateClass([\n  Validate60(OBJECT28)\n], TreemapSeriesGroup.prototype, \"label\", 2);\nvar TreemapSeriesTile = class extends BaseProperties16 {\n  constructor() {\n    super(...arguments);\n    this.fillOpacity = 1;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.cornerRadius = 0;\n    this.textAlign = \"center\";\n    this.verticalAlign = \"middle\";\n    this.gap = 0;\n    this.padding = 0;\n    this.label = new AutoSizedLabel();\n    this.secondaryLabel = new AutoSizeableSecondaryLabel();\n  }\n};\n__decorateClass([\n  Validate60(STRING27, { optional: true })\n], TreemapSeriesTile.prototype, \"fill\", 2);\n__decorateClass([\n  Validate60(RATIO31)\n], TreemapSeriesTile.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate60(COLOR_STRING25, { optional: true })\n], TreemapSeriesTile.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate60(POSITIVE_NUMBER28, { optional: true })\n], TreemapSeriesTile.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate60(RATIO31)\n], TreemapSeriesTile.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate60(POSITIVE_NUMBER28)\n], TreemapSeriesTile.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate60(TEXT_ALIGN3)\n], TreemapSeriesTile.prototype, \"textAlign\", 2);\n__decorateClass([\n  Validate60(VERTICAL_ALIGN2)\n], TreemapSeriesTile.prototype, \"verticalAlign\", 2);\n__decorateClass([\n  Validate60(POSITIVE_NUMBER28)\n], TreemapSeriesTile.prototype, \"gap\", 2);\n__decorateClass([\n  Validate60(POSITIVE_NUMBER28)\n], TreemapSeriesTile.prototype, \"padding\", 2);\n__decorateClass([\n  Validate60(OBJECT28)\n], TreemapSeriesTile.prototype, \"label\", 2);\n__decorateClass([\n  Validate60(OBJECT28)\n], TreemapSeriesTile.prototype, \"secondaryLabel\", 2);\nvar TreemapSeriesGroupHighlightStyle = class extends BaseProperties16 {\n  constructor() {\n    super(...arguments);\n    this.label = new AutoSizedLabel();\n  }\n};\n__decorateClass([\n  Validate60(STRING27, { optional: true })\n], TreemapSeriesGroupHighlightStyle.prototype, \"fill\", 2);\n__decorateClass([\n  Validate60(RATIO31, { optional: true })\n], TreemapSeriesGroupHighlightStyle.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate60(COLOR_STRING25, { optional: true })\n], TreemapSeriesGroupHighlightStyle.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate60(POSITIVE_NUMBER28, { optional: true })\n], TreemapSeriesGroupHighlightStyle.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate60(RATIO31, { optional: true })\n], TreemapSeriesGroupHighlightStyle.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate60(OBJECT28)\n], TreemapSeriesGroupHighlightStyle.prototype, \"label\", 2);\nvar TreemapSeriesTileHighlightStyle = class extends BaseProperties16 {\n  constructor() {\n    super(...arguments);\n    this.label = new AutoSizedLabel();\n    this.secondaryLabel = new AutoSizeableSecondaryLabel();\n  }\n};\n__decorateClass([\n  Validate60(STRING27, { optional: true })\n], TreemapSeriesTileHighlightStyle.prototype, \"fill\", 2);\n__decorateClass([\n  Validate60(RATIO31, { optional: true })\n], TreemapSeriesTileHighlightStyle.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate60(COLOR_STRING25, { optional: true })\n], TreemapSeriesTileHighlightStyle.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate60(POSITIVE_NUMBER28, { optional: true })\n], TreemapSeriesTileHighlightStyle.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate60(RATIO31, { optional: true })\n], TreemapSeriesTileHighlightStyle.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate60(OBJECT28)\n], TreemapSeriesTileHighlightStyle.prototype, \"label\", 2);\n__decorateClass([\n  Validate60(OBJECT28)\n], TreemapSeriesTileHighlightStyle.prototype, \"secondaryLabel\", 2);\nvar TreemapSeriesHighlightStyle = class extends HighlightStyle2 {\n  constructor() {\n    super(...arguments);\n    this.group = new TreemapSeriesGroupHighlightStyle();\n    this.tile = new TreemapSeriesTileHighlightStyle();\n  }\n};\n__decorateClass([\n  Validate60(OBJECT28)\n], TreemapSeriesHighlightStyle.prototype, \"group\", 2);\n__decorateClass([\n  Validate60(OBJECT28)\n], TreemapSeriesHighlightStyle.prototype, \"tile\", 2);\nvar TreemapSeriesProperties = class extends HierarchySeriesProperties2 {\n  constructor() {\n    super(...arguments);\n    this.highlightStyle = new TreemapSeriesHighlightStyle();\n    this.tooltip = new SeriesTooltip18();\n    this.group = new TreemapSeriesGroup();\n    this.tile = new TreemapSeriesTile();\n    this.undocumentedGroupFills = [];\n    this.undocumentedGroupStrokes = [];\n  }\n};\n__decorateClass([\n  Validate60(STRING27, { optional: true })\n], TreemapSeriesProperties.prototype, \"sizeName\", 2);\n__decorateClass([\n  Validate60(STRING27, { optional: true })\n], TreemapSeriesProperties.prototype, \"labelKey\", 2);\n__decorateClass([\n  Validate60(STRING27, { optional: true })\n], TreemapSeriesProperties.prototype, \"secondaryLabelKey\", 2);\n__decorateClass([\n  Validate60(FUNCTION19, { optional: true })\n], TreemapSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate60(OBJECT28)\n], TreemapSeriesProperties.prototype, \"highlightStyle\", 2);\n__decorateClass([\n  Validate60(OBJECT28)\n], TreemapSeriesProperties.prototype, \"tooltip\", 2);\n__decorateClass([\n  Validate60(OBJECT28)\n], TreemapSeriesProperties.prototype, \"group\", 2);\n__decorateClass([\n  Validate60(OBJECT28)\n], TreemapSeriesProperties.prototype, \"tile\", 2);\n__decorateClass([\n  Validate60(STRING_ARRAY)\n], TreemapSeriesProperties.prototype, \"undocumentedGroupFills\", 2);\n__decorateClass([\n  Validate60(STRING_ARRAY)\n], TreemapSeriesProperties.prototype, \"undocumentedGroupStrokes\", 2);\n\n// packages/ag-charts-enterprise/src/series/treemap/treemapSeries.ts\nvar { Rect: Rect6, Group: Group16, BBox: BBox11, Selection: Selection12, Text: Text15 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar { Color: Color5, Logger: Logger16, clamp: clamp3, isEqual: isEqual2, sanitizeHtml: sanitizeHtml15 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar tempText = new Text15();\nfunction getTextSize(text, style) {\n  const { fontStyle, fontWeight, fontSize, fontFamily } = style;\n  tempText.setProperties({\n    text,\n    fontStyle,\n    fontWeight,\n    fontSize,\n    fontFamily,\n    textAlign: \"left\",\n    textBaseline: \"top\"\n  });\n  const { width, height } = tempText.computeBBox();\n  return { width, height };\n}\nfunction validateColor(color) {\n  if (typeof color === \"string\" && !Color5.validColorString(color)) {\n    const fallbackColor = \"black\";\n    Logger16.warnOnce(\n      `invalid Treemap tile colour string \"${color}\". Affected treemap tiles will be coloured ${fallbackColor}.`\n    );\n    return fallbackColor;\n  }\n  return color;\n}\nfunction nodeSize(node) {\n  return node.children.length > 0 ? node.sumSize - node.size : node.size;\n}\nvar textAlignFactors2 = {\n  left: 0,\n  center: 0.5,\n  right: 1\n};\nvar verticalAlignFactors2 = {\n  top: 0,\n  middle: 0.5,\n  bottom: 1\n};\nvar DistantGroup = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.Group {\n  distanceSquared(x, y) {\n    return this.computeBBox().distanceSquared(x, y);\n  }\n};\nvar TreemapSeries = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.HierarchySeries {\n  constructor() {\n    super(...arguments);\n    this.properties = new TreemapSeriesProperties();\n    this.groupSelection = Selection12.select(this.contentGroup, DistantGroup);\n    this.highlightSelection = Selection12.select(this.highlightGroup, Group16);\n  }\n  groupTitleHeight(node, bbox) {\n    const label = this.labelData?.[node.index]?.label;\n    const { label: font } = this.properties.group;\n    const heightRatioThreshold = 3;\n    if (label == null) {\n      return;\n    } else if (font.fontSize > bbox.width / heightRatioThreshold || font.fontSize > bbox.height / heightRatioThreshold) {\n      return;\n    } else {\n      const { height: fontHeight } = getTextSize(label, font);\n      return Math.max(fontHeight, font.fontSize);\n    }\n  }\n  getNodePadding(node, bbox) {\n    if (node.index === 0) {\n      return {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      };\n    } else if (node.children.length === 0) {\n      const { padding: padding2 } = this.properties.tile;\n      return {\n        top: padding2,\n        right: padding2,\n        bottom: padding2,\n        left: padding2\n      };\n    }\n    const {\n      label: { spacing },\n      padding\n    } = this.properties.group;\n    const fontHeight = this.groupTitleHeight(node, bbox);\n    const titleHeight = fontHeight != null ? fontHeight + spacing : 0;\n    return {\n      top: padding + titleHeight,\n      right: padding,\n      bottom: padding,\n      left: padding\n    };\n  }\n  async processData() {\n    await super.processData();\n    const { childrenKey, colorKey, colorName, labelKey, secondaryLabelKey, sizeKey, sizeName, tile, group } = this.properties;\n    if (!this.data?.length) {\n      this.labelData = void 0;\n      return;\n    }\n    const defaultLabelFormatter = (value) => {\n      if (typeof value === \"number\") {\n        return value.toFixed(2);\n      } else if (typeof value === \"string\") {\n        return value;\n      } else {\n        return \"\";\n      }\n    };\n    this.labelData = Array.from(this.rootNode, ({ datum, depth, children }) => {\n      const isLeaf = children.length === 0;\n      const labelStyle = isLeaf ? tile.label : group.label;\n      let label;\n      if (datum != null && depth != null && labelKey != null) {\n        const value = datum[labelKey];\n        label = this.getLabelText(\n          labelStyle,\n          {\n            depth,\n            datum,\n            childrenKey,\n            colorKey,\n            colorName,\n            labelKey,\n            secondaryLabelKey,\n            sizeKey,\n            sizeName,\n            value\n          },\n          defaultLabelFormatter\n        );\n      }\n      if (label === \"\") {\n        label = void 0;\n      }\n      let secondaryLabel;\n      if (isLeaf && datum != null && depth != null && secondaryLabelKey != null) {\n        const value = datum[secondaryLabelKey];\n        secondaryLabel = this.getLabelText(\n          tile.secondaryLabel,\n          {\n            depth,\n            datum,\n            childrenKey,\n            colorKey,\n            colorName,\n            labelKey,\n            secondaryLabelKey,\n            sizeKey,\n            sizeName,\n            value\n          },\n          defaultLabelFormatter\n        );\n      }\n      if (secondaryLabel === \"\") {\n        secondaryLabel = void 0;\n      }\n      return label != null || secondaryLabel != null ? { label, secondaryLabel } : void 0;\n    });\n  }\n  sortChildren({ children }) {\n    const sortedChildrenIndices = Array.from(children, (_, i) => i).filter((i) => nodeSize(children[i]) > 0).sort((aIndex, bIndex) => nodeSize(children[bIndex]) - nodeSize(children[aIndex]));\n    const childAt = (i) => {\n      const sortedIndex = sortedChildrenIndices[i];\n      return children[sortedIndex];\n    };\n    return { sortedChildrenIndices, childAt };\n  }\n  /**\n   * Squarified Treemap algorithm\n   * https://www.win.tue.nl/~vanwijk/stm.pdf\n   */\n  squarify(node, bbox, outputBoxes, outputPadding) {\n    const { index, datum, children } = node;\n    if (bbox.width <= 0 || bbox.height <= 0) {\n      outputBoxes[index] = void 0;\n      outputPadding[index] = void 0;\n      return;\n    }\n    const padding = datum != null ? this.getNodePadding(node, bbox) : { top: 0, right: 0, bottom: 0, left: 0 };\n    outputBoxes[index] = index === 0 ? void 0 : bbox;\n    outputPadding[index] = index === 0 ? void 0 : padding;\n    const { sortedChildrenIndices, childAt } = this.sortChildren(node);\n    const allLeafNodes = sortedChildrenIndices.every((sortedIndex) => children[sortedIndex].children.length === 0);\n    const targetTileAspectRatio = 1;\n    const width = bbox.width - padding.left - padding.right;\n    const height = bbox.height - padding.top - padding.bottom;\n    if (width <= 0 || height <= 0)\n      return;\n    const numChildren = sortedChildrenIndices.length;\n    let stackSum = 0;\n    let startIndex = 0;\n    let minRatioDiff = Infinity;\n    let partitionSum = sortedChildrenIndices.reduce((sum, sortedIndex) => sum + nodeSize(children[sortedIndex]), 0);\n    const innerBox = new BBox11(bbox.x + padding.left, bbox.y + padding.top, width, height);\n    const partition = innerBox.clone();\n    let i = 0;\n    while (i < numChildren) {\n      const value = nodeSize(childAt(i));\n      const firstValue = nodeSize(childAt(startIndex));\n      const isVertical2 = partition.width < partition.height;\n      stackSum += value;\n      const partThickness = isVertical2 ? partition.height : partition.width;\n      const partLength = isVertical2 ? partition.width : partition.height;\n      const firstTileLength = partLength * firstValue / stackSum;\n      let stackThickness = partThickness * stackSum / partitionSum;\n      const ratio = Math.max(firstTileLength, stackThickness) / Math.min(firstTileLength, stackThickness);\n      const diff8 = Math.abs(targetTileAspectRatio - ratio);\n      if (diff8 < minRatioDiff) {\n        minRatioDiff = diff8;\n        i++;\n        continue;\n      }\n      stackSum -= value;\n      stackThickness = partThickness * stackSum / partitionSum;\n      let start2 = isVertical2 ? partition.x : partition.y;\n      for (let j = startIndex; j < i; j++) {\n        const child = childAt(j);\n        const childSize = nodeSize(child);\n        const x = isVertical2 ? start2 : partition.x;\n        const y = isVertical2 ? partition.y : start2;\n        const length = partLength * childSize / stackSum;\n        const stackWidth = isVertical2 ? length : stackThickness;\n        const stackHeight = isVertical2 ? stackThickness : length;\n        const childBbox = new BBox11(x, y, stackWidth, stackHeight);\n        this.applyGap(innerBox, childBbox, allLeafNodes);\n        this.squarify(child, childBbox, outputBoxes, outputPadding);\n        partitionSum -= childSize;\n        start2 += length;\n      }\n      if (isVertical2) {\n        partition.y += stackThickness;\n        partition.height -= stackThickness;\n      } else {\n        partition.x += stackThickness;\n        partition.width -= stackThickness;\n      }\n      startIndex = i;\n      stackSum = 0;\n      minRatioDiff = Infinity;\n    }\n    const isVertical = partition.width < partition.height;\n    let start = isVertical ? partition.x : partition.y;\n    for (let childIdx = startIndex; childIdx < numChildren; childIdx++) {\n      const child = childAt(childIdx);\n      const x = isVertical ? start : partition.x;\n      const y = isVertical ? partition.y : start;\n      const part = nodeSize(child) / partitionSum;\n      const childWidth = partition.width * (isVertical ? part : 1);\n      const childHeight = partition.height * (isVertical ? 1 : part);\n      const childBox = new BBox11(x, y, childWidth, childHeight);\n      this.applyGap(innerBox, childBox, allLeafNodes);\n      this.squarify(child, childBox, outputBoxes, outputPadding);\n      start += isVertical ? childWidth : childHeight;\n    }\n  }\n  applyGap(innerBox, childBox, allLeafNodes) {\n    const gap = allLeafNodes ? this.properties.tile.gap * 0.5 : this.properties.group.gap * 0.5;\n    const getBounds = (box) => ({\n      left: box.x,\n      top: box.y,\n      right: box.x + box.width,\n      bottom: box.y + box.height\n    });\n    const innerBounds = getBounds(innerBox);\n    const childBounds = getBounds(childBox);\n    const sides = [\"top\", \"right\", \"bottom\", \"left\"];\n    sides.forEach((side) => {\n      if (!isEqual2(innerBounds[side], childBounds[side])) {\n        childBox.shrink(gap, side);\n      }\n    });\n  }\n  async createNodeData() {\n    return void 0;\n  }\n  async updateSelections() {\n    if (!this.nodeDataRefresh) {\n      return;\n    }\n    this.nodeDataRefresh = false;\n    const { seriesRect } = this.chart ?? {};\n    if (!seriesRect)\n      return;\n    const descendants = Array.from(this.rootNode);\n    const updateGroup = (group) => {\n      group.append([\n        new Rect6(),\n        new Text15({ tag: 0 /* Primary */ }),\n        new Text15({ tag: 1 /* Secondary */ })\n      ]);\n    };\n    this.groupSelection.update(descendants, updateGroup, (node) => this.getDatumId(node));\n    this.highlightSelection.update(descendants, updateGroup, (node) => this.getDatumId(node));\n  }\n  getTileFormat(node, highlighted) {\n    const { datum, depth, children } = node;\n    const { colorKey, childrenKey, labelKey, secondaryLabelKey, sizeKey, tile, group, itemStyler } = this.properties;\n    if (!itemStyler || datum == null || depth == null) {\n      return {};\n    }\n    const isLeaf = children.length === 0;\n    const fill = this.getNodeFill(node);\n    const stroke = this.getNodeStroke(node);\n    const strokeWidth = isLeaf ? tile.strokeWidth : group.strokeWidth;\n    return this.ctx.callbackCache.call(itemStyler, {\n      seriesId: this.id,\n      highlighted,\n      datum,\n      depth,\n      colorKey,\n      childrenKey,\n      labelKey,\n      secondaryLabelKey,\n      sizeKey,\n      fill,\n      fillOpacity: 1,\n      stroke,\n      strokeWidth,\n      strokeOpacity: 1\n    });\n  }\n  getNodeFill(node) {\n    const isLeaf = node.children.length === 0;\n    if (isLeaf) {\n      return this.properties.tile.fill ?? node.fill;\n    }\n    const { undocumentedGroupFills } = this.properties;\n    const defaultFill = undocumentedGroupFills[Math.min(node.depth ?? 0, undocumentedGroupFills.length)];\n    return this.properties.group.fill ?? defaultFill;\n  }\n  getNodeStroke(node) {\n    const isLeaf = node.children.length === 0;\n    if (isLeaf) {\n      return this.properties.tile.stroke ?? node.stroke;\n    }\n    const { undocumentedGroupStrokes } = this.properties;\n    const defaultStroke = undocumentedGroupStrokes[Math.min(node.depth ?? 0, undocumentedGroupStrokes.length)];\n    return this.properties.group.stroke ?? defaultStroke;\n  }\n  async updateNodes() {\n    const { rootNode, data } = this;\n    const { highlightStyle, tile, group } = this.properties;\n    const { seriesRect } = this.chart ?? {};\n    if (!seriesRect || !data)\n      return;\n    const { width, height } = seriesRect;\n    const bboxes = Array.from(this.rootNode, () => void 0);\n    const paddings = Array.from(this.rootNode, () => void 0);\n    this.squarify(rootNode, new BBox11(0, 0, width, height), bboxes, paddings);\n    let highlightedNode = this.ctx.highlightManager?.getActiveHighlight();\n    if (highlightedNode != null && !this.properties.group.interactive && highlightedNode.children.length !== 0) {\n      highlightedNode = void 0;\n    }\n    this.updateNodeMidPoint(bboxes);\n    const updateRectFn = (node, rect, highlighted) => {\n      const bbox = bboxes[node.index];\n      if (bbox == null) {\n        rect.visible = false;\n        return;\n      }\n      const isLeaf = node.children.length === 0;\n      let highlightedFill;\n      let highlightedFillOpacity;\n      let highlightedStroke;\n      let highlightedStrokeWidth;\n      let highlightedStrokeOpacity;\n      if (highlighted) {\n        const { tile: hTitle, group: hGroup } = highlightStyle;\n        highlightedFill = isLeaf ? hTitle.fill : hGroup.fill;\n        highlightedFillOpacity = isLeaf ? hTitle.fillOpacity : hGroup.fillOpacity;\n        highlightedStroke = isLeaf ? hTitle.stroke : hGroup.stroke;\n        highlightedStrokeWidth = isLeaf ? hTitle.strokeWidth : hGroup.strokeWidth;\n        highlightedStrokeOpacity = isLeaf ? hTitle.strokeOpacity : hGroup.strokeOpacity;\n      }\n      const format = this.getTileFormat(node, highlighted);\n      const fill = format?.fill ?? highlightedFill ?? this.getNodeFill(node);\n      const fillOpacity = format?.fillOpacity ?? highlightedFillOpacity ?? (isLeaf ? tile.fillOpacity : group.fillOpacity);\n      const stroke = format?.stroke ?? highlightedStroke ?? this.getNodeStroke(node);\n      const strokeWidth = format?.strokeWidth ?? highlightedStrokeWidth ?? (isLeaf ? tile.strokeWidth : group.strokeWidth);\n      const strokeOpacity = format?.strokeOpacity ?? highlightedStrokeOpacity ?? (isLeaf ? tile.strokeOpacity : group.strokeOpacity);\n      rect.crisp = true;\n      rect.fill = validateColor(fill);\n      rect.fillOpacity = fillOpacity;\n      rect.stroke = validateColor(stroke);\n      rect.strokeWidth = strokeWidth;\n      rect.strokeOpacity = strokeOpacity;\n      rect.cornerRadius = isLeaf ? tile.cornerRadius : group.cornerRadius;\n      const onlyLeaves = node.parent?.children.every((n) => n.children.length === 0);\n      const parentBbox = node.parent != null ? bboxes[node.parent.index] : void 0;\n      const parentPadding = node.parent != null ? paddings[node.parent.index] : void 0;\n      if (onlyLeaves === true && parentBbox != null && parentPadding != null) {\n        rect.clipBBox = bbox;\n        rect.x = parentBbox.x + parentPadding.left;\n        rect.y = parentBbox.y + parentPadding.top;\n        rect.width = parentBbox.width - (parentPadding.left + parentPadding.right);\n        rect.height = parentBbox.height - (parentPadding.top + parentPadding.bottom);\n      } else {\n        rect.clipBBox = void 0;\n        rect.x = bbox.x;\n        rect.y = bbox.y;\n        rect.width = bbox.width;\n        rect.height = bbox.height;\n      }\n      rect.visible = true;\n    };\n    this.groupSelection.selectByClass(Rect6).forEach((rect) => updateRectFn(rect.datum, rect, false));\n    this.highlightSelection.selectByClass(Rect6).forEach((rect) => {\n      const isDatumHighlighted = rect.datum === highlightedNode;\n      rect.visible = isDatumHighlighted || (highlightedNode?.contains(rect.datum) ?? false);\n      if (rect.visible) {\n        updateRectFn(rect.datum, rect, isDatumHighlighted);\n      }\n    });\n    const labelMeta = Array.from(this.rootNode, (node) => {\n      const { index, children } = node;\n      const bbox = bboxes[index];\n      const labelDatum = this.labelData?.[index];\n      if (bbox == null || labelDatum == null) {\n        return;\n      }\n      if (children.length === 0) {\n        const layout = {\n          width: bbox.width,\n          height: bbox.height,\n          meta: null\n        };\n        const formatting = formatLabels(\n          labelDatum.label,\n          this.properties.tile.label,\n          labelDatum.secondaryLabel,\n          this.properties.tile.secondaryLabel,\n          { padding: tile.padding },\n          () => layout\n        );\n        if (formatting == null) {\n          return;\n        }\n        const { height: labelHeight, label, secondaryLabel } = formatting;\n        const { textAlign, verticalAlign, padding } = tile;\n        const textAlignFactor = textAlignFactors2[textAlign] ?? 0.5;\n        const labelX = bbox.x + padding + (bbox.width - 2 * padding) * textAlignFactor;\n        const verticalAlignFactor = verticalAlignFactors2[verticalAlign] ?? 0.5;\n        const labelYStart = bbox.y + padding + labelHeight * 0.5 + (bbox.height - 2 * padding - labelHeight) * verticalAlignFactor;\n        return {\n          label: label != null ? {\n            text: label.text,\n            fontSize: label.fontSize,\n            lineHeight: label.lineHeight,\n            style: this.properties.tile.label,\n            x: labelX,\n            y: labelYStart - (labelHeight - label.height) * 0.5\n          } : void 0,\n          secondaryLabel: secondaryLabel != null ? {\n            text: secondaryLabel.text,\n            fontSize: secondaryLabel.fontSize,\n            lineHeight: secondaryLabel.fontSize,\n            style: this.properties.tile.secondaryLabel,\n            x: labelX,\n            y: labelYStart + (labelHeight - secondaryLabel.height) * 0.5\n          } : void 0,\n          verticalAlign: \"middle\",\n          textAlign\n        };\n      } else if (labelDatum?.label == null) {\n        return;\n      } else {\n        const { padding, textAlign } = group;\n        const groupTitleHeight = this.groupTitleHeight(node, bbox);\n        if (groupTitleHeight == null) {\n          return;\n        }\n        const innerWidth = bbox.width - 2 * padding;\n        const text = Text15.wrap(labelDatum.label, bbox.width - 2 * padding, Infinity, group.label, \"never\");\n        const textAlignFactor = textAlignFactors2[textAlign] ?? 0.5;\n        return {\n          label: {\n            text,\n            fontSize: group.label.fontSize,\n            lineHeight: AutoSizedLabel.lineHeight(group.label.fontSize),\n            style: this.properties.group.label,\n            x: bbox.x + padding + innerWidth * textAlignFactor,\n            y: bbox.y + padding + groupTitleHeight * 0.5\n          },\n          secondaryLabel: void 0,\n          verticalAlign: \"middle\",\n          textAlign\n        };\n      }\n    });\n    const updateLabelFn = (node, text, tag, highlighted) => {\n      const isLeaf = node.children.length === 0;\n      const meta = labelMeta[node.index];\n      const label = tag === 0 /* Primary */ ? meta?.label : meta?.secondaryLabel;\n      if (meta == null || label == null) {\n        text.visible = false;\n        return;\n      }\n      let highlightedColor;\n      if (highlighted) {\n        const { tile: hTitle, group: hGroup } = highlightStyle;\n        highlightedColor = hTitle.secondaryLabel.color;\n        if (!isLeaf) {\n          highlightedColor = hGroup.label.color;\n        } else if (tag === 0 /* Primary */) {\n          highlightedColor = hTitle.label.color;\n        }\n      }\n      text.text = label.text;\n      text.fontSize = label.fontSize;\n      text.lineHeight = label.lineHeight;\n      text.fontStyle = label.style.fontStyle;\n      text.fontFamily = label.style.fontFamily;\n      text.fontWeight = label.style.fontWeight;\n      text.fill = highlightedColor ?? label.style.color;\n      text.textAlign = meta.textAlign;\n      text.textBaseline = meta.verticalAlign;\n      text.x = label.x;\n      text.y = label.y;\n      text.visible = true;\n    };\n    this.groupSelection.selectByClass(Text15).forEach((text) => {\n      updateLabelFn(text.datum, text, text.tag, false);\n    });\n    this.highlightSelection.selectByClass(Text15).forEach((text) => {\n      const isDatumHighlighted = text.datum === highlightedNode;\n      text.visible = isDatumHighlighted || (highlightedNode?.contains(text.datum) ?? false);\n      if (text.visible) {\n        updateLabelFn(text.datum, text, text.tag, isDatumHighlighted);\n      }\n    });\n  }\n  updateNodeMidPoint(bboxes) {\n    this.rootNode.walk((node) => {\n      const bbox = bboxes[node.index];\n      if (bbox != null) {\n        node.midPoint.x = bbox.x + bbox.width / 2;\n        node.midPoint.y = bbox.y;\n      }\n    });\n  }\n  pickNodeClosestDatum(point) {\n    const exactMatch = this.pickNodeExactShape(point);\n    if (exactMatch !== void 0) {\n      return exactMatch;\n    }\n    return this.pickNodeNearestDistantObject(point, this.groupSelection.nodes());\n  }\n  getTooltipHtml(node) {\n    const { datum, depth } = node;\n    const { id: seriesId } = this;\n    const {\n      tooltip,\n      colorKey,\n      colorName = colorKey,\n      labelKey,\n      secondaryLabelKey,\n      sizeKey,\n      sizeName = sizeKey,\n      childrenKey\n    } = this.properties;\n    const isLeaf = node.children.length === 0;\n    const interactive = isLeaf || this.properties.group.interactive;\n    if (datum == null || depth == null || !interactive) {\n      return ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.EMPTY_TOOLTIP_CONTENT;\n    }\n    const title = labelKey != null ? datum[labelKey] : void 0;\n    const format = this.getTileFormat(node, false);\n    const color = format?.fill ?? this.getNodeFill(node);\n    if (!tooltip.renderer && !title) {\n      return ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.EMPTY_TOOLTIP_CONTENT;\n    }\n    const contentArray = [];\n    const datumSecondaryLabel = secondaryLabelKey != null ? datum[secondaryLabelKey] : void 0;\n    if (datumSecondaryLabel != null && secondaryLabelKey !== colorKey && secondaryLabelKey !== sizeKey) {\n      contentArray.push(sanitizeHtml15(datumSecondaryLabel));\n    }\n    const datumSize = sizeKey != null ? datum[sizeKey] : void 0;\n    if (datumSize != null) {\n      contentArray.push(`${sizeName}: ${sanitizeHtml15(datumSize)}`);\n    }\n    const datumColor = colorKey != null ? datum[colorKey] : void 0;\n    if (datumColor != null) {\n      contentArray.push(`${colorName}: ${sanitizeHtml15(datumColor)}`);\n    }\n    const content = contentArray.join(\"<br>\");\n    const defaults = {\n      title,\n      color: isLeaf ? this.properties.tile.label.color : this.properties.group.label.color,\n      backgroundColor: color,\n      content\n    };\n    return tooltip.toTooltipHtml(defaults, {\n      depth,\n      datum,\n      colorKey,\n      labelKey,\n      secondaryLabelKey,\n      sizeKey,\n      title,\n      color,\n      seriesId,\n      childrenKey,\n      colorName,\n      itemId: void 0,\n      sizeName\n    });\n  }\n  pickFocus(opts) {\n    const { focusPath: path } = this;\n    if (path.length < 2 || this.focusSorted == null) {\n      path.length = 1;\n      this.focusSorted = this.sortChildren(path[0].nodeDatum);\n      path.push({ nodeDatum: this.focusSorted.childAt(0), childIndex: 0 });\n    }\n    const { datumIndexDelta: childDelta, otherIndexDelta: depthDelta } = opts;\n    const current = path[path.length - 1];\n    if (depthDelta === 1) {\n      if (current.nodeDatum.children.length > 0) {\n        this.focusSorted = this.sortChildren(current.nodeDatum);\n        const newFocus = { nodeDatum: this.focusSorted.childAt(0), childIndex: 0 };\n        path.push(newFocus);\n        return this.computeFocusOutputs(newFocus);\n      }\n    } else if (childDelta !== 0) {\n      const targetIndex = current.childIndex + childDelta;\n      const maxIndex = (current.nodeDatum.parent?.children.length ?? 1) - 1;\n      current.childIndex = clamp3(0, targetIndex, maxIndex);\n      current.nodeDatum = this.focusSorted.childAt(current.childIndex);\n      return this.computeFocusOutputs(current);\n    }\n    const result = super.pickFocus(opts);\n    if (depthDelta < 0) {\n      this.focusSorted = this.sortChildren(path[path.length - 1].nodeDatum.parent);\n    }\n    return result;\n  }\n  computeFocusBounds(node) {\n    const rects = this.groupSelection.selectByClass(Rect6);\n    return rects[node.index]?.computeTransformedBBox();\n  }\n};\nTreemapSeries.className = \"TreemapSeries\";\nTreemapSeries.type = \"treemap\";\n\n// packages/ag-charts-enterprise/src/series/treemap/treemapModule.ts\nvar {\n  DEFAULT_DIVERGING_SERIES_COLOUR_RANGE: DEFAULT_DIVERGING_SERIES_COLOUR_RANGE4,\n  DEFAULT_FONT_FAMILY: DEFAULT_FONT_FAMILY4,\n  DEFAULT_HIERARCHY_FILLS: DEFAULT_HIERARCHY_FILLS2,\n  DEFAULT_HIERARCHY_STROKES: DEFAULT_HIERARCHY_STROKES2,\n  DEFAULT_INSIDE_SERIES_LABEL_COLOUR: DEFAULT_INSIDE_SERIES_LABEL_COLOUR2,\n  DEFAULT_LABEL_COLOUR: DEFAULT_LABEL_COLOUR5,\n  FONT_WEIGHT: FONT_WEIGHT3\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme;\nvar TreemapModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"hierarchy\"],\n  identifier: \"treemap\",\n  instanceConstructor: TreemapSeries,\n  tooltipDefaults: { range: \"exact\" },\n  solo: true,\n  themeTemplate: {\n    series: {\n      group: {\n        label: {\n          enabled: true,\n          color: DEFAULT_LABEL_COLOUR5,\n          fontStyle: void 0,\n          fontWeight: FONT_WEIGHT3.NORMAL,\n          fontSize: 12,\n          fontFamily: DEFAULT_FONT_FAMILY4,\n          spacing: 4\n        },\n        fill: void 0,\n        // Override default fill\n        stroke: void 0,\n        // Override default stroke\n        strokeWidth: 1,\n        padding: 4,\n        gap: 2,\n        textAlign: \"left\"\n      },\n      tile: {\n        label: {\n          enabled: true,\n          color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR2,\n          fontStyle: void 0,\n          fontWeight: FONT_WEIGHT3.NORMAL,\n          fontSize: 18,\n          minimumFontSize: 10,\n          fontFamily: DEFAULT_FONT_FAMILY4,\n          wrapping: \"on-space\",\n          overflowStrategy: \"ellipsis\",\n          spacing: 2\n        },\n        secondaryLabel: {\n          enabled: true,\n          color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR2,\n          fontStyle: void 0,\n          fontWeight: void 0,\n          fontSize: 12,\n          minimumFontSize: 10,\n          fontFamily: DEFAULT_FONT_FAMILY4,\n          wrapping: \"never\",\n          overflowStrategy: \"ellipsis\"\n        },\n        fill: void 0,\n        // Override default fill\n        stroke: void 0,\n        // Override default stroke\n        strokeWidth: 0,\n        padding: 3,\n        gap: 1\n      },\n      // Override defaults\n      highlightStyle: {\n        group: {\n          label: {\n            color: DEFAULT_LABEL_COLOUR5\n          },\n          fill: void 0,\n          stroke: `rgba(0, 0, 0, 0.4)`,\n          strokeWidth: 2\n        },\n        tile: {\n          label: {\n            color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR2\n          },\n          secondaryLabel: {\n            color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR2\n          },\n          fill: void 0,\n          stroke: `rgba(0, 0, 0, 0.4)`,\n          strokeWidth: 2\n        }\n      }\n    },\n    gradientLegend: {\n      enabled: true\n    }\n  },\n  paletteFactory: ({ takeColors, colorsCount, themeTemplateParameters }) => {\n    const { fills, strokes } = takeColors(colorsCount);\n    const defaultColorRange = themeTemplateParameters.get(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE4);\n    const groupFills = themeTemplateParameters.get(DEFAULT_HIERARCHY_FILLS2);\n    const groupStrokes = themeTemplateParameters.get(DEFAULT_HIERARCHY_STROKES2);\n    return {\n      fills,\n      strokes,\n      colorRange: defaultColorRange,\n      undocumentedGroupFills: groupFills,\n      undocumentedGroupStrokes: groupStrokes\n    };\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/waterfall/waterfallModule.ts\n\n\n// packages/ag-charts-enterprise/src/series/waterfall/waterfallSeries.ts\n\n\n// packages/ag-charts-enterprise/src/series/waterfall/waterfallSeriesProperties.ts\n\nvar { DropShadow: DropShadow3, Label: Label14 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar {\n  AbstractBarSeriesProperties: AbstractBarSeriesProperties5,\n  BaseProperties: BaseProperties17,\n  PropertiesArray: PropertiesArray3,\n  SeriesTooltip: SeriesTooltip19,\n  Validate: Validate61,\n  BOOLEAN: BOOLEAN20,\n  COLOR_STRING: COLOR_STRING26,\n  FUNCTION: FUNCTION20,\n  LINE_DASH: LINE_DASH20,\n  NUMBER: NUMBER16,\n  OBJECT: OBJECT29,\n  OBJECT_ARRAY,\n  POSITIVE_NUMBER: POSITIVE_NUMBER29,\n  RATIO: RATIO32,\n  STRING: STRING28,\n  UNION: UNION8\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar WaterfallSeriesTotal = class extends BaseProperties17 {\n};\n__decorateClass([\n  Validate61(UNION8([\"subtotal\", \"total\"], \"a total type\"))\n], WaterfallSeriesTotal.prototype, \"totalType\", 2);\n__decorateClass([\n  Validate61(NUMBER16)\n], WaterfallSeriesTotal.prototype, \"index\", 2);\n__decorateClass([\n  Validate61(STRING28)\n], WaterfallSeriesTotal.prototype, \"axisLabel\", 2);\nvar WaterfallSeriesItemTooltip = class extends BaseProperties17 {\n};\n__decorateClass([\n  Validate61(FUNCTION20, { optional: true })\n], WaterfallSeriesItemTooltip.prototype, \"renderer\", 2);\nvar WaterfallSeriesLabel = class extends Label14 {\n  constructor() {\n    super(...arguments);\n    this.placement = \"end\";\n    this.padding = 6;\n  }\n};\n__decorateClass([\n  Validate61(UNION8([\"start\", \"end\", \"inside\"], \"a placement\"))\n], WaterfallSeriesLabel.prototype, \"placement\", 2);\n__decorateClass([\n  Validate61(POSITIVE_NUMBER29)\n], WaterfallSeriesLabel.prototype, \"padding\", 2);\nvar WaterfallSeriesItem = class extends BaseProperties17 {\n  constructor() {\n    super(...arguments);\n    this.fill = \"#c16068\";\n    this.stroke = \"#c16068\";\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.strokeWidth = 1;\n    this.cornerRadius = 0;\n    this.shadow = new DropShadow3().set({ enabled: false });\n    this.label = new WaterfallSeriesLabel();\n    this.tooltip = new WaterfallSeriesItemTooltip();\n  }\n};\n__decorateClass([\n  Validate61(STRING28, { optional: true })\n], WaterfallSeriesItem.prototype, \"name\", 2);\n__decorateClass([\n  Validate61(COLOR_STRING26)\n], WaterfallSeriesItem.prototype, \"fill\", 2);\n__decorateClass([\n  Validate61(COLOR_STRING26)\n], WaterfallSeriesItem.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate61(RATIO32)\n], WaterfallSeriesItem.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate61(RATIO32)\n], WaterfallSeriesItem.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate61(LINE_DASH20)\n], WaterfallSeriesItem.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate61(POSITIVE_NUMBER29)\n], WaterfallSeriesItem.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate61(POSITIVE_NUMBER29)\n], WaterfallSeriesItem.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate61(POSITIVE_NUMBER29)\n], WaterfallSeriesItem.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate61(FUNCTION20, { optional: true })\n], WaterfallSeriesItem.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate61(OBJECT29)\n], WaterfallSeriesItem.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate61(OBJECT29)\n], WaterfallSeriesItem.prototype, \"label\", 2);\n__decorateClass([\n  Validate61(OBJECT29)\n], WaterfallSeriesItem.prototype, \"tooltip\", 2);\nvar WaterfallSeriesConnectorLine = class extends BaseProperties17 {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.stroke = \"black\";\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.strokeWidth = 2;\n  }\n};\n__decorateClass([\n  Validate61(BOOLEAN20)\n], WaterfallSeriesConnectorLine.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate61(COLOR_STRING26)\n], WaterfallSeriesConnectorLine.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate61(RATIO32)\n], WaterfallSeriesConnectorLine.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate61(LINE_DASH20)\n], WaterfallSeriesConnectorLine.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate61(POSITIVE_NUMBER29)\n], WaterfallSeriesConnectorLine.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate61(POSITIVE_NUMBER29)\n], WaterfallSeriesConnectorLine.prototype, \"strokeWidth\", 2);\nvar WaterfallSeriesItems = class extends BaseProperties17 {\n  constructor() {\n    super(...arguments);\n    this.positive = new WaterfallSeriesItem();\n    this.negative = new WaterfallSeriesItem();\n    this.total = new WaterfallSeriesItem();\n  }\n};\n__decorateClass([\n  Validate61(OBJECT29)\n], WaterfallSeriesItems.prototype, \"positive\", 2);\n__decorateClass([\n  Validate61(OBJECT29)\n], WaterfallSeriesItems.prototype, \"negative\", 2);\n__decorateClass([\n  Validate61(OBJECT29)\n], WaterfallSeriesItems.prototype, \"total\", 2);\nvar WaterfallSeriesProperties = class extends AbstractBarSeriesProperties5 {\n  constructor() {\n    super(...arguments);\n    this.item = new WaterfallSeriesItems();\n    this.totals = new PropertiesArray3(WaterfallSeriesTotal);\n    this.line = new WaterfallSeriesConnectorLine();\n    this.tooltip = new SeriesTooltip19();\n  }\n};\n__decorateClass([\n  Validate61(STRING28)\n], WaterfallSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate61(STRING28)\n], WaterfallSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate61(STRING28, { optional: true })\n], WaterfallSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate61(STRING28, { optional: true })\n], WaterfallSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate61(OBJECT29)\n], WaterfallSeriesProperties.prototype, \"item\", 2);\n__decorateClass([\n  Validate61(OBJECT_ARRAY)\n], WaterfallSeriesProperties.prototype, \"totals\", 2);\n__decorateClass([\n  Validate61(OBJECT29)\n], WaterfallSeriesProperties.prototype, \"line\", 2);\n__decorateClass([\n  Validate61(OBJECT29)\n], WaterfallSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-enterprise/src/series/waterfall/waterfallSeries.ts\nvar {\n  adjustLabelPlacement,\n  SeriesNodePickMode: SeriesNodePickMode14,\n  fixNumericExtent: fixNumericExtent9,\n  valueProperty: valueProperty16,\n  keyProperty: keyProperty9,\n  accumulativeValueProperty,\n  trailingAccumulatedValueProperty,\n  ChartAxisDirection: ChartAxisDirection22,\n  getRectConfig: getRectConfig2,\n  updateRect: updateRect2,\n  checkCrisp: checkCrisp2,\n  updateLabelNode: updateLabelNode3,\n  prepareBarAnimationFunctions: prepareBarAnimationFunctions3,\n  collapsedStartingBarPosition: collapsedStartingBarPosition2,\n  resetBarSelectionsFn: resetBarSelectionsFn3,\n  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation7,\n  resetLabelFn: resetLabelFn5,\n  animationValidation: animationValidation9,\n  DEFAULT_CARTESIAN_DIRECTION_KEYS: DEFAULT_CARTESIAN_DIRECTION_KEYS2,\n  DEFAULT_CARTESIAN_DIRECTION_NAMES: DEFAULT_CARTESIAN_DIRECTION_NAMES2,\n  isFiniteNumber: isFiniteNumber10,\n  computeBarFocusBounds: computeBarFocusBounds6\n} = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport;\nvar { Rect: Rect7, motion: motion9 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene;\nvar { sanitizeHtml: sanitizeHtml16, isContinuous } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Util;\nvar { ContinuousScale: ContinuousScale4 } = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scale;\nvar WaterfallSeries = class extends ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.AbstractBarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS2,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES2,\n      pickModes: [SeriesNodePickMode14.NEAREST_NODE, SeriesNodePickMode14.EXACT_SHAPE_MATCH],\n      pathsPerSeries: 1,\n      hasHighlightedLabels: true,\n      pathsZIndexSubOrderOffset: [-1, -1],\n      animationResetFns: {\n        datum: resetBarSelectionsFn3,\n        label: resetLabelFn5\n      }\n    });\n    this.properties = new WaterfallSeriesProperties();\n    this.seriesItemTypes = /* @__PURE__ */ new Set([\"positive\", \"negative\", \"total\"]);\n  }\n  async processData(dataController) {\n    const { xKey, yKey, totals } = this.properties;\n    const { data = [] } = this;\n    if (!this.properties.isValid() || !this.visible)\n      return;\n    const positiveNumber = (v) => {\n      return isContinuous(v) && Number(v) >= 0;\n    };\n    const negativeNumber = (v) => {\n      return isContinuous(v) && Number(v) < 0;\n    };\n    const totalTypeValue = (v) => {\n      return v === \"total\" || v === \"subtotal\";\n    };\n    const propertyDefinition = {\n      missingValue: void 0,\n      invalidValue: void 0\n    };\n    const dataWithTotals = [];\n    const totalsMap = totals.reduce((result, total) => {\n      const totalsAtIndex = result.get(total.index);\n      if (totalsAtIndex) {\n        totalsAtIndex.push(total);\n      } else {\n        result.set(total.index, [total]);\n      }\n      return result;\n    }, /* @__PURE__ */ new Map());\n    data.forEach((datum, i) => {\n      dataWithTotals.push(datum);\n      totalsMap.get(i)?.forEach((total) => dataWithTotals.push({ ...total.toJson(), [xKey]: total.axisLabel }));\n    });\n    const extraProps = [];\n    if (!this.ctx.animationManager.isSkipped()) {\n      extraProps.push(animationValidation9());\n    }\n    const xScale = this.getCategoryAxis()?.scale;\n    const yScale = this.getValueAxis()?.scale;\n    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const { processedData } = await this.requestDataModel(dataController, dataWithTotals, {\n      props: [\n        keyProperty9(xKey, xScaleType, { id: `xValue` }),\n        accumulativeValueProperty(yKey, yScaleType, {\n          ...propertyDefinition,\n          id: `yCurrent`\n        }),\n        accumulativeValueProperty(yKey, yScaleType, {\n          ...propertyDefinition,\n          missingValue: 0,\n          id: `yCurrentTotal`\n        }),\n        accumulativeValueProperty(yKey, yScaleType, {\n          ...propertyDefinition,\n          id: `yCurrentPositive`,\n          validation: positiveNumber\n        }),\n        accumulativeValueProperty(yKey, yScaleType, {\n          ...propertyDefinition,\n          id: `yCurrentNegative`,\n          validation: negativeNumber\n        }),\n        trailingAccumulatedValueProperty(yKey, yScaleType, {\n          ...propertyDefinition,\n          id: `yPrevious`\n        }),\n        valueProperty16(yKey, yScaleType, { id: `yRaw` }),\n        // Raw value pass-through.\n        valueProperty16(\"totalType\", \"band\", {\n          id: `totalTypeValue`,\n          missingValue: void 0,\n          validation: totalTypeValue\n        }),\n        ...isContinuousX ? [ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.SMALLEST_KEY_INTERVAL, ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.LARGEST_KEY_INTERVAL] : [],\n        ...extraProps\n      ]\n    });\n    this.smallestDataInterval = processedData.reduced?.smallestKeyInterval;\n    this.largestDataInterval = processedData.reduced?.largestKeyInterval;\n    this.updateSeriesItemTypes();\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel, smallestDataInterval } = this;\n    if (!processedData || !dataModel)\n      return [];\n    const {\n      keys: [keys],\n      values\n    } = processedData.domain;\n    const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n    if (direction === this.getCategoryDirection()) {\n      if (keyDef?.def.type === \"key\" && keyDef?.def.valueType === \"category\") {\n        return keys;\n      }\n      const scalePadding = isFiniteNumber10(smallestDataInterval) ? smallestDataInterval : 0;\n      const keysExtent = ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.extent(keys) ?? [NaN, NaN];\n      const categoryAxis = this.getCategoryAxis();\n      const isReversed = Boolean(categoryAxis?.isReversed());\n      const isDirectionY = direction === ChartAxisDirection22.Y;\n      const padding0 = isReversed === isDirectionY ? 0 : -scalePadding;\n      const padding1 = isReversed === isDirectionY ? scalePadding : 0;\n      const d0 = keysExtent[0] + padding0;\n      const d1 = keysExtent[1] + padding1;\n      return fixNumericExtent9([d0, d1], categoryAxis);\n    } else {\n      const yCurrIndex = dataModel.resolveProcessedDataIndexById(this, \"yCurrent\");\n      const yExtent = values[yCurrIndex];\n      const fixedYExtent = [Math.min(0, yExtent[0]), Math.max(0, yExtent[1])];\n      return fixNumericExtent9(fixedYExtent);\n    }\n  }\n  async createNodeData() {\n    const { data, dataModel, smallestDataInterval } = this;\n    const { line } = this.properties;\n    const categoryAxis = this.getCategoryAxis();\n    const valueAxis = this.getValueAxis();\n    if (!(data && categoryAxis && valueAxis && dataModel)) {\n      return;\n    }\n    const xScale = categoryAxis.scale;\n    const yScale = valueAxis.scale;\n    const categoryAxisReversed = categoryAxis.isReversed();\n    const barAlongX = this.getBarDirection() === ChartAxisDirection22.X;\n    const barWidth = (ContinuousScale4.is(xScale) ? xScale.calcBandwidth(smallestDataInterval) : xScale.bandwidth) ?? 10;\n    if (this.processedData?.type !== \"ungrouped\") {\n      return;\n    }\n    const context = {\n      itemId: this.properties.yKey,\n      nodeData: [],\n      labelData: [],\n      pointData: [],\n      scales: this.calculateScaling(),\n      visible: this.visible\n    };\n    if (!this.visible)\n      return context;\n    const yRawIndex = dataModel.resolveProcessedDataIndexById(this, `yRaw`);\n    const xIndex = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const totalTypeIndex = dataModel.resolveProcessedDataIndexById(this, `totalTypeValue`);\n    const pointData = [];\n    const yCurrIndex = dataModel.resolveProcessedDataIndexById(this, \"yCurrent\");\n    const yPrevIndex = dataModel.resolveProcessedDataIndexById(this, \"yPrevious\");\n    const yCurrTotalIndex = dataModel.resolveProcessedDataIndexById(this, \"yCurrentTotal\");\n    function getValues(isTotal, isSubtotal, values) {\n      if (isTotal || isSubtotal) {\n        return {\n          cumulativeValue: values[yCurrTotalIndex],\n          trailingValue: isSubtotal ? trailingSubtotal : 0\n        };\n      }\n      return {\n        cumulativeValue: values[yCurrIndex],\n        trailingValue: values[yPrevIndex]\n      };\n    }\n    function getValue(isTotal, isSubtotal, rawValue, cumulativeValue, trailingValue) {\n      if (isTotal) {\n        return cumulativeValue;\n      }\n      if (isSubtotal) {\n        return (cumulativeValue ?? 0) - (trailingValue ?? 0);\n      }\n      return rawValue;\n    }\n    let trailingSubtotal = 0;\n    const { xKey, yKey, xName, yName } = this.properties;\n    this.processedData?.data.forEach(({ keys, datum, values }, dataIndex) => {\n      const datumType = values[totalTypeIndex];\n      const isSubtotal = this.isSubtotal(datumType);\n      const isTotal = this.isTotal(datumType);\n      const isTotalOrSubtotal = isTotal || isSubtotal;\n      const xDatum = keys[xIndex];\n      const x = Math.round(xScale.convert(xDatum));\n      const rawValue = values[yRawIndex];\n      const { cumulativeValue, trailingValue } = getValues(isTotal, isSubtotal, values);\n      if (isTotalOrSubtotal) {\n        trailingSubtotal = cumulativeValue ?? 0;\n      }\n      const currY = Math.round(yScale.convert(cumulativeValue));\n      const trailY = Math.round(yScale.convert(trailingValue));\n      const value = getValue(isTotal, isSubtotal, rawValue, cumulativeValue, trailingValue);\n      const isPositive = (value ?? 0) >= 0;\n      const seriesItemType = this.getSeriesItemType(isPositive, datumType);\n      const { fill, stroke, strokeWidth, label } = this.getItemConfig(seriesItemType);\n      const y = isPositive ? currY : trailY;\n      const bottomY = isPositive ? trailY : currY;\n      const barHeight = Math.max(strokeWidth, Math.abs(bottomY - y));\n      const rect = {\n        x: barAlongX ? Math.min(y, bottomY) : x,\n        y: barAlongX ? x : Math.min(y, bottomY),\n        width: barAlongX ? barHeight : barWidth,\n        height: barAlongX ? barWidth : barHeight\n      };\n      const nodeMidPoint = {\n        x: rect.x + rect.width / 2,\n        y: rect.y + rect.height / 2\n      };\n      const pointY = isTotalOrSubtotal ? currY : trailY;\n      const pixelAlignmentOffset = Math.floor(line.strokeWidth) % 2 / 2;\n      const startY = categoryAxisReversed ? currY : pointY;\n      const stopY = categoryAxisReversed ? pointY : currY;\n      let startCoordinates;\n      let stopCoordinates;\n      if (barAlongX) {\n        startCoordinates = {\n          x: startY + pixelAlignmentOffset,\n          y: rect.y\n        };\n        stopCoordinates = {\n          x: stopY + pixelAlignmentOffset,\n          y: rect.y + rect.height\n        };\n      } else {\n        startCoordinates = {\n          x: rect.x,\n          y: startY + pixelAlignmentOffset\n        };\n        stopCoordinates = {\n          x: rect.x + rect.width,\n          y: stopY + pixelAlignmentOffset\n        };\n      }\n      const pathPoint = {\n        // lineTo\n        x: categoryAxisReversed ? stopCoordinates.x : startCoordinates.x,\n        y: categoryAxisReversed ? stopCoordinates.y : startCoordinates.y,\n        // moveTo\n        x2: categoryAxisReversed ? startCoordinates.x : stopCoordinates.x,\n        y2: categoryAxisReversed ? startCoordinates.y : stopCoordinates.y,\n        size: 0\n      };\n      pointData.push(pathPoint);\n      const labelText = this.getLabelText(\n        label,\n        {\n          itemId: seriesItemType === \"subtotal\" ? \"total\" : seriesItemType,\n          value,\n          datum,\n          xKey,\n          yKey,\n          xName,\n          yName\n        },\n        (v) => isFiniteNumber10(v) ? v.toFixed(2) : String(v)\n      );\n      const nodeDatum = {\n        index: dataIndex,\n        series: this,\n        itemId: seriesItemType,\n        datum,\n        cumulativeValue: cumulativeValue ?? 0,\n        xValue: xDatum,\n        yValue: value,\n        yKey,\n        xKey,\n        x: rect.x,\n        y: rect.y,\n        width: rect.width,\n        height: rect.height,\n        midPoint: nodeMidPoint,\n        fill,\n        stroke,\n        strokeWidth,\n        opacity: 1,\n        label: {\n          text: labelText,\n          ...adjustLabelPlacement({\n            isPositive: (value ?? -1) >= 0,\n            isVertical: !barAlongX,\n            placement: label.placement,\n            padding: label.padding,\n            rect\n          })\n        }\n      };\n      context.nodeData.push(nodeDatum);\n      context.labelData.push(nodeDatum);\n    });\n    const connectorLinesEnabled = this.properties.line.enabled;\n    if (yCurrIndex !== void 0 && connectorLinesEnabled) {\n      context.pointData = pointData;\n    }\n    return context;\n  }\n  updateSeriesItemTypes() {\n    const { dataModel, seriesItemTypes, processedData } = this;\n    if (!dataModel || !processedData) {\n      return;\n    }\n    seriesItemTypes.clear();\n    const yPositiveIndex = dataModel.resolveProcessedDataIndexById(this, \"yCurrentPositive\");\n    const yNegativeIndex = dataModel.resolveProcessedDataIndexById(this, \"yCurrentNegative\");\n    const totalTypeIndex = dataModel.resolveProcessedDataIndexById(this, `totalTypeValue`);\n    const positiveDomain = processedData.domain.values[yPositiveIndex] ?? [];\n    const negativeDomain = processedData.domain.values[yNegativeIndex] ?? [];\n    if (positiveDomain.length > 0) {\n      seriesItemTypes.add(\"positive\");\n    }\n    if (negativeDomain.length > 0) {\n      seriesItemTypes.add(\"negative\");\n    }\n    const itemTypes = processedData?.domain.values[totalTypeIndex];\n    if (!itemTypes) {\n      return;\n    }\n    itemTypes.forEach((type) => {\n      if (type === \"total\" || type === \"subtotal\") {\n        seriesItemTypes.add(\"total\");\n      }\n    });\n  }\n  isSubtotal(datumType) {\n    return datumType === \"subtotal\";\n  }\n  isTotal(datumType) {\n    return datumType === \"total\";\n  }\n  nodeFactory() {\n    return new Rect7();\n  }\n  getSeriesItemType(isPositive, datumType) {\n    return datumType ?? (isPositive ? \"positive\" : \"negative\");\n  }\n  getItemConfig(seriesItemType) {\n    switch (seriesItemType) {\n      case \"positive\": {\n        return this.properties.item.positive;\n      }\n      case \"negative\": {\n        return this.properties.item.negative;\n      }\n      case \"subtotal\":\n      case \"total\": {\n        return this.properties.item.total;\n      }\n    }\n  }\n  async updateDatumSelection(opts) {\n    const { nodeData, datumSelection } = opts;\n    const data = nodeData ?? [];\n    return datumSelection.update(data);\n  }\n  async updateDatumNodes(opts) {\n    const { datumSelection, isHighlight } = opts;\n    const { id: seriesId, ctx } = this;\n    const {\n      yKey,\n      highlightStyle: { item: itemHighlightStyle }\n    } = this.properties;\n    const categoryAxis = this.getCategoryAxis();\n    const crisp = checkCrisp2(\n      categoryAxis?.scale,\n      categoryAxis?.visibleRange,\n      this.smallestDataInterval,\n      this.largestDataInterval\n    );\n    const categoryAlongX = this.getCategoryDirection() === ChartAxisDirection22.X;\n    datumSelection.each((rect, datum) => {\n      const seriesItemType = datum.itemId;\n      const {\n        fillOpacity,\n        strokeOpacity,\n        strokeWidth,\n        lineDash,\n        lineDashOffset,\n        cornerRadius,\n        itemStyler,\n        shadow: fillShadow\n      } = this.getItemConfig(seriesItemType);\n      const style = {\n        fill: datum.fill,\n        stroke: datum.stroke,\n        fillOpacity,\n        strokeOpacity,\n        lineDash,\n        lineDashOffset,\n        fillShadow,\n        strokeWidth: this.getStrokeWidth(strokeWidth),\n        cornerRadius\n      };\n      const visible = categoryAlongX ? datum.width > 0 : datum.height > 0;\n      const config = getRectConfig2({\n        datum,\n        isHighlighted: isHighlight,\n        style,\n        highlightStyle: itemHighlightStyle,\n        itemStyler,\n        seriesId,\n        itemId: datum.itemId,\n        ctx,\n        value: datum.yValue,\n        yKey\n      });\n      config.crisp = crisp;\n      config.visible = visible;\n      updateRect2({ rect, config });\n    });\n  }\n  async updateLabelSelection(opts) {\n    const { labelData, labelSelection } = opts;\n    if (labelData.length === 0) {\n      return labelSelection.update([]);\n    }\n    const itemId = labelData[0].itemId;\n    const { label } = this.getItemConfig(itemId);\n    const data = label.enabled ? labelData : [];\n    return labelSelection.update(data);\n  }\n  async updateLabelNodes(opts) {\n    opts.labelSelection.each((textNode, datum) => {\n      updateLabelNode3(textNode, this.getItemConfig(datum.itemId).label, datum.label);\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const categoryAxis = this.getCategoryAxis();\n    const valueAxis = this.getValueAxis();\n    if (!this.properties.isValid() || !categoryAxis || !valueAxis) {\n      return ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.EMPTY_TOOLTIP_CONTENT;\n    }\n    const { id: seriesId } = this;\n    const { xKey, yKey, xName, yName, tooltip } = this.properties;\n    const { datum, itemId, xValue, yValue } = nodeDatum;\n    const {\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash = [],\n      lineDashOffset,\n      cornerRadius,\n      name,\n      itemStyler\n    } = this.getItemConfig(itemId);\n    let format;\n    if (itemStyler) {\n      format = this.ctx.callbackCache.call(itemStyler, {\n        datum,\n        xKey,\n        yKey,\n        fill,\n        fillOpacity,\n        stroke,\n        strokeWidth,\n        strokeOpacity,\n        lineDash,\n        lineDashOffset,\n        cornerRadius,\n        highlighted: false,\n        seriesId,\n        itemId: nodeDatum.itemId\n      });\n    }\n    const color = format?.fill ?? fill ?? \"gray\";\n    const xString = sanitizeHtml16(categoryAxis.formatDatum(xValue));\n    const yString = sanitizeHtml16(valueAxis.formatDatum(yValue));\n    const isTotal = this.isTotal(itemId);\n    const isSubtotal = this.isSubtotal(itemId);\n    let ySubheading;\n    if (isTotal) {\n      ySubheading = \"Total\";\n    } else if (isSubtotal) {\n      ySubheading = \"Subtotal\";\n    } else {\n      ySubheading = name ?? yName ?? yKey;\n    }\n    const title = sanitizeHtml16(yName);\n    const content = `<b>${sanitizeHtml16(xName ?? xKey)}</b>: ${xString}<br/><b>${sanitizeHtml16(ySubheading)}</b>: ${yString}`;\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      { seriesId, itemId, datum, xKey, yKey, xName, yName, color, title }\n    );\n  }\n  getLegendData(legendType) {\n    if (legendType !== \"category\") {\n      return [];\n    }\n    const { id, seriesItemTypes } = this;\n    const legendData = [];\n    const capitalise = (text) => text.charAt(0).toUpperCase() + text.substring(1);\n    seriesItemTypes.forEach((item) => {\n      const { fill, stroke, fillOpacity, strokeOpacity, strokeWidth, name } = this.getItemConfig(item);\n      legendData.push({\n        legendType: \"category\",\n        id,\n        itemId: item,\n        seriesId: id,\n        enabled: true,\n        label: { text: name ?? capitalise(item) },\n        symbols: [{ marker: { fill, stroke, fillOpacity, strokeOpacity, strokeWidth } }]\n      });\n    });\n    return legendData;\n  }\n  toggleSeriesItem() {\n  }\n  animateEmptyUpdateReady({ datumSelection, labelSelection, contextData, paths }) {\n    const fns = prepareBarAnimationFunctions3(collapsedStartingBarPosition2(this.isVertical(), this.axes, \"normal\"));\n    motion9.fromToMotion(this.id, \"datums\", this.ctx.animationManager, [datumSelection], fns);\n    seriesLabelFadeInAnimation7(this, \"labels\", this.ctx.animationManager, labelSelection);\n    const { pointData } = contextData;\n    if (!pointData)\n      return;\n    const [lineNode] = paths;\n    if (this.isVertical()) {\n      this.animateConnectorLinesVertical(lineNode, pointData);\n    } else {\n      this.animateConnectorLinesHorizontal(lineNode, pointData);\n    }\n  }\n  animateConnectorLinesHorizontal(lineNode, pointData) {\n    const { path: linePath } = lineNode;\n    this.updateLineNode(lineNode);\n    const valueAxis = this.getValueAxis();\n    const valueAxisReversed = valueAxis?.isReversed();\n    const compare = valueAxisReversed ? (v, v2) => v < v2 : (v, v2) => v > v2;\n    const startX = valueAxis?.scale.convert(0);\n    const endX = pointData.reduce(\n      (end, point) => {\n        if (compare(point.x, end)) {\n          end = point.x;\n        }\n        return end;\n      },\n      valueAxisReversed ? Infinity : 0\n    );\n    const scale = (value, start1, end1, start2, end2) => {\n      return (value - start1) / (end1 - start1) * (end2 - start2) + start2;\n    };\n    this.ctx.animationManager.animate({\n      id: `${this.id}_connectors`,\n      groupId: this.id,\n      phase: \"initial\",\n      from: startX,\n      to: endX,\n      ease: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.Motion.easeOut,\n      collapsable: false,\n      onUpdate(pointX) {\n        linePath.clear(true);\n        pointData.forEach((point, index) => {\n          const x = scale(pointX, startX, endX, startX, point.x);\n          const x2 = scale(pointX, startX, endX, startX, point.x2);\n          if (index !== 0) {\n            linePath.lineTo(x, point.y);\n          }\n          linePath.moveTo(x2, point.y2);\n        });\n        lineNode.checkPathDirty();\n      }\n    });\n  }\n  animateConnectorLinesVertical(lineNode, pointData) {\n    const { path: linePath } = lineNode;\n    this.updateLineNode(lineNode);\n    const valueAxis = this.getValueAxis();\n    const valueAxisReversed = valueAxis?.isReversed();\n    const compare = valueAxisReversed ? (v, v2) => v > v2 : (v, v2) => v < v2;\n    const startY = valueAxis?.scale.convert(0);\n    const endY = pointData.reduce(\n      (end, point) => {\n        if (compare(point.y, end)) {\n          end = point.y;\n        }\n        return end;\n      },\n      valueAxisReversed ? 0 : Infinity\n    );\n    const scale = (value, start1, end1, start2, end2) => {\n      return (value - start1) / (end1 - start1) * (end2 - start2) + start2;\n    };\n    this.ctx.animationManager.animate({\n      id: `${this.id}_connectors`,\n      groupId: this.id,\n      phase: \"initial\",\n      from: startY,\n      to: endY,\n      ease: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.Motion.easeOut,\n      collapsable: false,\n      onUpdate(pointY) {\n        linePath.clear(true);\n        pointData.forEach((point, index) => {\n          const y = scale(pointY, startY, endY, startY, point.y);\n          const y2 = scale(pointY, startY, endY, startY, point.y2);\n          if (index !== 0) {\n            linePath.lineTo(point.x, y);\n          }\n          linePath.moveTo(point.x2, y2);\n        });\n        lineNode.checkPathDirty();\n      }\n    });\n  }\n  animateReadyResize(data) {\n    super.animateReadyResize(data);\n    this.resetConnectorLinesPath(data);\n  }\n  async updatePaths(opts) {\n    this.resetConnectorLinesPath({ contextData: opts.contextData, paths: opts.paths });\n  }\n  resetConnectorLinesPath({ contextData, paths }) {\n    if (paths.length === 0) {\n      return;\n    }\n    const [lineNode] = paths;\n    this.updateLineNode(lineNode);\n    const { path: linePath } = lineNode;\n    linePath.clear(true);\n    const { pointData } = contextData;\n    if (!pointData) {\n      return;\n    }\n    pointData.forEach((point, index) => {\n      if (index !== 0) {\n        linePath.lineTo(point.x, point.y);\n      }\n      linePath.moveTo(point.x2, point.y2);\n    });\n    lineNode.checkPathDirty();\n  }\n  updateLineNode(lineNode) {\n    const { stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this.properties.line;\n    lineNode.setProperties({\n      fill: void 0,\n      stroke,\n      strokeWidth: this.getStrokeWidth(strokeWidth),\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      lineJoin: \"round\",\n      pointerEvents: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Scene.PointerEvents.None\n    });\n  }\n  isLabelEnabled() {\n    const { positive, negative, total } = this.properties.item;\n    return positive.label.enabled || negative.label.enabled || total.label.enabled;\n  }\n  onDataChange() {\n  }\n  computeFocusBounds({ datumIndex, seriesRect }) {\n    return computeBarFocusBounds6(this.contextNodeData?.nodeData[datumIndex], this.contentGroup, seriesRect);\n  }\n};\nWaterfallSeries.className = \"WaterfallSeries\";\nWaterfallSeries.type = \"waterfall\";\n\n// packages/ag-charts-enterprise/src/series/waterfall/waterfallThemes.ts\n\nvar itemTheme = {\n  strokeWidth: 0,\n  label: {\n    enabled: false,\n    fontStyle: void 0,\n    fontWeight: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.FONT_WEIGHT.NORMAL,\n    fontSize: 12,\n    fontFamily: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_FONT_FAMILY,\n    color: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_LABEL_COLOUR,\n    formatter: void 0,\n    placement: \"end\"\n  }\n};\nvar WATERFALL_SERIES_THEME = {\n  series: {\n    item: {\n      positive: itemTheme,\n      negative: itemTheme,\n      total: itemTheme\n    },\n    line: {\n      stroke: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.PALETTE_NEUTRAL_STROKE,\n      strokeOpacity: 1,\n      lineDash: [0],\n      lineDashOffset: 0,\n      strokeWidth: 2\n    }\n  },\n  legend: {\n    enabled: true,\n    toggleSeries: false\n  }\n};\n\n// packages/ag-charts-enterprise/src/series/waterfall/waterfallModule.ts\nvar WaterfallModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"enterprise\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"waterfall\",\n  solo: true,\n  instanceConstructor: WaterfallSeries,\n  tooltipDefaults: { range: \"exact\" },\n  defaultAxes: [\n    {\n      type: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.CARTESIAN_AXIS_TYPE.CATEGORY,\n      position: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POSITION.BOTTOM\n    },\n    {\n      type: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.CARTESIAN_AXIS_TYPE.NUMBER,\n      position: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.POSITION.LEFT\n    }\n  ],\n  themeTemplate: WATERFALL_SERIES_THEME,\n  swapDefaultAxesCondition: ({ direction }) => direction === \"horizontal\",\n  paletteFactory: ({ takeColors, colorsCount, userPalette, palette }) => {\n    if (userPalette === \"user-indexed\") {\n      const { fills, strokes } = takeColors(colorsCount);\n      return {\n        line: { stroke: palette.neutral.stroke },\n        item: {\n          positive: {\n            fill: fills[0],\n            stroke: strokes[0]\n          },\n          negative: {\n            fill: fills[1],\n            stroke: strokes[1]\n          },\n          total: {\n            fill: fills[2],\n            stroke: strokes[2]\n          }\n        }\n      };\n    }\n    return {\n      line: { stroke: palette.neutral.stroke },\n      item: {\n        positive: {\n          fill: palette.up.fill,\n          stroke: palette.up.stroke,\n          label: {\n            color: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_LABEL_COLOUR\n          }\n        },\n        negative: {\n          fill: palette.down.fill,\n          stroke: palette.down.stroke,\n          label: {\n            color: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_LABEL_COLOUR\n          }\n        },\n        total: {\n          fill: palette.neutral.fill,\n          stroke: palette.neutral.stroke,\n          label: {\n            color: ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._Theme.DEFAULT_LABEL_COLOUR\n          }\n        }\n      }\n    };\n  }\n};\n\n// packages/ag-charts-enterprise/src/setup.ts\nfunction setupEnterpriseModules() {\n  ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.moduleRegistry.register(\n    AngleCategoryAxisModule,\n    AngleNumberAxisModule,\n    AnimationModule,\n    AnnotationsModule,\n    BackgroundModule,\n    BoxPlotModule,\n    CandlestickModule,\n    ChordModule,\n    OhlcModule,\n    BulletModule,\n    ContextMenuModule,\n    CrosshairModule,\n    DataSourceModule,\n    ErrorBarsModule,\n    MapLineModule,\n    MapLineBackgroundModule,\n    MapMarkerModule,\n    MapShapeModule,\n    MapShapeBackgroundModule,\n    NavigatorModule,\n    StatusBarModule,\n    GradientLegendModule,\n    HeatmapModule,\n    NightingaleModule,\n    OrdinalTimeAxisModule,\n    RadarAreaModule,\n    RadarLineModule,\n    RadialBarModule,\n    RadialColumnModule,\n    RadiusCategoryAxisModule,\n    RadiusNumberAxisModule,\n    RangeBarModule,\n    RangeAreaModule,\n    SankeyModule,\n    SunburstModule,\n    SyncModule,\n    TreemapModule,\n    WaterfallModule,\n    ZoomModule\n  );\n  ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.enterpriseModule.isEnterprise = true;\n  ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.enterpriseModule.licenseManager = (options) => new LicenseManager(\n    options.container?.ownerDocument ?? (typeof document === \"undefined\" ? void 0 : document)\n  );\n  ag_charts_community__WEBPACK_IMPORTED_MODULE_0__._ModuleSupport.enterpriseModule.injectWatermark = injectWatermark;\n}\n\n// packages/ag-charts-enterprise/src/main.ts\n\nsetupEnterpriseModules();\n\n\n\n//# sourceURL=webpack://utils/./node_modules/ag-charts-enterprise/dist/package/main.esm.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/rendering_utils/resources/js/initAgCharts.js");
/******/ 	
/******/ })()
;